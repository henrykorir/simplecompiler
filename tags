!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
A	test/callstacktest.cpp	/^	A()$/;"	f	class:A	access:public	signature:()
A	test/callstacktest.cpp	/^class A$/;"	c	file:
A	tmp/callstacktest.cpp	/^	A()$/;"	f	class:A	access:public	signature:()
A	tmp/callstacktest.cpp	/^class A$/;"	c	file:
A	tmp/protected.cpp	/^class A : protected base$/;"	c	file:	inherits:base
A	tmp/sizetest.cpp	/^struct A$/;"	s	file:
A::A	test/callstacktest.cpp	/^	A()$/;"	f	class:A	access:public	signature:()
A::A	tmp/callstacktest.cpp	/^	A()$/;"	f	class:A	access:public	signature:()
A::m	tmp/sizetest.cpp	/^	char m;$/;"	m	struct:A	file:	access:public
A::x	tmp/sizetest.cpp	/^	int x;$/;"	m	struct:A	file:	access:public
A::y	tmp/sizetest.cpp	/^	short y;$/;"	m	struct:A	file:	access:public
A::z	tmp/sizetest.cpp	/^	char z;$/;"	m	struct:A	file:	access:public
AExpression	test/output/gen.cpp	/^	AExpression()$/;"	f	struct:AExpression	access:public	signature:()
AExpression	test/output/gen.cpp	/^struct AExpression : public type$/;"	s	file:	inherits:type
AExpression	test/output/tinyg.cpp	/^	AExpression()$/;"	f	struct:AExpression	access:public	signature:()
AExpression	test/output/tinyg.cpp	/^struct AExpression : public type$/;"	s	file:	inherits:type
AExpression	test/output/tinyg/tinyg.cpp	/^	AExpression()$/;"	f	struct:AExpression	access:public	signature:()
AExpression	test/output/tinyg/tinyg.cpp	/^struct AExpression : public type$/;"	s	file:	inherits:type
AExpression	test/output/tinyg/tinyg_bk.cpp	/^	AExpression()$/;"	f	struct:AExpression	access:public	signature:()
AExpression	test/output/tinyg/tinyg_bk.cpp	/^struct AExpression : public type$/;"	s	file:	inherits:type
AExpression::AExpression	test/output/gen.cpp	/^	AExpression()$/;"	f	struct:AExpression	access:public	signature:()
AExpression::AExpression	test/output/tinyg.cpp	/^	AExpression()$/;"	f	struct:AExpression	access:public	signature:()
AExpression::AExpression	test/output/tinyg/tinyg.cpp	/^	AExpression()$/;"	f	struct:AExpression	access:public	signature:()
AExpression::AExpression	test/output/tinyg/tinyg_bk.cpp	/^	AExpression()$/;"	f	struct:AExpression	access:public	signature:()
AExpression::sid	test/output/gen.cpp	/^	enum{ sid = 1001 };$/;"	e	enum:AExpression::__anon98	file:
AExpression::sid	test/output/tinyg.cpp	/^	enum{ sid = 7 };$/;"	e	enum:AExpression::__anon12	file:
AExpression::sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 7 };$/;"	e	enum:AExpression::__anon43	file:
AExpression::sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 7 };$/;"	e	enum:AExpression::__anon74	file:
AProgramItem	test/output/gen.cpp	/^	AProgramItem()$/;"	f	struct:AProgramItem	access:public	signature:()
AProgramItem	test/output/gen.cpp	/^struct AProgramItem : public type$/;"	s	file:	inherits:type
AProgramItem	test/output/tinyg.cpp	/^	AProgramItem()$/;"	f	struct:AProgramItem	access:public	signature:()
AProgramItem	test/output/tinyg.cpp	/^struct AProgramItem : public type$/;"	s	file:	inherits:type
AProgramItem	test/output/tinyg/tinyg.cpp	/^	AProgramItem()$/;"	f	struct:AProgramItem	access:public	signature:()
AProgramItem	test/output/tinyg/tinyg.cpp	/^struct AProgramItem : public type$/;"	s	file:	inherits:type
AProgramItem	test/output/tinyg/tinyg_bk.cpp	/^	AProgramItem()$/;"	f	struct:AProgramItem	access:public	signature:()
AProgramItem	test/output/tinyg/tinyg_bk.cpp	/^struct AProgramItem : public type$/;"	s	file:	inherits:type
AProgramItem::AProgramItem	test/output/gen.cpp	/^	AProgramItem()$/;"	f	struct:AProgramItem	access:public	signature:()
AProgramItem::AProgramItem	test/output/tinyg.cpp	/^	AProgramItem()$/;"	f	struct:AProgramItem	access:public	signature:()
AProgramItem::AProgramItem	test/output/tinyg/tinyg.cpp	/^	AProgramItem()$/;"	f	struct:AProgramItem	access:public	signature:()
AProgramItem::AProgramItem	test/output/tinyg/tinyg_bk.cpp	/^	AProgramItem()$/;"	f	struct:AProgramItem	access:public	signature:()
AProgramItem::sid	test/output/gen.cpp	/^	enum{ sid = 1002 };$/;"	e	enum:AProgramItem::__anon99	file:
AProgramItem::sid	test/output/tinyg.cpp	/^	enum{ sid = 1 };$/;"	e	enum:AProgramItem::__anon6	file:
AProgramItem::sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 1 };$/;"	e	enum:AProgramItem::__anon37	file:
AProgramItem::sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 1 };$/;"	e	enum:AProgramItem::__anon68	file:
ASSERT_COMMAND_ARGUMENTS	test/unittest.h	39;"	d
AToUTF8	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::AToUTF8( MCD_CSTR pszANSI )$/;"	f	class:CMarkup	signature:( MCD_CSTR pszANSI )
AToUTF8	third_party/xml/Markup.h	/^	static MCD_STR AToUTF8( MCD_CSTR pszANSI );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR pszANSI )
AValue	test/output/gen.cpp	/^	AValue()$/;"	f	struct:AValue	access:public	signature:()
AValue	test/output/gen.cpp	/^struct AValue : public type$/;"	s	file:	inherits:type
AValue	test/output/tinyg.cpp	/^	AValue()$/;"	f	struct:AValue	access:public	signature:()
AValue	test/output/tinyg.cpp	/^struct AValue : public type$/;"	s	file:	inherits:type
AValue	test/output/tinyg/tinyg.cpp	/^	AValue()$/;"	f	struct:AValue	access:public	signature:()
AValue	test/output/tinyg/tinyg.cpp	/^struct AValue : public type$/;"	s	file:	inherits:type
AValue	test/output/tinyg/tinyg_bk.cpp	/^	AValue()$/;"	f	struct:AValue	access:public	signature:()
AValue	test/output/tinyg/tinyg_bk.cpp	/^struct AValue : public type$/;"	s	file:	inherits:type
AValue::AValue	test/output/gen.cpp	/^	AValue()$/;"	f	struct:AValue	access:public	signature:()
AValue::AValue	test/output/tinyg.cpp	/^	AValue()$/;"	f	struct:AValue	access:public	signature:()
AValue::AValue	test/output/tinyg/tinyg.cpp	/^	AValue()$/;"	f	struct:AValue	access:public	signature:()
AValue::AValue	test/output/tinyg/tinyg_bk.cpp	/^	AValue()$/;"	f	struct:AValue	access:public	signature:()
AValue::sid	test/output/gen.cpp	/^	enum{ sid = 1003 };$/;"	e	enum:AValue::__anon100	file:
AValue::sid	test/output/tinyg.cpp	/^	enum{ sid = 8 };$/;"	e	enum:AValue::__anon13	file:
AValue::sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 8 };$/;"	e	enum:AValue::__anon44	file:
AValue::sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 8 };$/;"	e	enum:AValue::__anon75	file:
AddAttrib	third_party/xml/Markup.h	/^	bool AddAttrib( MCD_CSTR szAttrib, MCD_CSTR szValue ) { return x_SetAttrib(m_iPos,szAttrib,szValue); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib, MCD_CSTR szValue )
AddAttrib	third_party/xml/Markup.h	/^	bool AddAttrib( MCD_CSTR szAttrib, int nValue ) { return x_SetAttrib(m_iPos,szAttrib,nValue); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib, int nValue )
AddChildAttrib	third_party/xml/Markup.h	/^	bool AddChildAttrib( MCD_CSTR szAttrib, MCD_CSTR szValue ) { return x_SetAttrib(m_iPosChild,szAttrib,szValue); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib, MCD_CSTR szValue )
AddChildAttrib	third_party/xml/Markup.h	/^	bool AddChildAttrib( MCD_CSTR szAttrib, int nValue ) { return x_SetAttrib(m_iPosChild,szAttrib,nValue); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib, int nValue )
AddChildElem	third_party/xml/Markup.h	/^	bool AddChildElem( MCD_CSTR szName, MCD_CSTR szData=NULL, int nFlags=0 ) { return x_AddElem(szName,szData,nFlags|MNF_CHILD); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szName, MCD_CSTR szData=NULL, int nFlags=0 )
AddChildElem	third_party/xml/Markup.h	/^	bool AddChildElem( MCD_CSTR szName, int nValue, int nFlags=0 ) { return x_AddElem(szName,nValue,nFlags|MNF_CHILD); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szName, int nValue, int nFlags=0 )
AddChildSubDoc	third_party/xml/Markup.h	/^	bool AddChildSubDoc( MCD_CSTR szSubDoc ) { return x_AddSubDoc(szSubDoc,MNF_CHILD); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szSubDoc )
AddElem	third_party/xml/Markup.h	/^	bool AddElem( MCD_CSTR szName, MCD_CSTR szData=NULL, int nFlags=0 ) { return x_AddElem(szName,szData,nFlags); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szName, MCD_CSTR szData=NULL, int nFlags=0 )
AddElem	third_party/xml/Markup.h	/^	bool AddElem( MCD_CSTR szName, int nValue, int nFlags=0 ) { return x_AddElem(szName,nValue,nFlags); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szName, int nValue, int nFlags=0 )
AddNode	third_party/xml/Markup.h	/^	bool AddNode( int nType, MCD_CSTR szText ) { return x_AddNode(nType,szText,0); };$/;"	f	class:CMarkup	access:public	signature:( int nType, MCD_CSTR szText )
AddSubDoc	third_party/xml/Markup.h	/^	bool AddSubDoc( MCD_CSTR szSubDoc ) { return x_AddSubDoc(szSubDoc,0); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szSubDoc )
AdjustStartTagLen	third_party/xml/Markup.cpp	/^	void AdjustStartTagLen( int n ) { nStartTagLen += n; };$/;"	f	struct:ElemPos	access:public	signature:( int n )
AlgorithmArg	galgorithm/lranalyse.cpp	/^	AlgorithmArg(const tinygrammar& tig);$/;"	p	struct:AlgorithmArg	file:	access:public	signature:(const tinygrammar& tig)
AlgorithmArg	galgorithm/lranalyse.cpp	/^AlgorithmArg::AlgorithmArg(const tinygrammar& gin)$/;"	f	class:AlgorithmArg	signature:(const tinygrammar& gin)
AlgorithmArg	galgorithm/lranalyse.cpp	/^struct AlgorithmArg$/;"	s	file:
AlgorithmArg::AlgorithmArg	galgorithm/lranalyse.cpp	/^	AlgorithmArg(const tinygrammar& tig);$/;"	p	struct:AlgorithmArg	file:	access:public	signature:(const tinygrammar& tig)
AlgorithmArg::AlgorithmArg	galgorithm/lranalyse.cpp	/^AlgorithmArg::AlgorithmArg(const tinygrammar& gin)$/;"	f	class:AlgorithmArg	signature:(const tinygrammar& gin)
AlgorithmArg::CheckLR1	galgorithm/lranalyse.cpp	/^	bool CheckLR1(const lrstate* cs) const;$/;"	p	struct:AlgorithmArg	file:	access:public	signature:(const lrstate* cs) const
AlgorithmArg::CheckLR1	galgorithm/lranalyse.cpp	/^bool AlgorithmArg::CheckLR1(const lrstate* cs) const$/;"	f	class:AlgorithmArg	signature:(const lrstate* cs) const
AlgorithmArg::closures	galgorithm/lranalyse.cpp	/^	eclosure::closure_array closures;$/;"	m	struct:AlgorithmArg	file:	access:public
AlgorithmArg::firstsets	galgorithm/lranalyse.cpp	/^	firstset::vecintset firstsets;$/;"	m	struct:AlgorithmArg	file:	access:public
AlgorithmArg::get_firsts	galgorithm/lranalyse.cpp	/^	void get_firsts(int32 x, const sfollowset& f, sfollowset& nf) const;$/;"	p	struct:AlgorithmArg	file:	access:public	signature:(int32 x, const sfollowset& f, sfollowset& nf) const
AlgorithmArg::get_firsts	galgorithm/lranalyse.cpp	/^void AlgorithmArg::get_firsts(int32 x, const sfollowset& f, sfollowset& nf) const$/;"	f	class:AlgorithmArg	signature:(int32 x, const sfollowset& f, sfollowset& nf) const
AlgorithmArg::get_lrsid	galgorithm/lranalyse.cpp	/^	int32 get_lrsid(const lrstate* p) const;$/;"	p	struct:AlgorithmArg	file:	access:public	signature:(const lrstate* p) const
AlgorithmArg::get_lrsid	galgorithm/lranalyse.cpp	/^int32 AlgorithmArg::get_lrsid(const lrstate* p) const$/;"	f	class:AlgorithmArg	signature:(const lrstate* p) const
AlgorithmArg::get_next_symbol	galgorithm/lranalyse.cpp	/^	int32 get_next_symbol(const production& p, int32 idot) const;$/;"	p	struct:AlgorithmArg	file:	access:public	signature:(const production& p, int32 idot) const
AlgorithmArg::get_next_symbol	galgorithm/lranalyse.cpp	/^int32 AlgorithmArg::get_next_symbol(const production& p, int32 idot) const$/;"	f	class:AlgorithmArg	signature:(const production& p, int32 idot) const
AlgorithmArg::get_pid	galgorithm/lranalyse.cpp	/^	int32 get_pid(const production* p) const;$/;"	p	struct:AlgorithmArg	file:	access:public	signature:(const production* p) const
AlgorithmArg::get_pid	galgorithm/lranalyse.cpp	/^int32 AlgorithmArg::get_pid(const production* p) const$/;"	f	class:AlgorithmArg	signature:(const production* p) const
AlgorithmArg::insert_new_state	galgorithm/lranalyse.cpp	/^	const lrstate* insert_new_state(const lrstate* A, int32 a, const lrstate* B);$/;"	p	struct:AlgorithmArg	file:	access:public	signature:(const lrstate* A, int32 a, const lrstate* B)
AlgorithmArg::insert_new_state	galgorithm/lranalyse.cpp	/^const lrstate* AlgorithmArg::insert_new_state(const lrstate* A, int32 a, const lrstate* B)$/;"	f	class:AlgorithmArg	signature:(const lrstate* A, int32 a, const lrstate* B)
AlgorithmArg::ists	galgorithm/lranalyse.cpp	/^	kog::smart_vector<int> ists; \/\/ is terminate symbol$/;"	m	struct:AlgorithmArg	file:	access:public
AlgorithmArg::lrsts	galgorithm/lranalyse.cpp	/^	std::list<lrstate> lrsts;$/;"	m	struct:AlgorithmArg	file:	access:public
AlgorithmArg::ntpi	galgorithm/lranalyse.cpp	/^	kog::smart_vector<int32> ntpi;$/;"	m	struct:AlgorithmArg	file:	access:public
AlgorithmArg::plist	galgorithm/lranalyse.cpp	/^	kog::smart_vector<const production*> plist;$/;"	m	struct:AlgorithmArg	file:	access:public
AlgorithmArg::sparsesheet	galgorithm/lranalyse.cpp	/^	std::list<kog::triple<const lrstate*, int32, nextstate> > sparsesheet;$/;"	m	struct:AlgorithmArg	file:	access:public
AlgorithmArg::tig	galgorithm/lranalyse.cpp	/^	const tinygrammar* tig;$/;"	m	struct:AlgorithmArg	file:	access:public
AlgorithmArg::update_closure	galgorithm/lranalyse.cpp	/^	void update_closure(lrstate& lrs) const;$/;"	p	struct:AlgorithmArg	file:	access:public	signature:(lrstate& lrs) const
AlgorithmArg::update_closure	galgorithm/lranalyse.cpp	/^void AlgorithmArg::update_closure(lrstate& li) const$/;"	f	class:AlgorithmArg	signature:(lrstate& li) const
Allink_	include/tree.h	/^	_Allink Allink_;$/;"	m	class:_tree_node	access:public
Alloc	third_party/xml/Markup.cpp	/^	void Alloc( int nNewSize ) { TagPos* pLNew = new TagPos[nNewSize]; Copy(pLNew); nSize=nNewSize; };$/;"	f	struct:ElemStack	access:protected	signature:( int nNewSize )
Alval_	include/tree.h	/^	_Alnode Alval_;$/;"	m	class:_tree_node	access:public
Aproduction	test/vhelp.h	/^	Aproduction(int32 L, const V& v)$/;"	f	class:Aproduction	access:public	signature:(int32 L, const V& v)
Aproduction	test/vhelp.h	/^    Aproduction(int32 L, const V& v, const std::string& funct)$/;"	f	class:Aproduction	access:public	signature:(int32 L, const V& v, const std::string& funct)
Aproduction	test/vhelp.h	/^class Aproduction : public compile::production$/;"	c	inherits:compile::production
Aproduction::Aproduction	test/vhelp.h	/^	Aproduction(int32 L, const V& v)$/;"	f	class:Aproduction	access:public	signature:(int32 L, const V& v)
Aproduction::Aproduction	test/vhelp.h	/^    Aproduction(int32 L, const V& v, const std::string& funct)$/;"	f	class:Aproduction	access:public	signature:(int32 L, const V& v, const std::string& funct)
Aproduction::int32	test/vhelp.h	/^	typedef compile::int32 int32;$/;"	t	class:Aproduction	access:private
Aproduction::tstring	test/vhelp.h	/^	typedef compile::tstring tstring;$/;"	t	class:Aproduction	access:private
Assignment	test/output/tinyg.cpp	/^	Assignment()$/;"	f	struct:Assignment	access:public	signature:()
Assignment	test/output/tinyg.cpp	/^struct Assignment : public type$/;"	s	file:	inherits:type
Assignment	test/output/tinyg/tinyg.cpp	/^	Assignment()$/;"	f	struct:Assignment	access:public	signature:()
Assignment	test/output/tinyg/tinyg.cpp	/^struct Assignment : public type$/;"	s	file:	inherits:type
Assignment	test/output/tinyg/tinyg_bk.cpp	/^	Assignment()$/;"	f	struct:Assignment	access:public	signature:()
Assignment	test/output/tinyg/tinyg_bk.cpp	/^struct Assignment : public type$/;"	s	file:	inherits:type
Assignment::Assignment	test/output/tinyg.cpp	/^	Assignment()$/;"	f	struct:Assignment	access:public	signature:()
Assignment::Assignment	test/output/tinyg/tinyg.cpp	/^	Assignment()$/;"	f	struct:Assignment	access:public	signature:()
Assignment::Assignment	test/output/tinyg/tinyg_bk.cpp	/^	Assignment()$/;"	f	struct:Assignment	access:public	signature:()
Assignment::sid	test/output/tinyg.cpp	/^	enum{ sid = 19 };$/;"	e	enum:Assignment::__anon24	file:
Assignment::sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 19 };$/;"	e	enum:Assignment::__anon55	file:
Assignment::sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 20 };$/;"	e	enum:Assignment::__anon86	file:
Asymbol	test/vhelp.h	/^	Asymbol(const tstring& sname, int32 ist, const tstring& regex_exp = "")$/;"	f	class:Asymbol	access:public	signature:(const tstring& sname, int32 ist, const tstring& regex_exp = Ó)
Asymbol	test/vhelp.h	/^class Asymbol : public compile::symbol$/;"	c	inherits:compile::symbol
Asymbol::Asymbol	test/vhelp.h	/^	Asymbol(const tstring& sname, int32 ist, const tstring& regex_exp = "")$/;"	f	class:Asymbol	access:public	signature:(const tstring& sname, int32 ist, const tstring& regex_exp = Ó)
Asymbol::int32	test/vhelp.h	/^	typedef compile::int32 int32;$/;"	t	class:Asymbol	access:private
Asymbol::keywords	test/tinygrammartest.cpp	/^std::deque<std::pair<tstring, int32> > Asymbol::keywords;$/;"	m	class:Asymbol	file:
Asymbol::keywords	test/vhelp.h	/^	static std::deque<std::pair<tstring, int32> > keywords;$/;"	m	class:Asymbol	access:public
Asymbol::smacs	test/tinygrammartest.cpp	/^std::deque<std::pair<tstring, int32> > Asymbol::smacs;$/;"	m	class:Asymbol	file:
Asymbol::smacs	test/vhelp.h	/^	static std::deque<std::pair<tstring, int32> > smacs;$/;"	m	class:Asymbol	access:public
Asymbol::stringBuf	test/tinygrammartest.cpp	/^std::deque<tchar> Asymbol::stringBuf;$/;"	m	class:Asymbol	file:
Asymbol::stringBuf	test/vhelp.h	/^	static std::deque<tchar> stringBuf;$/;"	m	class:Asymbol	access:public
Asymbol::tchar	test/vhelp.h	/^	typedef compile::tchar tchar;$/;"	t	class:Asymbol	access:private
Asymbol::tstring	test/vhelp.h	/^	typedef compile::tstring tstring;$/;"	t	class:Asymbol	access:private
AttribPredicateMatch	third_party/xml/Markup.cpp	/^	bool AttribPredicateMatch( TokenPos& token );$/;"	p	struct:PathPos	file:	access:public	signature:( TokenPos& token )
AttribPredicateMatch	third_party/xml/Markup.cpp	/^bool PathPos::AttribPredicateMatch( TokenPos& token )$/;"	f	class:PathPos	signature:( TokenPos& token )
BomTable	third_party/xml/Markup.cpp	/^struct BomTableStruct { const char* pszBom; int nBomLen; MCD_PCSZ pszBomEnc; int nBomFlag; } BomTable[] =$/;"	v	typeref:struct:BomTableStruct
BomTableStruct	third_party/xml/Markup.cpp	/^struct BomTableStruct { const char* pszBom; int nBomLen; MCD_PCSZ pszBomEnc; int nBomFlag; } BomTable[] =$/;"	s	file:
BomTableStruct::nBomFlag	third_party/xml/Markup.cpp	/^struct BomTableStruct { const char* pszBom; int nBomLen; MCD_PCSZ pszBomEnc; int nBomFlag; } BomTable[] =$/;"	m	struct:BomTableStruct	file:	access:public
BomTableStruct::nBomLen	third_party/xml/Markup.cpp	/^struct BomTableStruct { const char* pszBom; int nBomLen; MCD_PCSZ pszBomEnc; int nBomFlag; } BomTable[] =$/;"	m	struct:BomTableStruct	file:	access:public
BomTableStruct::pszBom	third_party/xml/Markup.cpp	/^struct BomTableStruct { const char* pszBom; int nBomLen; MCD_PCSZ pszBomEnc; int nBomFlag; } BomTable[] =$/;"	m	struct:BomTableStruct	file:	access:public
BomTableStruct::pszBomEnc	third_party/xml/Markup.cpp	/^struct BomTableStruct { const char* pszBom; int nBomLen; MCD_PCSZ pszBomEnc; int nBomFlag; } BomTable[] =$/;"	m	struct:BomTableStruct	file:	access:public
CALLF	makecompiler/gensyntax.cpp	452;"	d	file:
CATCH_EXCEPTIONS_COUT	include/macros.h	71;"	d
CMarkup	third_party/xml/Markup.h	/^	CMarkup( MCD_CSTR szDoc ) { x_InitMarkup(); SetDoc( szDoc ); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szDoc )
CMarkup	third_party/xml/Markup.h	/^	CMarkup( const CMarkup& markup ) { x_InitMarkup(); *this = markup; };$/;"	f	class:CMarkup	access:public	signature:( const CMarkup& markup )
CMarkup	third_party/xml/Markup.h	/^	CMarkup( int nFlags ) { x_InitMarkup(); SetDoc( NULL ); m_nDocFlags = nFlags; };$/;"	f	class:CMarkup	access:public	signature:( int nFlags )
CMarkup	third_party/xml/Markup.h	/^	CMarkup() { x_InitMarkup(); SetDoc( NULL ); };$/;"	f	class:CMarkup	access:public	signature:()
CMarkup	third_party/xml/Markup.h	/^class CMarkup$/;"	c
CMarkup::AToUTF8	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::AToUTF8( MCD_CSTR pszANSI )$/;"	f	class:CMarkup	signature:( MCD_CSTR pszANSI )
CMarkup::AToUTF8	third_party/xml/Markup.h	/^	static MCD_STR AToUTF8( MCD_CSTR pszANSI );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR pszANSI )
CMarkup::AddAttrib	third_party/xml/Markup.h	/^	bool AddAttrib( MCD_CSTR szAttrib, MCD_CSTR szValue ) { return x_SetAttrib(m_iPos,szAttrib,szValue); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib, MCD_CSTR szValue )
CMarkup::AddAttrib	third_party/xml/Markup.h	/^	bool AddAttrib( MCD_CSTR szAttrib, int nValue ) { return x_SetAttrib(m_iPos,szAttrib,nValue); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib, int nValue )
CMarkup::AddChildAttrib	third_party/xml/Markup.h	/^	bool AddChildAttrib( MCD_CSTR szAttrib, MCD_CSTR szValue ) { return x_SetAttrib(m_iPosChild,szAttrib,szValue); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib, MCD_CSTR szValue )
CMarkup::AddChildAttrib	third_party/xml/Markup.h	/^	bool AddChildAttrib( MCD_CSTR szAttrib, int nValue ) { return x_SetAttrib(m_iPosChild,szAttrib,nValue); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib, int nValue )
CMarkup::AddChildElem	third_party/xml/Markup.h	/^	bool AddChildElem( MCD_CSTR szName, MCD_CSTR szData=NULL, int nFlags=0 ) { return x_AddElem(szName,szData,nFlags|MNF_CHILD); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szName, MCD_CSTR szData=NULL, int nFlags=0 )
CMarkup::AddChildElem	third_party/xml/Markup.h	/^	bool AddChildElem( MCD_CSTR szName, int nValue, int nFlags=0 ) { return x_AddElem(szName,nValue,nFlags|MNF_CHILD); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szName, int nValue, int nFlags=0 )
CMarkup::AddChildSubDoc	third_party/xml/Markup.h	/^	bool AddChildSubDoc( MCD_CSTR szSubDoc ) { return x_AddSubDoc(szSubDoc,MNF_CHILD); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szSubDoc )
CMarkup::AddElem	third_party/xml/Markup.h	/^	bool AddElem( MCD_CSTR szName, MCD_CSTR szData=NULL, int nFlags=0 ) { return x_AddElem(szName,szData,nFlags); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szName, MCD_CSTR szData=NULL, int nFlags=0 )
CMarkup::AddElem	third_party/xml/Markup.h	/^	bool AddElem( MCD_CSTR szName, int nValue, int nFlags=0 ) { return x_AddElem(szName,nValue,nFlags); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szName, int nValue, int nFlags=0 )
CMarkup::AddNode	third_party/xml/Markup.h	/^	bool AddNode( int nType, MCD_CSTR szText ) { return x_AddNode(nType,szText,0); };$/;"	f	class:CMarkup	access:public	signature:( int nType, MCD_CSTR szText )
CMarkup::AddSubDoc	third_party/xml/Markup.h	/^	bool AddSubDoc( MCD_CSTR szSubDoc ) { return x_AddSubDoc(szSubDoc,0); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szSubDoc )
CMarkup::CMarkup	third_party/xml/Markup.h	/^	CMarkup( MCD_CSTR szDoc ) { x_InitMarkup(); SetDoc( szDoc ); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szDoc )
CMarkup::CMarkup	third_party/xml/Markup.h	/^	CMarkup( const CMarkup& markup ) { x_InitMarkup(); *this = markup; };$/;"	f	class:CMarkup	access:public	signature:( const CMarkup& markup )
CMarkup::CMarkup	third_party/xml/Markup.h	/^	CMarkup( int nFlags ) { x_InitMarkup(); SetDoc( NULL ); m_nDocFlags = nFlags; };$/;"	f	class:CMarkup	access:public	signature:( int nFlags )
CMarkup::CMarkup	third_party/xml/Markup.h	/^	CMarkup() { x_InitMarkup(); SetDoc( NULL ); };$/;"	f	class:CMarkup	access:public	signature:()
CMarkup::DecodeCharUTF16	third_party/xml/Markup.cpp	/^int CMarkup::DecodeCharUTF16( const unsigned short*& pwszUTF16, const unsigned short* pszUTF16End\/*=NULL*\/ )$/;"	f	class:CMarkup	signature:( const unsigned short*& pwszUTF16, const unsigned short* pszUTF16End )
CMarkup::DecodeCharUTF16	third_party/xml/Markup.h	/^	static int DecodeCharUTF16( const unsigned short*& pwszUTF16, const unsigned short* pszUTF16End = NULL );$/;"	p	class:CMarkup	access:public	signature:( const unsigned short*& pwszUTF16, const unsigned short* pszUTF16End = NULL )
CMarkup::DecodeCharUTF8	third_party/xml/Markup.cpp	/^int CMarkup::DecodeCharUTF8( const char*& pszUTF8, const char* pszUTF8End\/*=NULL*\/ )$/;"	f	class:CMarkup	signature:( const char*& pszUTF8, const char* pszUTF8End )
CMarkup::DecodeCharUTF8	third_party/xml/Markup.h	/^	static int DecodeCharUTF8( const char*& pszUTF8, const char* pszUTF8End = NULL );$/;"	p	class:CMarkup	access:public	signature:( const char*& pszUTF8, const char* pszUTF8End = NULL )
CMarkup::DetectUTF8	third_party/xml/Markup.cpp	/^bool CMarkup::DetectUTF8( const char* pText, int nTextLen, int* pnNonASCII\/*=NULL*\/, bool* bErrorAtEnd\/*=NULL*\/ )$/;"	f	class:CMarkup	signature:( const char* pText, int nTextLen, int* pnNonASCII , bool* bErrorAtEnd )
CMarkup::DetectUTF8	third_party/xml/Markup.h	/^	static bool DetectUTF8( const char* pText, int nTextLen, int* pnNonASCII = NULL, bool* bErrorAtEnd = NULL );$/;"	p	class:CMarkup	access:public	signature:( const char* pText, int nTextLen, int* pnNonASCII = NULL, bool* bErrorAtEnd = NULL )
CMarkup::EncodeCharUTF16	third_party/xml/Markup.cpp	/^void CMarkup::EncodeCharUTF16( int nUChar, unsigned short* pwszUTF16, int& nUTF16Len )$/;"	f	class:CMarkup	signature:( int nUChar, unsigned short* pwszUTF16, int& nUTF16Len )
CMarkup::EncodeCharUTF16	third_party/xml/Markup.h	/^	static void EncodeCharUTF16( int nUChar, unsigned short* pwszUTF16, int& nUTF16Len );$/;"	p	class:CMarkup	access:public	signature:( int nUChar, unsigned short* pwszUTF16, int& nUTF16Len )
CMarkup::EncodeCharUTF8	third_party/xml/Markup.cpp	/^void CMarkup::EncodeCharUTF8( int nUChar, char* pszUTF8, int& nUTF8Len )$/;"	f	class:CMarkup	signature:( int nUChar, char* pszUTF8, int& nUTF8Len )
CMarkup::EncodeCharUTF8	third_party/xml/Markup.h	/^	static void EncodeCharUTF8( int nUChar, char* pszUTF8, int& nUTF8Len );$/;"	p	class:CMarkup	access:public	signature:( int nUChar, char* pszUTF8, int& nUTF8Len )
CMarkup::EscapeText	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::EscapeText( MCD_CSTR szText, int nFlags )$/;"	f	class:CMarkup	signature:( MCD_CSTR szText, int nFlags )
CMarkup::EscapeText	third_party/xml/Markup.h	/^	static MCD_STR EscapeText( MCD_CSTR szText, int nFlags = 0 );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR szText, int nFlags = 0 )
CMarkup::FindChildElem	third_party/xml/Markup.cpp	/^bool CMarkup::FindChildElem( MCD_CSTR szName )$/;"	f	class:CMarkup	signature:( MCD_CSTR szName )
CMarkup::FindChildElem	third_party/xml/Markup.h	/^	bool FindChildElem( MCD_CSTR szName=NULL );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR szName=NULL )
CMarkup::FindElem	third_party/xml/Markup.cpp	/^bool CMarkup::FindElem( MCD_CSTR szName )$/;"	f	class:CMarkup	signature:( MCD_CSTR szName )
CMarkup::FindElem	third_party/xml/Markup.h	/^	bool FindElem( MCD_CSTR szName=NULL );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR szName=NULL )
CMarkup::FindNode	third_party/xml/Markup.cpp	/^int CMarkup::FindNode( int nType )$/;"	f	class:CMarkup	signature:( int nType )
CMarkup::FindNode	third_party/xml/Markup.h	/^	int FindNode( int nType=0 );$/;"	p	class:CMarkup	access:public	signature:( int nType=0 )
CMarkup::GetAttrib	third_party/xml/Markup.h	/^	MCD_STR GetAttrib( MCD_CSTR szAttrib ) const { return x_GetAttrib(m_iPos,szAttrib); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib ) const
CMarkup::GetAttribName	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::GetAttribName( int n ) const$/;"	f	class:CMarkup	signature:( int n ) const
CMarkup::GetAttribName	third_party/xml/Markup.h	/^	MCD_STR GetAttribName( int n ) const;$/;"	p	class:CMarkup	access:public	signature:( int n ) const
CMarkup::GetChildAttrib	third_party/xml/Markup.h	/^	MCD_STR GetChildAttrib( MCD_CSTR szAttrib ) const { return x_GetAttrib(m_iPosChild,szAttrib); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib ) const
CMarkup::GetChildData	third_party/xml/Markup.h	/^	MCD_STR GetChildData() { return x_GetData(m_iPosChild); };$/;"	f	class:CMarkup	access:public	signature:()
CMarkup::GetChildSubDoc	third_party/xml/Markup.h	/^	MCD_STR GetChildSubDoc() { return x_GetSubDoc(m_iPosChild); };$/;"	f	class:CMarkup	access:public	signature:()
CMarkup::GetChildTagName	third_party/xml/Markup.h	/^	MCD_STR GetChildTagName() const { return x_GetTagName(m_iPosChild); };$/;"	f	class:CMarkup	access:public	signature:() const
CMarkup::GetData	third_party/xml/Markup.h	/^	MCD_STR GetData() { return x_GetData(m_iPos); };$/;"	f	class:CMarkup	access:public	signature:()
CMarkup::GetDeclaredEncoding	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::GetDeclaredEncoding( MCD_CSTR szDoc )$/;"	f	class:CMarkup	signature:( MCD_CSTR szDoc )
CMarkup::GetDeclaredEncoding	third_party/xml/Markup.h	/^	static MCD_STR GetDeclaredEncoding( MCD_CSTR szDoc );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR szDoc )
CMarkup::GetDoc	third_party/xml/Markup.h	/^	const MCD_STR& GetDoc() const { return m_strDoc; };$/;"	f	class:CMarkup	access:public	signature:() const
CMarkup::GetDocFlags	third_party/xml/Markup.h	/^	int GetDocFlags() const { return m_nDocFlags; };$/;"	f	class:CMarkup	access:public	signature:() const
CMarkup::GetElemContent	third_party/xml/Markup.h	/^	MCD_STR GetElemContent() const { return x_GetElemContent(m_iPos); };$/;"	f	class:CMarkup	access:public	signature:() const
CMarkup::GetEncodingCodePage	third_party/xml/Markup.cpp	/^int CMarkup::GetEncodingCodePage( MCD_CSTR pszEncoding )$/;"	f	class:CMarkup	signature:( MCD_CSTR pszEncoding )
CMarkup::GetEncodingCodePage	third_party/xml/Markup.h	/^	static int GetEncodingCodePage( MCD_CSTR pszEncoding );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR pszEncoding )
CMarkup::GetError	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::GetError() const$/;"	f	class:CMarkup	signature:() const
CMarkup::GetError	third_party/xml/Markup.h	/^	MCD_STR GetError() const;$/;"	p	class:CMarkup	access:public	signature:() const
CMarkup::GetNodeType	third_party/xml/Markup.h	/^	int GetNodeType() { return m_nNodeType; };$/;"	f	class:CMarkup	access:public	signature:()
CMarkup::GetResult	third_party/xml/Markup.h	/^	const MCD_STR& GetResult() const { return m_strResult; };$/;"	f	class:CMarkup	access:public	signature:() const
CMarkup::GetSubDoc	third_party/xml/Markup.h	/^	MCD_STR GetSubDoc() { return x_GetSubDoc(m_iPos); };$/;"	f	class:CMarkup	access:public	signature:()
CMarkup::GetTagName	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::GetTagName() const$/;"	f	class:CMarkup	signature:() const
CMarkup::GetTagName	third_party/xml/Markup.h	/^	MCD_STR GetTagName() const;$/;"	p	class:CMarkup	access:public	signature:() const
CMarkup::InsertChildElem	third_party/xml/Markup.h	/^	bool InsertChildElem( MCD_CSTR szName, MCD_CSTR szData=NULL, int nFlags=0 ) { return x_AddElem(szName,szData,nFlags|MNF_INSERT|MNF_CHILD); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szName, MCD_CSTR szData=NULL, int nFlags=0 )
CMarkup::InsertChildElem	third_party/xml/Markup.h	/^	bool InsertChildElem( MCD_CSTR szName, int nValue, int nFlags=0 ) { return x_AddElem(szName,nValue,nFlags|MNF_INSERT|MNF_CHILD); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szName, int nValue, int nFlags=0 )
CMarkup::InsertChildSubDoc	third_party/xml/Markup.h	/^	bool InsertChildSubDoc( MCD_CSTR szSubDoc ) { return x_AddSubDoc(szSubDoc,MNF_CHILD|MNF_INSERT); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szSubDoc )
CMarkup::InsertElem	third_party/xml/Markup.h	/^	bool InsertElem( MCD_CSTR szName, MCD_CSTR szData=NULL, int nFlags=0 ) { return x_AddElem(szName,szData,nFlags|MNF_INSERT); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szName, MCD_CSTR szData=NULL, int nFlags=0 )
CMarkup::InsertElem	third_party/xml/Markup.h	/^	bool InsertElem( MCD_CSTR szName, int nValue, int nFlags=0 ) { return x_AddElem(szName,nValue,nFlags|MNF_INSERT); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szName, int nValue, int nFlags=0 )
CMarkup::InsertNode	third_party/xml/Markup.h	/^	bool InsertNode( int nType, MCD_CSTR szText ) { return x_AddNode(nType,szText,MNF_INSERT); };$/;"	f	class:CMarkup	access:public	signature:( int nType, MCD_CSTR szText )
CMarkup::InsertSubDoc	third_party/xml/Markup.h	/^	bool InsertSubDoc( MCD_CSTR szSubDoc ) { return x_AddSubDoc(szSubDoc,MNF_INSERT); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szSubDoc )
CMarkup::IntoElem	third_party/xml/Markup.cpp	/^bool CMarkup::IntoElem()$/;"	f	class:CMarkup	signature:()
CMarkup::IntoElem	third_party/xml/Markup.h	/^	bool IntoElem();$/;"	p	class:CMarkup	access:public	signature:()
CMarkup::IsWellFormed	third_party/xml/Markup.cpp	/^bool CMarkup::IsWellFormed()$/;"	f	class:CMarkup	signature:()
CMarkup::IsWellFormed	third_party/xml/Markup.h	/^	bool IsWellFormed();$/;"	p	class:CMarkup	access:public	signature:()
CMarkup::Load	third_party/xml/Markup.cpp	/^bool CMarkup::Load( MCD_CSTR_FILENAME szFileName )$/;"	f	class:CMarkup	signature:( MCD_CSTR_FILENAME szFileName )
CMarkup::Load	third_party/xml/Markup.h	/^	bool Load( MCD_CSTR_FILENAME szFileName );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR_FILENAME szFileName )
CMarkup::MDF_APPENDFILE	third_party/xml/Markup.h	/^		MDF_APPENDFILE = 64,$/;"	e	enum:CMarkup::MarkupDocFlags
CMarkup::MDF_IGNORECASE	third_party/xml/Markup.h	/^		MDF_IGNORECASE = 8,$/;"	e	enum:CMarkup::MarkupDocFlags
CMarkup::MDF_READFILE	third_party/xml/Markup.h	/^		MDF_READFILE = 16,$/;"	e	enum:CMarkup::MarkupDocFlags
CMarkup::MDF_UTF16BEFILE	third_party/xml/Markup.h	/^		MDF_UTF16BEFILE = 128$/;"	e	enum:CMarkup::MarkupDocFlags
CMarkup::MDF_UTF16LEFILE	third_party/xml/Markup.h	/^		MDF_UTF16LEFILE = 1,$/;"	e	enum:CMarkup::MarkupDocFlags
CMarkup::MDF_UTF8PREAMBLE	third_party/xml/Markup.h	/^		MDF_UTF8PREAMBLE = 4,$/;"	e	enum:CMarkup::MarkupDocFlags
CMarkup::MDF_WRITEFILE	third_party/xml/Markup.h	/^		MDF_WRITEFILE = 32,$/;"	e	enum:CMarkup::MarkupDocFlags
CMarkup::MNF_CHILD	third_party/xml/Markup.h	/^		MNF_CHILD      = 0x004000$/;"	e	enum:CMarkup::MarkupNodeFlagsInternal
CMarkup::MNF_ESCAPEQUOTES	third_party/xml/Markup.h	/^		MNF_ESCAPEQUOTES  = 0x100,$/;"	e	enum:CMarkup::MarkupNodeFlags
CMarkup::MNF_ILLDATA	third_party/xml/Markup.h	/^		MNF_ILLDATA    = 0x200000$/;"	e	enum:CMarkup::MarkupNodeFlags
CMarkup::MNF_INSERT	third_party/xml/Markup.h	/^		MNF_INSERT     = 0x002000,$/;"	e	enum:CMarkup::MarkupNodeFlagsInternal
CMarkup::MNF_NONENDED	third_party/xml/Markup.h	/^		MNF_NONENDED   = 0x100000,$/;"	e	enum:CMarkup::MarkupNodeFlags
CMarkup::MNF_WITHCDATA	third_party/xml/Markup.h	/^		MNF_WITHCDATA      = 0x01,$/;"	e	enum:CMarkup::MarkupNodeFlags
CMarkup::MNF_WITHNOEND	third_party/xml/Markup.h	/^		MNF_WITHNOEND      = 0x10,$/;"	e	enum:CMarkup::MarkupNodeFlags
CMarkup::MNF_WITHNOLINES	third_party/xml/Markup.h	/^		MNF_WITHNOLINES    = 0x02,$/;"	e	enum:CMarkup::MarkupNodeFlags
CMarkup::MNF_WITHREFS	third_party/xml/Markup.h	/^		MNF_WITHREFS       = 0x08,$/;"	e	enum:CMarkup::MarkupNodeFlags
CMarkup::MNF_WITHXHTMLSPACE	third_party/xml/Markup.h	/^		MNF_WITHXHTMLSPACE = 0x04,$/;"	e	enum:CMarkup::MarkupNodeFlags
CMarkup::MNT_CDATA_SECTION	third_party/xml/Markup.h	/^		MNT_CDATA_SECTION			= 8,    \/\/ 0x0008$/;"	e	enum:CMarkup::MarkupNodeType
CMarkup::MNT_COMMENT	third_party/xml/Markup.h	/^		MNT_COMMENT					= 32,   \/\/ 0x0020$/;"	e	enum:CMarkup::MarkupNodeType
CMarkup::MNT_DOCUMENT_TYPE	third_party/xml/Markup.h	/^		MNT_DOCUMENT_TYPE			= 64,   \/\/ 0x0040$/;"	e	enum:CMarkup::MarkupNodeType
CMarkup::MNT_ELEMENT	third_party/xml/Markup.h	/^		MNT_ELEMENT					= 1,    \/\/ 0x0001$/;"	e	enum:CMarkup::MarkupNodeType
CMarkup::MNT_EXCLUDE_WHITESPACE	third_party/xml/Markup.h	/^		MNT_EXCLUDE_WHITESPACE		= 123,  \/\/ 0x007b$/;"	e	enum:CMarkup::MarkupNodeType
CMarkup::MNT_LONE_END_TAG	third_party/xml/Markup.h	/^		MNT_LONE_END_TAG			= 128,  \/\/ 0x0080$/;"	e	enum:CMarkup::MarkupNodeType
CMarkup::MNT_NODE_ERROR	third_party/xml/Markup.h	/^		MNT_NODE_ERROR              = 32768 \/\/ 0x8000$/;"	e	enum:CMarkup::MarkupNodeType
CMarkup::MNT_PROCESSING_INSTRUCTION	third_party/xml/Markup.h	/^		MNT_PROCESSING_INSTRUCTION	= 16,   \/\/ 0x0010$/;"	e	enum:CMarkup::MarkupNodeType
CMarkup::MNT_TEXT	third_party/xml/Markup.h	/^		MNT_TEXT					= 2,    \/\/ 0x0002$/;"	e	enum:CMarkup::MarkupNodeType
CMarkup::MNT_TEXT_AND_WHITESPACE	third_party/xml/Markup.h	/^		MNT_TEXT_AND_WHITESPACE     = 6,    \/\/ 0x0006$/;"	e	enum:CMarkup::MarkupNodeType
CMarkup::MNT_WHITESPACE	third_party/xml/Markup.h	/^		MNT_WHITESPACE				= 4,    \/\/ 0x0004$/;"	e	enum:CMarkup::MarkupNodeType
CMarkup::MarkupDocFlags	third_party/xml/Markup.h	/^	enum MarkupDocFlags$/;"	g	class:CMarkup	access:public
CMarkup::MarkupNodeFlags	third_party/xml/Markup.h	/^	enum MarkupNodeFlags$/;"	g	class:CMarkup	access:public
CMarkup::MarkupNodeFlagsInternal	third_party/xml/Markup.h	/^	enum MarkupNodeFlagsInternal$/;"	g	class:CMarkup	access:protected
CMarkup::MarkupNodeType	third_party/xml/Markup.h	/^	enum MarkupNodeType$/;"	g	class:CMarkup	access:public
CMarkup::OutOfElem	third_party/xml/Markup.cpp	/^bool CMarkup::OutOfElem()$/;"	f	class:CMarkup	signature:()
CMarkup::OutOfElem	third_party/xml/Markup.h	/^	bool OutOfElem();$/;"	p	class:CMarkup	access:public	signature:()
CMarkup::ReadTextFile	third_party/xml/Markup.cpp	/^bool CMarkup::ReadTextFile( MCD_CSTR_FILENAME szFileName, MCD_STR& strDoc, MCD_STR* pstrResult, int* pnDocFlags, MCD_STR* pstrEncoding )$/;"	f	class:CMarkup	signature:( MCD_CSTR_FILENAME szFileName, MCD_STR& strDoc, MCD_STR* pstrResult, int* pnDocFlags, MCD_STR* pstrEncoding )
CMarkup::ReadTextFile	third_party/xml/Markup.h	/^	static bool ReadTextFile( MCD_CSTR_FILENAME szFileName, MCD_STR& strDoc, MCD_STR* pstrResult=NULL, int* pnDocFlags=NULL, MCD_STR* pstrEncoding=NULL );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR_FILENAME szFileName, MCD_STR& strDoc, MCD_STR* pstrResult=NULL, int* pnDocFlags=NULL, MCD_STR* pstrEncoding=NULL )
CMarkup::RemoveChildElem	third_party/xml/Markup.cpp	/^bool CMarkup::RemoveChildElem()$/;"	f	class:CMarkup	signature:()
CMarkup::RemoveChildElem	third_party/xml/Markup.h	/^	bool RemoveChildElem();$/;"	p	class:CMarkup	access:public	signature:()
CMarkup::RemoveElem	third_party/xml/Markup.cpp	/^bool CMarkup::RemoveElem()$/;"	f	class:CMarkup	signature:()
CMarkup::RemoveElem	third_party/xml/Markup.h	/^	bool RemoveElem();$/;"	p	class:CMarkup	access:public	signature:()
CMarkup::RemoveNode	third_party/xml/Markup.cpp	/^bool CMarkup::RemoveNode()$/;"	f	class:CMarkup	signature:()
CMarkup::RemoveNode	third_party/xml/Markup.h	/^	bool RemoveNode();$/;"	p	class:CMarkup	access:public	signature:()
CMarkup::ResetChildPos	third_party/xml/Markup.h	/^	void ResetChildPos() { x_SetPos(m_iPosParent,m_iPos,0); };$/;"	f	class:CMarkup	access:public	signature:()
CMarkup::ResetMainPos	third_party/xml/Markup.h	/^	void ResetMainPos() { x_SetPos(m_iPosParent,0,0); };$/;"	f	class:CMarkup	access:public	signature:()
CMarkup::ResetPos	third_party/xml/Markup.h	/^	void ResetPos() { x_SetPos(0,0,0); };$/;"	f	class:CMarkup	access:public	signature:()
CMarkup::RestorePos	third_party/xml/Markup.cpp	/^bool CMarkup::RestorePos( MCD_CSTR szPosName \/*=""*\/, int nMap \/*=0*\/ )$/;"	f	class:CMarkup	signature:( MCD_CSTR szPosName , int nMap )
CMarkup::RestorePos	third_party/xml/Markup.h	/^	bool RestorePos( MCD_CSTR szPosName=MCD_T(""), int nMap = 0 );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR szPosName=MCD_T(Ó), int nMap = 0 )
CMarkup::Save	third_party/xml/Markup.cpp	/^bool CMarkup::Save( MCD_CSTR_FILENAME szFileName )$/;"	f	class:CMarkup	signature:( MCD_CSTR_FILENAME szFileName )
CMarkup::Save	third_party/xml/Markup.h	/^	bool Save( MCD_CSTR_FILENAME szFileName );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR_FILENAME szFileName )
CMarkup::SavePos	third_party/xml/Markup.cpp	/^bool CMarkup::SavePos( MCD_CSTR szPosName \/*=""*\/, int nMap \/*=0*\/ )$/;"	f	class:CMarkup	signature:( MCD_CSTR szPosName , int nMap )
CMarkup::SavePos	third_party/xml/Markup.h	/^	bool SavePos( MCD_CSTR szPosName=MCD_T(""), int nMap = 0 );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR szPosName=MCD_T(Ó), int nMap = 0 )
CMarkup::SetAttrib	third_party/xml/Markup.h	/^	bool SetAttrib( MCD_CSTR szAttrib, MCD_CSTR szValue, int nFlags=0 ) { return x_SetAttrib(m_iPos,szAttrib,szValue,nFlags); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib, MCD_CSTR szValue, int nFlags=0 )
CMarkup::SetAttrib	third_party/xml/Markup.h	/^	bool SetAttrib( MCD_CSTR szAttrib, int nValue, int nFlags=0 ) { return x_SetAttrib(m_iPos,szAttrib,nValue,nFlags); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib, int nValue, int nFlags=0 )
CMarkup::SetChildAttrib	third_party/xml/Markup.h	/^	bool SetChildAttrib( MCD_CSTR szAttrib, MCD_CSTR szValue, int nFlags=0 ) { return x_SetAttrib(m_iPosChild,szAttrib,szValue,nFlags); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib, MCD_CSTR szValue, int nFlags=0 )
CMarkup::SetChildAttrib	third_party/xml/Markup.h	/^	bool SetChildAttrib( MCD_CSTR szAttrib, int nValue, int nFlags=0 ) { return x_SetAttrib(m_iPosChild,szAttrib,nValue,nFlags); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib, int nValue, int nFlags=0 )
CMarkup::SetChildData	third_party/xml/Markup.h	/^	bool SetChildData( MCD_CSTR szData, int nFlags=0 ) { return x_SetData(m_iPosChild,szData,nFlags); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szData, int nFlags=0 )
CMarkup::SetChildData	third_party/xml/Markup.h	/^	bool SetChildData( int nValue ) { return x_SetData(m_iPosChild,nValue); };$/;"	f	class:CMarkup	access:public	signature:( int nValue )
CMarkup::SetData	third_party/xml/Markup.h	/^	bool SetData( MCD_CSTR szData, int nFlags=0 ) { return x_SetData(m_iPos,szData,nFlags); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szData, int nFlags=0 )
CMarkup::SetData	third_party/xml/Markup.h	/^	bool SetData( int nValue ) { return x_SetData(m_iPos,nValue); };$/;"	f	class:CMarkup	access:public	signature:( int nValue )
CMarkup::SetDoc	third_party/xml/Markup.cpp	/^bool CMarkup::SetDoc( MCD_PCSZ pDoc )$/;"	f	class:CMarkup	signature:( MCD_PCSZ pDoc )
CMarkup::SetDoc	third_party/xml/Markup.cpp	/^bool CMarkup::SetDoc( const MCD_STR& strDoc )$/;"	f	class:CMarkup	signature:( const MCD_STR& strDoc )
CMarkup::SetDoc	third_party/xml/Markup.h	/^	bool SetDoc( MCD_PCSZ pDoc );$/;"	p	class:CMarkup	access:public	signature:( MCD_PCSZ pDoc )
CMarkup::SetDoc	third_party/xml/Markup.h	/^	bool SetDoc( const MCD_STR& strDoc );$/;"	p	class:CMarkup	access:public	signature:( const MCD_STR& strDoc )
CMarkup::SetDocFlags	third_party/xml/Markup.h	/^	void SetDocFlags( int nFlags ) { m_nDocFlags = (nFlags & ~(MDF_READFILE|MDF_WRITEFILE|MDF_APPENDFILE)); };$/;"	f	class:CMarkup	access:public	signature:( int nFlags )
CMarkup::SetElemContent	third_party/xml/Markup.h	/^	bool SetElemContent( MCD_CSTR szContent ) { return x_SetElemContent(szContent); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szContent )
CMarkup::SetMapSize	third_party/xml/Markup.cpp	/^bool CMarkup::SetMapSize( int nSize, int nMap \/*=0*\/ )$/;"	f	class:CMarkup	signature:( int nSize, int nMap )
CMarkup::SetMapSize	third_party/xml/Markup.h	/^	bool SetMapSize( int nSize, int nMap = 0 );$/;"	p	class:CMarkup	access:public	signature:( int nSize, int nMap = 0 )
CMarkup::UTF16To8	third_party/xml/Markup.cpp	/^int CMarkup::UTF16To8( char* pszUTF8, const unsigned short* pwszUTF16, int nUTF8Count )$/;"	f	class:CMarkup	signature:( char* pszUTF8, const unsigned short* pwszUTF16, int nUTF8Count )
CMarkup::UTF16To8	third_party/xml/Markup.h	/^	static int UTF16To8( char *pszUTF8, const unsigned short* pwszUTF16, int nUTF8Count );$/;"	p	class:CMarkup	access:public	signature:( char *pszUTF8, const unsigned short* pwszUTF16, int nUTF8Count )
CMarkup::UTF8To16	third_party/xml/Markup.cpp	/^int CMarkup::UTF8To16( unsigned short* pwszUTF16, const char* pszUTF8, int nUTF8Count )$/;"	f	class:CMarkup	signature:( unsigned short* pwszUTF16, const char* pszUTF8, int nUTF8Count )
CMarkup::UTF8To16	third_party/xml/Markup.h	/^	static int UTF8To16( unsigned short* pwszUTF16, const char* pszUTF8, int nUTF8Count );$/;"	p	class:CMarkup	access:public	signature:( unsigned short* pwszUTF16, const char* pszUTF8, int nUTF8Count )
CMarkup::UTF8ToA	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::UTF8ToA( MCD_CSTR pszUTF8, int* pnFailed\/*=NULL*\/ )$/;"	f	class:CMarkup	signature:( MCD_CSTR pszUTF8, int* pnFailed )
CMarkup::UTF8ToA	third_party/xml/Markup.h	/^	static MCD_STR UTF8ToA( MCD_CSTR pszUTF8, int* pnFailed = NULL );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR pszUTF8, int* pnFailed = NULL )
CMarkup::UnescapeText	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::UnescapeText( MCD_CSTR szText, int nTextLength \/*=-1*\/ )$/;"	f	class:CMarkup	signature:( MCD_CSTR szText, int nTextLength )
CMarkup::UnescapeText	third_party/xml/Markup.h	/^	static MCD_STR UnescapeText( MCD_CSTR szText, int nTextLength = -1 );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR szText, int nTextLength = -1 )
CMarkup::WriteTextFile	third_party/xml/Markup.cpp	/^bool CMarkup::WriteTextFile( MCD_CSTR_FILENAME szFileName, const MCD_STR& strDoc, MCD_STR* pstrResult, int* pnDocFlags, MCD_STR* pstrEncoding )$/;"	f	class:CMarkup	signature:( MCD_CSTR_FILENAME szFileName, const MCD_STR& strDoc, MCD_STR* pstrResult, int* pnDocFlags, MCD_STR* pstrEncoding )
CMarkup::WriteTextFile	third_party/xml/Markup.h	/^	static bool WriteTextFile( MCD_CSTR_FILENAME szFileName, const MCD_STR& strDoc, MCD_STR* pstrResult=NULL, int* pnDocFlags=NULL, MCD_STR* pstrEncoding=NULL );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR_FILENAME szFileName, const MCD_STR& strDoc, MCD_STR* pstrResult=NULL, int* pnDocFlags=NULL, MCD_STR* pstrEncoding=NULL )
CMarkup::m_iPos	third_party/xml/Markup.h	/^	int m_iPos;$/;"	m	class:CMarkup	access:protected
CMarkup::m_iPosChild	third_party/xml/Markup.h	/^	int m_iPosChild;$/;"	m	class:CMarkup	access:protected
CMarkup::m_iPosDeleted	third_party/xml/Markup.h	/^	int m_iPosDeleted;$/;"	m	class:CMarkup	access:protected
CMarkup::m_iPosFree	third_party/xml/Markup.h	/^	int m_iPosFree;$/;"	m	class:CMarkup	access:protected
CMarkup::m_iPosParent	third_party/xml/Markup.h	/^	int m_iPosParent;$/;"	m	class:CMarkup	access:protected
CMarkup::m_nDocFlags	third_party/xml/Markup.h	/^	int m_nDocFlags;$/;"	m	class:CMarkup	access:protected
CMarkup::m_nNodeLength	third_party/xml/Markup.h	/^	int m_nNodeLength;$/;"	m	class:CMarkup	access:protected
CMarkup::m_nNodeOffset	third_party/xml/Markup.h	/^	int m_nNodeOffset;$/;"	m	class:CMarkup	access:protected
CMarkup::m_nNodeType	third_party/xml/Markup.h	/^	int m_nNodeType;$/;"	m	class:CMarkup	access:protected
CMarkup::m_pDebugCur	third_party/xml/Markup.h	/^	MCD_PCSZ m_pDebugCur;$/;"	m	class:CMarkup	access:protected
CMarkup::m_pDebugPos	third_party/xml/Markup.h	/^	MCD_PCSZ m_pDebugPos;$/;"	m	class:CMarkup	access:protected
CMarkup::m_pElemPosTree	third_party/xml/Markup.h	/^	ElemPosTree* m_pElemPosTree;$/;"	m	class:CMarkup	access:protected
CMarkup::m_pFilePos	third_party/xml/Markup.h	/^	FilePos* m_pFilePos;$/;"	m	class:CMarkup	access:protected
CMarkup::m_pSavedPosMaps	third_party/xml/Markup.h	/^	SavedPosMapArray* m_pSavedPosMaps;$/;"	m	class:CMarkup	access:protected
CMarkup::m_strDoc	third_party/xml/Markup.h	/^	MCD_STR m_strDoc;$/;"	m	class:CMarkup	access:protected
CMarkup::m_strResult	third_party/xml/Markup.h	/^	MCD_STR m_strResult;$/;"	m	class:CMarkup	access:protected
CMarkup::operator =	third_party/xml/Markup.cpp	/^void CMarkup::operator=( const CMarkup& markup )$/;"	f	class:CMarkup	signature:( const CMarkup& markup )
CMarkup::operator =	third_party/xml/Markup.h	/^	void operator=( const CMarkup& markup );$/;"	p	class:CMarkup	access:public	signature:( const CMarkup& markup )
CMarkup::x_AddElem	third_party/xml/Markup.cpp	/^bool CMarkup::x_AddElem( MCD_PCSZ pName, MCD_PCSZ pValue, int nFlags )$/;"	f	class:CMarkup	signature:( MCD_PCSZ pName, MCD_PCSZ pValue, int nFlags )
CMarkup::x_AddElem	third_party/xml/Markup.cpp	/^bool CMarkup::x_AddElem( MCD_PCSZ pName, int nValue, int nFlags )$/;"	f	class:CMarkup	signature:( MCD_PCSZ pName, int nValue, int nFlags )
CMarkup::x_AddElem	third_party/xml/Markup.h	/^	bool x_AddElem( MCD_PCSZ pName, MCD_PCSZ pValue, int nFlags );$/;"	p	class:CMarkup	access:protected	signature:( MCD_PCSZ pName, MCD_PCSZ pValue, int nFlags )
CMarkup::x_AddElem	third_party/xml/Markup.h	/^	bool x_AddElem( MCD_PCSZ pName, int nValue, int nFlags );$/;"	p	class:CMarkup	access:protected	signature:( MCD_PCSZ pName, int nValue, int nFlags )
CMarkup::x_AddNode	third_party/xml/Markup.cpp	/^bool CMarkup::x_AddNode( int nNodeType, MCD_PCSZ pText, int nNodeFlags )$/;"	f	class:CMarkup	signature:( int nNodeType, MCD_PCSZ pText, int nNodeFlags )
CMarkup::x_AddNode	third_party/xml/Markup.h	/^	bool x_AddNode( int nNodeType, MCD_PCSZ pText, int nNodeFlags );$/;"	p	class:CMarkup	access:protected	signature:( int nNodeType, MCD_PCSZ pText, int nNodeFlags )
CMarkup::x_AddSubDoc	third_party/xml/Markup.cpp	/^bool CMarkup::x_AddSubDoc( MCD_PCSZ pSubDoc, int nFlags )$/;"	f	class:CMarkup	signature:( MCD_PCSZ pSubDoc, int nFlags )
CMarkup::x_AddSubDoc	third_party/xml/Markup.h	/^	bool x_AddSubDoc( MCD_PCSZ pSubDoc, int nFlags );$/;"	p	class:CMarkup	access:protected	signature:( MCD_PCSZ pSubDoc, int nFlags )
CMarkup::x_Adjust	third_party/xml/Markup.cpp	/^void CMarkup::x_Adjust( int iPos, int nShift, bool bAfterPos \/*=false*\/ )$/;"	f	class:CMarkup	signature:( int iPos, int nShift, bool bAfterPos )
CMarkup::x_Adjust	third_party/xml/Markup.h	/^	void x_Adjust( int iPos, int nShift, bool bAfterPos = false );$/;"	p	class:CMarkup	access:protected	signature:( int iPos, int nShift, bool bAfterPos = false )
CMarkup::x_AdjustForNode	third_party/xml/Markup.cpp	/^void CMarkup::x_AdjustForNode( int iPosParent, int iPos, int nShift )$/;"	f	class:CMarkup	signature:( int iPosParent, int iPos, int nShift )
CMarkup::x_AdjustForNode	third_party/xml/Markup.h	/^	void x_AdjustForNode( int iPosParent, int iPos, int nShift );$/;"	p	class:CMarkup	access:protected	signature:( int iPosParent, int iPos, int nShift )
CMarkup::x_AllocElemPos	third_party/xml/Markup.cpp	/^bool CMarkup::x_AllocElemPos( int nNewSize \/*=0*\/ )$/;"	f	class:CMarkup	signature:( int nNewSize )
CMarkup::x_AllocElemPos	third_party/xml/Markup.h	/^	bool x_AllocElemPos( int nNewSize = 0 );$/;"	p	class:CMarkup	access:protected	signature:( int nNewSize = 0 )
CMarkup::x_CheckSavedPos	third_party/xml/Markup.cpp	/^void CMarkup::x_CheckSavedPos()$/;"	f	class:CMarkup	signature:()
CMarkup::x_CheckSavedPos	third_party/xml/Markup.h	/^	void x_CheckSavedPos();$/;"	p	class:CMarkup	access:protected	signature:()
CMarkup::x_CreateNode	third_party/xml/Markup.cpp	/^bool CMarkup::x_CreateNode( MCD_STR& strNode, int nNodeType, MCD_PCSZ pText )$/;"	f	class:CMarkup	signature:( MCD_STR& strNode, int nNodeType, MCD_PCSZ pText )
CMarkup::x_CreateNode	third_party/xml/Markup.h	/^	static bool x_CreateNode( MCD_STR& strNode, int nNodeType, MCD_PCSZ pText );$/;"	p	class:CMarkup	access:protected	signature:( MCD_STR& strNode, int nNodeType, MCD_PCSZ pText )
CMarkup::x_DocChange	third_party/xml/Markup.cpp	/^void CMarkup::x_DocChange( int nLeft, int nReplace, const MCD_STR& strInsert )$/;"	f	class:CMarkup	signature:( int nLeft, int nReplace, const MCD_STR& strInsert )
CMarkup::x_DocChange	third_party/xml/Markup.h	/^	void x_DocChange( int nLeft, int nReplace, const MCD_STR& strInsert );$/;"	p	class:CMarkup	access:protected	signature:( int nLeft, int nReplace, const MCD_STR& strInsert )
CMarkup::x_EncodeCDATASection	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::x_EncodeCDATASection( MCD_PCSZ szData )$/;"	f	class:CMarkup	signature:( MCD_PCSZ szData )
CMarkup::x_EncodeCDATASection	third_party/xml/Markup.h	/^	static MCD_STR x_EncodeCDATASection( MCD_PCSZ szData );$/;"	p	class:CMarkup	access:protected	signature:( MCD_PCSZ szData )
CMarkup::x_FindElem	third_party/xml/Markup.cpp	/^int CMarkup::x_FindElem( int iPosParent, int iPos, PathPos& path ) const$/;"	f	class:CMarkup	signature:( int iPosParent, int iPos, PathPos& path ) const
CMarkup::x_FindElem	third_party/xml/Markup.h	/^	int x_FindElem( int iPosParent, int iPos, PathPos& path ) const;$/;"	p	class:CMarkup	access:protected	signature:( int iPosParent, int iPos, PathPos& path ) const
CMarkup::x_GetAttrib	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::x_GetAttrib( int iPos, MCD_PCSZ pAttrib ) const$/;"	f	class:CMarkup	signature:( int iPos, MCD_PCSZ pAttrib ) const
CMarkup::x_GetAttrib	third_party/xml/Markup.h	/^	MCD_STR x_GetAttrib( int iPos, MCD_PCSZ pAttrib ) const;$/;"	p	class:CMarkup	access:protected	signature:( int iPos, MCD_PCSZ pAttrib ) const
CMarkup::x_GetData	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::x_GetData( int iPos )$/;"	f	class:CMarkup	signature:( int iPos )
CMarkup::x_GetData	third_party/xml/Markup.h	/^	MCD_STR x_GetData( int iPos );$/;"	p	class:CMarkup	access:protected	signature:( int iPos )
CMarkup::x_GetElemContent	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::x_GetElemContent( int iPos ) const$/;"	f	class:CMarkup	signature:( int iPos ) const
CMarkup::x_GetElemContent	third_party/xml/Markup.h	/^	MCD_STR x_GetElemContent( int iPos ) const;$/;"	p	class:CMarkup	access:protected	signature:( int iPos ) const
CMarkup::x_GetFreePos	third_party/xml/Markup.cpp	/^int CMarkup::x_GetFreePos()$/;"	f	class:CMarkup	signature:()
CMarkup::x_GetFreePos	third_party/xml/Markup.h	/^	int x_GetFreePos();$/;"	p	class:CMarkup	access:protected	signature:()
CMarkup::x_GetParent	third_party/xml/Markup.cpp	/^int CMarkup::x_GetParent( int i )$/;"	f	class:CMarkup	signature:( int i )
CMarkup::x_GetParent	third_party/xml/Markup.h	/^	int x_GetParent( int i );$/;"	p	class:CMarkup	access:protected	signature:( int i )
CMarkup::x_GetPath	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::x_GetPath( int iPos ) const$/;"	f	class:CMarkup	signature:( int iPos ) const
CMarkup::x_GetPath	third_party/xml/Markup.h	/^	MCD_STR x_GetPath( int iPos ) const;$/;"	p	class:CMarkup	access:protected	signature:( int iPos ) const
CMarkup::x_GetSubDoc	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::x_GetSubDoc( int iPos )$/;"	f	class:CMarkup	signature:( int iPos )
CMarkup::x_GetSubDoc	third_party/xml/Markup.h	/^	MCD_STR x_GetSubDoc( int iPos );$/;"	p	class:CMarkup	access:protected	signature:( int iPos )
CMarkup::x_GetTagName	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::x_GetTagName( int iPos ) const$/;"	f	class:CMarkup	signature:( int iPos ) const
CMarkup::x_GetTagName	third_party/xml/Markup.h	/^	MCD_STR x_GetTagName( int iPos ) const;$/;"	p	class:CMarkup	access:protected	signature:( int iPos ) const
CMarkup::x_InitMarkup	third_party/xml/Markup.cpp	/^void CMarkup::x_InitMarkup()$/;"	f	class:CMarkup	signature:()
CMarkup::x_InitMarkup	third_party/xml/Markup.h	/^	void x_InitMarkup();$/;"	p	class:CMarkup	access:protected	signature:()
CMarkup::x_InsertNew	third_party/xml/Markup.cpp	/^int CMarkup::x_InsertNew( int iPosParent, int& iPosRel, NodePos& node )$/;"	f	class:CMarkup	signature:( int iPosParent, int& iPosRel, NodePos& node )
CMarkup::x_InsertNew	third_party/xml/Markup.h	/^	int x_InsertNew( int iPosParent, int& iPosRel, NodePos& node );$/;"	p	class:CMarkup	access:protected	signature:( int iPosParent, int& iPosRel, NodePos& node )
CMarkup::x_LinkElem	third_party/xml/Markup.cpp	/^void CMarkup::x_LinkElem( int iPosParent, int iPosBefore, int iPos )$/;"	f	class:CMarkup	signature:( int iPosParent, int iPosBefore, int iPos )
CMarkup::x_LinkElem	third_party/xml/Markup.h	/^	void x_LinkElem( int iPosParent, int iPosBefore, int iPos );$/;"	p	class:CMarkup	access:protected	signature:( int iPosParent, int iPosBefore, int iPos )
CMarkup::x_ParseDoc	third_party/xml/Markup.cpp	/^bool CMarkup::x_ParseDoc()$/;"	f	class:CMarkup	signature:()
CMarkup::x_ParseDoc	third_party/xml/Markup.h	/^	bool x_ParseDoc();$/;"	p	class:CMarkup	access:protected	signature:()
CMarkup::x_ParseElem	third_party/xml/Markup.cpp	/^int CMarkup::x_ParseElem( int iPosParent, TokenPos& token )$/;"	f	class:CMarkup	signature:( int iPosParent, TokenPos& token )
CMarkup::x_ParseElem	third_party/xml/Markup.h	/^	int x_ParseElem( int iPos, TokenPos& token );$/;"	p	class:CMarkup	access:protected	signature:( int iPos, TokenPos& token )
CMarkup::x_ReleasePos	third_party/xml/Markup.cpp	/^int CMarkup::x_ReleasePos( int iPos )$/;"	f	class:CMarkup	signature:( int iPos )
CMarkup::x_ReleasePos	third_party/xml/Markup.h	/^	int x_ReleasePos( int iPos );$/;"	p	class:CMarkup	access:protected	signature:( int iPos )
CMarkup::x_ReleaseSubDoc	third_party/xml/Markup.cpp	/^int CMarkup::x_ReleaseSubDoc( int iPos )$/;"	f	class:CMarkup	signature:( int iPos )
CMarkup::x_ReleaseSubDoc	third_party/xml/Markup.h	/^	int x_ReleaseSubDoc( int iPos );$/;"	p	class:CMarkup	access:protected	signature:( int iPos )
CMarkup::x_RemoveElem	third_party/xml/Markup.cpp	/^int CMarkup::x_RemoveElem( int iPos )$/;"	f	class:CMarkup	signature:( int iPos )
CMarkup::x_RemoveElem	third_party/xml/Markup.h	/^	int x_RemoveElem( int iPos );$/;"	p	class:CMarkup	access:protected	signature:( int iPos )
CMarkup::x_RemoveNode	third_party/xml/Markup.cpp	/^void CMarkup::x_RemoveNode( int iPosParent, int& iPos, int& nNodeType, int& nNodeOffset, int& nNodeLength )$/;"	f	class:CMarkup	signature:( int iPosParent, int& iPos, int& nNodeType, int& nNodeOffset, int& nNodeLength )
CMarkup::x_RemoveNode	third_party/xml/Markup.h	/^	void x_RemoveNode( int iPosParent, int& iPos, int& nNodeType, int& nNodeOffset, int& nNodeLength );$/;"	p	class:CMarkup	access:protected	signature:( int iPosParent, int& iPos, int& nNodeType, int& nNodeOffset, int& nNodeLength )
CMarkup::x_SetAttrib	third_party/xml/Markup.cpp	/^bool CMarkup::x_SetAttrib( int iPos, MCD_PCSZ pAttrib, MCD_PCSZ pValue, int nFlags \/*=0*\/ )$/;"	f	class:CMarkup	signature:( int iPos, MCD_PCSZ pAttrib, MCD_PCSZ pValue, int nFlags )
CMarkup::x_SetAttrib	third_party/xml/Markup.cpp	/^bool CMarkup::x_SetAttrib( int iPos, MCD_PCSZ pAttrib, int nValue, int nFlags \/*=0*\/ )$/;"	f	class:CMarkup	signature:( int iPos, MCD_PCSZ pAttrib, int nValue, int nFlags )
CMarkup::x_SetAttrib	third_party/xml/Markup.h	/^	bool x_SetAttrib( int iPos, MCD_PCSZ pAttrib, MCD_PCSZ pValue, int nFlags=0 );$/;"	p	class:CMarkup	access:protected	signature:( int iPos, MCD_PCSZ pAttrib, MCD_PCSZ pValue, int nFlags=0 )
CMarkup::x_SetAttrib	third_party/xml/Markup.h	/^	bool x_SetAttrib( int iPos, MCD_PCSZ pAttrib, int nValue, int nFlags=0 );$/;"	p	class:CMarkup	access:protected	signature:( int iPos, MCD_PCSZ pAttrib, int nValue, int nFlags=0 )
CMarkup::x_SetData	third_party/xml/Markup.cpp	/^bool CMarkup::x_SetData( int iPos, MCD_PCSZ szData, int nFlags )$/;"	f	class:CMarkup	signature:( int iPos, MCD_PCSZ szData, int nFlags )
CMarkup::x_SetData	third_party/xml/Markup.cpp	/^bool CMarkup::x_SetData( int iPos, int nValue )$/;"	f	class:CMarkup	signature:( int iPos, int nValue )
CMarkup::x_SetData	third_party/xml/Markup.h	/^	bool x_SetData( int iPos, MCD_PCSZ szData, int nFlags );$/;"	p	class:CMarkup	access:protected	signature:( int iPos, MCD_PCSZ szData, int nFlags )
CMarkup::x_SetData	third_party/xml/Markup.h	/^	bool x_SetData( int iPos, int nValue );$/;"	p	class:CMarkup	access:protected	signature:( int iPos, int nValue )
CMarkup::x_SetDebugState	third_party/xml/Markup.cpp	/^void CMarkup::x_SetDebugState()$/;"	f	class:CMarkup	signature:()
CMarkup::x_SetDebugState	third_party/xml/Markup.h	/^	void x_SetDebugState();$/;"	p	class:CMarkup	access:protected	signature:()
CMarkup::x_SetElemContent	third_party/xml/Markup.cpp	/^bool CMarkup::x_SetElemContent( MCD_PCSZ szContent )$/;"	f	class:CMarkup	signature:( MCD_PCSZ szContent )
CMarkup::x_SetElemContent	third_party/xml/Markup.h	/^	bool x_SetElemContent( MCD_PCSZ szContent );$/;"	p	class:CMarkup	access:protected	signature:( MCD_PCSZ szContent )
CMarkup::x_SetPos	third_party/xml/Markup.cpp	/^void CMarkup::x_SetPos( int iPosParent, int iPos, int iPosChild )$/;"	f	class:CMarkup	signature:( int iPosParent, int iPos, int iPosChild )
CMarkup::x_SetPos	third_party/xml/Markup.h	/^	void x_SetPos( int iPosParent, int iPos, int iPosChild );$/;"	p	class:CMarkup	access:protected	signature:( int iPosParent, int iPos, int iPosChild )
CMarkup::x_UnlinkElem	third_party/xml/Markup.cpp	/^int CMarkup::x_UnlinkElem( int iPos )$/;"	f	class:CMarkup	signature:( int iPos )
CMarkup::x_UnlinkElem	third_party/xml/Markup.h	/^	int x_UnlinkElem( int iPos );$/;"	p	class:CMarkup	access:protected	signature:( int iPos )
CMarkup::x_UnlinkPrevElem	third_party/xml/Markup.cpp	/^int CMarkup::x_UnlinkPrevElem( int iPosParent, int iPosBefore, int iPos )$/;"	f	class:CMarkup	signature:( int iPosParent, int iPosBefore, int iPos )
CMarkup::x_UnlinkPrevElem	third_party/xml/Markup.h	/^	int x_UnlinkPrevElem( int iPosParent, int iPosBefore, int iPos );$/;"	p	class:CMarkup	access:protected	signature:( int iPosParent, int iPosBefore, int iPos )
CMarkup::~CMarkup	third_party/xml/Markup.cpp	/^CMarkup::~CMarkup()$/;"	f	class:CMarkup	signature:()
CMarkup::~CMarkup	third_party/xml/Markup.h	/^	~CMarkup();$/;"	p	class:CMarkup	access:public	signature:()
CONTENT_BEGIN	makecompiler/gensyntax.cpp	448;"	d	file:
CONTENT_END	makecompiler/gensyntax.cpp	449;"	d	file:
CalcSlot	third_party/xml/Markup.cpp	/^	static int CalcSlot( MCD_PCSZ pName, int n, bool bIC );$/;"	p	struct:ElemStack	file:	access:public	signature:( MCD_PCSZ pName, int n, bool bIC )
CalcSlot	third_party/xml/Markup.cpp	/^int ElemStack::CalcSlot( MCD_PCSZ pName, int n, bool bIC )$/;"	f	class:ElemStack	signature:( MCD_PCSZ pName, int n, bool bIC )
CanConvert	third_party/xml/Markup.cpp	/^	static bool CanConvert( MCD_CSTR pszToEncoding, MCD_CSTR pszFromEncoding );$/;"	p	struct:TextEncoding	file:	access:public	signature:( MCD_CSTR pszToEncoding, MCD_CSTR pszFromEncoding )
CanConvert	third_party/xml/Markup.cpp	/^bool TextEncoding::CanConvert( MCD_CSTR pszToEncoding, MCD_CSTR pszFromEncoding )$/;"	f	class:TextEncoding	signature:( MCD_CSTR pszToEncoding, MCD_CSTR pszFromEncoding )
Ccount	compiler/variable.h	/^	uint32 Ccount;$/;"	m	class:variable	access:public
CheckLR1	galgorithm/lranalyse.cpp	/^	bool CheckLR1(const lrstate* cs) const;$/;"	p	struct:AlgorithmArg	file:	access:public	signature:(const lrstate* cs) const
CheckLR1	galgorithm/lranalyse.cpp	/^bool AlgorithmArg::CheckLR1(const lrstate* cs) const$/;"	f	class:AlgorithmArg	signature:(const lrstate* cs) const
Clear	third_party/xml/Markup.cpp	/^	void Clear() { m_nL=0; m_nR=-1; m_nNext=0; };$/;"	f	struct:TokenPos	access:public	signature:()
Clear	third_party/xml/Markup.cpp	/^	void Clear() { m_nSegs=0; m_nSize=0; m_pSegs=NULL; };$/;"	f	struct:ElemPosTree	access:public	signature:()
ClearVirtualParent	third_party/xml/Markup.cpp	/^	void ClearVirtualParent() { memset(this,0,sizeof(ElemPos)); };$/;"	f	struct:ElemPos	access:public	signature:()
Column	include/arrayX.h	/^	const static size_t Column = _Col;$/;"	m	struct:SmartMatrix	access:public
ConstRowVector	include/arrayX.h	/^	typedef const_pointer ConstRowVector;$/;"	t	struct:SmartMatrix	access:public
ContentLen	third_party/xml/Markup.cpp	/^	int ContentLen() const { return nLength - StartTagLen() - EndTagLen(); };$/;"	f	struct:ElemPos	access:public	signature:() const
Copy	third_party/xml/Markup.cpp	/^	void Copy( TagPos* pLNew ) { for(int n=0;n<nSize;++n) pLNew[n]=pL[n]; if (pL) delete [] pL; pL=pLNew; };$/;"	f	struct:ElemStack	access:protected	signature:( TagPos* pLNew )
CopyElemPosTree	third_party/xml/Markup.cpp	/^	void CopyElemPosTree( ElemPosTree* pOtherTree, int n );$/;"	p	struct:ElemPosTree	file:	access:public	signature:( ElemPosTree* pOtherTree, int n )
CopyElemPosTree	third_party/xml/Markup.cpp	/^void ElemPosTree::CopyElemPosTree( ElemPosTree* pOtherTree, int n )$/;"	f	class:ElemPosTree	signature:( ElemPosTree* pOtherTree, int n )
CopySavedPosMaps	third_party/xml/Markup.cpp	/^	void CopySavedPosMaps( SavedPosMapArray* pOtherMaps );$/;"	p	struct:SavedPosMapArray	file:	access:public	signature:( SavedPosMapArray* pOtherMaps )
CopySavedPosMaps	third_party/xml/Markup.cpp	/^void SavedPosMapArray::CopySavedPosMaps( SavedPosMapArray* pOtherMaps )$/;"	f	class:SavedPosMapArray	signature:( SavedPosMapArray* pOtherMaps )
Current	third_party/xml/Markup.cpp	/^	TagPos& Current() { return pL[iTop]; };$/;"	f	struct:ElemStack	access:public	signature:()
DecodeCharUTF16	third_party/xml/Markup.cpp	/^int CMarkup::DecodeCharUTF16( const unsigned short*& pwszUTF16, const unsigned short* pszUTF16End\/*=NULL*\/ )$/;"	f	class:CMarkup	signature:( const unsigned short*& pwszUTF16, const unsigned short* pszUTF16End )
DecodeCharUTF16	third_party/xml/Markup.h	/^	static int DecodeCharUTF16( const unsigned short*& pwszUTF16, const unsigned short* pszUTF16End = NULL );$/;"	p	class:CMarkup	access:public	signature:( const unsigned short*& pwszUTF16, const unsigned short* pszUTF16End = NULL )
DecodeCharUTF8	third_party/xml/Markup.cpp	/^int CMarkup::DecodeCharUTF8( const char*& pszUTF8, const char* pszUTF8End\/*=NULL*\/ )$/;"	f	class:CMarkup	signature:( const char*& pszUTF8, const char* pszUTF8End )
DecodeCharUTF8	third_party/xml/Markup.h	/^	static int DecodeCharUTF8( const char*& pszUTF8, const char* pszUTF8End = NULL );$/;"	p	class:CMarkup	access:public	signature:( const char*& pszUTF8, const char* pszUTF8End = NULL )
DetectUTF8	third_party/xml/Markup.cpp	/^bool CMarkup::DetectUTF8( const char* pText, int nTextLen, int* pnNonASCII\/*=NULL*\/, bool* bErrorAtEnd\/*=NULL*\/ )$/;"	f	class:CMarkup	signature:( const char* pText, int nTextLen, int* pnNonASCII , bool* bErrorAtEnd )
DetectUTF8	third_party/xml/Markup.h	/^	static bool DetectUTF8( const char* pText, int nTextLen, int* pnNonASCII = NULL, bool* bErrorAtEnd = NULL );$/;"	p	class:CMarkup	access:public	signature:( const char* pText, int nTextLen, int* pnNonASCII = NULL, bool* bErrorAtEnd = NULL )
Diff_Mast_Grate_Than_Zero	include/iteratorX.h	/^template<size_t D> struct Diff_Mast_Grate_Than_Zero{};$/;"	s
ELEM	third_party/xml/Markup.cpp	1023;"	d	file:
ENTRYF	makecompiler/gensyntax.cpp	451;"	d	file:
ENTRYV	makecompiler/gensyntax.cpp	450;"	d	file:
ElemPos	third_party/xml/Markup.cpp	/^	ElemPos( const ElemPos& pos ) { *this = pos; };$/;"	f	struct:ElemPos	access:public	signature:( const ElemPos& pos )
ElemPos	third_party/xml/Markup.cpp	/^	ElemPos() {};$/;"	f	struct:ElemPos	access:public	signature:()
ElemPos	third_party/xml/Markup.cpp	/^struct ElemPos$/;"	s	file:
ElemPos::AdjustStartTagLen	third_party/xml/Markup.cpp	/^	void AdjustStartTagLen( int n ) { nStartTagLen += n; };$/;"	f	struct:ElemPos	access:public	signature:( int n )
ElemPos::ClearVirtualParent	third_party/xml/Markup.cpp	/^	void ClearVirtualParent() { memset(this,0,sizeof(ElemPos)); };$/;"	f	struct:ElemPos	access:public	signature:()
ElemPos::ContentLen	third_party/xml/Markup.cpp	/^	int ContentLen() const { return nLength - StartTagLen() - EndTagLen(); };$/;"	f	struct:ElemPos	access:public	signature:() const
ElemPos::ElemPos	third_party/xml/Markup.cpp	/^	ElemPos( const ElemPos& pos ) { *this = pos; };$/;"	f	struct:ElemPos	access:public	signature:( const ElemPos& pos )
ElemPos::ElemPos	third_party/xml/Markup.cpp	/^	ElemPos() {};$/;"	f	struct:ElemPos	access:public	signature:()
ElemPos::EndTagLen	third_party/xml/Markup.cpp	/^	int EndTagLen() const { return nEndTagLen; };$/;"	f	struct:ElemPos	access:public	signature:() const
ElemPos::IsEmptyElement	third_party/xml/Markup.cpp	/^	bool IsEmptyElement() { return (StartTagLen()==nLength)?true:false; };$/;"	f	struct:ElemPos	access:public	signature:()
ElemPos::IsUnparsed	third_party/xml/Markup.cpp	/^	bool IsUnparsed() { return EndTagLen() == 1; };$/;"	f	struct:ElemPos	access:public	signature:()
ElemPos::Level	third_party/xml/Markup.cpp	/^    int Level() const { return nFlags & 0xffff; };$/;"	f	struct:ElemPos	access:public	signature:() const
ElemPos::SetEndTagLen	third_party/xml/Markup.cpp	/^	void SetEndTagLen( int n ) { nEndTagLen = n; };$/;"	f	struct:ElemPos	access:public	signature:( int n )
ElemPos::SetEndTagLenUnparsed	third_party/xml/Markup.cpp	/^	void SetEndTagLenUnparsed() { SetEndTagLen(1); };$/;"	f	struct:ElemPos	access:public	signature:()
ElemPos::SetLevel	third_party/xml/Markup.cpp	/^    void SetLevel( int nLev ) { nFlags = (nFlags & ~0xffff) | nLev; };$/;"	f	struct:ElemPos	access:public	signature:( int nLev )
ElemPos::SetStartTagLen	third_party/xml/Markup.cpp	/^	void SetStartTagLen( int n ) { nStartTagLen = n; };$/;"	f	struct:ElemPos	access:public	signature:( int n )
ElemPos::StartAfter	third_party/xml/Markup.cpp	/^	int StartAfter() const { return nStart + nLength; };$/;"	f	struct:ElemPos	access:public	signature:() const
ElemPos::StartContent	third_party/xml/Markup.cpp	/^	int StartContent() const { return nStart + StartTagLen(); };$/;"	f	struct:ElemPos	access:public	signature:() const
ElemPos::StartTagLen	third_party/xml/Markup.cpp	/^	int StartTagLen() const { return nStartTagLen; };$/;"	f	struct:ElemPos	access:public	signature:() const
ElemPos::iElemChild	third_party/xml/Markup.cpp	/^	int iElemChild; \/\/ first child$/;"	m	struct:ElemPos	file:	access:public
ElemPos::iElemNext	third_party/xml/Markup.cpp	/^	int iElemNext; \/\/ next sibling$/;"	m	struct:ElemPos	file:	access:public
ElemPos::iElemParent	third_party/xml/Markup.cpp	/^	int iElemParent;$/;"	m	struct:ElemPos	file:	access:public
ElemPos::iElemPrev	third_party/xml/Markup.cpp	/^	int iElemPrev; \/\/ if this is first, iElemPrev points to last$/;"	m	struct:ElemPos	file:	access:public
ElemPos::nEndTagLen	third_party/xml/Markup.cpp	/^	unsigned int nEndTagLen : 10; \/\/ 1K limit for end tag$/;"	m	struct:ElemPos	file:	access:public
ElemPos::nFlags	third_party/xml/Markup.cpp	/^    int nFlags; \/\/ 16 bits flags, 16 bits level 65536 depth limit$/;"	m	struct:ElemPos	file:	access:public
ElemPos::nLength	third_party/xml/Markup.cpp	/^	int nLength;$/;"	m	struct:ElemPos	file:	access:public
ElemPos::nStart	third_party/xml/Markup.cpp	/^	int nStart;$/;"	m	struct:ElemPos	file:	access:public
ElemPos::nStartTagLen	third_party/xml/Markup.cpp	/^	unsigned int nStartTagLen : 22; \/\/ 4MB limit for start tag$/;"	m	struct:ElemPos	file:	access:public
ElemPosTree	third_party/xml/Markup.cpp	/^	ElemPosTree() { Clear(); };$/;"	f	struct:ElemPosTree	access:public	signature:()
ElemPosTree	third_party/xml/Markup.cpp	/^struct ElemPosTree$/;"	s	file:
ElemPosTree::Clear	third_party/xml/Markup.cpp	/^	void Clear() { m_nSegs=0; m_nSize=0; m_pSegs=NULL; };$/;"	f	struct:ElemPosTree	access:public	signature:()
ElemPosTree::CopyElemPosTree	third_party/xml/Markup.cpp	/^	void CopyElemPosTree( ElemPosTree* pOtherTree, int n );$/;"	p	struct:ElemPosTree	file:	access:public	signature:( ElemPosTree* pOtherTree, int n )
ElemPosTree::CopyElemPosTree	third_party/xml/Markup.cpp	/^void ElemPosTree::CopyElemPosTree( ElemPosTree* pOtherTree, int n )$/;"	f	class:ElemPosTree	signature:( ElemPosTree* pOtherTree, int n )
ElemPosTree::ElemPosTree	third_party/xml/Markup.cpp	/^	ElemPosTree() { Clear(); };$/;"	f	struct:ElemPosTree	access:public	signature:()
ElemPosTree::GetRefElemPosAt	third_party/xml/Markup.cpp	/^	ElemPos& GetRefElemPosAt(int i) const { return m_pSegs[i>>PA_SEGBITS][i&PA_SEGMASK]; };$/;"	f	struct:ElemPosTree	access:public	signature:(int i) const
ElemPosTree::GetSize	third_party/xml/Markup.cpp	/^	int GetSize() const { return m_nSize; };$/;"	f	struct:ElemPosTree	access:public	signature:() const
ElemPosTree::GrowElemPosTree	third_party/xml/Markup.cpp	/^	void GrowElemPosTree( int nNewSize );$/;"	p	struct:ElemPosTree	file:	access:public	signature:( int nNewSize )
ElemPosTree::GrowElemPosTree	third_party/xml/Markup.cpp	/^void ElemPosTree::GrowElemPosTree( int nNewSize )$/;"	f	class:ElemPosTree	signature:( int nNewSize )
ElemPosTree::PA_SEGBITS	third_party/xml/Markup.cpp	/^	enum { PA_SEGBITS = 16, PA_SEGMASK = 0xffff };$/;"	e	enum:ElemPosTree::__anon133	file:
ElemPosTree::PA_SEGMASK	third_party/xml/Markup.cpp	/^	enum { PA_SEGBITS = 16, PA_SEGMASK = 0xffff };$/;"	e	enum:ElemPosTree::__anon133	file:
ElemPosTree::Release	third_party/xml/Markup.cpp	/^	void Release() { for (int n=0;n<SegsUsed();++n) delete[] (char*)m_pSegs[n]; if (m_pSegs) delete[] (char*)m_pSegs; };$/;"	f	struct:ElemPosTree	access:public	signature:()
ElemPosTree::ReleaseElemPosTree	third_party/xml/Markup.cpp	/^	void ReleaseElemPosTree() { Release(); Clear(); };$/;"	f	struct:ElemPosTree	access:public	signature:()
ElemPosTree::SegsUsed	third_party/xml/Markup.cpp	/^	int SegsUsed() const { return ((m_nSize-1)>>PA_SEGBITS) + 1; };$/;"	f	struct:ElemPosTree	access:public	signature:() const
ElemPosTree::m_nSegs	third_party/xml/Markup.cpp	/^	int m_nSegs;$/;"	m	struct:ElemPosTree	file:	access:private
ElemPosTree::m_nSize	third_party/xml/Markup.cpp	/^	int m_nSize;$/;"	m	struct:ElemPosTree	file:	access:private
ElemPosTree::m_pSegs	third_party/xml/Markup.cpp	/^	ElemPos** m_pSegs;$/;"	m	struct:ElemPosTree	file:	access:private
ElemPosTree::~ElemPosTree	third_party/xml/Markup.cpp	/^	~ElemPosTree() { Release(); };$/;"	f	struct:ElemPosTree	access:public	signature:()
ElemStack	third_party/xml/Markup.cpp	/^	ElemStack() { iTop=0; iUsed=0; iPar=0; nLevel=0; nSize=0; pL=NULL; Alloc(7); pL[0].Init(); InitTable(); };$/;"	f	struct:ElemStack	access:public	signature:()
ElemStack	third_party/xml/Markup.cpp	/^struct ElemStack$/;"	s	file:
ElemStack::Alloc	third_party/xml/Markup.cpp	/^	void Alloc( int nNewSize ) { TagPos* pLNew = new TagPos[nNewSize]; Copy(pLNew); nSize=nNewSize; };$/;"	f	struct:ElemStack	access:protected	signature:( int nNewSize )
ElemStack::CalcSlot	third_party/xml/Markup.cpp	/^	static int CalcSlot( MCD_PCSZ pName, int n, bool bIC );$/;"	p	struct:ElemStack	file:	access:public	signature:( MCD_PCSZ pName, int n, bool bIC )
ElemStack::CalcSlot	third_party/xml/Markup.cpp	/^int ElemStack::CalcSlot( MCD_PCSZ pName, int n, bool bIC )$/;"	f	class:ElemStack	signature:( MCD_PCSZ pName, int n, bool bIC )
ElemStack::Copy	third_party/xml/Markup.cpp	/^	void Copy( TagPos* pLNew ) { for(int n=0;n<nSize;++n) pLNew[n]=pL[n]; if (pL) delete [] pL; pL=pLNew; };$/;"	f	struct:ElemStack	access:protected	signature:( TagPos* pLNew )
ElemStack::Current	third_party/xml/Markup.cpp	/^	TagPos& Current() { return pL[iTop]; };$/;"	f	struct:ElemStack	access:public	signature:()
ElemStack::ElemStack	third_party/xml/Markup.cpp	/^	ElemStack() { iTop=0; iUsed=0; iPar=0; nLevel=0; nSize=0; pL=NULL; Alloc(7); pL[0].Init(); InitTable(); };$/;"	f	struct:ElemStack	access:public	signature:()
ElemStack::GetRefTagPosAt	third_party/xml/Markup.cpp	/^	TagPos& GetRefTagPosAt( int i ) { return pL[i]; };$/;"	f	struct:ElemStack	access:public	signature:( int i )
ElemStack::InitTable	third_party/xml/Markup.cpp	/^	void InitTable() { memset(anTable,0,sizeof(int)*LS_TABLESIZE); };$/;"	f	struct:ElemStack	access:public	signature:()
ElemStack::IntoLevel	third_party/xml/Markup.cpp	/^	void IntoLevel() { iPar = iTop; ++nLevel; };$/;"	f	struct:ElemStack	access:public	signature:()
ElemStack::LS_TABLESIZE	third_party/xml/Markup.cpp	/^	enum { LS_TABLESIZE = 23 };$/;"	e	enum:ElemStack::__anon134	file:
ElemStack::NextParent	third_party/xml/Markup.cpp	/^	TagPos& NextParent( int& i ) { int iCur=i; i=pL[i].iParent; return pL[iCur]; };$/;"	f	struct:ElemStack	access:public	signature:( int& i )
ElemStack::OutOfLevel	third_party/xml/Markup.cpp	/^	void OutOfLevel() { if (iPar!=iTop) Pop(); iPar = pL[iTop].iParent; --nLevel; };$/;"	f	struct:ElemStack	access:public	signature:()
ElemStack::Pop	third_party/xml/Markup.cpp	/^	void Pop() { iTop = iPar; while (iUsed && pL[iUsed].iParent==iPar) { if (pL[iUsed].nSlot!=-1) Unslot(pL[iUsed]); --iUsed; } };$/;"	f	struct:ElemStack	access:public	signature:()
ElemStack::PopOutOfLevel	third_party/xml/Markup.cpp	/^	void PopOutOfLevel() { --iTop; };$/;"	f	struct:ElemStack	access:public	signature:()
ElemStack::Push	third_party/xml/Markup.cpp	/^	void Push( MCD_PCSZ pName, int n ) { ++iUsed; if (iUsed==nSize) Alloc(nSize*2); pL[iUsed].SetTagName(pName,n); pL[iUsed].iParent=iPar; iTop=iUsed; };$/;"	f	struct:ElemStack	access:public	signature:( MCD_PCSZ pName, int n )
ElemStack::PushIntoLevel	third_party/xml/Markup.cpp	/^	void PushIntoLevel( MCD_PCSZ pName, int n ) { ++iTop; if (iTop==nSize) Alloc(nSize*2); pL[iTop].SetTagName(pName,n); };$/;"	f	struct:ElemStack	access:public	signature:( MCD_PCSZ pName, int n )
ElemStack::PushTagAndCount	third_party/xml/Markup.cpp	/^	void PushTagAndCount( TokenPos& token );$/;"	p	struct:ElemStack	file:	access:public	signature:( TokenPos& token )
ElemStack::PushTagAndCount	third_party/xml/Markup.cpp	/^void ElemStack::PushTagAndCount( TokenPos& token )$/;"	f	class:ElemStack	signature:( TokenPos& token )
ElemStack::Slot	third_party/xml/Markup.cpp	/^	void Slot( int n ) { pL[iUsed].nSlot=n; int i=anTable[n]; anTable[n]=iUsed; pL[iUsed].iSlotNext=i; if (i) pL[i].iSlotPrev=iUsed; };$/;"	f	struct:ElemStack	access:public	signature:( int n )
ElemStack::Unslot	third_party/xml/Markup.cpp	/^	void Unslot( TagPos& lp ) { int n=lp.iSlotNext,p=lp.iSlotPrev; if (n) pL[n].iSlotPrev=p; if (p) pL[p].iSlotNext=n; else anTable[lp.nSlot]=n; };$/;"	f	struct:ElemStack	access:public	signature:( TagPos& lp )
ElemStack::anTable	third_party/xml/Markup.cpp	/^	int anTable[LS_TABLESIZE];$/;"	m	struct:ElemStack	file:	access:protected
ElemStack::iPar	third_party/xml/Markup.cpp	/^	int iPar;$/;"	m	struct:ElemStack	file:	access:public
ElemStack::iTop	third_party/xml/Markup.cpp	/^	int iTop;$/;"	m	struct:ElemStack	file:	access:public
ElemStack::iUsed	third_party/xml/Markup.cpp	/^	int iUsed;$/;"	m	struct:ElemStack	file:	access:protected
ElemStack::nLevel	third_party/xml/Markup.cpp	/^	int nLevel;$/;"	m	struct:ElemStack	file:	access:public
ElemStack::nSize	third_party/xml/Markup.cpp	/^	int nSize;$/;"	m	struct:ElemStack	file:	access:protected
ElemStack::pL	third_party/xml/Markup.cpp	/^	TagPos* pL;$/;"	m	struct:ElemStack	file:	access:protected
ElemStack::~ElemStack	third_party/xml/Markup.cpp	/^	~ElemStack() { if (pL) delete [] pL; };$/;"	f	struct:ElemStack	access:public	signature:()
EncodeCharUTF16	third_party/xml/Markup.cpp	/^void CMarkup::EncodeCharUTF16( int nUChar, unsigned short* pwszUTF16, int& nUTF16Len )$/;"	f	class:CMarkup	signature:( int nUChar, unsigned short* pwszUTF16, int& nUTF16Len )
EncodeCharUTF16	third_party/xml/Markup.h	/^	static void EncodeCharUTF16( int nUChar, unsigned short* pwszUTF16, int& nUTF16Len );$/;"	p	class:CMarkup	access:public	signature:( int nUChar, unsigned short* pwszUTF16, int& nUTF16Len )
EncodeCharUTF8	third_party/xml/Markup.cpp	/^void CMarkup::EncodeCharUTF8( int nUChar, char* pszUTF8, int& nUTF8Len )$/;"	f	class:CMarkup	signature:( int nUChar, char* pszUTF8, int& nUTF8Len )
EncodeCharUTF8	third_party/xml/Markup.h	/^	static void EncodeCharUTF8( int nUChar, char* pszUTF8, int& nUTF8Len );$/;"	p	class:CMarkup	access:public	signature:( int nUChar, char* pszUTF8, int& nUTF8Len )
EncodingNameTable	third_party/xml/Markup.cpp	/^MCD_PCSZ EncodingNameTable[155] =$/;"	v
EndTagLen	third_party/xml/Markup.cpp	/^	int EndTagLen() const { return nEndTagLen; };$/;"	f	struct:ElemPos	access:public	signature:() const
Error	compiler/word.h	/^	enum{Known = 1, Unknown = 0, Error = -1};$/;"	e	enum:word::__anon129
Error	syntax/word.h	/^	enum{Known = 1, Unknown = 0, Error = -1};$/;"	e	enum:word::__anon125
EscapeText	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::EscapeText( MCD_CSTR szText, int nFlags )$/;"	f	class:CMarkup	signature:( MCD_CSTR szText, int nFlags )
EscapeText	third_party/xml/Markup.h	/^	static MCD_STR EscapeText( MCD_CSTR szText, int nFlags = 0 );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR szText, int nFlags = 0 )
Expression	test/output/gen.cpp	/^	Expression()$/;"	f	struct:Expression	access:public	signature:()
Expression	test/output/gen.cpp	/^struct Expression : public type$/;"	s	file:	inherits:type
Expression::Expression	test/output/gen.cpp	/^	Expression()$/;"	f	struct:Expression	access:public	signature:()
Expression::sid	test/output/gen.cpp	/^	enum{ sid = 1004 };$/;"	e	enum:Expression::__anon101	file:
Expressions	test/output/tinyg.cpp	/^	Expressions()$/;"	f	struct:Expressions	access:public	signature:()
Expressions	test/output/tinyg.cpp	/^struct Expressions : public type$/;"	s	file:	inherits:type
Expressions	test/output/tinyg/tinyg.cpp	/^	Expressions()$/;"	f	struct:Expressions	access:public	signature:()
Expressions	test/output/tinyg/tinyg.cpp	/^struct Expressions : public type$/;"	s	file:	inherits:type
Expressions	test/output/tinyg/tinyg_bk.cpp	/^	Expressions()$/;"	f	struct:Expressions	access:public	signature:()
Expressions	test/output/tinyg/tinyg_bk.cpp	/^struct Expressions : public type$/;"	s	file:	inherits:type
Expressions::Expressions	test/output/tinyg.cpp	/^	Expressions()$/;"	f	struct:Expressions	access:public	signature:()
Expressions::Expressions	test/output/tinyg/tinyg.cpp	/^	Expressions()$/;"	f	struct:Expressions	access:public	signature:()
Expressions::Expressions	test/output/tinyg/tinyg_bk.cpp	/^	Expressions()$/;"	f	struct:Expressions	access:public	signature:()
Expressions::sid	test/output/tinyg.cpp	/^	enum{ sid = 4 };$/;"	e	enum:Expressions::__anon9	file:
Expressions::sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 4 };$/;"	e	enum:Expressions::__anon40	file:
Expressions::sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 4 };$/;"	e	enum:Expressions::__anon71	file:
FINDNODEBAD	third_party/xml/Markup.cpp	2306;"	d	file:
FINDNODETYPE	third_party/xml/Markup.cpp	2304;"	d	file:
FINDNODETYPENAME	third_party/xml/Markup.cpp	2305;"	d	file:
FIRST_NONTSID	galgorithm/regex2nfa.cpp	15;"	d	file:
FileAtTop	third_party/xml/Markup.cpp	/^	bool FileAtTop();$/;"	p	struct:FilePos	file:	access:public	signature:()
FileAtTop	third_party/xml/Markup.cpp	/^bool FilePos::FileAtTop()$/;"	f	class:FilePos	signature:()
FileCheckRaggedEnd	third_party/xml/Markup.cpp	/^	bool FileCheckRaggedEnd( void* pBuffer );$/;"	p	struct:FilePos	file:	access:public	signature:( void* pBuffer )
FileCheckRaggedEnd	third_party/xml/Markup.cpp	/^bool FilePos::FileCheckRaggedEnd( void* pBuffer )$/;"	f	class:FilePos	signature:( void* pBuffer )
FileClose	third_party/xml/Markup.cpp	/^	bool FileClose();$/;"	p	struct:FilePos	file:	access:public	signature:()
FileClose	third_party/xml/Markup.cpp	/^bool FilePos::FileClose()$/;"	f	class:FilePos	signature:()
FileErrorAddResult	third_party/xml/Markup.cpp	/^	bool FileErrorAddResult();$/;"	p	struct:FilePos	file:	access:public	signature:()
FileErrorAddResult	third_party/xml/Markup.cpp	/^bool FilePos::FileErrorAddResult()$/;"	f	class:FilePos	signature:()
FileFlush	third_party/xml/Markup.cpp	/^	bool FileFlush( MCD_STR& strBuffer, int nWriteStrLen = -1, bool bFflush = false );$/;"	p	struct:FilePos	file:	access:public	signature:( MCD_STR& strBuffer, int nWriteStrLen = -1, bool bFflush = false )
FileFlush	third_party/xml/Markup.cpp	/^bool FilePos::FileFlush( MCD_STR& strBuffer, int nWriteStrLen\/*=-1*\/, bool bFflush\/*=false*\/ )$/;"	f	class:FilePos	signature:( MCD_STR& strBuffer, int nWriteStrLen , bool bFflush )
FileGatherEnd	third_party/xml/Markup.cpp	/^	int FileGatherEnd( MCD_STR& strSubDoc );$/;"	p	struct:FilePos	file:	access:public	signature:( MCD_STR& strSubDoc )
FileGatherEnd	third_party/xml/Markup.cpp	/^int FilePos::FileGatherEnd( MCD_STR& strMarkup )$/;"	f	class:FilePos	signature:( MCD_STR& strMarkup )
FileGatherStart	third_party/xml/Markup.cpp	/^	void FileGatherStart( int nStart );$/;"	p	struct:FilePos	file:	access:public	signature:( int nStart )
FileGatherStart	third_party/xml/Markup.cpp	/^void FilePos::FileGatherStart( int nStart )$/;"	f	class:FilePos	signature:( int nStart )
FileOpen	third_party/xml/Markup.cpp	/^	bool FileOpen( MCD_CSTR_FILENAME szFileName );$/;"	p	struct:FilePos	file:	access:public	signature:( MCD_CSTR_FILENAME szFileName )
FileOpen	third_party/xml/Markup.cpp	/^bool FilePos::FileOpen( MCD_CSTR_FILENAME szFileName )$/;"	f	class:FilePos	signature:( MCD_CSTR_FILENAME szFileName )
FilePos	third_party/xml/Markup.cpp	/^	FilePos()$/;"	f	struct:FilePos	access:public	signature:()
FilePos	third_party/xml/Markup.cpp	/^struct FilePos$/;"	s	file:
FilePos::FileAtTop	third_party/xml/Markup.cpp	/^	bool FileAtTop();$/;"	p	struct:FilePos	file:	access:public	signature:()
FilePos::FileAtTop	third_party/xml/Markup.cpp	/^bool FilePos::FileAtTop()$/;"	f	class:FilePos	signature:()
FilePos::FileCheckRaggedEnd	third_party/xml/Markup.cpp	/^	bool FileCheckRaggedEnd( void* pBuffer );$/;"	p	struct:FilePos	file:	access:public	signature:( void* pBuffer )
FilePos::FileCheckRaggedEnd	third_party/xml/Markup.cpp	/^bool FilePos::FileCheckRaggedEnd( void* pBuffer )$/;"	f	class:FilePos	signature:( void* pBuffer )
FilePos::FileClose	third_party/xml/Markup.cpp	/^	bool FileClose();$/;"	p	struct:FilePos	file:	access:public	signature:()
FilePos::FileClose	third_party/xml/Markup.cpp	/^bool FilePos::FileClose()$/;"	f	class:FilePos	signature:()
FilePos::FileErrorAddResult	third_party/xml/Markup.cpp	/^	bool FileErrorAddResult();$/;"	p	struct:FilePos	file:	access:public	signature:()
FilePos::FileErrorAddResult	third_party/xml/Markup.cpp	/^bool FilePos::FileErrorAddResult()$/;"	f	class:FilePos	signature:()
FilePos::FileFlush	third_party/xml/Markup.cpp	/^	bool FileFlush( MCD_STR& strBuffer, int nWriteStrLen = -1, bool bFflush = false );$/;"	p	struct:FilePos	file:	access:public	signature:( MCD_STR& strBuffer, int nWriteStrLen = -1, bool bFflush = false )
FilePos::FileFlush	third_party/xml/Markup.cpp	/^bool FilePos::FileFlush( MCD_STR& strBuffer, int nWriteStrLen\/*=-1*\/, bool bFflush\/*=false*\/ )$/;"	f	class:FilePos	signature:( MCD_STR& strBuffer, int nWriteStrLen , bool bFflush )
FilePos::FileGatherEnd	third_party/xml/Markup.cpp	/^	int FileGatherEnd( MCD_STR& strSubDoc );$/;"	p	struct:FilePos	file:	access:public	signature:( MCD_STR& strSubDoc )
FilePos::FileGatherEnd	third_party/xml/Markup.cpp	/^int FilePos::FileGatherEnd( MCD_STR& strMarkup )$/;"	f	class:FilePos	signature:( MCD_STR& strMarkup )
FilePos::FileGatherStart	third_party/xml/Markup.cpp	/^	void FileGatherStart( int nStart );$/;"	p	struct:FilePos	file:	access:public	signature:( int nStart )
FilePos::FileGatherStart	third_party/xml/Markup.cpp	/^void FilePos::FileGatherStart( int nStart )$/;"	f	class:FilePos	signature:( int nStart )
FilePos::FileOpen	third_party/xml/Markup.cpp	/^	bool FileOpen( MCD_CSTR_FILENAME szFileName );$/;"	p	struct:FilePos	file:	access:public	signature:( MCD_CSTR_FILENAME szFileName )
FilePos::FileOpen	third_party/xml/Markup.cpp	/^bool FilePos::FileOpen( MCD_CSTR_FILENAME szFileName )$/;"	f	class:FilePos	signature:( MCD_CSTR_FILENAME szFileName )
FilePos::FilePos	third_party/xml/Markup.cpp	/^	FilePos()$/;"	f	struct:FilePos	access:public	signature:()
FilePos::FileRead	third_party/xml/Markup.cpp	/^	bool FileRead( void* pBuffer );$/;"	p	struct:FilePos	file:	access:public	signature:( void* pBuffer )
FilePos::FileRead	third_party/xml/Markup.cpp	/^bool FilePos::FileRead( void* pBuffer )$/;"	f	class:FilePos	signature:( void* pBuffer )
FilePos::FileReadNextBuffer	third_party/xml/Markup.cpp	/^	bool FileReadNextBuffer();$/;"	p	struct:FilePos	file:	access:public	signature:()
FilePos::FileReadNextBuffer	third_party/xml/Markup.cpp	/^bool FilePos::FileReadNextBuffer()$/;"	f	class:FilePos	signature:()
FilePos::FileReadText	third_party/xml/Markup.cpp	/^	bool FileReadText( MCD_STR& strDoc );$/;"	p	struct:FilePos	file:	access:public	signature:( MCD_STR& strDoc )
FilePos::FileReadText	third_party/xml/Markup.cpp	/^bool FilePos::FileReadText( MCD_STR& strDoc )$/;"	f	class:FilePos	signature:( MCD_STR& strDoc )
FilePos::FileSpecifyEncoding	third_party/xml/Markup.cpp	/^	void FileSpecifyEncoding( MCD_STR* pstrEncoding );$/;"	p	struct:FilePos	file:	access:public	signature:( MCD_STR* pstrEncoding )
FilePos::FileSpecifyEncoding	third_party/xml/Markup.cpp	/^void FilePos::FileSpecifyEncoding( MCD_STR* pstrEncoding )$/;"	f	class:FilePos	signature:( MCD_STR* pstrEncoding )
FilePos::FileWrite	third_party/xml/Markup.cpp	/^	bool FileWrite( void* pBuffer, const void* pConstBuffer = NULL );$/;"	p	struct:FilePos	file:	access:public	signature:( void* pBuffer, const void* pConstBuffer = NULL )
FilePos::FileWrite	third_party/xml/Markup.cpp	/^bool FilePos::FileWrite( void* pBuffer, const void* pConstBuffer \/*=NULL*\/ )$/;"	f	class:FilePos	signature:( void* pBuffer, const void* pConstBuffer )
FilePos::FileWriteText	third_party/xml/Markup.cpp	/^	bool FileWriteText( const MCD_STR& strDoc, int nWriteStrLen = -1 );$/;"	p	struct:FilePos	file:	access:public	signature:( const MCD_STR& strDoc, int nWriteStrLen = -1 )
FilePos::FileWriteText	third_party/xml/Markup.cpp	/^bool FilePos::FileWriteText( const MCD_STR& strDoc, int nWriteStrLen\/*=-1*\/ )$/;"	f	class:FilePos	signature:( const MCD_STR& strDoc, int nWriteStrLen )
FilePos::m_elemstack	third_party/xml/Markup.cpp	/^	ElemStack m_elemstack;$/;"	m	struct:FilePos	file:	access:public
FilePos::m_fp	third_party/xml/Markup.cpp	/^	FILE* m_fp;$/;"	m	struct:FilePos	file:	access:public
FilePos::m_nBlockSizeBasis	third_party/xml/Markup.cpp	/^	int m_nBlockSizeBasis;$/;"	m	struct:FilePos	file:	access:public
FilePos::m_nDocFlags	third_party/xml/Markup.cpp	/^	int m_nDocFlags;$/;"	m	struct:FilePos	file:	access:public
FilePos::m_nFileByteLen	third_party/xml/Markup.cpp	/^	MCD_INTFILEOFFSET m_nFileByteLen;$/;"	m	struct:FilePos	file:	access:public
FilePos::m_nFileByteOffset	third_party/xml/Markup.cpp	/^	MCD_INTFILEOFFSET m_nFileByteOffset;$/;"	m	struct:FilePos	file:	access:public
FilePos::m_nFileCharUnitSize	third_party/xml/Markup.cpp	/^	int m_nFileCharUnitSize;$/;"	m	struct:FilePos	file:	access:public
FilePos::m_nOpFileByteLen	third_party/xml/Markup.cpp	/^	int m_nOpFileByteLen;$/;"	m	struct:FilePos	file:	access:public
FilePos::m_nOpFileTextLen	third_party/xml/Markup.cpp	/^	int m_nOpFileTextLen;$/;"	m	struct:FilePos	file:	access:public
FilePos::m_nReadBufferRemoved	third_party/xml/Markup.cpp	/^	int m_nReadBufferRemoved;$/;"	m	struct:FilePos	file:	access:public
FilePos::m_nReadBufferStart	third_party/xml/Markup.cpp	/^	int m_nReadBufferStart;$/;"	m	struct:FilePos	file:	access:public
FilePos::m_nReadGatherStart	third_party/xml/Markup.cpp	/^	int m_nReadGatherStart;$/;"	m	struct:FilePos	file:	access:public
FilePos::m_pstrBuffer	third_party/xml/Markup.cpp	/^	MCD_STR* m_pstrBuffer;$/;"	m	struct:FilePos	file:	access:public
FilePos::m_strEncoding	third_party/xml/Markup.cpp	/^	MCD_STR m_strEncoding;$/;"	m	struct:FilePos	file:	access:public
FilePos::m_strIOResult	third_party/xml/Markup.cpp	/^	MCD_STR m_strIOResult;$/;"	m	struct:FilePos	file:	access:public
FilePos::m_strReadGatherMarkup	third_party/xml/Markup.cpp	/^	MCD_STR m_strReadGatherMarkup;$/;"	m	struct:FilePos	file:	access:public
FileRead	third_party/xml/Markup.cpp	/^	bool FileRead( void* pBuffer );$/;"	p	struct:FilePos	file:	access:public	signature:( void* pBuffer )
FileRead	third_party/xml/Markup.cpp	/^bool FilePos::FileRead( void* pBuffer )$/;"	f	class:FilePos	signature:( void* pBuffer )
FileReadNextBuffer	third_party/xml/Markup.cpp	/^	bool FileReadNextBuffer();$/;"	p	struct:FilePos	file:	access:public	signature:()
FileReadNextBuffer	third_party/xml/Markup.cpp	/^bool FilePos::FileReadNextBuffer()$/;"	f	class:FilePos	signature:()
FileReadText	third_party/xml/Markup.cpp	/^	bool FileReadText( MCD_STR& strDoc );$/;"	p	struct:FilePos	file:	access:public	signature:( MCD_STR& strDoc )
FileReadText	third_party/xml/Markup.cpp	/^bool FilePos::FileReadText( MCD_STR& strDoc )$/;"	f	class:FilePos	signature:( MCD_STR& strDoc )
FileSpecifyEncoding	third_party/xml/Markup.cpp	/^	void FileSpecifyEncoding( MCD_STR* pstrEncoding );$/;"	p	struct:FilePos	file:	access:public	signature:( MCD_STR* pstrEncoding )
FileSpecifyEncoding	third_party/xml/Markup.cpp	/^void FilePos::FileSpecifyEncoding( MCD_STR* pstrEncoding )$/;"	f	class:FilePos	signature:( MCD_STR* pstrEncoding )
FileWrite	third_party/xml/Markup.cpp	/^	bool FileWrite( void* pBuffer, const void* pConstBuffer = NULL );$/;"	p	struct:FilePos	file:	access:public	signature:( void* pBuffer, const void* pConstBuffer = NULL )
FileWrite	third_party/xml/Markup.cpp	/^bool FilePos::FileWrite( void* pBuffer, const void* pConstBuffer \/*=NULL*\/ )$/;"	f	class:FilePos	signature:( void* pBuffer, const void* pConstBuffer )
FileWriteText	third_party/xml/Markup.cpp	/^	bool FileWriteText( const MCD_STR& strDoc, int nWriteStrLen = -1 );$/;"	p	struct:FilePos	file:	access:public	signature:( const MCD_STR& strDoc, int nWriteStrLen = -1 )
FileWriteText	third_party/xml/Markup.cpp	/^bool FilePos::FileWriteText( const MCD_STR& strDoc, int nWriteStrLen\/*=-1*\/ )$/;"	f	class:FilePos	signature:( const MCD_STR& strDoc, int nWriteStrLen )
FindAny	third_party/xml/Markup.cpp	/^	bool FindAny()$/;"	f	struct:TokenPos	access:public	signature:()
FindAttrib	third_party/xml/Markup.cpp	/^	bool FindAttrib( MCD_PCSZ pAttrib, int n = 0 );$/;"	p	struct:TokenPos	file:	access:public	signature:( MCD_PCSZ pAttrib, int n = 0 )
FindAttrib	third_party/xml/Markup.cpp	/^bool TokenPos::FindAttrib( MCD_PCSZ pAttrib, int n\/*=0*\/ )$/;"	f	class:TokenPos	signature:( MCD_PCSZ pAttrib, int n )
FindChildElem	third_party/xml/Markup.cpp	/^bool CMarkup::FindChildElem( MCD_CSTR szName )$/;"	f	class:CMarkup	signature:( MCD_CSTR szName )
FindChildElem	third_party/xml/Markup.h	/^	bool FindChildElem( MCD_CSTR szName=NULL );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR szName=NULL )
FindElem	third_party/xml/Markup.cpp	/^bool CMarkup::FindElem( MCD_CSTR szName )$/;"	f	class:CMarkup	signature:( MCD_CSTR szName )
FindElem	third_party/xml/Markup.h	/^	bool FindElem( MCD_CSTR szName=NULL );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR szName=NULL )
FindName	third_party/xml/Markup.cpp	/^	bool FindName()$/;"	f	struct:TokenPos	access:public	signature:()
FindNode	third_party/xml/Markup.cpp	/^int CMarkup::FindNode( int nType )$/;"	f	class:CMarkup	signature:( int nType )
FindNode	third_party/xml/Markup.h	/^	int FindNode( int nType=0 );$/;"	p	class:CMarkup	access:public	signature:( int nType=0 )
FindRaggedEnd	third_party/xml/Markup.cpp	/^	bool FindRaggedEnd( int& nTruncBeforeBytes );$/;"	p	struct:TextEncoding	file:	access:public	signature:( int& nTruncBeforeBytes )
FindRaggedEnd	third_party/xml/Markup.cpp	/^bool TextEncoding::FindRaggedEnd( int& nTruncBeforeBytes )$/;"	f	class:TextEncoding	signature:( int& nTruncBeforeBytes )
Fname	compiler/variable.h	/^	const char* Fname;$/;"	m	class:variable	access:public
Format	include/stringXF.h	/^namespace Format$/;"	n
Format::IsDigit	include/stringXF.h	/^	struct IsDigit$/;"	s	namespace:Format
Format::IsDigit::operator ()	include/stringXF.h	/^		bool operator()(char _Ch) const$/;"	f	struct:Format::IsDigit	access:public	signature:(char _Ch) const
Format::IsDigit::operator ()	include/stringXF.h	/^		bool operator()(wchar_t _Ch) const$/;"	f	struct:Format::IsDigit	access:public	signature:(wchar_t _Ch) const
Format::IsSpace	include/stringXF.h	/^	struct IsSpace$/;"	s	namespace:Format
Format::IsSpace::operator ()	include/stringXF.h	/^		bool operator()(char _Ch) const$/;"	f	struct:Format::IsSpace	access:public	signature:(char _Ch) const
Format::IsSpace::operator ()	include/stringXF.h	/^		bool operator()(wchar_t _Ch) const$/;"	f	struct:Format::IsSpace	access:public	signature:(wchar_t _Ch) const
Format::meta	include/stringXF.h	/^	_Elem meta(unsigned short _ch)$/;"	f	namespace:Format	signature:(unsigned short _ch)
Format::swcvt	include/stringXF.h	/^	struct swcvt$/;"	s	namespace:Format
Format::swcvt::convert	include/stringXF.h	/^		static bool convert(const std::string& _Src, std::string& _Dst)$/;"	f	struct:Format::swcvt	access:public	signature:(const std::string& _Src, std::string& _Dst)
Format::swcvt::convert	include/stringXF.h	/^		static bool convert(const std::string& _Src, std::wstring& _Dst)$/;"	f	struct:Format::swcvt	access:public	signature:(const std::string& _Src, std::wstring& _Dst)
Format::swcvt::convert	include/stringXF.h	/^		static bool convert(const std::wstring& _Src, std::string& _Dst)$/;"	f	struct:Format::swcvt	access:public	signature:(const std::wstring& _Src, std::string& _Dst)
Format::swcvt::convert	include/stringXF.h	/^		static bool convert(const std::wstring& _Src, std::wstring& _Dst)$/;"	f	struct:Format::swcvt	access:public	signature:(const std::wstring& _Src, std::wstring& _Dst)
Format::swcvt::convert	include/stringXF.h	/^		static std::basic_string<_Dst_Elem> convert(const std::basic_string<_Src_Elem>& _Src)$/;"	f	struct:Format::swcvt	access:public	signature:(const std::basic_string<_Src_Elem>& _Src)
Format::swcvt::convert	include/stringXF.h	/^		static std::string convert(const std::wstring& _Src)$/;"	f	struct:Format::swcvt	access:public	signature:(const std::wstring& _Src)
Format::swcvt::convert	include/stringXF.h	/^		static std::wstring convert(const std::string& _Src)$/;"	f	struct:Format::swcvt	access:public	signature:(const std::string& _Src)
Format::swcvt::tryconvert	include/stringXF.h	/^		static bool tryconvert(const std::string& _Src, std::wstring& _Dst, std::exception& ex)$/;"	f	struct:Format::swcvt	access:private	signature:(const std::string& _Src, std::wstring& _Dst, std::exception& ex)
Format::swcvt::tryconvert	include/stringXF.h	/^		static bool tryconvert(const std::wstring& _Src, std::string& _Dst, std::exception& ex)$/;"	f	struct:Format::swcvt	access:private	signature:(const std::wstring& _Src, std::string& _Dst, std::exception& ex)
ForwardUntil	third_party/xml/Markup.cpp	/^	void ForwardUntil( MCD_PCSZ szStopChars ) { while ( m_pDocText[m_nNext] && ! MCD_PSZCHR(szStopChars,m_pDocText[m_nNext]) ) m_nNext += MCD_CLEN(&m_pDocText[m_nNext]); }$/;"	f	struct:TokenPos	access:public	signature:( MCD_PCSZ szStopChars )
FuncCall	test/output/gen.cpp	/^	FuncCall()$/;"	f	struct:FuncCall	access:public	signature:()
FuncCall	test/output/gen.cpp	/^struct FuncCall : public type$/;"	s	file:	inherits:type
FuncCall	test/output/tinyg.cpp	/^	FuncCall()$/;"	f	struct:FuncCall	access:public	signature:()
FuncCall	test/output/tinyg.cpp	/^struct FuncCall : public type$/;"	s	file:	inherits:type
FuncCall	test/output/tinyg/tinyg.cpp	/^	FuncCall()$/;"	f	struct:FuncCall	access:public	signature:()
FuncCall	test/output/tinyg/tinyg.cpp	/^struct FuncCall : public type$/;"	s	file:	inherits:type
FuncCall	test/output/tinyg/tinyg_bk.cpp	/^	FuncCall()$/;"	f	struct:FuncCall	access:public	signature:()
FuncCall	test/output/tinyg/tinyg_bk.cpp	/^struct FuncCall : public type$/;"	s	file:	inherits:type
FuncCall::FuncCall	test/output/gen.cpp	/^	FuncCall()$/;"	f	struct:FuncCall	access:public	signature:()
FuncCall::FuncCall	test/output/tinyg.cpp	/^	FuncCall()$/;"	f	struct:FuncCall	access:public	signature:()
FuncCall::FuncCall	test/output/tinyg/tinyg.cpp	/^	FuncCall()$/;"	f	struct:FuncCall	access:public	signature:()
FuncCall::FuncCall	test/output/tinyg/tinyg_bk.cpp	/^	FuncCall()$/;"	f	struct:FuncCall	access:public	signature:()
FuncCall::sid	test/output/gen.cpp	/^	enum{ sid = 1005 };$/;"	e	enum:FuncCall::__anon102	file:
FuncCall::sid	test/output/tinyg.cpp	/^	enum{ sid = 10 };$/;"	e	enum:FuncCall::__anon15	file:
FuncCall::sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 10 };$/;"	e	enum:FuncCall::__anon46	file:
FuncCall::sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 10 };$/;"	e	enum:FuncCall::__anon77	file:
Function	test/output/gen.cpp	/^	Function()$/;"	f	struct:Function	access:public	signature:()
Function	test/output/gen.cpp	/^struct Function : public type$/;"	s	file:	inherits:type
Function	test/output/tinyg.cpp	/^	Function()$/;"	f	struct:Function	access:public	signature:()
Function	test/output/tinyg.cpp	/^struct Function : public type$/;"	s	file:	inherits:type
Function	test/output/tinyg/tinyg.cpp	/^	Function()$/;"	f	struct:Function	access:public	signature:()
Function	test/output/tinyg/tinyg.cpp	/^struct Function : public type$/;"	s	file:	inherits:type
Function	test/output/tinyg/tinyg_bk.cpp	/^	Function()$/;"	f	struct:Function	access:public	signature:()
Function	test/output/tinyg/tinyg_bk.cpp	/^struct Function : public type$/;"	s	file:	inherits:type
Function::Function	test/output/gen.cpp	/^	Function()$/;"	f	struct:Function	access:public	signature:()
Function::Function	test/output/tinyg.cpp	/^	Function()$/;"	f	struct:Function	access:public	signature:()
Function::Function	test/output/tinyg/tinyg.cpp	/^	Function()$/;"	f	struct:Function	access:public	signature:()
Function::Function	test/output/tinyg/tinyg_bk.cpp	/^	Function()$/;"	f	struct:Function	access:public	signature:()
Function::sid	test/output/gen.cpp	/^	enum{ sid = 1006 };$/;"	e	enum:Function::__anon103	file:
Function::sid	test/output/tinyg.cpp	/^	enum{ sid = 3 };$/;"	e	enum:Function::__anon8	file:
Function::sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 3 };$/;"	e	enum:Function::__anon39	file:
Function::sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 3 };$/;"	e	enum:Function::__anon70	file:
FunctionContent	test/output/gen.cpp	/^	FunctionContent()$/;"	f	struct:FunctionContent	access:public	signature:()
FunctionContent	test/output/gen.cpp	/^struct FunctionContent : public type$/;"	s	file:	inherits:type
FunctionContent	test/output/tinyg.cpp	/^	FunctionContent()$/;"	f	struct:FunctionContent	access:public	signature:()
FunctionContent	test/output/tinyg.cpp	/^struct FunctionContent : public type$/;"	s	file:	inherits:type
FunctionContent	test/output/tinyg/tinyg.cpp	/^	FunctionContent()$/;"	f	struct:FunctionContent	access:public	signature:()
FunctionContent	test/output/tinyg/tinyg.cpp	/^struct FunctionContent : public type$/;"	s	file:	inherits:type
FunctionContent	test/output/tinyg/tinyg_bk.cpp	/^	FunctionContent()$/;"	f	struct:FunctionContent	access:public	signature:()
FunctionContent	test/output/tinyg/tinyg_bk.cpp	/^struct FunctionContent : public type$/;"	s	file:	inherits:type
FunctionContent::FunctionContent	test/output/gen.cpp	/^	FunctionContent()$/;"	f	struct:FunctionContent	access:public	signature:()
FunctionContent::FunctionContent	test/output/tinyg.cpp	/^	FunctionContent()$/;"	f	struct:FunctionContent	access:public	signature:()
FunctionContent::FunctionContent	test/output/tinyg/tinyg.cpp	/^	FunctionContent()$/;"	f	struct:FunctionContent	access:public	signature:()
FunctionContent::FunctionContent	test/output/tinyg/tinyg_bk.cpp	/^	FunctionContent()$/;"	f	struct:FunctionContent	access:public	signature:()
FunctionContent::sid	test/output/gen.cpp	/^	enum{ sid = 1007 };$/;"	e	enum:FunctionContent::__anon104	file:
FunctionContent::sid	test/output/tinyg.cpp	/^	enum{ sid = 14 };$/;"	e	enum:FunctionContent::__anon19	file:
FunctionContent::sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 14 };$/;"	e	enum:FunctionContent::__anon50	file:
FunctionContent::sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 14 };$/;"	e	enum:FunctionContent::__anon81	file:
GVALUE	syntax/global_values.h	22;"	d
GVALUE_A	syntax/global_values.h	24;"	d
GVALUE_D	syntax/global_values.h	20;"	d
GetAttrib	third_party/xml/Markup.h	/^	MCD_STR GetAttrib( MCD_CSTR szAttrib ) const { return x_GetAttrib(m_iPos,szAttrib); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib ) const
GetAttribName	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::GetAttribName( int n ) const$/;"	f	class:CMarkup	signature:( int n ) const
GetAttribName	third_party/xml/Markup.h	/^	MCD_STR GetAttribName( int n ) const;$/;"	p	class:CMarkup	access:public	signature:( int n ) const
GetChar	third_party/xml/Markup.cpp	/^	MCD_CHAR GetChar() { return p[i]; };$/;"	f	struct:PathPos	access:public	signature:()
GetChildAttrib	third_party/xml/Markup.h	/^	MCD_STR GetChildAttrib( MCD_CSTR szAttrib ) const { return x_GetAttrib(m_iPosChild,szAttrib); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib ) const
GetChildData	third_party/xml/Markup.h	/^	MCD_STR GetChildData() { return x_GetData(m_iPosChild); };$/;"	f	class:CMarkup	access:public	signature:()
GetChildSubDoc	third_party/xml/Markup.h	/^	MCD_STR GetChildSubDoc() { return x_GetSubDoc(m_iPosChild); };$/;"	f	class:CMarkup	access:public	signature:()
GetChildTagName	third_party/xml/Markup.h	/^	MCD_STR GetChildTagName() const { return x_GetTagName(m_iPosChild); };$/;"	f	class:CMarkup	access:public	signature:() const
GetData	third_party/xml/Markup.h	/^	MCD_STR GetData() { return x_GetData(m_iPos); };$/;"	f	class:CMarkup	access:public	signature:()
GetDeclaredEncoding	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::GetDeclaredEncoding( MCD_CSTR szDoc )$/;"	f	class:CMarkup	signature:( MCD_CSTR szDoc )
GetDeclaredEncoding	third_party/xml/Markup.h	/^	static MCD_STR GetDeclaredEncoding( MCD_CSTR szDoc );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR szDoc )
GetDoc	third_party/xml/Markup.h	/^	const MCD_STR& GetDoc() const { return m_strDoc; };$/;"	f	class:CMarkup	access:public	signature:() const
GetDocFlags	third_party/xml/Markup.h	/^	int GetDocFlags() const { return m_nDocFlags; };$/;"	f	class:CMarkup	access:public	signature:() const
GetElemContent	third_party/xml/Markup.h	/^	MCD_STR GetElemContent() const { return x_GetElemContent(m_iPos); };$/;"	f	class:CMarkup	access:public	signature:() const
GetEncodingCodePage	third_party/xml/Markup.cpp	/^int CMarkup::GetEncodingCodePage( MCD_CSTR pszEncoding )$/;"	f	class:CMarkup	signature:( MCD_CSTR pszEncoding )
GetEncodingCodePage	third_party/xml/Markup.h	/^	static int GetEncodingCodePage( MCD_CSTR pszEncoding );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR pszEncoding )
GetError	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::GetError() const$/;"	f	class:CMarkup	signature:() const
GetError	third_party/xml/Markup.h	/^	MCD_STR GetError() const;$/;"	p	class:CMarkup	access:public	signature:() const
GetMap	third_party/xml/Markup.cpp	/^	bool GetMap( SavedPosMap*& pMap, int nMap, int nMapSize = 7 );$/;"	p	struct:SavedPosMapArray	file:	access:public	signature:( SavedPosMap*& pMap, int nMap, int nMapSize = 7 )
GetMap	third_party/xml/Markup.cpp	/^bool SavedPosMapArray::GetMap( SavedPosMap*& pMap, int nMap, int nMapSize \/*=7*\/ )$/;"	f	class:SavedPosMapArray	signature:( SavedPosMap*& pMap, int nMap, int nMapSize )
GetNodeType	third_party/xml/Markup.h	/^	int GetNodeType() { return m_nNodeType; };$/;"	f	class:CMarkup	access:public	signature:()
GetNumAndInc	third_party/xml/Markup.cpp	/^	int GetNumAndInc() { int n=0; while (p[i]>='0'&&p[i]<='9') n=n*10+(int)p[i++]-(int)'0'; return n; };$/;"	f	struct:PathPos	access:public	signature:()
GetPathAttribName	third_party/xml/Markup.cpp	/^	MCD_PCSZ GetPathAttribName() { if (iPathAttribName) return &p[iPathAttribName]; return NULL; };$/;"	f	struct:PathPos	access:public	signature:()
GetPtr	third_party/xml/Markup.cpp	/^	MCD_PCSZ GetPtr() { return &p[i]; };$/;"	f	struct:PathPos	access:public	signature:()
GetRefElemPosAt	third_party/xml/Markup.cpp	/^	ElemPos& GetRefElemPosAt(int i) const { return m_pSegs[i>>PA_SEGBITS][i&PA_SEGMASK]; };$/;"	f	struct:ElemPosTree	access:public	signature:(int i) const
GetRefTagPosAt	third_party/xml/Markup.cpp	/^	TagPos& GetRefTagPosAt( int i ) { return pL[i]; };$/;"	f	struct:ElemStack	access:public	signature:( int i )
GetResult	third_party/xml/Markup.h	/^	const MCD_STR& GetResult() const { return m_strResult; };$/;"	f	class:CMarkup	access:public	signature:() const
GetSize	third_party/xml/Markup.cpp	/^	int GetSize() const { return m_nSize; };$/;"	f	struct:ElemPosTree	access:public	signature:() const
GetSubDoc	third_party/xml/Markup.h	/^	MCD_STR GetSubDoc() { return x_GetSubDoc(m_iPos); };$/;"	f	class:CMarkup	access:public	signature:()
GetTagName	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::GetTagName() const$/;"	f	class:CMarkup	signature:() const
GetTagName	third_party/xml/Markup.h	/^	MCD_STR GetTagName() const;$/;"	p	class:CMarkup	access:public	signature:() const
GetTokenPtr	third_party/xml/Markup.cpp	/^	MCD_PCSZ GetTokenPtr() const { return &m_pDocText[m_nL]; };$/;"	f	struct:TokenPos	access:public	signature:() const
GetTokenText	third_party/xml/Markup.cpp	/^	MCD_STR GetTokenText() const { return MCD_STR( GetTokenPtr(), Length() ); };$/;"	f	struct:TokenPos	access:public	signature:() const
GetTypeAndInc	third_party/xml/Markup.cpp	/^	int GetTypeAndInc() { i=-1; if (p) { if (p[0]=='\/') { if (p[1]=='\/') i=2; else i=1; } else if (p[0]) i=0; } nPathType=i+1; return nPathType; };$/;"	f	struct:PathPos	access:public	signature:()
GetValAndInc	third_party/xml/Markup.cpp	/^	MCD_PCSZ GetValAndInc() { ++i; MCD_CHAR cEnd=']'; if (p[i]=='\\''||p[i]=='\\"') cEnd=p[i++]; int iVal=i; IncWord(cEnd); nLen=i-iVal; if (cEnd!=']') ++i; return &p[iVal]; };$/;"	f	struct:PathPos	access:public	signature:()
GetValOrWordLen	third_party/xml/Markup.cpp	/^	int GetValOrWordLen() { return nLen; };$/;"	f	struct:PathPos	access:public	signature:()
GetWordAndInc	third_party/xml/Markup.cpp	/^	MCD_PCSZ GetWordAndInc() { int iWord=i; IncWord(); nLen=i-iWord; return &p[iWord]; };$/;"	f	struct:PathPos	access:public	signature:()
GrowElemPosTree	third_party/xml/Markup.cpp	/^	void GrowElemPosTree( int nNewSize );$/;"	p	struct:ElemPosTree	file:	access:public	signature:( int nNewSize )
GrowElemPosTree	third_party/xml/Markup.cpp	/^void ElemPosTree::GrowElemPosTree( int nNewSize )$/;"	f	class:ElemPosTree	signature:( int nNewSize )
IConv	third_party/xml/Markup.cpp	/^	int IConv( void* pTo, int nToCharSize, int nFromCharSize );$/;"	p	struct:TextEncoding	file:	access:public	signature:( void* pTo, int nToCharSize, int nFromCharSize )
IConv	third_party/xml/Markup.cpp	/^int TextEncoding::IConv( void* pTo, int nToCharSize, int nFromCharSize )$/;"	f	class:TextEncoding	signature:( void* pTo, int nToCharSize, int nFromCharSize )
IConvName	third_party/xml/Markup.cpp	/^	static const char* IConvName( char* szEncoding, MCD_CSTR pszEncoding );$/;"	p	struct:TextEncoding	file:	access:public	signature:( char* szEncoding, MCD_CSTR pszEncoding )
IConvName	third_party/xml/Markup.cpp	/^const char* TextEncoding::IConvName( char* szEncoding, MCD_CSTR pszEncoding )$/;"	f	class:TextEncoding	signature:( char* szEncoding, MCD_CSTR pszEncoding )
IDX	test/vhelp.h	52;"	d
Ident	tmp/coutfun.cpp	/^	Ident(int i = 0)$/;"	f	struct:Ident	access:public	signature:(int i = 0)
Ident	tmp/coutfun.cpp	/^struct Ident$/;"	s	file:
Ident::Ident	tmp/coutfun.cpp	/^	Ident(int i = 0)$/;"	f	struct:Ident	access:public	signature:(int i = 0)
Ident::inc	tmp/coutfun.cpp	/^	int inc;$/;"	m	struct:Ident	file:	access:public
Ident::newline	tmp/coutfun.cpp	/^	static std::ostream& newline(std::ostream& os)$/;"	f	struct:Ident	access:public	signature:(std::ostream& os)
Ident::operator <<	tmp/coutfun.cpp	/^	friend std::ostream& operator<<(std::ostream& os, const Ident& a)$/;"	f	struct:Ident	access:friend	signature:(std::ostream& os, const Ident& a)
Ident::tabs	tmp/coutfun.cpp	/^	static int tabs;$/;"	m	struct:Ident	file:	access:public
Ident::tabs	tmp/coutfun.cpp	/^int Ident::tabs = 0;$/;"	m	class:Ident	file:
Inc	third_party/xml/Markup.cpp	/^	void Inc( int n ) { i+=n; };$/;"	f	struct:PathPos	access:public	signature:( int n )
IncChar	third_party/xml/Markup.cpp	/^	void IncChar() { ++i; };$/;"	f	struct:PathPos	access:public	signature:()
IncCount	third_party/xml/Markup.cpp	/^	void IncCount() { if (nCount) ++nCount; };$/;"	f	struct:TagPos	access:public	signature:()
IncWord	third_party/xml/Markup.cpp	/^	void IncWord( MCD_CHAR c ) { while (p[i]&&p[i]!=c) i+=MCD_CLEN(&p[i]); };$/;"	f	struct:PathPos	access:public	signature:( MCD_CHAR c )
IncWord	third_party/xml/Markup.cpp	/^	void IncWord() { while (p[i]&&!MCD_PSZCHR(MCD_T(" =\/[]"),p[i])) i+=MCD_CLEN(&p[i]); };$/;"	f	struct:PathPos	access:public	signature:()
Init	third_party/xml/Markup.cpp	/^	void Init( int i=0, int n=1 ) { nCount=1; nTagNames=n; iNext=i; iPrev=0; nSlot=-1; iSlotPrev=0; iSlotNext=0; };$/;"	f	struct:TagPos	access:public	signature:( int i=0, int n=1 )
InitTable	third_party/xml/Markup.cpp	/^	void InitTable() { memset(anTable,0,sizeof(int)*LS_TABLESIZE); };$/;"	f	struct:ElemStack	access:public	signature:()
InsertChildElem	third_party/xml/Markup.h	/^	bool InsertChildElem( MCD_CSTR szName, MCD_CSTR szData=NULL, int nFlags=0 ) { return x_AddElem(szName,szData,nFlags|MNF_INSERT|MNF_CHILD); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szName, MCD_CSTR szData=NULL, int nFlags=0 )
InsertChildElem	third_party/xml/Markup.h	/^	bool InsertChildElem( MCD_CSTR szName, int nValue, int nFlags=0 ) { return x_AddElem(szName,nValue,nFlags|MNF_INSERT|MNF_CHILD); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szName, int nValue, int nFlags=0 )
InsertChildSubDoc	third_party/xml/Markup.h	/^	bool InsertChildSubDoc( MCD_CSTR szSubDoc ) { return x_AddSubDoc(szSubDoc,MNF_CHILD|MNF_INSERT); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szSubDoc )
InsertElem	third_party/xml/Markup.h	/^	bool InsertElem( MCD_CSTR szName, MCD_CSTR szData=NULL, int nFlags=0 ) { return x_AddElem(szName,szData,nFlags|MNF_INSERT); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szName, MCD_CSTR szData=NULL, int nFlags=0 )
InsertElem	third_party/xml/Markup.h	/^	bool InsertElem( MCD_CSTR szName, int nValue, int nFlags=0 ) { return x_AddElem(szName,nValue,nFlags|MNF_INSERT); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szName, int nValue, int nFlags=0 )
InsertNode	third_party/xml/Markup.h	/^	bool InsertNode( int nType, MCD_CSTR szText ) { return x_AddNode(nType,szText,MNF_INSERT); };$/;"	f	class:CMarkup	access:public	signature:( int nType, MCD_CSTR szText )
InsertSubDoc	third_party/xml/Markup.h	/^	bool InsertSubDoc( MCD_CSTR szSubDoc ) { return x_AddSubDoc(szSubDoc,MNF_INSERT); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szSubDoc )
IntoElem	third_party/xml/Markup.cpp	/^bool CMarkup::IntoElem()$/;"	f	class:CMarkup	signature:()
IntoElem	third_party/xml/Markup.h	/^	bool IntoElem();$/;"	p	class:CMarkup	access:public	signature:()
IntoLevel	third_party/xml/Markup.cpp	/^	void IntoLevel() { iPar = iTop; ++nLevel; };$/;"	f	struct:ElemStack	access:public	signature:()
IsAbsolutePath	third_party/xml/Markup.cpp	/^	bool IsAbsolutePath() { return nPathType == 2; };$/;"	f	struct:PathPos	access:public	signature:()
IsAnywherePath	third_party/xml/Markup.cpp	/^	bool IsAnywherePath() { return nPathType == 3; };$/;"	f	struct:PathPos	access:public	signature:()
IsAtPathEnd	third_party/xml/Markup.cpp	/^	bool IsAtPathEnd() { return ((!p[i])||(iPathAttribName&&i+2>=iPathAttribName))?true:false; }; $/;"	f	struct:PathPos	access:public	signature:()
IsBetween	include/functionalX.h	/^inline bool IsBetween(const Value_Type& min_value, const Value_Type& max_value, const Value_Type& value)$/;"	f	signature:(const Value_Type& min_value, const Value_Type& max_value, const Value_Type& value)
IsDigit	include/stringXF.h	/^	struct IsDigit$/;"	s	namespace:Format
IsEmptyElement	third_party/xml/Markup.cpp	/^	bool IsEmptyElement() { return (StartTagLen()==nLength)?true:false; };$/;"	f	struct:ElemPos	access:public	signature:()
IsPath	third_party/xml/Markup.cpp	/^	bool IsPath() { return nPathType > 0; };$/;"	f	struct:PathPos	access:public	signature:()
IsSpace	include/stringXF.h	/^	struct IsSpace$/;"	s	namespace:Format
IsUnparsed	third_party/xml/Markup.cpp	/^	bool IsUnparsed() { return EndTagLen() == 1; };$/;"	f	struct:ElemPos	access:public	signature:()
IsWellFormed	third_party/xml/Markup.cpp	/^bool CMarkup::IsWellFormed()$/;"	f	class:CMarkup	signature:()
IsWellFormed	third_party/xml/Markup.h	/^	bool IsWellFormed();$/;"	p	class:CMarkup	access:public	signature:()
Known	compiler/word.h	/^	enum{Known = 1, Unknown = 0, Error = -1};$/;"	e	enum:word::__anon129
Known	syntax/word.h	/^	enum{Known = 1, Unknown = 0, Error = -1};$/;"	e	enum:word::__anon125
L	galgorithm/regex2nfa.cpp	/^		int L; \/\/ left$/;"	m	struct:parsecontent::prod	file:	access:public
L	tmp/back/regex2nfa.cpp	/^		int L; \/\/ left$/;"	m	struct:parsecontent::prod	file:	access:public
LOAD_GLOBAL_VALUES_FROMFILE	syntax/global_values.h	18;"	d
LS_TABLESIZE	third_party/xml/Markup.cpp	/^	enum { LS_TABLESIZE = 23 };$/;"	e	enum:ElemStack::__anon134	file:
L_	syntax/production.h	/^	int32 L_;$/;"	m	class:production	access:private
Lcount	compiler/variable.h	/^	uint32 Lcount;$/;"	m	class:variable	access:public
Length	include/arrayX.h	/^	const static size_t Length = _Length;$/;"	m	struct:SmartArray	access:public
Length	include/arrayX.h	/^	const static size_t Length = _Row * _Col;$/;"	m	struct:SmartMatrix	access:public
Length	third_party/xml/Markup.cpp	/^	int Length() const { return m_nR - m_nL + 1; };$/;"	f	struct:TokenPos	access:public	signature:() const
Level	third_party/xml/Markup.cpp	/^    int Level() const { return nFlags & 0xffff; };$/;"	f	struct:ElemPos	access:public	signature:() const
Lfuncs	syntax/symbol.h	/^	int8 Lfuncs;$/;"	m	struct:symbol	access:public
Lname	syntax/symbol.h	/^	int16 Lname;$/;"	m	struct:symbol	access:public
Load	third_party/xml/Markup.cpp	/^bool CMarkup::Load( MCD_CSTR_FILENAME szFileName )$/;"	f	class:CMarkup	signature:( MCD_CSTR_FILENAME szFileName )
Load	third_party/xml/Markup.h	/^	bool Load( MCD_CSTR_FILENAME szFileName );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR_FILENAME szFileName )
MARKUP_FILEBLOCKSIZE	third_party/xml/Markup.h	62;"	d
MARKUP_ICONV	third_party/xml/Markup.h	42;"	d
MARKUP_MBCS	third_party/xml/Markup.h	49;"	d
MARKUP_SETDEBUGSTATE	third_party/xml/Markup.h	414;"	d
MARKUP_SETDEBUGSTATE	third_party/xml/Markup.h	416;"	d
MARKUP_SIZEOFWCHAR	third_party/xml/Markup.h	53;"	d
MARKUP_SIZEOFWCHAR	third_party/xml/Markup.h	55;"	d
MARKUP_STL	third_party/xml/Markup.h	15;"	d
MARKUP_STL	third_party/xml/Markup.h	39;"	d
MARKUP_WINCONV	third_party/xml/Markup.h	59;"	d
MCD_2PCSZ	third_party/xml/Markup.h	155;"	d
MCD_2PCSZ	third_party/xml/Markup.h	175;"	d
MCD_ACP	third_party/xml/Markup.h	67;"	d
MCD_BLDAPPEND	third_party/xml/Markup.h	170;"	d
MCD_BLDAPPEND	third_party/xml/Markup.h	189;"	d
MCD_BLDAPPEND1	third_party/xml/Markup.h	171;"	d
MCD_BLDAPPEND1	third_party/xml/Markup.h	190;"	d
MCD_BLDAPPENDN	third_party/xml/Markup.h	169;"	d
MCD_BLDAPPENDN	third_party/xml/Markup.h	188;"	d
MCD_BLDCHECK	third_party/xml/Markup.h	167;"	d
MCD_BLDCHECK	third_party/xml/Markup.h	186;"	d
MCD_BLDRELEASE	third_party/xml/Markup.h	168;"	d
MCD_BLDRELEASE	third_party/xml/Markup.h	187;"	d
MCD_BLDRESERVE	third_party/xml/Markup.h	166;"	d
MCD_BLDRESERVE	third_party/xml/Markup.h	185;"	d
MCD_CHAR	third_party/xml/Markup.h	106;"	d
MCD_CHAR	third_party/xml/Markup.h	72;"	d
MCD_CLEN	third_party/xml/Markup.h	104;"	d
MCD_CLEN	third_party/xml/Markup.h	132;"	d
MCD_CLEN	third_party/xml/Markup.h	134;"	d
MCD_CLEN	third_party/xml/Markup.h	138;"	d
MCD_CSTR	third_party/xml/Markup.h	/^	MCD_CSTR( MCD_PCSZ p ) { pcsz=p; };$/;"	f	struct:MCD_CSTR	access:public	signature:( MCD_PCSZ p )
MCD_CSTR	third_party/xml/Markup.h	/^	MCD_CSTR( const MCD_STR& s ) { pcsz = MCD_2PCSZ(s); };$/;"	f	struct:MCD_CSTR	access:public	signature:( const MCD_STR& s )
MCD_CSTR	third_party/xml/Markup.h	/^	MCD_CSTR() { pcsz=NULL; };$/;"	f	struct:MCD_CSTR	access:public	signature:()
MCD_CSTR	third_party/xml/Markup.h	/^struct MCD_CSTR$/;"	s
MCD_CSTR::MCD_CSTR	third_party/xml/Markup.h	/^	MCD_CSTR( MCD_PCSZ p ) { pcsz=p; };$/;"	f	struct:MCD_CSTR	access:public	signature:( MCD_PCSZ p )
MCD_CSTR::MCD_CSTR	third_party/xml/Markup.h	/^	MCD_CSTR( const MCD_STR& s ) { pcsz = MCD_2PCSZ(s); };$/;"	f	struct:MCD_CSTR	access:public	signature:( const MCD_STR& s )
MCD_CSTR::MCD_CSTR	third_party/xml/Markup.h	/^	MCD_CSTR() { pcsz=NULL; };$/;"	f	struct:MCD_CSTR	access:public	signature:()
MCD_CSTR::operator MCD_PCSZ	third_party/xml/Markup.h	/^	operator MCD_PCSZ() const { return pcsz; };$/;"	f	struct:MCD_CSTR	access:public	signature:() const
MCD_CSTR::pcsz	third_party/xml/Markup.h	/^	MCD_PCSZ pcsz;$/;"	m	struct:MCD_CSTR	access:public
MCD_CSTR_FILENAME	third_party/xml/Markup.h	/^	MCD_CSTR_FILENAME( MCD_PCSZ_FILENAME p ) { pcsz=p; };$/;"	f	struct:MCD_CSTR_FILENAME	access:public	signature:( MCD_PCSZ_FILENAME p )
MCD_CSTR_FILENAME	third_party/xml/Markup.h	/^	MCD_CSTR_FILENAME( const std::string& s ) { pcsz = s.c_str(); };$/;"	f	struct:MCD_CSTR_FILENAME	access:public	signature:( const std::string& s )
MCD_CSTR_FILENAME	third_party/xml/Markup.h	/^	MCD_CSTR_FILENAME() { pcsz=NULL; };$/;"	f	struct:MCD_CSTR_FILENAME	access:public	signature:()
MCD_CSTR_FILENAME	third_party/xml/Markup.h	/^struct MCD_CSTR_FILENAME$/;"	s
MCD_CSTR_FILENAME	third_party/xml/Markup.h	221;"	d
MCD_CSTR_FILENAME::MCD_CSTR_FILENAME	third_party/xml/Markup.h	/^	MCD_CSTR_FILENAME( MCD_PCSZ_FILENAME p ) { pcsz=p; };$/;"	f	struct:MCD_CSTR_FILENAME	access:public	signature:( MCD_PCSZ_FILENAME p )
MCD_CSTR_FILENAME::MCD_CSTR_FILENAME	third_party/xml/Markup.h	/^	MCD_CSTR_FILENAME( const std::string& s ) { pcsz = s.c_str(); };$/;"	f	struct:MCD_CSTR_FILENAME	access:public	signature:( const std::string& s )
MCD_CSTR_FILENAME::MCD_CSTR_FILENAME	third_party/xml/Markup.h	/^	MCD_CSTR_FILENAME() { pcsz=NULL; };$/;"	f	struct:MCD_CSTR_FILENAME	access:public	signature:()
MCD_CSTR_FILENAME::operator MCD_PCSZ_FILENAME	third_party/xml/Markup.h	/^	operator MCD_PCSZ_FILENAME() const { return pcsz; };$/;"	f	struct:MCD_CSTR_FILENAME	access:public	signature:() const
MCD_CSTR_FILENAME::pcsz	third_party/xml/Markup.h	/^	MCD_PCSZ_FILENAME pcsz;$/;"	m	struct:MCD_CSTR_FILENAME	access:public
MCD_ENC	third_party/xml/Markup.h	100;"	d
MCD_ENC	third_party/xml/Markup.h	102;"	d
MCD_ENC	third_party/xml/Markup.h	130;"	d
MCD_ENC	third_party/xml/Markup.h	137;"	d
MCD_FOPEN	third_party/xml/Markup.h	119;"	d
MCD_FOPEN	third_party/xml/Markup.h	126;"	d
MCD_FOPEN	third_party/xml/Markup.h	208;"	d
MCD_FOPEN	third_party/xml/Markup.h	209;"	d
MCD_FOPEN	third_party/xml/Markup.h	85;"	d
MCD_FOPEN	third_party/xml/Markup.h	96;"	d
MCD_FSEEK	third_party/xml/Markup.h	227;"	d
MCD_FSEEK	third_party/xml/Markup.h	235;"	d
MCD_FSEEK	third_party/xml/Markup.h	239;"	d
MCD_FTELL	third_party/xml/Markup.h	228;"	d
MCD_FTELL	third_party/xml/Markup.h	236;"	d
MCD_FTELL	third_party/xml/Markup.h	240;"	d
MCD_GETBUFFER	third_party/xml/Markup.h	164;"	d
MCD_GETBUFFER	third_party/xml/Markup.h	183;"	d
MCD_INTFILEOFFSET	third_party/xml/Markup.h	229;"	d
MCD_INTFILEOFFSET	third_party/xml/Markup.h	237;"	d
MCD_INTFILEOFFSET	third_party/xml/Markup.h	241;"	d
MCD_PCSZ	third_party/xml/Markup.h	107;"	d
MCD_PCSZ	third_party/xml/Markup.h	73;"	d
MCD_PCSZ_FILENAME	third_party/xml/Markup.h	211;"	d
MCD_PCSZ_FILENAME	third_party/xml/Markup.h	223;"	d
MCD_PSZCAT	third_party/xml/Markup.h	117;"	d
MCD_PSZCAT	third_party/xml/Markup.h	124;"	d
MCD_PSZCAT	third_party/xml/Markup.h	83;"	d
MCD_PSZCAT	third_party/xml/Markup.h	94;"	d
MCD_PSZCHR	third_party/xml/Markup.h	109;"	d
MCD_PSZCHR	third_party/xml/Markup.h	75;"	d
MCD_PSZCPY	third_party/xml/Markup.h	115;"	d
MCD_PSZCPY	third_party/xml/Markup.h	122;"	d
MCD_PSZCPY	third_party/xml/Markup.h	81;"	d
MCD_PSZCPY	third_party/xml/Markup.h	92;"	d
MCD_PSZLEN	third_party/xml/Markup.h	108;"	d
MCD_PSZLEN	third_party/xml/Markup.h	74;"	d
MCD_PSZNCMP	third_party/xml/Markup.h	112;"	d
MCD_PSZNCMP	third_party/xml/Markup.h	78;"	d
MCD_PSZNCPY	third_party/xml/Markup.h	116;"	d
MCD_PSZNCPY	third_party/xml/Markup.h	123;"	d
MCD_PSZNCPY	third_party/xml/Markup.h	82;"	d
MCD_PSZNCPY	third_party/xml/Markup.h	93;"	d
MCD_PSZSTR	third_party/xml/Markup.h	110;"	d
MCD_PSZSTR	third_party/xml/Markup.h	76;"	d
MCD_PSZTOL	third_party/xml/Markup.h	111;"	d
MCD_PSZTOL	third_party/xml/Markup.h	77;"	d
MCD_RELEASEBUFFER	third_party/xml/Markup.h	165;"	d
MCD_RELEASEBUFFER	third_party/xml/Markup.h	184;"	d
MCD_SPRINTF	third_party/xml/Markup.h	118;"	d
MCD_SPRINTF	third_party/xml/Markup.h	125;"	d
MCD_SPRINTF	third_party/xml/Markup.h	84;"	d
MCD_SPRINTF	third_party/xml/Markup.h	95;"	d
MCD_SSZ	third_party/xml/Markup.h	114;"	d
MCD_SSZ	third_party/xml/Markup.h	121;"	d
MCD_SSZ	third_party/xml/Markup.h	80;"	d
MCD_SSZ	third_party/xml/Markup.h	88;"	d
MCD_SSZ	third_party/xml/Markup.h	90;"	d
MCD_STR	third_party/xml/Markup.h	151;"	d
MCD_STR	third_party/xml/Markup.h	153;"	d
MCD_STR	third_party/xml/Markup.h	174;"	d
MCD_STRASSIGN	third_party/xml/Markup.h	161;"	d
MCD_STRASSIGN	third_party/xml/Markup.h	181;"	d
MCD_STRCAPACITY	third_party/xml/Markup.h	162;"	d
MCD_STRCAPACITY	third_party/xml/Markup.h	182;"	d
MCD_STRCLEAR	third_party/xml/Markup.h	157;"	d
MCD_STRCLEAR	third_party/xml/Markup.h	177;"	d
MCD_STRCLEARSIZE	third_party/xml/Markup.h	158;"	d
MCD_STRCLEARSIZE	third_party/xml/Markup.h	178;"	d
MCD_STRERROR	third_party/xml/Markup.h	142;"	d
MCD_STRINSERTREPLACE	third_party/xml/Markup.h	163;"	d
MCD_STRISEMPTY	third_party/xml/Markup.h	159;"	d
MCD_STRISEMPTY	third_party/xml/Markup.h	179;"	d
MCD_STRLENGTH	third_party/xml/Markup.h	156;"	d
MCD_STRLENGTH	third_party/xml/Markup.h	176;"	d
MCD_STRMID	third_party/xml/Markup.h	160;"	d
MCD_STRMID	third_party/xml/Markup.h	180;"	d
MCD_STRTOINT	third_party/xml/Markup.h	192;"	d
MCD_T	third_party/xml/Markup.h	128;"	d
MCD_T	third_party/xml/Markup.h	98;"	d
MCD_T_FILENAME	third_party/xml/Markup.h	210;"	d
MCD_T_FILENAME	third_party/xml/Markup.h	222;"	d
MCD_UTF16	third_party/xml/Markup.h	69;"	d
MCD_UTF32	third_party/xml/Markup.h	70;"	d
MCD_UTF8	third_party/xml/Markup.h	68;"	d
MDF_APPENDFILE	third_party/xml/Markup.h	/^		MDF_APPENDFILE = 64,$/;"	e	enum:CMarkup::MarkupDocFlags
MDF_IGNORECASE	third_party/xml/Markup.h	/^		MDF_IGNORECASE = 8,$/;"	e	enum:CMarkup::MarkupDocFlags
MDF_READFILE	third_party/xml/Markup.h	/^		MDF_READFILE = 16,$/;"	e	enum:CMarkup::MarkupDocFlags
MDF_UTF16BEFILE	third_party/xml/Markup.h	/^		MDF_UTF16BEFILE = 128$/;"	e	enum:CMarkup::MarkupDocFlags
MDF_UTF16LEFILE	third_party/xml/Markup.h	/^		MDF_UTF16LEFILE = 1,$/;"	e	enum:CMarkup::MarkupDocFlags
MDF_UTF8PREAMBLE	third_party/xml/Markup.h	/^		MDF_UTF8PREAMBLE = 4,$/;"	e	enum:CMarkup::MarkupDocFlags
MDF_WRITEFILE	third_party/xml/Markup.h	/^		MDF_WRITEFILE = 32,$/;"	e	enum:CMarkup::MarkupDocFlags
MEMBER_VARIABLE_GET	compiler/extract.h	/^	MEMBER_VARIABLE_GET(const deqwords&, words, words_);$/;"	p	class:streamsplit	access:public	signature:(const deqwords&, words, words_)
MEMBER_VARIABLE_GET	compiler/scope.h	/^    MEMBER_VARIABLE_GET(scope*, parent, parent_);$/;"	p	class:scope	access:public	signature:(scope*, parent, parent_)
MEMBER_VARIABLE_GET	compiler/variable.h	/^    MEMBER_VARIABLE_GET(_Str, name, name_);$/;"	p	class:variable	access:public	signature:(_Str, name, name_)
MEMBER_VARIABLE_GET	compiler/variable.h	/^    MEMBER_VARIABLE_GET(const compile::type*, vtype, type_);$/;"	p	class:variable	access:public	signature:(const compile::type*, vtype, type_)
MEMBER_VARIABLE_GET	compiler/variable.h	/^    MEMBER_VARIABLE_GET(const scope*, env, env_);$/;"	p	class:variable	access:public	signature:(const scope*, env, env_)
MEMBER_VARIABLE_GET	include/macros.h	7;"	d
MEMBER_VARIABLE_GET	syntax/production.h	/^	MEMBER_VARIABLE_GET(const right_array&, right, Rs_);$/;"	p	class:production	access:public	signature:(const right_array&, right, Rs_)
MEMBER_VARIABLE_GET	syntax/production.h	/^	MEMBER_VARIABLE_GET(int32, right_size, Rs_.size());$/;"	p	class:production	access:public	signature:(int32, right_size, Rs_.size())
MEMBER_VARIABLE_GET_INDEXER	include/macros.h	28;"	d
MEMBER_VARIABLE_GET_SET	compiler/variable.h	/^    MEMBER_VARIABLE_GET_SET(uint32, address, pos_);$/;"	p	class:variable	access:public	signature:(uint32, address, pos_)
MEMBER_VARIABLE_GET_SET	compiler/variable.h	/^    MEMBER_VARIABLE_GET_SET(value*, initvalue, initv_);$/;"	p	class:variable	access:public	signature:(value*, initvalue, initv_)
MEMBER_VARIABLE_GET_SET	include/macros.h	13;"	d
MEMBER_VARIABLE_GET_SET	syntax/automachine.h	/^	MEMBER_VARIABLE_GET_SET(int, sstate, sstate_);$/;"	p	class:automachine	access:public	signature:(int, sstate, sstate_)
MEMBER_VARIABLE_GET_SET	syntax/automachine.h	/^	MEMBER_VARIABLE_GET_SET(sparsesheet, sheet, *sheet_);$/;"	p	class:automachine	access:public	signature:(sparsesheet, sheet, *sheet_)
MEMBER_VARIABLE_GET_SET	syntax/global_values.h	/^	MEMBER_VARIABLE_GET_SET(std::string, LogFile, logFile_);$/;"	p	class:global_values	access:public	signature:(std::string, LogFile, logFile_)
MEMBER_VARIABLE_GET_SET	syntax/grammar.h	/^	MEMBER_VARIABLE_GET_SET(int32, endings, ending_symbol_);$/;"	p	class:tinygrammar	access:public	signature:(int32, endings, ending_symbol_)
MEMBER_VARIABLE_GET_SET	syntax/grammar.h	/^	MEMBER_VARIABLE_GET_SET(int32, eplisons, eplison_symbol_);$/;"	p	class:tinygrammar	access:public	signature:(int32, eplisons, eplison_symbol_)
MEMBER_VARIABLE_GET_SET	syntax/grammar.h	/^	MEMBER_VARIABLE_GET_SET(int32, starts, start_symbol_);$/;"	p	class:tinygrammar	access:public	signature:(int32, starts, start_symbol_)
MEMBER_VARIABLE_GET_SET	syntax/grammar.h	/^	MEMBER_VARIABLE_GET_SET(symholder, symbols, symbols_);$/;"	p	class:tinygrammar	access:public	signature:(symholder, symbols, symbols_)
MEMBER_VARIABLE_GET_SET	syntax/grammar.h	/^	MEMBER_VARIABLE_GET_SET(vecprods, productions, productions_);$/;"	p	class:tinygrammar	access:public	signature:(vecprods, productions, productions_)
MEMBER_VARIABLE_GET_SET	syntax/production.h	/^	MEMBER_VARIABLE_GET_SET(int32, left, L_);$/;"	p	class:production	access:public	signature:(int32, left, L_)
MEMBER_VARIABLE_GET_SET	syntax/production.h	/^    MEMBER_VARIABLE_GET_SET(_Str, func, func_);$/;"	p	class:production	access:public	signature:(_Str, func, func_)
MEMBER_VARIABLE_GET_SET	syntax/statemachine.h	/^	MEMBER_VARIABLE_GET_SET(tstring, str, str_);$/;"	p	class:state_machine	access:public	signature:(tstring, str, str_)
MEMBER_VARIABLE_GET_SET	test/unittest.h	/^	MEMBER_VARIABLE_GET_SET(std::string, out_folder, outfolder_);$/;"	p	class:unittest	access:public	signature:(std::string, out_folder, outfolder_)
MEMBER_VARIABLE_GET_SET_INDEXER	include/macros.h	24;"	d
MEMBER_VARIABLE_GET_SET_INDEXER	syntax/production.h	/^	MEMBER_VARIABLE_GET_SET_INDEXER(int32, std::size_t, Rs_);$/;"	p	class:production	access:public	signature:(int32, std::size_t, Rs_)
MEMBER_VARIABLE_INDEXER	include/macros.h	32;"	d
MEMBER_VARIABLE_INDEXER_GET_SET_TEMPLATE	include/macros.h	17;"	d
MEMBER_VARIABLE_INDEXER_GET_TEMPLATE	include/macros.h	21;"	d
MEMBER_VARIABLE_INDEXER_TEMPLATE	include/macros.h	31;"	d
MEMBER_VARIABLE_SET	include/macros.h	10;"	d
MICROSIFT_VISUAL_STUDIO	include/stringXF.h	24;"	d
MNF_CHILD	third_party/xml/Markup.h	/^		MNF_CHILD      = 0x004000$/;"	e	enum:CMarkup::MarkupNodeFlagsInternal
MNF_DELETED	third_party/xml/Markup.cpp	/^	MNF_DELETED    = 0x020000,$/;"	e	enum:MarkupNodeFlagsInternal2	file:
MNF_EMPTY	third_party/xml/Markup.cpp	/^	MNF_EMPTY      = 0x010000,$/;"	e	enum:MarkupNodeFlagsInternal2	file:
MNF_ESCAPEQUOTES	third_party/xml/Markup.h	/^		MNF_ESCAPEQUOTES  = 0x100,$/;"	e	enum:CMarkup::MarkupNodeFlags
MNF_FIRST	third_party/xml/Markup.cpp	/^	MNF_FIRST      = 0x080000,$/;"	e	enum:MarkupNodeFlagsInternal2	file:
MNF_ILLDATA	third_party/xml/Markup.h	/^		MNF_ILLDATA    = 0x200000$/;"	e	enum:CMarkup::MarkupNodeFlags
MNF_ILLFORMED	third_party/xml/Markup.cpp	/^	MNF_ILLFORMED  = 0x800000,$/;"	e	enum:MarkupNodeFlagsInternal2	file:
MNF_INSERT	third_party/xml/Markup.h	/^		MNF_INSERT     = 0x002000,$/;"	e	enum:CMarkup::MarkupNodeFlagsInternal
MNF_NONENDED	third_party/xml/Markup.h	/^		MNF_NONENDED   = 0x100000,$/;"	e	enum:CMarkup::MarkupNodeFlags
MNF_PUBLIC	third_party/xml/Markup.cpp	/^	MNF_PUBLIC     = 0x300000,$/;"	e	enum:MarkupNodeFlagsInternal2	file:
MNF_QUOTED	third_party/xml/Markup.cpp	/^	MNF_QUOTED     = 0x008000,$/;"	e	enum:MarkupNodeFlagsInternal2	file:
MNF_REPLACE	third_party/xml/Markup.cpp	/^	MNF_REPLACE    = 0x001000,$/;"	e	enum:MarkupNodeFlagsInternal2	file:
MNF_USER	third_party/xml/Markup.cpp	/^	MNF_USER      = 0xf000000$/;"	e	enum:MarkupNodeFlagsInternal2	file:
MNF_WITHCDATA	third_party/xml/Markup.h	/^		MNF_WITHCDATA      = 0x01,$/;"	e	enum:CMarkup::MarkupNodeFlags
MNF_WITHNOEND	third_party/xml/Markup.h	/^		MNF_WITHNOEND      = 0x10,$/;"	e	enum:CMarkup::MarkupNodeFlags
MNF_WITHNOLINES	third_party/xml/Markup.h	/^		MNF_WITHNOLINES    = 0x02,$/;"	e	enum:CMarkup::MarkupNodeFlags
MNF_WITHREFS	third_party/xml/Markup.h	/^		MNF_WITHREFS       = 0x08,$/;"	e	enum:CMarkup::MarkupNodeFlags
MNF_WITHXHTMLSPACE	third_party/xml/Markup.h	/^		MNF_WITHXHTMLSPACE = 0x04,$/;"	e	enum:CMarkup::MarkupNodeFlags
MNT_CDATA_SECTION	third_party/xml/Markup.h	/^		MNT_CDATA_SECTION			= 8,    \/\/ 0x0008$/;"	e	enum:CMarkup::MarkupNodeType
MNT_COMMENT	third_party/xml/Markup.h	/^		MNT_COMMENT					= 32,   \/\/ 0x0020$/;"	e	enum:CMarkup::MarkupNodeType
MNT_DOCUMENT_TYPE	third_party/xml/Markup.h	/^		MNT_DOCUMENT_TYPE			= 64,   \/\/ 0x0040$/;"	e	enum:CMarkup::MarkupNodeType
MNT_ELEMENT	third_party/xml/Markup.h	/^		MNT_ELEMENT					= 1,    \/\/ 0x0001$/;"	e	enum:CMarkup::MarkupNodeType
MNT_EXCLUDE_WHITESPACE	third_party/xml/Markup.h	/^		MNT_EXCLUDE_WHITESPACE		= 123,  \/\/ 0x007b$/;"	e	enum:CMarkup::MarkupNodeType
MNT_LONE_END_TAG	third_party/xml/Markup.h	/^		MNT_LONE_END_TAG			= 128,  \/\/ 0x0080$/;"	e	enum:CMarkup::MarkupNodeType
MNT_NODE_ERROR	third_party/xml/Markup.h	/^		MNT_NODE_ERROR              = 32768 \/\/ 0x8000$/;"	e	enum:CMarkup::MarkupNodeType
MNT_PROCESSING_INSTRUCTION	third_party/xml/Markup.h	/^		MNT_PROCESSING_INSTRUCTION	= 16,   \/\/ 0x0010$/;"	e	enum:CMarkup::MarkupNodeType
MNT_TEXT	third_party/xml/Markup.h	/^		MNT_TEXT					= 2,    \/\/ 0x0002$/;"	e	enum:CMarkup::MarkupNodeType
MNT_TEXT_AND_WHITESPACE	third_party/xml/Markup.h	/^		MNT_TEXT_AND_WHITESPACE     = 6,    \/\/ 0x0006$/;"	e	enum:CMarkup::MarkupNodeType
MNT_WHITESPACE	third_party/xml/Markup.h	/^		MNT_WHITESPACE				= 4,    \/\/ 0x0004$/;"	e	enum:CMarkup::MarkupNodeType
MRC_COUNT	third_party/xml/Markup.cpp	/^	MRC_COUNT    = 1,$/;"	e	enum:MarkupResultCode	file:
MRC_ENCODING	third_party/xml/Markup.cpp	/^	MRC_ENCODING = 8,$/;"	e	enum:MarkupResultCode	file:
MRC_LENGTH	third_party/xml/Markup.cpp	/^	MRC_LENGTH   = 16,$/;"	e	enum:MarkupResultCode	file:
MRC_MODIFY	third_party/xml/Markup.cpp	/^	MRC_MODIFY   = 32,$/;"	e	enum:MarkupResultCode	file:
MRC_MSG	third_party/xml/Markup.cpp	/^	MRC_MSG      = 64$/;"	e	enum:MarkupResultCode	file:
MRC_NUMBER	third_party/xml/Markup.cpp	/^	MRC_NUMBER   = 4,$/;"	e	enum:MarkupResultCode	file:
MRC_TYPE	third_party/xml/Markup.cpp	/^	MRC_TYPE     = 2,$/;"	e	enum:MarkupResultCode	file:
MarkupDocFlags	third_party/xml/Markup.h	/^	enum MarkupDocFlags$/;"	g	class:CMarkup	access:public
MarkupNodeFlags	third_party/xml/Markup.h	/^	enum MarkupNodeFlags$/;"	g	class:CMarkup	access:public
MarkupNodeFlagsInternal	third_party/xml/Markup.h	/^	enum MarkupNodeFlagsInternal$/;"	g	class:CMarkup	access:protected
MarkupNodeFlagsInternal2	third_party/xml/Markup.cpp	/^enum MarkupNodeFlagsInternal2$/;"	g	file:
MarkupNodeType	third_party/xml/Markup.h	/^	enum MarkupNodeType$/;"	g	class:CMarkup	access:public
MarkupResultCode	third_party/xml/Markup.cpp	/^enum MarkupResultCode$/;"	g	file:
Match	third_party/xml/Markup.cpp	/^	bool Match( MCD_CSTR szName )$/;"	f	struct:TokenPos	access:public	signature:( MCD_CSTR szName )
NAMESPACE_BEGIN	include/macros.h	34;"	d
NAMESPACE_END	include/macros.h	35;"	d
NEW_UNITTEST	test/unittest.h	36;"	d
NON_COPYABLE_OBJECT	include/logger.h	/^	NON_COPYABLE_OBJECT(logger);$/;"	p	class:logger	access:private	signature:(logger)
NON_COPYABLE_OBJECT	include/macros.h	37;"	d
NON_COPYABLE_OBJECT	include/singleton.h	12;"	d
NextParent	third_party/xml/Markup.cpp	/^	TagPos& NextParent( int& i ) { int iCur=i; i=pL[i].iParent; return pL[iCur]; };$/;"	f	struct:ElemStack	access:public	signature:( int& i )
No	include/functionalX.h	/^	No = -1,$/;"	e	enum:TriSate
NoName0	test/output/tinyg.cpp	/^	NoName0()$/;"	f	struct:NoName0	access:public	signature:()
NoName0	test/output/tinyg.cpp	/^struct NoName0 : public type$/;"	s	file:	inherits:type
NoName0	test/output/tinyg/tinyg.cpp	/^	NoName0()$/;"	f	struct:NoName0	access:public	signature:()
NoName0	test/output/tinyg/tinyg.cpp	/^struct NoName0 : public type$/;"	s	file:	inherits:type
NoName0	test/output/tinyg/tinyg_bk.cpp	/^	NoName0()$/;"	f	struct:NoName0	access:public	signature:()
NoName0	test/output/tinyg/tinyg_bk.cpp	/^struct NoName0 : public type$/;"	s	file:	inherits:type
NoName0::NoName0	test/output/tinyg.cpp	/^	NoName0()$/;"	f	struct:NoName0	access:public	signature:()
NoName0::NoName0	test/output/tinyg/tinyg.cpp	/^	NoName0()$/;"	f	struct:NoName0	access:public	signature:()
NoName0::NoName0	test/output/tinyg/tinyg_bk.cpp	/^	NoName0()$/;"	f	struct:NoName0	access:public	signature:()
NoName0::sid	test/output/tinyg.cpp	/^	enum{ sid = 16 };$/;"	e	enum:NoName0::__anon21	file:
NoName0::sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 16 };$/;"	e	enum:NoName0::__anon52	file:
NoName0::sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 16 };$/;"	e	enum:NoName0::__anon83	file:
NoName1	test/output/tinyg.cpp	/^	NoName1()$/;"	f	struct:NoName1	access:public	signature:()
NoName1	test/output/tinyg.cpp	/^struct NoName1 : public type$/;"	s	file:	inherits:type
NoName1	test/output/tinyg/tinyg.cpp	/^	NoName1()$/;"	f	struct:NoName1	access:public	signature:()
NoName1	test/output/tinyg/tinyg.cpp	/^struct NoName1 : public type$/;"	s	file:	inherits:type
NoName1	test/output/tinyg/tinyg_bk.cpp	/^	NoName1()$/;"	f	struct:NoName1	access:public	signature:()
NoName1	test/output/tinyg/tinyg_bk.cpp	/^struct NoName1 : public type$/;"	s	file:	inherits:type
NoName10	test/output/tinyg.cpp	/^	NoName10()$/;"	f	struct:NoName10	access:public	signature:()
NoName10	test/output/tinyg.cpp	/^struct NoName10 : public type$/;"	s	file:	inherits:type
NoName10	test/output/tinyg/tinyg.cpp	/^	NoName10()$/;"	f	struct:NoName10	access:public	signature:()
NoName10	test/output/tinyg/tinyg.cpp	/^struct NoName10 : public type$/;"	s	file:	inherits:type
NoName10	test/output/tinyg/tinyg_bk.cpp	/^	NoName10()$/;"	f	struct:NoName10	access:public	signature:()
NoName10	test/output/tinyg/tinyg_bk.cpp	/^struct NoName10 : public type$/;"	s	file:	inherits:type
NoName10::NoName10	test/output/tinyg.cpp	/^	NoName10()$/;"	f	struct:NoName10	access:public	signature:()
NoName10::NoName10	test/output/tinyg/tinyg.cpp	/^	NoName10()$/;"	f	struct:NoName10	access:public	signature:()
NoName10::NoName10	test/output/tinyg/tinyg_bk.cpp	/^	NoName10()$/;"	f	struct:NoName10	access:public	signature:()
NoName10::sid	test/output/tinyg.cpp	/^	enum{ sid = 27 };$/;"	e	enum:NoName10::__anon32	file:
NoName10::sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 27 };$/;"	e	enum:NoName10::__anon63	file:
NoName10::sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 28 };$/;"	e	enum:NoName10::__anon94	file:
NoName11	test/output/tinyg.cpp	/^	NoName11()$/;"	f	struct:NoName11	access:public	signature:()
NoName11	test/output/tinyg.cpp	/^struct NoName11 : public type$/;"	s	file:	inherits:type
NoName11	test/output/tinyg/tinyg.cpp	/^	NoName11()$/;"	f	struct:NoName11	access:public	signature:()
NoName11	test/output/tinyg/tinyg.cpp	/^struct NoName11 : public type$/;"	s	file:	inherits:type
NoName11	test/output/tinyg/tinyg_bk.cpp	/^	NoName11()$/;"	f	struct:NoName11	access:public	signature:()
NoName11	test/output/tinyg/tinyg_bk.cpp	/^struct NoName11 : public type$/;"	s	file:	inherits:type
NoName11::NoName11	test/output/tinyg.cpp	/^	NoName11()$/;"	f	struct:NoName11	access:public	signature:()
NoName11::NoName11	test/output/tinyg/tinyg.cpp	/^	NoName11()$/;"	f	struct:NoName11	access:public	signature:()
NoName11::NoName11	test/output/tinyg/tinyg_bk.cpp	/^	NoName11()$/;"	f	struct:NoName11	access:public	signature:()
NoName11::sid	test/output/tinyg.cpp	/^	enum{ sid = 28 };$/;"	e	enum:NoName11::__anon33	file:
NoName11::sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 28 };$/;"	e	enum:NoName11::__anon64	file:
NoName11::sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 29 };$/;"	e	enum:NoName11::__anon95	file:
NoName12	test/output/tinyg.cpp	/^	NoName12()$/;"	f	struct:NoName12	access:public	signature:()
NoName12	test/output/tinyg.cpp	/^struct NoName12 : public type$/;"	s	file:	inherits:type
NoName12	test/output/tinyg/tinyg.cpp	/^	NoName12()$/;"	f	struct:NoName12	access:public	signature:()
NoName12	test/output/tinyg/tinyg.cpp	/^struct NoName12 : public type$/;"	s	file:	inherits:type
NoName12	test/output/tinyg/tinyg_bk.cpp	/^	NoName12()$/;"	f	struct:NoName12	access:public	signature:()
NoName12	test/output/tinyg/tinyg_bk.cpp	/^struct NoName12 : public type$/;"	s	file:	inherits:type
NoName12::NoName12	test/output/tinyg.cpp	/^	NoName12()$/;"	f	struct:NoName12	access:public	signature:()
NoName12::NoName12	test/output/tinyg/tinyg.cpp	/^	NoName12()$/;"	f	struct:NoName12	access:public	signature:()
NoName12::NoName12	test/output/tinyg/tinyg_bk.cpp	/^	NoName12()$/;"	f	struct:NoName12	access:public	signature:()
NoName12::sid	test/output/tinyg.cpp	/^	enum{ sid = 29 };$/;"	e	enum:NoName12::__anon34	file:
NoName12::sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 29 };$/;"	e	enum:NoName12::__anon65	file:
NoName12::sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 30 };$/;"	e	enum:NoName12::__anon96	file:
NoName13	test/output/tinyg.cpp	/^	NoName13()$/;"	f	struct:NoName13	access:public	signature:()
NoName13	test/output/tinyg.cpp	/^struct NoName13 : public type$/;"	s	file:	inherits:type
NoName13	test/output/tinyg/tinyg.cpp	/^	NoName13()$/;"	f	struct:NoName13	access:public	signature:()
NoName13	test/output/tinyg/tinyg.cpp	/^struct NoName13 : public type$/;"	s	file:	inherits:type
NoName13	test/output/tinyg/tinyg_bk.cpp	/^	NoName13()$/;"	f	struct:NoName13	access:public	signature:()
NoName13	test/output/tinyg/tinyg_bk.cpp	/^struct NoName13 : public type$/;"	s	file:	inherits:type
NoName13::NoName13	test/output/tinyg.cpp	/^	NoName13()$/;"	f	struct:NoName13	access:public	signature:()
NoName13::NoName13	test/output/tinyg/tinyg.cpp	/^	NoName13()$/;"	f	struct:NoName13	access:public	signature:()
NoName13::NoName13	test/output/tinyg/tinyg_bk.cpp	/^	NoName13()$/;"	f	struct:NoName13	access:public	signature:()
NoName13::sid	test/output/tinyg.cpp	/^	enum{ sid = 30 };$/;"	e	enum:NoName13::__anon35	file:
NoName13::sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 30 };$/;"	e	enum:NoName13::__anon66	file:
NoName13::sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 31 };$/;"	e	enum:NoName13::__anon97	file:
NoName1::NoName1	test/output/tinyg.cpp	/^	NoName1()$/;"	f	struct:NoName1	access:public	signature:()
NoName1::NoName1	test/output/tinyg/tinyg.cpp	/^	NoName1()$/;"	f	struct:NoName1	access:public	signature:()
NoName1::NoName1	test/output/tinyg/tinyg_bk.cpp	/^	NoName1()$/;"	f	struct:NoName1	access:public	signature:()
NoName1::sid	test/output/tinyg.cpp	/^	enum{ sid = 17 };$/;"	e	enum:NoName1::__anon22	file:
NoName1::sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 17 };$/;"	e	enum:NoName1::__anon53	file:
NoName1::sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 17 };$/;"	e	enum:NoName1::__anon84	file:
NoName2	test/output/tinyg.cpp	/^	NoName2()$/;"	f	struct:NoName2	access:public	signature:()
NoName2	test/output/tinyg.cpp	/^struct NoName2 : public type$/;"	s	file:	inherits:type
NoName2	test/output/tinyg/tinyg.cpp	/^	NoName2()$/;"	f	struct:NoName2	access:public	signature:()
NoName2	test/output/tinyg/tinyg.cpp	/^struct NoName2 : public type$/;"	s	file:	inherits:type
NoName2	test/output/tinyg/tinyg_bk.cpp	/^	NoName2()$/;"	f	struct:NoName2	access:public	signature:()
NoName2	test/output/tinyg/tinyg_bk.cpp	/^struct NoName2 : public type$/;"	s	file:	inherits:type
NoName2::NoName2	test/output/tinyg.cpp	/^	NoName2()$/;"	f	struct:NoName2	access:public	signature:()
NoName2::NoName2	test/output/tinyg/tinyg.cpp	/^	NoName2()$/;"	f	struct:NoName2	access:public	signature:()
NoName2::NoName2	test/output/tinyg/tinyg_bk.cpp	/^	NoName2()$/;"	f	struct:NoName2	access:public	signature:()
NoName2::sid	test/output/tinyg.cpp	/^	enum{ sid = 18 };$/;"	e	enum:NoName2::__anon23	file:
NoName2::sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 18 };$/;"	e	enum:NoName2::__anon54	file:
NoName2::sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 18 };$/;"	e	enum:NoName2::__anon85	file:
NoName3	test/output/tinyg.cpp	/^	NoName3()$/;"	f	struct:NoName3	access:public	signature:()
NoName3	test/output/tinyg.cpp	/^struct NoName3 : public type$/;"	s	file:	inherits:type
NoName3	test/output/tinyg/tinyg.cpp	/^	NoName3()$/;"	f	struct:NoName3	access:public	signature:()
NoName3	test/output/tinyg/tinyg.cpp	/^struct NoName3 : public type$/;"	s	file:	inherits:type
NoName3	test/output/tinyg/tinyg_bk.cpp	/^	NoName3()$/;"	f	struct:NoName3	access:public	signature:()
NoName3	test/output/tinyg/tinyg_bk.cpp	/^struct NoName3 : public type$/;"	s	file:	inherits:type
NoName3::NoName3	test/output/tinyg.cpp	/^	NoName3()$/;"	f	struct:NoName3	access:public	signature:()
NoName3::NoName3	test/output/tinyg/tinyg.cpp	/^	NoName3()$/;"	f	struct:NoName3	access:public	signature:()
NoName3::NoName3	test/output/tinyg/tinyg_bk.cpp	/^	NoName3()$/;"	f	struct:NoName3	access:public	signature:()
NoName3::sid	test/output/tinyg.cpp	/^	enum{ sid = 20 };$/;"	e	enum:NoName3::__anon25	file:
NoName3::sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 20 };$/;"	e	enum:NoName3::__anon56	file:
NoName3::sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 21 };$/;"	e	enum:NoName3::__anon87	file:
NoName4	test/output/tinyg.cpp	/^	NoName4()$/;"	f	struct:NoName4	access:public	signature:()
NoName4	test/output/tinyg.cpp	/^struct NoName4 : public type$/;"	s	file:	inherits:type
NoName4	test/output/tinyg/tinyg.cpp	/^	NoName4()$/;"	f	struct:NoName4	access:public	signature:()
NoName4	test/output/tinyg/tinyg.cpp	/^struct NoName4 : public type$/;"	s	file:	inherits:type
NoName4	test/output/tinyg/tinyg_bk.cpp	/^	NoName4()$/;"	f	struct:NoName4	access:public	signature:()
NoName4	test/output/tinyg/tinyg_bk.cpp	/^struct NoName4 : public type$/;"	s	file:	inherits:type
NoName4::NoName4	test/output/tinyg.cpp	/^	NoName4()$/;"	f	struct:NoName4	access:public	signature:()
NoName4::NoName4	test/output/tinyg/tinyg.cpp	/^	NoName4()$/;"	f	struct:NoName4	access:public	signature:()
NoName4::NoName4	test/output/tinyg/tinyg_bk.cpp	/^	NoName4()$/;"	f	struct:NoName4	access:public	signature:()
NoName4::sid	test/output/tinyg.cpp	/^	enum{ sid = 21 };$/;"	e	enum:NoName4::__anon26	file:
NoName4::sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 21 };$/;"	e	enum:NoName4::__anon57	file:
NoName4::sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 22 };$/;"	e	enum:NoName4::__anon88	file:
NoName5	test/output/tinyg.cpp	/^	NoName5()$/;"	f	struct:NoName5	access:public	signature:()
NoName5	test/output/tinyg.cpp	/^struct NoName5 : public type$/;"	s	file:	inherits:type
NoName5	test/output/tinyg/tinyg.cpp	/^	NoName5()$/;"	f	struct:NoName5	access:public	signature:()
NoName5	test/output/tinyg/tinyg.cpp	/^struct NoName5 : public type$/;"	s	file:	inherits:type
NoName5	test/output/tinyg/tinyg_bk.cpp	/^	NoName5()$/;"	f	struct:NoName5	access:public	signature:()
NoName5	test/output/tinyg/tinyg_bk.cpp	/^struct NoName5 : public type$/;"	s	file:	inherits:type
NoName5::NoName5	test/output/tinyg.cpp	/^	NoName5()$/;"	f	struct:NoName5	access:public	signature:()
NoName5::NoName5	test/output/tinyg/tinyg.cpp	/^	NoName5()$/;"	f	struct:NoName5	access:public	signature:()
NoName5::NoName5	test/output/tinyg/tinyg_bk.cpp	/^	NoName5()$/;"	f	struct:NoName5	access:public	signature:()
NoName5::sid	test/output/tinyg.cpp	/^	enum{ sid = 22 };$/;"	e	enum:NoName5::__anon27	file:
NoName5::sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 22 };$/;"	e	enum:NoName5::__anon58	file:
NoName5::sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 23 };$/;"	e	enum:NoName5::__anon89	file:
NoName6	test/output/tinyg.cpp	/^	NoName6()$/;"	f	struct:NoName6	access:public	signature:()
NoName6	test/output/tinyg.cpp	/^struct NoName6 : public type$/;"	s	file:	inherits:type
NoName6	test/output/tinyg/tinyg.cpp	/^	NoName6()$/;"	f	struct:NoName6	access:public	signature:()
NoName6	test/output/tinyg/tinyg.cpp	/^struct NoName6 : public type$/;"	s	file:	inherits:type
NoName6	test/output/tinyg/tinyg_bk.cpp	/^	NoName6()$/;"	f	struct:NoName6	access:public	signature:()
NoName6	test/output/tinyg/tinyg_bk.cpp	/^struct NoName6 : public type$/;"	s	file:	inherits:type
NoName6::NoName6	test/output/tinyg.cpp	/^	NoName6()$/;"	f	struct:NoName6	access:public	signature:()
NoName6::NoName6	test/output/tinyg/tinyg.cpp	/^	NoName6()$/;"	f	struct:NoName6	access:public	signature:()
NoName6::NoName6	test/output/tinyg/tinyg_bk.cpp	/^	NoName6()$/;"	f	struct:NoName6	access:public	signature:()
NoName6::sid	test/output/tinyg.cpp	/^	enum{ sid = 23 };$/;"	e	enum:NoName6::__anon28	file:
NoName6::sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 23 };$/;"	e	enum:NoName6::__anon59	file:
NoName6::sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 24 };$/;"	e	enum:NoName6::__anon90	file:
NoName7	test/output/tinyg.cpp	/^	NoName7()$/;"	f	struct:NoName7	access:public	signature:()
NoName7	test/output/tinyg.cpp	/^struct NoName7 : public type$/;"	s	file:	inherits:type
NoName7	test/output/tinyg/tinyg.cpp	/^	NoName7()$/;"	f	struct:NoName7	access:public	signature:()
NoName7	test/output/tinyg/tinyg.cpp	/^struct NoName7 : public type$/;"	s	file:	inherits:type
NoName7	test/output/tinyg/tinyg_bk.cpp	/^	NoName7()$/;"	f	struct:NoName7	access:public	signature:()
NoName7	test/output/tinyg/tinyg_bk.cpp	/^struct NoName7 : public type$/;"	s	file:	inherits:type
NoName7::NoName7	test/output/tinyg.cpp	/^	NoName7()$/;"	f	struct:NoName7	access:public	signature:()
NoName7::NoName7	test/output/tinyg/tinyg.cpp	/^	NoName7()$/;"	f	struct:NoName7	access:public	signature:()
NoName7::NoName7	test/output/tinyg/tinyg_bk.cpp	/^	NoName7()$/;"	f	struct:NoName7	access:public	signature:()
NoName7::sid	test/output/tinyg.cpp	/^	enum{ sid = 24 };$/;"	e	enum:NoName7::__anon29	file:
NoName7::sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 24 };$/;"	e	enum:NoName7::__anon60	file:
NoName7::sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 25 };$/;"	e	enum:NoName7::__anon91	file:
NoName8	test/output/tinyg.cpp	/^	NoName8()$/;"	f	struct:NoName8	access:public	signature:()
NoName8	test/output/tinyg.cpp	/^struct NoName8 : public type$/;"	s	file:	inherits:type
NoName8	test/output/tinyg/tinyg.cpp	/^	NoName8()$/;"	f	struct:NoName8	access:public	signature:()
NoName8	test/output/tinyg/tinyg.cpp	/^struct NoName8 : public type$/;"	s	file:	inherits:type
NoName8	test/output/tinyg/tinyg_bk.cpp	/^	NoName8()$/;"	f	struct:NoName8	access:public	signature:()
NoName8	test/output/tinyg/tinyg_bk.cpp	/^struct NoName8 : public type$/;"	s	file:	inherits:type
NoName8::NoName8	test/output/tinyg.cpp	/^	NoName8()$/;"	f	struct:NoName8	access:public	signature:()
NoName8::NoName8	test/output/tinyg/tinyg.cpp	/^	NoName8()$/;"	f	struct:NoName8	access:public	signature:()
NoName8::NoName8	test/output/tinyg/tinyg_bk.cpp	/^	NoName8()$/;"	f	struct:NoName8	access:public	signature:()
NoName8::sid	test/output/tinyg.cpp	/^	enum{ sid = 25 };$/;"	e	enum:NoName8::__anon30	file:
NoName8::sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 25 };$/;"	e	enum:NoName8::__anon61	file:
NoName8::sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 26 };$/;"	e	enum:NoName8::__anon92	file:
NoName9	test/output/tinyg.cpp	/^	NoName9()$/;"	f	struct:NoName9	access:public	signature:()
NoName9	test/output/tinyg.cpp	/^struct NoName9 : public type$/;"	s	file:	inherits:type
NoName9	test/output/tinyg/tinyg.cpp	/^	NoName9()$/;"	f	struct:NoName9	access:public	signature:()
NoName9	test/output/tinyg/tinyg.cpp	/^struct NoName9 : public type$/;"	s	file:	inherits:type
NoName9	test/output/tinyg/tinyg_bk.cpp	/^	NoName9()$/;"	f	struct:NoName9	access:public	signature:()
NoName9	test/output/tinyg/tinyg_bk.cpp	/^struct NoName9 : public type$/;"	s	file:	inherits:type
NoName9::NoName9	test/output/tinyg.cpp	/^	NoName9()$/;"	f	struct:NoName9	access:public	signature:()
NoName9::NoName9	test/output/tinyg/tinyg.cpp	/^	NoName9()$/;"	f	struct:NoName9	access:public	signature:()
NoName9::NoName9	test/output/tinyg/tinyg_bk.cpp	/^	NoName9()$/;"	f	struct:NoName9	access:public	signature:()
NoName9::sid	test/output/tinyg.cpp	/^	enum{ sid = 26 };$/;"	e	enum:NoName9::__anon31	file:
NoName9::sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 26 };$/;"	e	enum:NoName9::__anon62	file:
NoName9::sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 27 };$/;"	e	enum:NoName9::__anon93	file:
NodePos	third_party/xml/Markup.cpp	/^	NodePos( int n ) { nNodeFlags=n; nNodeType=0; nStart=0; nLength=0; };$/;"	f	struct:NodePos	access:public	signature:( int n )
NodePos	third_party/xml/Markup.cpp	/^	NodePos() {};$/;"	f	struct:NodePos	access:public	signature:()
NodePos	third_party/xml/Markup.cpp	/^struct NodePos$/;"	s	file:
NodePos::NodePos	third_party/xml/Markup.cpp	/^	NodePos( int n ) { nNodeFlags=n; nNodeType=0; nStart=0; nLength=0; };$/;"	f	struct:NodePos	access:public	signature:( int n )
NodePos::NodePos	third_party/xml/Markup.cpp	/^	NodePos() {};$/;"	f	struct:NodePos	access:public	signature:()
NodePos::nLength	third_party/xml/Markup.cpp	/^	int nLength;$/;"	m	struct:NodePos	file:	access:public
NodePos::nNodeFlags	third_party/xml/Markup.cpp	/^	int nNodeFlags;$/;"	m	struct:NodePos	file:	access:public
NodePos::nNodeType	third_party/xml/Markup.cpp	/^	int nNodeType;$/;"	m	struct:NodePos	file:	access:public
NodePos::nStart	third_party/xml/Markup.cpp	/^	int nStart;$/;"	m	struct:NodePos	file:	access:public
NodePos::strMeta	third_party/xml/Markup.cpp	/^	MCD_STR strMeta;$/;"	m	struct:NodePos	file:	access:public
NonOp	include/functionalX.h	/^struct NonOp : public std::unary_function<_Arg, _Arg>$/;"	s	inherits:std::unary_function
NonOp::operator ()	include/functionalX.h	/^	_Arg& operator()(_Arg& _arg) const$/;"	f	struct:NonOp	access:public	signature:(_Arg& _arg) const
NonOp::operator ()	include/functionalX.h	/^	const _Arg& operator()(const _Arg& _arg) const$/;"	f	struct:NonOp	access:public	signature:(const _Arg& _arg) const
OVERWRITE_FUNCTION_1	include/macros.h	43;"	d
OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(append, const _Elem*, _Ptr);$/;"	p	class:xstring_basic	access:public	signature:(append, const _Elem*, _Ptr)
OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(append, const _Mybase&, _Right);$/;"	p	class:xstring_basic	access:public	signature:(append, const _Mybase&, _Right)
OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(assign, const _Elem*, _Ptr);$/;"	p	class:xstring_basic	access:public	signature:(assign, const _Elem*, _Ptr)
OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(assign, const _Mybase&, _Right);$/;"	p	class:xstring_basic	access:public	signature:(assign, const _Mybase&, _Right)
OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(operator+=, _Elem, _Ch);$/;"	p	class:xstring_basic	access:public	signature:(operator+=, _Elem, _Ch)
OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(operator+=, const _Elem*&, _Ptr);$/;"	p	class:xstring_basic	access:public	signature:(operator+=, const _Elem*&, _Ptr)
OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(operator+=, const _Mybase&, _Right);$/;"	p	class:xstring_basic	access:public	signature:(operator+=, const _Mybase&, _Right)
OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(operator=, _Elem, _Ch);$/;"	p	class:xstring_basic	access:public	signature:(operator=, _Elem, _Ch)
OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(operator=, const _Elem*&, _Ptr);$/;"	p	class:xstring_basic	access:public	signature:(operator=, const _Elem*&, _Ptr)
OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(operator=, const _Mybase&, _Right);$/;"	p	class:xstring_basic	access:public	signature:(operator=, const _Mybase&, _Right)
OVERWRITE_FUNCTION_2	include/macros.h	50;"	d
OVERWRITE_FUNCTION_2	include/stringX.h	/^	OVERWRITE_FUNCTION_2(append, _It, _First, _It, _Last);$/;"	p	class:xstring_basic	access:public	signature:(append, _It, _First, _It, _Last)
OVERWRITE_FUNCTION_2	include/stringX.h	/^	OVERWRITE_FUNCTION_2(append, const _Elem*, _Ptr, size_type, _Count);$/;"	p	class:xstring_basic	access:public	signature:(append, const _Elem*, _Ptr, size_type, _Count)
OVERWRITE_FUNCTION_2	include/stringX.h	/^	OVERWRITE_FUNCTION_2(append, size_type, _Count, _Elem, _Ch);$/;"	p	class:xstring_basic	access:public	signature:(append, size_type, _Count, _Elem, _Ch)
OVERWRITE_FUNCTION_2	include/stringX.h	/^	OVERWRITE_FUNCTION_2(assign, _It, _First, _It, _Last);$/;"	p	class:xstring_basic	access:public	signature:(assign, _It, _First, _It, _Last)
OVERWRITE_FUNCTION_2	include/stringX.h	/^	OVERWRITE_FUNCTION_2(assign, const _Elem*, _Ptr, size_type, _Count);$/;"	p	class:xstring_basic	access:public	signature:(assign, const _Elem*, _Ptr, size_type, _Count)
OVERWRITE_FUNCTION_2	include/stringX.h	/^	OVERWRITE_FUNCTION_2(assign, size_type, _Count, _Elem, _Ch);$/;"	p	class:xstring_basic	access:public	signature:(assign, size_type, _Count, _Elem, _Ch)
OVERWRITE_FUNCTION_2	include/stringX.h	/^	OVERWRITE_FUNCTION_2(insert, size_type, _Off, const _Elem*, _Ptr);$/;"	p	class:xstring_basic	access:public	signature:(insert, size_type, _Off, const _Elem*, _Ptr)
OVERWRITE_FUNCTION_2	include/stringX.h	/^	OVERWRITE_FUNCTION_2(insert, size_type, _Off, const _Mybase&, _Right);$/;"	p	class:xstring_basic	access:public	signature:(insert, size_type, _Off, const _Mybase&, _Right)
OVERWRITE_FUNCTION_3	include/macros.h	57;"	d
OVERWRITE_FUNCTION_3	include/stringX.h	/^	OVERWRITE_FUNCTION_3(append, const _Mybase&, _Right, size_type, _Roff, size_type, _Count);$/;"	p	class:xstring_basic	access:public	signature:(append, const _Mybase&, _Right, size_type, _Roff, size_type, _Count)
OVERWRITE_FUNCTION_3	include/stringX.h	/^	OVERWRITE_FUNCTION_3(assign, const _Mybase&, _Right, size_type, _Roff, size_type, _Count);$/;"	p	class:xstring_basic	access:public	signature:(assign, const _Mybase&, _Right, size_type, _Roff, size_type, _Count)
OVERWRITE_FUNCTION_3	include/stringX.h	/^	OVERWRITE_FUNCTION_3(insert, size_type, _Off, const _Elem*, _Ptr, size_type, _Count);$/;"	p	class:xstring_basic	access:public	signature:(insert, size_type, _Off, const _Elem*, _Ptr, size_type, _Count)
OVERWRITE_FUNCTION_3	include/stringX.h	/^	OVERWRITE_FUNCTION_3(insert, size_type, _Off, size_type, _Count, _Elem, _Ch);$/;"	p	class:xstring_basic	access:public	signature:(insert, size_type, _Off, size_type, _Count, _Elem, _Ch)
OVERWRITE_FUNCTION_3	include/stringX.h	/^	OVERWRITE_FUNCTION_3(replace, size_type, _Off, size_type, _N0, const _Elem*, _Ptr);$/;"	p	class:xstring_basic	access:public	signature:(replace, size_type, _Off, size_type, _N0, const _Elem*, _Ptr)
OVERWRITE_FUNCTION_3	include/stringX.h	/^	OVERWRITE_FUNCTION_3(replace, size_type, _Off, size_type, _N0, const _Myt&, _Right);$/;"	p	class:xstring_basic	access:public	signature:(replace, size_type, _Off, size_type, _N0, const _Myt&, _Right)
OVERWRITE_FUNCTION_3	include/stringX.h	/^	OVERWRITE_FUNCTION_3(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, const _Elem*, _Ptr);$/;"	p	class:xstring_basic	access:public	signature:(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, const _Elem*, _Ptr)
OVERWRITE_FUNCTION_3	include/stringX.h	/^	OVERWRITE_FUNCTION_3(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, const _Myt&, _Right);$/;"	p	class:xstring_basic	access:public	signature:(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, const _Myt&, _Right)
OVERWRITE_FUNCTION_4	include/macros.h	64;"	d
OVERWRITE_FUNCTION_4	include/stringX.h	/^	OVERWRITE_FUNCTION_4(insert, size_type, _Off, const _Mybase&, _Right, size_type, _Roff, size_type, _Count);$/;"	p	class:xstring_basic	access:public	signature:(insert, size_type, _Off, const _Mybase&, _Right, size_type, _Roff, size_type, _Count)
OVERWRITE_FUNCTION_4	include/stringX.h	/^	OVERWRITE_FUNCTION_4(replace, size_type, _Off, size_type, _N0, const _Elem*, _Ptr, size_type, _Count);$/;"	p	class:xstring_basic	access:public	signature:(replace, size_type, _Off, size_type, _N0, const _Elem*, _Ptr, size_type, _Count)
OVERWRITE_FUNCTION_4	include/stringX.h	/^	OVERWRITE_FUNCTION_4(replace, size_type, _Off, size_type, _N0, size_type, _Count, _Elem, _Ch);$/;"	p	class:xstring_basic	access:public	signature:(replace, size_type, _Off, size_type, _N0, size_type, _Count, _Elem, _Ch)
OVERWRITE_FUNCTION_4	include/stringX.h	/^	OVERWRITE_FUNCTION_4(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, _It, _First2, _It, _Last2);$/;"	p	class:xstring_basic	access:public	signature:(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, _It, _First2, _It, _Last2)
OVERWRITE_FUNCTION_4	include/stringX.h	/^	OVERWRITE_FUNCTION_4(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, const _Elem*, _Ptr, size_type, _Count);$/;"	p	class:xstring_basic	access:public	signature:(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, const _Elem*, _Ptr, size_type, _Count)
OVERWRITE_FUNCTION_4	include/stringX.h	/^	OVERWRITE_FUNCTION_4(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, size_type, _Count, _Elem, _Ch);$/;"	p	class:xstring_basic	access:public	signature:(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, size_type, _Count, _Elem, _Ch)
Op	test/output/tinyg.cpp	/^	Op()$/;"	f	struct:Op	access:public	signature:()
Op	test/output/tinyg.cpp	/^struct Op : public type$/;"	s	file:	inherits:type
Op	test/output/tinyg/tinyg.cpp	/^	Op()$/;"	f	struct:Op	access:public	signature:()
Op	test/output/tinyg/tinyg.cpp	/^struct Op : public type$/;"	s	file:	inherits:type
Op	test/output/tinyg/tinyg_bk.cpp	/^	Op()$/;"	f	struct:Op	access:public	signature:()
Op	test/output/tinyg/tinyg_bk.cpp	/^struct Op : public type$/;"	s	file:	inherits:type
Op::Op	test/output/tinyg.cpp	/^	Op()$/;"	f	struct:Op	access:public	signature:()
Op::Op	test/output/tinyg/tinyg.cpp	/^	Op()$/;"	f	struct:Op	access:public	signature:()
Op::Op	test/output/tinyg/tinyg_bk.cpp	/^	Op()$/;"	f	struct:Op	access:public	signature:()
Op::sid	test/output/tinyg.cpp	/^	enum{ sid = 11 };$/;"	e	enum:Op::__anon16	file:
Op::sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 11 };$/;"	e	enum:Op::__anon47	file:
Op::sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 11 };$/;"	e	enum:Op::__anon78	file:
OutOfElem	third_party/xml/Markup.cpp	/^bool CMarkup::OutOfElem()$/;"	f	class:CMarkup	signature:()
OutOfElem	third_party/xml/Markup.h	/^	bool OutOfElem();$/;"	p	class:CMarkup	access:public	signature:()
OutOfLevel	third_party/xml/Markup.cpp	/^	void OutOfLevel() { if (iPar!=iTop) Pop(); iPar = pL[iTop].iParent; --nLevel; };$/;"	f	struct:ElemStack	access:public	signature:()
PA_SEGBITS	third_party/xml/Markup.cpp	/^	enum { PA_SEGBITS = 16, PA_SEGMASK = 0xffff };$/;"	e	enum:ElemPosTree::__anon133	file:
PA_SEGMASK	third_party/xml/Markup.cpp	/^	enum { PA_SEGBITS = 16, PA_SEGMASK = 0xffff };$/;"	e	enum:ElemPosTree::__anon133	file:
PI	include/mathX.h	13;"	d
ParseNode	third_party/xml/Markup.cpp	/^	int ParseNode( NodePos& node );$/;"	p	struct:TokenPos	file:	access:public	signature:( NodePos& node )
ParseNode	third_party/xml/Markup.cpp	/^int TokenPos::ParseNode( NodePos& node )$/;"	f	class:TokenPos	signature:( NodePos& node )
ParsePath	third_party/xml/Markup.cpp	/^	bool ParsePath();$/;"	p	struct:PathPos	file:	access:private	signature:()
ParsePath	third_party/xml/Markup.cpp	/^bool PathPos::ParsePath()$/;"	f	class:PathPos	signature:()
PathPos	third_party/xml/Markup.cpp	/^	PathPos( MCD_PCSZ pszPath, bool b ) { p=pszPath; bReader=b; i=0; iPathAttribName=0; iSave=0; nPathType=0; if (!ParsePath()) nPathType=-1; };$/;"	f	struct:PathPos	access:public	signature:( MCD_PCSZ pszPath, bool b )
PathPos	third_party/xml/Markup.cpp	/^struct PathPos$/;"	s	file:
PathPos::AttribPredicateMatch	third_party/xml/Markup.cpp	/^	bool AttribPredicateMatch( TokenPos& token );$/;"	p	struct:PathPos	file:	access:public	signature:( TokenPos& token )
PathPos::AttribPredicateMatch	third_party/xml/Markup.cpp	/^bool PathPos::AttribPredicateMatch( TokenPos& token )$/;"	f	class:PathPos	signature:( TokenPos& token )
PathPos::GetChar	third_party/xml/Markup.cpp	/^	MCD_CHAR GetChar() { return p[i]; };$/;"	f	struct:PathPos	access:public	signature:()
PathPos::GetNumAndInc	third_party/xml/Markup.cpp	/^	int GetNumAndInc() { int n=0; while (p[i]>='0'&&p[i]<='9') n=n*10+(int)p[i++]-(int)'0'; return n; };$/;"	f	struct:PathPos	access:public	signature:()
PathPos::GetPathAttribName	third_party/xml/Markup.cpp	/^	MCD_PCSZ GetPathAttribName() { if (iPathAttribName) return &p[iPathAttribName]; return NULL; };$/;"	f	struct:PathPos	access:public	signature:()
PathPos::GetPtr	third_party/xml/Markup.cpp	/^	MCD_PCSZ GetPtr() { return &p[i]; };$/;"	f	struct:PathPos	access:public	signature:()
PathPos::GetTypeAndInc	third_party/xml/Markup.cpp	/^	int GetTypeAndInc() { i=-1; if (p) { if (p[0]=='\/') { if (p[1]=='\/') i=2; else i=1; } else if (p[0]) i=0; } nPathType=i+1; return nPathType; };$/;"	f	struct:PathPos	access:public	signature:()
PathPos::GetValAndInc	third_party/xml/Markup.cpp	/^	MCD_PCSZ GetValAndInc() { ++i; MCD_CHAR cEnd=']'; if (p[i]=='\\''||p[i]=='\\"') cEnd=p[i++]; int iVal=i; IncWord(cEnd); nLen=i-iVal; if (cEnd!=']') ++i; return &p[iVal]; };$/;"	f	struct:PathPos	access:public	signature:()
PathPos::GetValOrWordLen	third_party/xml/Markup.cpp	/^	int GetValOrWordLen() { return nLen; };$/;"	f	struct:PathPos	access:public	signature:()
PathPos::GetWordAndInc	third_party/xml/Markup.cpp	/^	MCD_PCSZ GetWordAndInc() { int iWord=i; IncWord(); nLen=i-iWord; return &p[iWord]; };$/;"	f	struct:PathPos	access:public	signature:()
PathPos::Inc	third_party/xml/Markup.cpp	/^	void Inc( int n ) { i+=n; };$/;"	f	struct:PathPos	access:public	signature:( int n )
PathPos::IncChar	third_party/xml/Markup.cpp	/^	void IncChar() { ++i; };$/;"	f	struct:PathPos	access:public	signature:()
PathPos::IncWord	third_party/xml/Markup.cpp	/^	void IncWord( MCD_CHAR c ) { while (p[i]&&p[i]!=c) i+=MCD_CLEN(&p[i]); };$/;"	f	struct:PathPos	access:public	signature:( MCD_CHAR c )
PathPos::IncWord	third_party/xml/Markup.cpp	/^	void IncWord() { while (p[i]&&!MCD_PSZCHR(MCD_T(" =\/[]"),p[i])) i+=MCD_CLEN(&p[i]); };$/;"	f	struct:PathPos	access:public	signature:()
PathPos::IsAbsolutePath	third_party/xml/Markup.cpp	/^	bool IsAbsolutePath() { return nPathType == 2; };$/;"	f	struct:PathPos	access:public	signature:()
PathPos::IsAnywherePath	third_party/xml/Markup.cpp	/^	bool IsAnywherePath() { return nPathType == 3; };$/;"	f	struct:PathPos	access:public	signature:()
PathPos::IsAtPathEnd	third_party/xml/Markup.cpp	/^	bool IsAtPathEnd() { return ((!p[i])||(iPathAttribName&&i+2>=iPathAttribName))?true:false; }; $/;"	f	struct:PathPos	access:public	signature:()
PathPos::IsPath	third_party/xml/Markup.cpp	/^	bool IsPath() { return nPathType > 0; };$/;"	f	struct:PathPos	access:public	signature:()
PathPos::ParsePath	third_party/xml/Markup.cpp	/^	bool ParsePath();$/;"	p	struct:PathPos	file:	access:private	signature:()
PathPos::ParsePath	third_party/xml/Markup.cpp	/^bool PathPos::ParsePath()$/;"	f	class:PathPos	signature:()
PathPos::PathPos	third_party/xml/Markup.cpp	/^	PathPos( MCD_PCSZ pszPath, bool b ) { p=pszPath; bReader=b; i=0; iPathAttribName=0; iSave=0; nPathType=0; if (!ParsePath()) nPathType=-1; };$/;"	f	struct:PathPos	access:public	signature:( MCD_PCSZ pszPath, bool b )
PathPos::RevertOffset	third_party/xml/Markup.cpp	/^	void RevertOffset() { i=iSave; };$/;"	f	struct:PathPos	access:public	signature:()
PathPos::RevertOffsetAsName	third_party/xml/Markup.cpp	/^	void RevertOffsetAsName() { i=iSave; nPathType=1; };$/;"	f	struct:PathPos	access:public	signature:()
PathPos::SaveOffset	third_party/xml/Markup.cpp	/^	void SaveOffset() { iSave=i; };$/;"	f	struct:PathPos	access:public	signature:()
PathPos::ValidPath	third_party/xml/Markup.cpp	/^	bool ValidPath() { return nPathType != -1; };$/;"	f	struct:PathPos	access:public	signature:()
PathPos::bReader	third_party/xml/Markup.cpp	/^	bool bReader;$/;"	m	struct:PathPos	file:	access:private
PathPos::i	third_party/xml/Markup.cpp	/^	int i;$/;"	m	struct:PathPos	file:	access:private
PathPos::iPathAttribName	third_party/xml/Markup.cpp	/^	int iPathAttribName;$/;"	m	struct:PathPos	file:	access:private
PathPos::iSave	third_party/xml/Markup.cpp	/^	int iSave;$/;"	m	struct:PathPos	file:	access:private
PathPos::nLen	third_party/xml/Markup.cpp	/^	int nLen;$/;"	m	struct:PathPos	file:	access:private
PathPos::nPathType	third_party/xml/Markup.cpp	/^	int nPathType; \/\/ -1 invalid, 0 empty, 1 name, 2 absolute path, 3 anywhere path$/;"	m	struct:PathPos	file:	access:private
PathPos::p	third_party/xml/Markup.cpp	/^	MCD_PCSZ p;$/;"	m	struct:PathPos	file:	access:private
PerformConversion	third_party/xml/Markup.cpp	/^	int PerformConversion( void* pTo, MCD_CSTR pszToEncoding = NULL );$/;"	p	struct:TextEncoding	file:	access:public	signature:( void* pTo, MCD_CSTR pszToEncoding = NULL )
PerformConversion	third_party/xml/Markup.cpp	/^int TextEncoding::PerformConversion( void* pTo, MCD_CSTR pszToEncoding\/*=NULL*\/ )$/;"	f	class:TextEncoding	signature:( void* pTo, MCD_CSTR pszToEncoding )
Pop	third_party/xml/Markup.cpp	/^	void Pop() { iTop = iPar; while (iUsed && pL[iUsed].iParent==iPar) { if (pL[iUsed].nSlot!=-1) Unslot(pL[iUsed]); --iUsed; } };$/;"	f	struct:ElemStack	access:public	signature:()
PopOutOfLevel	third_party/xml/Markup.cpp	/^	void PopOutOfLevel() { --iTop; };$/;"	f	struct:ElemStack	access:public	signature:()
PredefEntityTable	third_party/xml/Markup.cpp	/^MCD_PCSZ PredefEntityTable[130] =$/;"	v
Print	test/output/gen.cpp	/^	Print()$/;"	f	struct:Print	access:public	signature:()
Print	test/output/gen.cpp	/^struct Print : public type$/;"	s	file:	inherits:type
Print::Print	test/output/gen.cpp	/^	Print()$/;"	f	struct:Print	access:public	signature:()
Print::sid	test/output/gen.cpp	/^	enum{ sid = 1008 };$/;"	e	enum:Print::__anon105	file:
PrintFunc	test/output/tinyg.cpp	/^	PrintFunc()$/;"	f	struct:PrintFunc	access:public	signature:()
PrintFunc	test/output/tinyg.cpp	/^struct PrintFunc : public type$/;"	s	file:	inherits:type
PrintFunc	test/output/tinyg/tinyg.cpp	/^	PrintFunc()$/;"	f	struct:PrintFunc	access:public	signature:()
PrintFunc	test/output/tinyg/tinyg.cpp	/^struct PrintFunc : public type$/;"	s	file:	inherits:type
PrintFunc	test/output/tinyg/tinyg_bk.cpp	/^	PrintFunc()$/;"	f	struct:PrintFunc	access:public	signature:()
PrintFunc	test/output/tinyg/tinyg_bk.cpp	/^struct PrintFunc : public type$/;"	s	file:	inherits:type
PrintFunc::PrintFunc	test/output/tinyg.cpp	/^	PrintFunc()$/;"	f	struct:PrintFunc	access:public	signature:()
PrintFunc::PrintFunc	test/output/tinyg/tinyg.cpp	/^	PrintFunc()$/;"	f	struct:PrintFunc	access:public	signature:()
PrintFunc::PrintFunc	test/output/tinyg/tinyg_bk.cpp	/^	PrintFunc()$/;"	f	struct:PrintFunc	access:public	signature:()
PrintFunc::sid	test/output/tinyg.cpp	/^	enum{ sid = 12 };$/;"	e	enum:PrintFunc::__anon17	file:
PrintFunc::sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 12 };$/;"	e	enum:PrintFunc::__anon48	file:
PrintFunc::sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 12 };$/;"	e	enum:PrintFunc::__anon79	file:
Program	test/output/gen.cpp	/^	Program()$/;"	f	struct:Program	access:public	signature:()
Program	test/output/gen.cpp	/^struct Program : public type$/;"	s	file:	inherits:type
Program	test/output/tinyg.cpp	/^	Program()$/;"	f	struct:Program	access:public	signature:()
Program	test/output/tinyg.cpp	/^struct Program : public type$/;"	s	file:	inherits:type
Program	test/output/tinyg/tinyg.cpp	/^	Program()$/;"	f	struct:Program	access:public	signature:()
Program	test/output/tinyg/tinyg.cpp	/^struct Program : public type$/;"	s	file:	inherits:type
Program	test/output/tinyg/tinyg_bk.cpp	/^	Program()$/;"	f	struct:Program	access:public	signature:()
Program	test/output/tinyg/tinyg_bk.cpp	/^struct Program : public type$/;"	s	file:	inherits:type
Program::Program	test/output/gen.cpp	/^	Program()$/;"	f	struct:Program	access:public	signature:()
Program::Program	test/output/tinyg.cpp	/^	Program()$/;"	f	struct:Program	access:public	signature:()
Program::Program	test/output/tinyg/tinyg.cpp	/^	Program()$/;"	f	struct:Program	access:public	signature:()
Program::Program	test/output/tinyg/tinyg_bk.cpp	/^	Program()$/;"	f	struct:Program	access:public	signature:()
Program::sid	test/output/gen.cpp	/^	enum{ sid = 1009 };$/;"	e	enum:Program::__anon106	file:
Program::sid	test/output/tinyg.cpp	/^	enum{ sid = 0 };$/;"	e	enum:Program::__anon5	file:
Program::sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 0 };$/;"	e	enum:Program::__anon36	file:
Program::sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 0 };$/;"	e	enum:Program::__anon67	file:
Push	third_party/xml/Markup.cpp	/^	void Push( MCD_PCSZ pName, int n ) { ++iUsed; if (iUsed==nSize) Alloc(nSize*2); pL[iUsed].SetTagName(pName,n); pL[iUsed].iParent=iPar; iTop=iUsed; };$/;"	f	struct:ElemStack	access:public	signature:( MCD_PCSZ pName, int n )
PushIntoLevel	third_party/xml/Markup.cpp	/^	void PushIntoLevel( MCD_PCSZ pName, int n ) { ++iTop; if (iTop==nSize) Alloc(nSize*2); pL[iTop].SetTagName(pName,n); };$/;"	f	struct:ElemStack	access:public	signature:( MCD_PCSZ pName, int n )
PushTagAndCount	third_party/xml/Markup.cpp	/^	void PushTagAndCount( TokenPos& token );$/;"	p	struct:ElemStack	file:	access:public	signature:( TokenPos& token )
PushTagAndCount	third_party/xml/Markup.cpp	/^void ElemStack::PushTagAndCount( TokenPos& token )$/;"	f	class:ElemStack	signature:( TokenPos& token )
ReadTextFile	third_party/xml/Markup.cpp	/^bool CMarkup::ReadTextFile( MCD_CSTR_FILENAME szFileName, MCD_STR& strDoc, MCD_STR* pstrResult, int* pnDocFlags, MCD_STR* pstrEncoding )$/;"	f	class:CMarkup	signature:( MCD_CSTR_FILENAME szFileName, MCD_STR& strDoc, MCD_STR* pstrResult, int* pnDocFlags, MCD_STR* pstrEncoding )
ReadTextFile	third_party/xml/Markup.h	/^	static bool ReadTextFile( MCD_CSTR_FILENAME szFileName, MCD_STR& strDoc, MCD_STR* pstrResult=NULL, int* pnDocFlags=NULL, MCD_STR* pstrEncoding=NULL );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR_FILENAME szFileName, MCD_STR& strDoc, MCD_STR* pstrResult=NULL, int* pnDocFlags=NULL, MCD_STR* pstrEncoding=NULL )
Release	third_party/xml/Markup.cpp	/^	void Release() { for (int n=0;n<SegsUsed();++n) delete[] (char*)m_pSegs[n]; if (m_pSegs) delete[] (char*)m_pSegs; };$/;"	f	struct:ElemPosTree	access:public	signature:()
ReleaseElemPosTree	third_party/xml/Markup.cpp	/^	void ReleaseElemPosTree() { Release(); Clear(); };$/;"	f	struct:ElemPosTree	access:public	signature:()
ReleaseMaps	third_party/xml/Markup.cpp	/^	void ReleaseMaps() { SavedPosMap**p = m_pMaps; if (p) { while (*p) delete *p++; delete[] m_pMaps; m_pMaps=NULL; } };$/;"	f	struct:SavedPosMapArray	access:public	signature:()
RemoveChildElem	third_party/xml/Markup.cpp	/^bool CMarkup::RemoveChildElem()$/;"	f	class:CMarkup	signature:()
RemoveChildElem	third_party/xml/Markup.h	/^	bool RemoveChildElem();$/;"	p	class:CMarkup	access:public	signature:()
RemoveElem	third_party/xml/Markup.cpp	/^bool CMarkup::RemoveElem()$/;"	f	class:CMarkup	signature:()
RemoveElem	third_party/xml/Markup.h	/^	bool RemoveElem();$/;"	p	class:CMarkup	access:public	signature:()
RemoveNode	third_party/xml/Markup.cpp	/^bool CMarkup::RemoveNode()$/;"	f	class:CMarkup	signature:()
RemoveNode	third_party/xml/Markup.h	/^	bool RemoveNode();$/;"	p	class:CMarkup	access:public	signature:()
ResetChildPos	third_party/xml/Markup.h	/^	void ResetChildPos() { x_SetPos(m_iPosParent,m_iPos,0); };$/;"	f	class:CMarkup	access:public	signature:()
ResetMainPos	third_party/xml/Markup.h	/^	void ResetMainPos() { x_SetPos(m_iPosParent,0,0); };$/;"	f	class:CMarkup	access:public	signature:()
ResetPos	third_party/xml/Markup.h	/^	void ResetPos() { x_SetPos(0,0,0); };$/;"	f	class:CMarkup	access:public	signature:()
RestorePos	third_party/xml/Markup.cpp	/^bool CMarkup::RestorePos( MCD_CSTR szPosName \/*=""*\/, int nMap \/*=0*\/ )$/;"	f	class:CMarkup	signature:( MCD_CSTR szPosName , int nMap )
RestorePos	third_party/xml/Markup.h	/^	bool RestorePos( MCD_CSTR szPosName=MCD_T(""), int nMap = 0 );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR szPosName=MCD_T(Ó), int nMap = 0 )
ReturnExp	test/output/gen.cpp	/^	ReturnExp()$/;"	f	struct:ReturnExp	access:public	signature:()
ReturnExp	test/output/gen.cpp	/^struct ReturnExp : public type$/;"	s	file:	inherits:type
ReturnExp	test/output/tinyg.cpp	/^	ReturnExp()$/;"	f	struct:ReturnExp	access:public	signature:()
ReturnExp	test/output/tinyg.cpp	/^struct ReturnExp : public type$/;"	s	file:	inherits:type
ReturnExp	test/output/tinyg/tinyg.cpp	/^	ReturnExp()$/;"	f	struct:ReturnExp	access:public	signature:()
ReturnExp	test/output/tinyg/tinyg.cpp	/^struct ReturnExp : public type$/;"	s	file:	inherits:type
ReturnExp	test/output/tinyg/tinyg_bk.cpp	/^	ReturnExp()$/;"	f	struct:ReturnExp	access:public	signature:()
ReturnExp	test/output/tinyg/tinyg_bk.cpp	/^struct ReturnExp : public type$/;"	s	file:	inherits:type
ReturnExp::ReturnExp	test/output/gen.cpp	/^	ReturnExp()$/;"	f	struct:ReturnExp	access:public	signature:()
ReturnExp::ReturnExp	test/output/tinyg.cpp	/^	ReturnExp()$/;"	f	struct:ReturnExp	access:public	signature:()
ReturnExp::ReturnExp	test/output/tinyg/tinyg.cpp	/^	ReturnExp()$/;"	f	struct:ReturnExp	access:public	signature:()
ReturnExp::ReturnExp	test/output/tinyg/tinyg_bk.cpp	/^	ReturnExp()$/;"	f	struct:ReturnExp	access:public	signature:()
ReturnExp::sid	test/output/gen.cpp	/^	enum{ sid = 1010 };$/;"	e	enum:ReturnExp::__anon107	file:
ReturnExp::sid	test/output/tinyg.cpp	/^	enum{ sid = 15 };$/;"	e	enum:ReturnExp::__anon20	file:
ReturnExp::sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 15 };$/;"	e	enum:ReturnExp::__anon51	file:
ReturnExp::sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 15 };$/;"	e	enum:ReturnExp::__anon82	file:
RevertOffset	third_party/xml/Markup.cpp	/^	void RevertOffset() { i=iSave; };$/;"	f	struct:PathPos	access:public	signature:()
RevertOffsetAsName	third_party/xml/Markup.cpp	/^	void RevertOffsetAsName() { i=iSave; nPathType=1; };$/;"	f	struct:PathPos	access:public	signature:()
Row	include/arrayX.h	/^	const static size_t Row = _Row;$/;"	m	struct:SmartMatrix	access:public
RowVector	include/arrayX.h	/^	typedef pointer RowVector;$/;"	t	struct:SmartMatrix	access:public
Rs_	syntax/production.h	/^	right_array Rs_;$/;"	m	class:production	access:private
SEP	makecompiler/gensyntax.cpp	454;"	d	file:
SPM_CHILD	third_party/xml/Markup.cpp	/^	enum { SPM_MAIN = 1, SPM_CHILD = 2, SPM_USED = 4, SPM_LAST = 8 };$/;"	e	enum:SavedPos::__anon135	file:
SPM_LAST	third_party/xml/Markup.cpp	/^	enum { SPM_MAIN = 1, SPM_CHILD = 2, SPM_USED = 4, SPM_LAST = 8 };$/;"	e	enum:SavedPos::__anon135	file:
SPM_MAIN	third_party/xml/Markup.cpp	/^	enum { SPM_MAIN = 1, SPM_CHILD = 2, SPM_USED = 4, SPM_LAST = 8 };$/;"	e	enum:SavedPos::__anon135	file:
SPM_USED	third_party/xml/Markup.cpp	/^	enum { SPM_MAIN = 1, SPM_CHILD = 2, SPM_USED = 4, SPM_LAST = 8 };$/;"	e	enum:SavedPos::__anon135	file:
Save	third_party/xml/Markup.cpp	/^bool CMarkup::Save( MCD_CSTR_FILENAME szFileName )$/;"	f	class:CMarkup	signature:( MCD_CSTR_FILENAME szFileName )
Save	third_party/xml/Markup.h	/^	bool Save( MCD_CSTR_FILENAME szFileName );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR_FILENAME szFileName )
SaveOffset	third_party/xml/Markup.cpp	/^	void SaveOffset() { iSave=i; };$/;"	f	struct:PathPos	access:public	signature:()
SavePos	third_party/xml/Markup.cpp	/^bool CMarkup::SavePos( MCD_CSTR szPosName \/*=""*\/, int nMap \/*=0*\/ )$/;"	f	class:CMarkup	signature:( MCD_CSTR szPosName , int nMap )
SavePos	third_party/xml/Markup.h	/^	bool SavePos( MCD_CSTR szPosName=MCD_T(""), int nMap = 0 );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR szPosName=MCD_T(Ó), int nMap = 0 )
SavedPos	third_party/xml/Markup.cpp	/^	SavedPos() { nSavedPosFlags=0; iPos=0; };$/;"	f	struct:SavedPos	access:public	signature:()
SavedPos	third_party/xml/Markup.cpp	/^struct SavedPos$/;"	s	file:
SavedPos::SPM_CHILD	third_party/xml/Markup.cpp	/^	enum { SPM_MAIN = 1, SPM_CHILD = 2, SPM_USED = 4, SPM_LAST = 8 };$/;"	e	enum:SavedPos::__anon135	file:
SavedPos::SPM_LAST	third_party/xml/Markup.cpp	/^	enum { SPM_MAIN = 1, SPM_CHILD = 2, SPM_USED = 4, SPM_LAST = 8 };$/;"	e	enum:SavedPos::__anon135	file:
SavedPos::SPM_MAIN	third_party/xml/Markup.cpp	/^	enum { SPM_MAIN = 1, SPM_CHILD = 2, SPM_USED = 4, SPM_LAST = 8 };$/;"	e	enum:SavedPos::__anon135	file:
SavedPos::SPM_USED	third_party/xml/Markup.cpp	/^	enum { SPM_MAIN = 1, SPM_CHILD = 2, SPM_USED = 4, SPM_LAST = 8 };$/;"	e	enum:SavedPos::__anon135	file:
SavedPos::SavedPos	third_party/xml/Markup.cpp	/^	SavedPos() { nSavedPosFlags=0; iPos=0; };$/;"	f	struct:SavedPos	access:public	signature:()
SavedPos::iPos	third_party/xml/Markup.cpp	/^	int iPos;$/;"	m	struct:SavedPos	file:	access:public
SavedPos::nSavedPosFlags	third_party/xml/Markup.cpp	/^	int nSavedPosFlags;$/;"	m	struct:SavedPos	file:	access:public
SavedPos::strName	third_party/xml/Markup.cpp	/^	MCD_STR strName;$/;"	m	struct:SavedPos	file:	access:public
SavedPosMap	third_party/xml/Markup.cpp	/^	SavedPosMap( int nSize ) { nMapSize=nSize; pTable = new SavedPos*[nSize]; memset(pTable,0,nSize*sizeof(SavedPos*)); };$/;"	f	struct:SavedPosMap	access:public	signature:( int nSize )
SavedPosMap	third_party/xml/Markup.cpp	/^struct SavedPosMap$/;"	s	file:
SavedPosMap::SavedPosMap	third_party/xml/Markup.cpp	/^	SavedPosMap( int nSize ) { nMapSize=nSize; pTable = new SavedPos*[nSize]; memset(pTable,0,nSize*sizeof(SavedPos*)); };$/;"	f	struct:SavedPosMap	access:public	signature:( int nSize )
SavedPosMap::nMapSize	third_party/xml/Markup.cpp	/^	int nMapSize;$/;"	m	struct:SavedPosMap	file:	access:public
SavedPosMap::pTable	third_party/xml/Markup.cpp	/^	SavedPos** pTable;$/;"	m	struct:SavedPosMap	file:	access:public
SavedPosMap::~SavedPosMap	third_party/xml/Markup.cpp	/^	~SavedPosMap() { if (pTable) { for (int n=0;n<nMapSize;++n) if (pTable[n]) delete[] pTable[n]; delete[] pTable; } };$/;"	f	struct:SavedPosMap	access:public	signature:()
SavedPosMapArray	third_party/xml/Markup.cpp	/^	SavedPosMapArray() { m_pMaps = NULL; };$/;"	f	struct:SavedPosMapArray	access:public	signature:()
SavedPosMapArray	third_party/xml/Markup.cpp	/^struct SavedPosMapArray$/;"	s	file:
SavedPosMapArray::CopySavedPosMaps	third_party/xml/Markup.cpp	/^	void CopySavedPosMaps( SavedPosMapArray* pOtherMaps );$/;"	p	struct:SavedPosMapArray	file:	access:public	signature:( SavedPosMapArray* pOtherMaps )
SavedPosMapArray::CopySavedPosMaps	third_party/xml/Markup.cpp	/^void SavedPosMapArray::CopySavedPosMaps( SavedPosMapArray* pOtherMaps )$/;"	f	class:SavedPosMapArray	signature:( SavedPosMapArray* pOtherMaps )
SavedPosMapArray::GetMap	third_party/xml/Markup.cpp	/^	bool GetMap( SavedPosMap*& pMap, int nMap, int nMapSize = 7 );$/;"	p	struct:SavedPosMapArray	file:	access:public	signature:( SavedPosMap*& pMap, int nMap, int nMapSize = 7 )
SavedPosMapArray::GetMap	third_party/xml/Markup.cpp	/^bool SavedPosMapArray::GetMap( SavedPosMap*& pMap, int nMap, int nMapSize \/*=7*\/ )$/;"	f	class:SavedPosMapArray	signature:( SavedPosMap*& pMap, int nMap, int nMapSize )
SavedPosMapArray::ReleaseMaps	third_party/xml/Markup.cpp	/^	void ReleaseMaps() { SavedPosMap**p = m_pMaps; if (p) { while (*p) delete *p++; delete[] m_pMaps; m_pMaps=NULL; } };$/;"	f	struct:SavedPosMapArray	access:public	signature:()
SavedPosMapArray::SavedPosMapArray	third_party/xml/Markup.cpp	/^	SavedPosMapArray() { m_pMaps = NULL; };$/;"	f	struct:SavedPosMapArray	access:public	signature:()
SavedPosMapArray::m_pMaps	third_party/xml/Markup.cpp	/^	SavedPosMap** m_pMaps; \/\/ NULL terminated array$/;"	m	struct:SavedPosMapArray	file:	access:public
SavedPosMapArray::~SavedPosMapArray	third_party/xml/Markup.cpp	/^	~SavedPosMapArray() { ReleaseMaps(); };$/;"	f	struct:SavedPosMapArray	access:public	signature:()
SegsUsed	third_party/xml/Markup.cpp	/^	int SegsUsed() const { return ((m_nSize-1)>>PA_SEGBITS) + 1; };$/;"	f	struct:ElemPosTree	access:public	signature:() const
SetAttrib	third_party/xml/Markup.h	/^	bool SetAttrib( MCD_CSTR szAttrib, MCD_CSTR szValue, int nFlags=0 ) { return x_SetAttrib(m_iPos,szAttrib,szValue,nFlags); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib, MCD_CSTR szValue, int nFlags=0 )
SetAttrib	third_party/xml/Markup.h	/^	bool SetAttrib( MCD_CSTR szAttrib, int nValue, int nFlags=0 ) { return x_SetAttrib(m_iPos,szAttrib,nValue,nFlags); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib, int nValue, int nFlags=0 )
SetChildAttrib	third_party/xml/Markup.h	/^	bool SetChildAttrib( MCD_CSTR szAttrib, MCD_CSTR szValue, int nFlags=0 ) { return x_SetAttrib(m_iPosChild,szAttrib,szValue,nFlags); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib, MCD_CSTR szValue, int nFlags=0 )
SetChildAttrib	third_party/xml/Markup.h	/^	bool SetChildAttrib( MCD_CSTR szAttrib, int nValue, int nFlags=0 ) { return x_SetAttrib(m_iPosChild,szAttrib,nValue,nFlags); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib, int nValue, int nFlags=0 )
SetChildData	third_party/xml/Markup.h	/^	bool SetChildData( MCD_CSTR szData, int nFlags=0 ) { return x_SetData(m_iPosChild,szData,nFlags); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szData, int nFlags=0 )
SetChildData	third_party/xml/Markup.h	/^	bool SetChildData( int nValue ) { return x_SetData(m_iPosChild,nValue); };$/;"	f	class:CMarkup	access:public	signature:( int nValue )
SetData	third_party/xml/Markup.h	/^	bool SetData( MCD_CSTR szData, int nFlags=0 ) { return x_SetData(m_iPos,szData,nFlags); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szData, int nFlags=0 )
SetData	third_party/xml/Markup.h	/^	bool SetData( int nValue ) { return x_SetData(m_iPos,nValue); };$/;"	f	class:CMarkup	access:public	signature:( int nValue )
SetDoc	third_party/xml/Markup.cpp	/^bool CMarkup::SetDoc( MCD_PCSZ pDoc )$/;"	f	class:CMarkup	signature:( MCD_PCSZ pDoc )
SetDoc	third_party/xml/Markup.cpp	/^bool CMarkup::SetDoc( const MCD_STR& strDoc )$/;"	f	class:CMarkup	signature:( const MCD_STR& strDoc )
SetDoc	third_party/xml/Markup.h	/^	bool SetDoc( MCD_PCSZ pDoc );$/;"	p	class:CMarkup	access:public	signature:( MCD_PCSZ pDoc )
SetDoc	third_party/xml/Markup.h	/^	bool SetDoc( const MCD_STR& strDoc );$/;"	p	class:CMarkup	access:public	signature:( const MCD_STR& strDoc )
SetDocFlags	third_party/xml/Markup.h	/^	void SetDocFlags( int nFlags ) { m_nDocFlags = (nFlags & ~(MDF_READFILE|MDF_WRITEFILE|MDF_APPENDFILE)); };$/;"	f	class:CMarkup	access:public	signature:( int nFlags )
SetElemContent	third_party/xml/Markup.h	/^	bool SetElemContent( MCD_CSTR szContent ) { return x_SetElemContent(szContent); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szContent )
SetEndTagLen	third_party/xml/Markup.cpp	/^	void SetEndTagLen( int n ) { nEndTagLen = n; };$/;"	f	struct:ElemPos	access:public	signature:( int n )
SetEndTagLenUnparsed	third_party/xml/Markup.cpp	/^	void SetEndTagLenUnparsed() { SetEndTagLen(1); };$/;"	f	struct:ElemPos	access:public	signature:()
SetLevel	third_party/xml/Markup.cpp	/^    void SetLevel( int nLev ) { nFlags = (nFlags & ~0xffff) | nLev; };$/;"	f	struct:ElemPos	access:public	signature:( int nLev )
SetMapSize	third_party/xml/Markup.cpp	/^bool CMarkup::SetMapSize( int nSize, int nMap \/*=0*\/ )$/;"	f	class:CMarkup	signature:( int nSize, int nMap )
SetMapSize	third_party/xml/Markup.h	/^	bool SetMapSize( int nSize, int nMap = 0 );$/;"	p	class:CMarkup	access:public	signature:( int nSize, int nMap = 0 )
SetStartTagLen	third_party/xml/Markup.cpp	/^	void SetStartTagLen( int n ) { nStartTagLen = n; };$/;"	f	struct:ElemPos	access:public	signature:( int n )
SetTagName	third_party/xml/Markup.cpp	/^	void SetTagName( MCD_PCSZ pName, int n ) { MCD_STRASSIGN(strTagName,pName,n); };$/;"	f	struct:TagPos	access:public	signature:( MCD_PCSZ pName, int n )
Slot	third_party/xml/Markup.cpp	/^	void Slot( int n ) { pL[iUsed].nSlot=n; int i=anTable[n]; anTable[n]=iUsed; pL[iUsed].iSlotNext=i; if (i) pL[i].iSlotPrev=iUsed; };$/;"	f	struct:ElemStack	access:public	signature:( int n )
SmartArray	include/arrayX.h	/^	SmartArray() {}$/;"	f	struct:SmartArray	access:public	signature:()
SmartArray	include/arrayX.h	/^	SmartArray(_Iter _First, _Iter _Last)$/;"	f	struct:SmartArray	access:public	signature:(_Iter _First, _Iter _Last)
SmartArray	include/arrayX.h	/^	explicit SmartArray(const_reference val)$/;"	f	struct:SmartArray	access:public	signature:(const_reference val)
SmartArray	include/arrayX.h	/^struct SmartArray$/;"	s
SmartArray::Length	include/arrayX.h	/^	const static size_t Length = _Length;$/;"	m	struct:SmartArray	access:public
SmartArray::SmartArray	include/arrayX.h	/^	SmartArray() {}$/;"	f	struct:SmartArray	access:public	signature:()
SmartArray::SmartArray	include/arrayX.h	/^	SmartArray(_Iter _First, _Iter _Last)$/;"	f	struct:SmartArray	access:public	signature:(_Iter _First, _Iter _Last)
SmartArray::SmartArray	include/arrayX.h	/^	explicit SmartArray(const_reference val)$/;"	f	struct:SmartArray	access:public	signature:(const_reference val)
SmartArray::_Myt	include/arrayX.h	/^	typedef SmartArray<_Ty, _Length> _Myt;$/;"	t	struct:SmartArray	access:public
SmartArray::_buf	include/arrayX.h	/^	_Ty _buf[_Length];$/;"	m	struct:SmartArray	access:private
SmartArray::at	include/arrayX.h	/^	const_reference at(size_type idx) const$/;"	f	struct:SmartArray	access:public	signature:(size_type idx) const
SmartArray::at	include/arrayX.h	/^	reference at(size_type idx)$/;"	f	struct:SmartArray	access:public	signature:(size_type idx)
SmartArray::attach	include/arrayX.h	/^	static SmartArray<const value_type, _Length>* attach(const value_type anArray[_Length])$/;"	f	struct:SmartArray	access:public	signature:(const value_type anArray[_Length])
SmartArray::attach	include/arrayX.h	/^	static _Myt* attach(value_type anArray[_Length])$/;"	f	struct:SmartArray	access:public	signature:(value_type anArray[_Length])
SmartArray::back	include/arrayX.h	/^	const_reference back() const { return _buf[_Length - 1]; }$/;"	f	struct:SmartArray	access:public	signature:() const
SmartArray::back	include/arrayX.h	/^	reference back() { return _buf[_Length - 1]; }$/;"	f	struct:SmartArray	access:public	signature:()
SmartArray::begin	include/arrayX.h	/^	const_iterator begin() const { return const_iterator(_buf, _Length); }$/;"	f	struct:SmartArray	access:public	signature:() const
SmartArray::begin	include/arrayX.h	/^	iterator begin() { return iterator(_buf, _Length); }$/;"	f	struct:SmartArray	access:public	signature:()
SmartArray::const_iterator	include/arrayX.h	/^	typedef array_iterator<const value_type> const_iterator;$/;"	t	struct:SmartArray	access:public
SmartArray::const_pointer	include/arrayX.h	/^	typedef const _Ty* const_pointer;$/;"	t	struct:SmartArray	access:public
SmartArray::const_reference	include/arrayX.h	/^	typedef const value_type& const_reference;$/;"	t	struct:SmartArray	access:public
SmartArray::const_reverse_iterator	include/arrayX.h	/^	typedef std::reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	struct:SmartArray	access:public
SmartArray::end	include/arrayX.h	/^	const_iterator end() const { return const_iterator(_buf + _Length, _Length, 0); }$/;"	f	struct:SmartArray	access:public	signature:() const
SmartArray::end	include/arrayX.h	/^	iterator end() { return iterator(_buf + _Length, _Length, 0); }$/;"	f	struct:SmartArray	access:public	signature:()
SmartArray::front	include/arrayX.h	/^	const_reference front() const { return _buf[0]; }$/;"	f	struct:SmartArray	access:public	signature:() const
SmartArray::front	include/arrayX.h	/^	reference front() { return _buf[0]; }$/;"	f	struct:SmartArray	access:public	signature:()
SmartArray::iterator	include/arrayX.h	/^	typedef array_iterator<value_type> iterator;$/;"	t	struct:SmartArray	access:public
SmartArray::operator =	include/arrayX.h	/^	_Myt& operator=(const _Ty& val)$/;"	f	struct:SmartArray	access:public	signature:(const _Ty& val)
SmartArray::operator []	include/arrayX.h	/^	const_reference operator[](size_type idx) const { return _buf[idx]; }$/;"	f	struct:SmartArray	access:public	signature:(size_type idx) const
SmartArray::operator []	include/arrayX.h	/^	reference operator[](size_type idx) { return _buf[idx]; }$/;"	f	struct:SmartArray	access:public	signature:(size_type idx)
SmartArray::pointer	include/arrayX.h	/^	typedef _Ty* pointer;$/;"	t	struct:SmartArray	access:public
SmartArray::ptr	include/arrayX.h	/^	const_pointer ptr() const { return _buf; }$/;"	f	struct:SmartArray	access:public	signature:() const
SmartArray::ptr	include/arrayX.h	/^	pointer ptr() { return _buf; }$/;"	f	struct:SmartArray	access:public	signature:()
SmartArray::rbegin	include/arrayX.h	/^	const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); }$/;"	f	struct:SmartArray	access:public	signature:() const
SmartArray::rbegin	include/arrayX.h	/^	reverse_iterator rbegin() { return reverse_iterator(end()); }$/;"	f	struct:SmartArray	access:public	signature:()
SmartArray::reference	include/arrayX.h	/^	typedef value_type& reference;$/;"	t	struct:SmartArray	access:public
SmartArray::rend	include/arrayX.h	/^	const_reverse_iterator rend() const { return const_reverse_iterator(begin()); }$/;"	f	struct:SmartArray	access:public	signature:() const
SmartArray::rend	include/arrayX.h	/^	reverse_iterator rend() { return reverse_iterator(begin()); }$/;"	f	struct:SmartArray	access:public	signature:()
SmartArray::reverse_iterator	include/arrayX.h	/^	typedef std::reverse_iterator<iterator> reverse_iterator;$/;"	t	struct:SmartArray	access:public
SmartArray::size	include/arrayX.h	/^	size_t size() const {return _Length;}$/;"	f	struct:SmartArray	access:public	signature:() const
SmartArray::size_type	include/arrayX.h	/^	typedef std::size_t size_type;$/;"	t	struct:SmartArray	access:public
SmartArray::value_type	include/arrayX.h	/^	typedef typename mpl::remove_const<_Ty>::type value_type;$/;"	t	struct:SmartArray	access:public
SmartMatrix	include/arrayX.h	/^	SmartMatrix()$/;"	f	struct:SmartMatrix	access:public	signature:()
SmartMatrix	include/arrayX.h	/^	SmartMatrix(_IterIn _First, _IterIn _Last)$/;"	f	struct:SmartMatrix	access:public	signature:(_IterIn _First, _IterIn _Last)
SmartMatrix	include/arrayX.h	/^	SmartMatrix(const _Ty& val)$/;"	f	struct:SmartMatrix	access:public	signature:(const _Ty& val)
SmartMatrix	include/arrayX.h	/^struct SmartMatrix$/;"	s
SmartMatrix::Column	include/arrayX.h	/^	const static size_t Column = _Col;$/;"	m	struct:SmartMatrix	access:public
SmartMatrix::ConstRowVector	include/arrayX.h	/^	typedef const_pointer ConstRowVector;$/;"	t	struct:SmartMatrix	access:public
SmartMatrix::Length	include/arrayX.h	/^	const static size_t Length = _Row * _Col;$/;"	m	struct:SmartMatrix	access:public
SmartMatrix::Row	include/arrayX.h	/^	const static size_t Row = _Row;$/;"	m	struct:SmartMatrix	access:public
SmartMatrix::RowVector	include/arrayX.h	/^	typedef pointer RowVector;$/;"	t	struct:SmartMatrix	access:public
SmartMatrix::SmartMatrix	include/arrayX.h	/^	SmartMatrix()$/;"	f	struct:SmartMatrix	access:public	signature:()
SmartMatrix::SmartMatrix	include/arrayX.h	/^	SmartMatrix(_IterIn _First, _IterIn _Last)$/;"	f	struct:SmartMatrix	access:public	signature:(_IterIn _First, _IterIn _Last)
SmartMatrix::SmartMatrix	include/arrayX.h	/^	SmartMatrix(const _Ty& val)$/;"	f	struct:SmartMatrix	access:public	signature:(const _Ty& val)
SmartMatrix::_Myt	include/arrayX.h	/^	typedef SmartMatrix<_Ty, _Row, _Col> _Myt;$/;"	t	struct:SmartMatrix	access:public
SmartMatrix::_values	include/arrayX.h	/^	_Ty _values[_Row][_Col];$/;"	m	struct:SmartMatrix	access:private
SmartMatrix::begin	include/arrayX.h	/^	const_iterator begin() const { return const_iterator(_values[0], Length); }$/;"	f	struct:SmartMatrix	access:public	signature:() const
SmartMatrix::begin	include/arrayX.h	/^	iterator begin() { return iterator(_values[0], Length); }$/;"	f	struct:SmartMatrix	access:public	signature:()
SmartMatrix::col	include/arrayX.h	/^	size_t col() const { return _Col; }$/;"	f	struct:SmartMatrix	access:public	signature:() const
SmartMatrix::const_iterator	include/arrayX.h	/^	typedef array_iterator<const value_type> const_iterator;$/;"	t	struct:SmartMatrix	access:public
SmartMatrix::const_pointer	include/arrayX.h	/^	typedef const _Ty* const_pointer;$/;"	t	struct:SmartMatrix	access:public
SmartMatrix::const_reference	include/arrayX.h	/^	typedef const value_type& const_reference;$/;"	t	struct:SmartMatrix	access:public
SmartMatrix::const_reverse_iterator	include/arrayX.h	/^	typedef std::reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	struct:SmartMatrix	access:public
SmartMatrix::end	include/arrayX.h	/^	const_iterator end() const { return const_iterator(_values[0] + Length, Length, 0); }$/;"	f	struct:SmartMatrix	access:public	signature:() const
SmartMatrix::end	include/arrayX.h	/^	iterator end() { return iterator(_values[0] + Length, Length, 0); }$/;"	f	struct:SmartMatrix	access:public	signature:()
SmartMatrix::iterator	include/arrayX.h	/^	typedef array_iterator<value_type> iterator;$/;"	t	struct:SmartMatrix	access:public
SmartMatrix::operator ()	include/arrayX.h	/^	const_reference operator()(size_type r, size_type c) const { return _values[r][c]; }$/;"	f	struct:SmartMatrix	access:public	signature:(size_type r, size_type c) const
SmartMatrix::operator ()	include/arrayX.h	/^	reference operator()(size_type r, size_type c) { return _values[r][c]; }$/;"	f	struct:SmartMatrix	access:public	signature:(size_type r, size_type c)
SmartMatrix::operator []	include/arrayX.h	/^	ConstRowVector operator[](size_type idx) const{return _values[idx];}$/;"	f	struct:SmartMatrix	access:public	signature:(size_type idx) const
SmartMatrix::operator []	include/arrayX.h	/^	RowVector operator[](size_type idx) {return _values[idx];}$/;"	f	struct:SmartMatrix	access:public	signature:(size_type idx)
SmartMatrix::pointer	include/arrayX.h	/^	typedef _Ty* pointer;$/;"	t	struct:SmartMatrix	access:public
SmartMatrix::ptr	include/arrayX.h	/^	_Ty* ptr() { return _values[0]; }$/;"	f	struct:SmartMatrix	access:public	signature:()
SmartMatrix::ptr	include/arrayX.h	/^	const _Ty* ptr() const { return _values[0]; }$/;"	f	struct:SmartMatrix	access:public	signature:() const
SmartMatrix::reference	include/arrayX.h	/^	typedef value_type& reference;$/;"	t	struct:SmartMatrix	access:public
SmartMatrix::reverse_iterator	include/arrayX.h	/^	typedef std::reverse_iterator<iterator> reverse_iterator;$/;"	t	struct:SmartMatrix	access:public
SmartMatrix::row	include/arrayX.h	/^	size_t row() const { return _Row; }$/;"	f	struct:SmartMatrix	access:public	signature:() const
SmartMatrix::size	include/arrayX.h	/^	size_t size() const {return Length; }$/;"	f	struct:SmartMatrix	access:public	signature:() const
SmartMatrix::size_type	include/arrayX.h	/^	typedef std::size_t size_type;$/;"	t	struct:SmartMatrix	access:public
SmartMatrix::value_type	include/arrayX.h	/^	typedef typename mpl::remove_const<_Ty>::type value_type;$/;"	t	struct:SmartMatrix	access:public
StartAfter	third_party/xml/Markup.cpp	/^	int StartAfter() const { return nStart + nLength; };$/;"	f	struct:ElemPos	access:public	signature:() const
StartContent	third_party/xml/Markup.cpp	/^	int StartContent() const { return nStart + StartTagLen(); };$/;"	f	struct:ElemPos	access:public	signature:() const
StartTagLen	third_party/xml/Markup.cpp	/^	int StartTagLen() const { return nStartTagLen; };$/;"	f	struct:ElemPos	access:public	signature:() const
StrNIACmp	third_party/xml/Markup.cpp	/^	static int StrNIACmp( MCD_PCSZ p1, MCD_PCSZ p2, int n )$/;"	f	struct:TokenPos	access:public	signature:( MCD_PCSZ p1, MCD_PCSZ p2, int n )
THIS_FILE	third_party/xml/Markup.cpp	/^static char THIS_FILE[]=__FILE__;$/;"	v	file:
THIS_FILE	third_party/xml/Markup.cpp	35;"	d	file:
TRIPLE	makecompiler/gensyntax.cpp	453;"	d	file:
TagPos	third_party/xml/Markup.cpp	/^	TagPos() { Init(); };$/;"	f	struct:TagPos	access:public	signature:()
TagPos	third_party/xml/Markup.cpp	/^struct TagPos$/;"	s	file:
TagPos::IncCount	third_party/xml/Markup.cpp	/^	void IncCount() { if (nCount) ++nCount; };$/;"	f	struct:TagPos	access:public	signature:()
TagPos::Init	third_party/xml/Markup.cpp	/^	void Init( int i=0, int n=1 ) { nCount=1; nTagNames=n; iNext=i; iPrev=0; nSlot=-1; iSlotPrev=0; iSlotNext=0; };$/;"	f	struct:TagPos	access:public	signature:( int i=0, int n=1 )
TagPos::SetTagName	third_party/xml/Markup.cpp	/^	void SetTagName( MCD_PCSZ pName, int n ) { MCD_STRASSIGN(strTagName,pName,n); };$/;"	f	struct:TagPos	access:public	signature:( MCD_PCSZ pName, int n )
TagPos::TagPos	third_party/xml/Markup.cpp	/^	TagPos() { Init(); };$/;"	f	struct:TagPos	access:public	signature:()
TagPos::iNext	third_party/xml/Markup.cpp	/^	int iNext;$/;"	m	struct:TagPos	file:	access:public
TagPos::iParent	third_party/xml/Markup.cpp	/^	int iParent;$/;"	m	struct:TagPos	file:	access:public
TagPos::iPrev	third_party/xml/Markup.cpp	/^	int iPrev;$/;"	m	struct:TagPos	file:	access:public
TagPos::iSlotNext	third_party/xml/Markup.cpp	/^	int iSlotNext;$/;"	m	struct:TagPos	file:	access:public
TagPos::iSlotPrev	third_party/xml/Markup.cpp	/^	int iSlotPrev;$/;"	m	struct:TagPos	file:	access:public
TagPos::nCount	third_party/xml/Markup.cpp	/^	int nCount;$/;"	m	struct:TagPos	file:	access:public
TagPos::nSlot	third_party/xml/Markup.cpp	/^	int nSlot;$/;"	m	struct:TagPos	file:	access:public
TagPos::nTagNames	third_party/xml/Markup.cpp	/^	int nTagNames;$/;"	m	struct:TagPos	file:	access:public
TagPos::strTagName	third_party/xml/Markup.cpp	/^	MCD_STR strTagName;$/;"	m	struct:TagPos	file:	access:public
TextEncoding	third_party/xml/Markup.cpp	/^	TextEncoding( MCD_CSTR pszFromEncoding, const void* pFromBuffer, int nFromBufferLen )$/;"	f	struct:TextEncoding	access:public	signature:( MCD_CSTR pszFromEncoding, const void* pFromBuffer, int nFromBufferLen )
TextEncoding	third_party/xml/Markup.cpp	/^struct TextEncoding$/;"	s	file:
TextEncoding::CanConvert	third_party/xml/Markup.cpp	/^	static bool CanConvert( MCD_CSTR pszToEncoding, MCD_CSTR pszFromEncoding );$/;"	p	struct:TextEncoding	file:	access:public	signature:( MCD_CSTR pszToEncoding, MCD_CSTR pszFromEncoding )
TextEncoding::CanConvert	third_party/xml/Markup.cpp	/^bool TextEncoding::CanConvert( MCD_CSTR pszToEncoding, MCD_CSTR pszFromEncoding )$/;"	f	class:TextEncoding	signature:( MCD_CSTR pszToEncoding, MCD_CSTR pszFromEncoding )
TextEncoding::FindRaggedEnd	third_party/xml/Markup.cpp	/^	bool FindRaggedEnd( int& nTruncBeforeBytes );$/;"	p	struct:TextEncoding	file:	access:public	signature:( int& nTruncBeforeBytes )
TextEncoding::FindRaggedEnd	third_party/xml/Markup.cpp	/^bool TextEncoding::FindRaggedEnd( int& nTruncBeforeBytes )$/;"	f	class:TextEncoding	signature:( int& nTruncBeforeBytes )
TextEncoding::IConv	third_party/xml/Markup.cpp	/^	int IConv( void* pTo, int nToCharSize, int nFromCharSize );$/;"	p	struct:TextEncoding	file:	access:public	signature:( void* pTo, int nToCharSize, int nFromCharSize )
TextEncoding::IConv	third_party/xml/Markup.cpp	/^int TextEncoding::IConv( void* pTo, int nToCharSize, int nFromCharSize )$/;"	f	class:TextEncoding	signature:( void* pTo, int nToCharSize, int nFromCharSize )
TextEncoding::IConvName	third_party/xml/Markup.cpp	/^	static const char* IConvName( char* szEncoding, MCD_CSTR pszEncoding );$/;"	p	struct:TextEncoding	file:	access:public	signature:( char* szEncoding, MCD_CSTR pszEncoding )
TextEncoding::IConvName	third_party/xml/Markup.cpp	/^const char* TextEncoding::IConvName( char* szEncoding, MCD_CSTR pszEncoding )$/;"	f	class:TextEncoding	signature:( char* szEncoding, MCD_CSTR pszEncoding )
TextEncoding::PerformConversion	third_party/xml/Markup.cpp	/^	int PerformConversion( void* pTo, MCD_CSTR pszToEncoding = NULL );$/;"	p	struct:TextEncoding	file:	access:public	signature:( void* pTo, MCD_CSTR pszToEncoding = NULL )
TextEncoding::PerformConversion	third_party/xml/Markup.cpp	/^int TextEncoding::PerformConversion( void* pTo, MCD_CSTR pszToEncoding\/*=NULL*\/ )$/;"	f	class:TextEncoding	signature:( void* pTo, MCD_CSTR pszToEncoding )
TextEncoding::TextEncoding	third_party/xml/Markup.cpp	/^	TextEncoding( MCD_CSTR pszFromEncoding, const void* pFromBuffer, int nFromBufferLen )$/;"	f	struct:TextEncoding	access:public	signature:( MCD_CSTR pszFromEncoding, const void* pFromBuffer, int nFromBufferLen )
TextEncoding::m_nFailedChars	third_party/xml/Markup.cpp	/^	int m_nFailedChars;$/;"	m	struct:TextEncoding	file:	access:public
TextEncoding::m_nFromLen	third_party/xml/Markup.cpp	/^	int m_nFromLen;$/;"	m	struct:TextEncoding	file:	access:public
TextEncoding::m_nToCount	third_party/xml/Markup.cpp	/^	int m_nToCount;$/;"	m	struct:TextEncoding	file:	access:public
TextEncoding::m_pFrom	third_party/xml/Markup.cpp	/^	const void* m_pFrom;$/;"	m	struct:TextEncoding	file:	access:public
TextEncoding::m_strFromEncoding	third_party/xml/Markup.cpp	/^	MCD_STR m_strFromEncoding;$/;"	m	struct:TextEncoding	file:	access:public
TextEncoding::m_strToEncoding	third_party/xml/Markup.cpp	/^	MCD_STR m_strToEncoding;$/;"	m	struct:TextEncoding	file:	access:public
TokenPos	third_party/xml/Markup.cpp	/^	TokenPos( MCD_CSTR sz, int n, FilePos* p=NULL ) { Clear(); m_pDocText=sz; m_nTokenFlags=n; m_pReaderFilePos=p; };$/;"	f	struct:TokenPos	access:public	signature:( MCD_CSTR sz, int n, FilePos* p=NULL )
TokenPos	third_party/xml/Markup.cpp	/^struct TokenPos$/;"	s	file:
TokenPos::Clear	third_party/xml/Markup.cpp	/^	void Clear() { m_nL=0; m_nR=-1; m_nNext=0; };$/;"	f	struct:TokenPos	access:public	signature:()
TokenPos::FindAny	third_party/xml/Markup.cpp	/^	bool FindAny()$/;"	f	struct:TokenPos	access:public	signature:()
TokenPos::FindAttrib	third_party/xml/Markup.cpp	/^	bool FindAttrib( MCD_PCSZ pAttrib, int n = 0 );$/;"	p	struct:TokenPos	file:	access:public	signature:( MCD_PCSZ pAttrib, int n = 0 )
TokenPos::FindAttrib	third_party/xml/Markup.cpp	/^bool TokenPos::FindAttrib( MCD_PCSZ pAttrib, int n\/*=0*\/ )$/;"	f	class:TokenPos	signature:( MCD_PCSZ pAttrib, int n )
TokenPos::FindName	third_party/xml/Markup.cpp	/^	bool FindName()$/;"	f	struct:TokenPos	access:public	signature:()
TokenPos::ForwardUntil	third_party/xml/Markup.cpp	/^	void ForwardUntil( MCD_PCSZ szStopChars ) { while ( m_pDocText[m_nNext] && ! MCD_PSZCHR(szStopChars,m_pDocText[m_nNext]) ) m_nNext += MCD_CLEN(&m_pDocText[m_nNext]); }$/;"	f	struct:TokenPos	access:public	signature:( MCD_PCSZ szStopChars )
TokenPos::GetTokenPtr	third_party/xml/Markup.cpp	/^	MCD_PCSZ GetTokenPtr() const { return &m_pDocText[m_nL]; };$/;"	f	struct:TokenPos	access:public	signature:() const
TokenPos::GetTokenText	third_party/xml/Markup.cpp	/^	MCD_STR GetTokenText() const { return MCD_STR( GetTokenPtr(), Length() ); };$/;"	f	struct:TokenPos	access:public	signature:() const
TokenPos::Length	third_party/xml/Markup.cpp	/^	int Length() const { return m_nR - m_nL + 1; };$/;"	f	struct:TokenPos	access:public	signature:() const
TokenPos::Match	third_party/xml/Markup.cpp	/^	bool Match( MCD_CSTR szName )$/;"	f	struct:TokenPos	access:public	signature:( MCD_CSTR szName )
TokenPos::ParseNode	third_party/xml/Markup.cpp	/^	int ParseNode( NodePos& node );$/;"	p	struct:TokenPos	file:	access:public	signature:( NodePos& node )
TokenPos::ParseNode	third_party/xml/Markup.cpp	/^int TokenPos::ParseNode( NodePos& node )$/;"	f	class:TokenPos	signature:( NodePos& node )
TokenPos::StrNIACmp	third_party/xml/Markup.cpp	/^	static int StrNIACmp( MCD_PCSZ p1, MCD_PCSZ p2, int n )$/;"	f	struct:TokenPos	access:public	signature:( MCD_PCSZ p1, MCD_PCSZ p2, int n )
TokenPos::TokenPos	third_party/xml/Markup.cpp	/^	TokenPos( MCD_CSTR sz, int n, FilePos* p=NULL ) { Clear(); m_pDocText=sz; m_nTokenFlags=n; m_pReaderFilePos=p; };$/;"	f	struct:TokenPos	access:public	signature:( MCD_CSTR sz, int n, FilePos* p=NULL )
TokenPos::WhitespaceToTag	third_party/xml/Markup.cpp	/^	int WhitespaceToTag( int n ) { m_nNext = n; if (FindAny()&&m_pDocText[m_nNext]!='<') { m_nNext=n; m_nR=n-1; } return m_nNext; };$/;"	f	struct:TokenPos	access:public	signature:( int n )
TokenPos::m_nL	third_party/xml/Markup.cpp	/^	int m_nL;$/;"	m	struct:TokenPos	file:	access:public
TokenPos::m_nNext	third_party/xml/Markup.cpp	/^	int m_nNext;$/;"	m	struct:TokenPos	file:	access:public
TokenPos::m_nPreSpaceLength	third_party/xml/Markup.cpp	/^	int m_nPreSpaceLength;$/;"	m	struct:TokenPos	file:	access:public
TokenPos::m_nPreSpaceStart	third_party/xml/Markup.cpp	/^	int m_nPreSpaceStart;$/;"	m	struct:TokenPos	file:	access:public
TokenPos::m_nR	third_party/xml/Markup.cpp	/^	int m_nR;$/;"	m	struct:TokenPos	file:	access:public
TokenPos::m_nTokenFlags	third_party/xml/Markup.cpp	/^	int m_nTokenFlags;$/;"	m	struct:TokenPos	file:	access:public
TokenPos::m_pDocText	third_party/xml/Markup.cpp	/^	MCD_PCSZ m_pDocText;$/;"	m	struct:TokenPos	file:	access:public
TokenPos::m_pReaderFilePos	third_party/xml/Markup.cpp	/^	FilePos* m_pReaderFilePos;$/;"	m	struct:TokenPos	file:	access:public
TriSate	include/functionalX.h	/^enum TriSate$/;"	g
UTF16To8	third_party/xml/Markup.cpp	/^int CMarkup::UTF16To8( char* pszUTF8, const unsigned short* pwszUTF16, int nUTF8Count )$/;"	f	class:CMarkup	signature:( char* pszUTF8, const unsigned short* pwszUTF16, int nUTF8Count )
UTF16To8	third_party/xml/Markup.h	/^	static int UTF16To8( char *pszUTF8, const unsigned short* pwszUTF16, int nUTF8Count );$/;"	p	class:CMarkup	access:public	signature:( char *pszUTF8, const unsigned short* pwszUTF16, int nUTF8Count )
UTF8To16	third_party/xml/Markup.cpp	/^int CMarkup::UTF8To16( unsigned short* pwszUTF16, const char* pszUTF8, int nUTF8Count )$/;"	f	class:CMarkup	signature:( unsigned short* pwszUTF16, const char* pszUTF8, int nUTF8Count )
UTF8To16	third_party/xml/Markup.h	/^	static int UTF8To16( unsigned short* pwszUTF16, const char* pszUTF8, int nUTF8Count );$/;"	p	class:CMarkup	access:public	signature:( unsigned short* pwszUTF16, const char* pszUTF8, int nUTF8Count )
UTF8ToA	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::UTF8ToA( MCD_CSTR pszUTF8, int* pnFailed\/*=NULL*\/ )$/;"	f	class:CMarkup	signature:( MCD_CSTR pszUTF8, int* pnFailed )
UTF8ToA	third_party/xml/Markup.h	/^	static MCD_STR UTF8ToA( MCD_CSTR pszUTF8, int* pnFailed = NULL );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR pszUTF8, int* pnFailed = NULL )
UnKnown	include/functionalX.h	/^	UnKnown = 0$/;"	e	enum:TriSate
UnescapeText	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::UnescapeText( MCD_CSTR szText, int nTextLength \/*=-1*\/ )$/;"	f	class:CMarkup	signature:( MCD_CSTR szText, int nTextLength )
UnescapeText	third_party/xml/Markup.h	/^	static MCD_STR UnescapeText( MCD_CSTR szText, int nTextLength = -1 );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR szText, int nTextLength = -1 )
Unknown	compiler/word.h	/^	enum{Known = 1, Unknown = 0, Error = -1};$/;"	e	enum:word::__anon129
Unknown	syntax/word.h	/^	enum{Known = 1, Unknown = 0, Error = -1};$/;"	e	enum:word::__anon125
Unslot	third_party/xml/Markup.cpp	/^	void Unslot( TagPos& lp ) { int n=lp.iSlotNext,p=lp.iSlotPrev; if (n) pL[n].iSlotPrev=p; if (p) pL[p].iSlotNext=n; else anTable[lp.nSlot]=n; };$/;"	f	struct:ElemStack	access:public	signature:( TagPos& lp )
V	test/vhelp.h	/^	V() {}$/;"	f	class:V	access:public	signature:()
V	test/vhelp.h	/^	V(IDX _0) : v(1)$/;"	f	class:V	access:public	signature:(IDX _0)
V	test/vhelp.h	/^	V(IDX _0, IDX _1) : v(2)$/;"	f	class:V	access:public	signature:(IDX _0, IDX _1)
V	test/vhelp.h	/^	V(IDX _0, IDX _1, IDX _2) : v(3)$/;"	f	class:V	access:public	signature:(IDX _0, IDX _1, IDX _2)
V	test/vhelp.h	/^	V(IDX _0, IDX _1, IDX _2, IDX _3) : v(4)$/;"	f	class:V	access:public	signature:(IDX _0, IDX _1, IDX _2, IDX _3)
V	test/vhelp.h	/^	V(IDX _0, IDX _1, IDX _2, IDX _3, IDX _4) : v(5)$/;"	f	class:V	access:public	signature:(IDX _0, IDX _1, IDX _2, IDX _3, IDX _4)
V	test/vhelp.h	/^	V(IDX _0, IDX _1, IDX _2, IDX _3, IDX _4, IDX _5) : v(6)$/;"	f	class:V	access:public	signature:(IDX _0, IDX _1, IDX _2, IDX _3, IDX _4, IDX _5)
V	test/vhelp.h	/^	V(IDX _0, IDX _1, IDX _2, IDX _3, IDX _4, IDX _5, IDX _6) : v(7)$/;"	f	class:V	access:public	signature:(IDX _0, IDX _1, IDX _2, IDX _3, IDX _4, IDX _5, IDX _6)
V	test/vhelp.h	/^	V(IDX _0, IDX _1, IDX _2, IDX _3, IDX _4, IDX _5, IDX _6, IDX _7) : v(8)$/;"	f	class:V	access:public	signature:(IDX _0, IDX _1, IDX _2, IDX _3, IDX _4, IDX _5, IDX _6, IDX _7)
V	test/vhelp.h	/^	V(IDX _0, IDX _1, IDX _2, IDX _3, IDX _4, IDX _5, IDX _6,$/;"	f	class:V	access:public	signature:(IDX _0, IDX _1, IDX _2, IDX _3, IDX _4, IDX _5, IDX _6, IDX _7, IDX _8, IDX _9, IDX _10, IDX _11, IDX _12)
V	test/vhelp.h	/^    V(IDX _0, IDX _1, IDX _2, IDX _3, IDX _4, IDX _5, IDX _6,$/;"	f	class:V	access:public	signature:(IDX _0, IDX _1, IDX _2, IDX _3, IDX _4, IDX _5, IDX _6, IDX _7, IDX _8)
V	test/vhelp.h	/^class V : public kog::smart_vector<compile::int32>$/;"	c	inherits:kog::smart_vector
V::V	test/vhelp.h	/^	V() {}$/;"	f	class:V	access:public	signature:()
V::V	test/vhelp.h	/^	V(IDX _0) : v(1)$/;"	f	class:V	access:public	signature:(IDX _0)
V::V	test/vhelp.h	/^	V(IDX _0, IDX _1) : v(2)$/;"	f	class:V	access:public	signature:(IDX _0, IDX _1)
V::V	test/vhelp.h	/^	V(IDX _0, IDX _1, IDX _2) : v(3)$/;"	f	class:V	access:public	signature:(IDX _0, IDX _1, IDX _2)
V::V	test/vhelp.h	/^	V(IDX _0, IDX _1, IDX _2, IDX _3) : v(4)$/;"	f	class:V	access:public	signature:(IDX _0, IDX _1, IDX _2, IDX _3)
V::V	test/vhelp.h	/^	V(IDX _0, IDX _1, IDX _2, IDX _3, IDX _4) : v(5)$/;"	f	class:V	access:public	signature:(IDX _0, IDX _1, IDX _2, IDX _3, IDX _4)
V::V	test/vhelp.h	/^	V(IDX _0, IDX _1, IDX _2, IDX _3, IDX _4, IDX _5) : v(6)$/;"	f	class:V	access:public	signature:(IDX _0, IDX _1, IDX _2, IDX _3, IDX _4, IDX _5)
V::V	test/vhelp.h	/^	V(IDX _0, IDX _1, IDX _2, IDX _3, IDX _4, IDX _5, IDX _6) : v(7)$/;"	f	class:V	access:public	signature:(IDX _0, IDX _1, IDX _2, IDX _3, IDX _4, IDX _5, IDX _6)
V::V	test/vhelp.h	/^	V(IDX _0, IDX _1, IDX _2, IDX _3, IDX _4, IDX _5, IDX _6, IDX _7) : v(8)$/;"	f	class:V	access:public	signature:(IDX _0, IDX _1, IDX _2, IDX _3, IDX _4, IDX _5, IDX _6, IDX _7)
V::V	test/vhelp.h	/^	V(IDX _0, IDX _1, IDX _2, IDX _3, IDX _4, IDX _5, IDX _6,$/;"	f	class:V	access:public	signature:(IDX _0, IDX _1, IDX _2, IDX _3, IDX _4, IDX _5, IDX _6, IDX _7, IDX _8, IDX _9, IDX _10, IDX _11, IDX _12)
V::V	test/vhelp.h	/^    V(IDX _0, IDX _1, IDX _2, IDX _3, IDX _4, IDX _5, IDX _6,$/;"	f	class:V	access:public	signature:(IDX _0, IDX _1, IDX _2, IDX _3, IDX _4, IDX _5, IDX _6, IDX _7, IDX _8)
V::int32	test/vhelp.h	/^	typedef compile::int32 int32;$/;"	t	class:V	access:private
V::symbols	test/vhelp.h	/^	static const compile::symholder*& symbols()$/;"	f	class:V	access:public	signature:()
V::tstring	test/vhelp.h	/^	typedef compile::tstring tstring;$/;"	t	class:V	access:private
V::v	test/vhelp.h	/^	typedef kog::smart_vector<int32> v;$/;"	t	class:V	access:private
ValidPath	third_party/xml/Markup.cpp	/^	bool ValidPath() { return nPathType != -1; };$/;"	f	struct:PathPos	access:public	signature:()
ValueDeclear	test/output/gen.cpp	/^	ValueDeclear()$/;"	f	struct:ValueDeclear	access:public	signature:()
ValueDeclear	test/output/gen.cpp	/^struct ValueDeclear : public type$/;"	s	file:	inherits:type
ValueDeclear	test/output/tinyg.cpp	/^	ValueDeclear()$/;"	f	struct:ValueDeclear	access:public	signature:()
ValueDeclear	test/output/tinyg.cpp	/^struct ValueDeclear : public type$/;"	s	file:	inherits:type
ValueDeclear	test/output/tinyg/tinyg.cpp	/^	ValueDeclear()$/;"	f	struct:ValueDeclear	access:public	signature:()
ValueDeclear	test/output/tinyg/tinyg.cpp	/^struct ValueDeclear : public type$/;"	s	file:	inherits:type
ValueDeclear	test/output/tinyg/tinyg_bk.cpp	/^	ValueDeclear()$/;"	f	struct:ValueDeclear	access:public	signature:()
ValueDeclear	test/output/tinyg/tinyg_bk.cpp	/^struct ValueDeclear : public type$/;"	s	file:	inherits:type
ValueDeclear::ValueDeclear	test/output/gen.cpp	/^	ValueDeclear()$/;"	f	struct:ValueDeclear	access:public	signature:()
ValueDeclear::ValueDeclear	test/output/tinyg.cpp	/^	ValueDeclear()$/;"	f	struct:ValueDeclear	access:public	signature:()
ValueDeclear::ValueDeclear	test/output/tinyg/tinyg.cpp	/^	ValueDeclear()$/;"	f	struct:ValueDeclear	access:public	signature:()
ValueDeclear::ValueDeclear	test/output/tinyg/tinyg_bk.cpp	/^	ValueDeclear()$/;"	f	struct:ValueDeclear	access:public	signature:()
ValueDeclear::sid	test/output/gen.cpp	/^	enum{ sid = 1011 };$/;"	e	enum:ValueDeclear::__anon108	file:
ValueDeclear::sid	test/output/tinyg.cpp	/^	enum{ sid = 2 };$/;"	e	enum:ValueDeclear::__anon7	file:
ValueDeclear::sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 2 };$/;"	e	enum:ValueDeclear::__anon38	file:
ValueDeclear::sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 2 };$/;"	e	enum:ValueDeclear::__anon69	file:
Valuetype	test/output/tinyg.cpp	/^	Valuetype()$/;"	f	struct:Valuetype	access:public	signature:()
Valuetype	test/output/tinyg.cpp	/^struct Valuetype : public type$/;"	s	file:	inherits:type
Valuetype	test/output/tinyg/tinyg.cpp	/^	Valuetype()$/;"	f	struct:Valuetype	access:public	signature:()
Valuetype	test/output/tinyg/tinyg.cpp	/^struct Valuetype : public type$/;"	s	file:	inherits:type
Valuetype	test/output/tinyg/tinyg_bk.cpp	/^	Valuetype()$/;"	f	struct:Valuetype	access:public	signature:()
Valuetype	test/output/tinyg/tinyg_bk.cpp	/^struct Valuetype : public type$/;"	s	file:	inherits:type
Valuetype::Valuetype	test/output/tinyg.cpp	/^	Valuetype()$/;"	f	struct:Valuetype	access:public	signature:()
Valuetype::Valuetype	test/output/tinyg/tinyg.cpp	/^	Valuetype()$/;"	f	struct:Valuetype	access:public	signature:()
Valuetype::Valuetype	test/output/tinyg/tinyg_bk.cpp	/^	Valuetype()$/;"	f	struct:Valuetype	access:public	signature:()
Valuetype::sid	test/output/tinyg.cpp	/^	enum{ sid = 5 };$/;"	e	enum:Valuetype::__anon10	file:
Valuetype::sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 5 };$/;"	e	enum:Valuetype::__anon41	file:
Valuetype::sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 5 };$/;"	e	enum:Valuetype::__anon72	file:
WhitespaceToTag	third_party/xml/Markup.cpp	/^	int WhitespaceToTag( int n ) { m_nNext = n; if (FindAny()&&m_pDocText[m_nNext]!='<') { m_nNext=n; m_nR=n-1; } return m_nNext; };$/;"	f	struct:TokenPos	access:public	signature:( int n )
WriteTextFile	third_party/xml/Markup.cpp	/^bool CMarkup::WriteTextFile( MCD_CSTR_FILENAME szFileName, const MCD_STR& strDoc, MCD_STR* pstrResult, int* pnDocFlags, MCD_STR* pstrEncoding )$/;"	f	class:CMarkup	signature:( MCD_CSTR_FILENAME szFileName, const MCD_STR& strDoc, MCD_STR* pstrResult, int* pnDocFlags, MCD_STR* pstrEncoding )
WriteTextFile	third_party/xml/Markup.h	/^	static bool WriteTextFile( MCD_CSTR_FILENAME szFileName, const MCD_STR& strDoc, MCD_STR* pstrResult=NULL, int* pnDocFlags=NULL, MCD_STR* pstrEncoding=NULL );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR_FILENAME szFileName, const MCD_STR& strDoc, MCD_STR* pstrResult=NULL, int* pnDocFlags=NULL, MCD_STR* pstrEncoding=NULL )
XML_NAMESPACE_BEGIN	third_party/xml/Markup.h	12;"	d
XML_NAMESPACE_END	third_party/xml/Markup.h	13;"	d
Yes	include/functionalX.h	/^	Yes = 1,$/;"	e	enum:TriSate
_ARRAYX_H_HUXL_	include/arrayX.h	7;"	d
_ASM_GENERATE_H_SC_	asmgenerate.h	5;"	d
_AUTO_MACHINE_H_	syntax/automachine.h	5;"	d
_Allink	include/tree.h	/^	typedef typename _Alloc::template rebind<link>::other _Allink;$/;"	t	class:_tree_node	access:public
_Alnode	include/tree.h	/^	typedef typename _Alloc::template rebind<tnode>::other _Alnode;$/;"	t	class:_tree_node	access:public
_BASIC_GRAMMARS_H_SC_	galgorithm/basicalgorithms.h	5;"	d
_BASIC_GRAMMARS_H_SC_	galgorithm/firstfollow.h	6;"	d
_BASIC_TYPES_H_SC_	include/basic_types.h	5;"	d
_BUCKETHASH_H_HUXL_	include/buckethash.h	5;"	d
_Base	include/functionalX.h	/^	typedef std::pair<_Iter, _Iter> _Base;$/;"	t	struct:range_t	access:public
_Base	include/iteratorX.h	/^	typedef std::iterator<std::random_access_iterator_tag, _Tx> _Base;$/;"	t	struct:array_iterator	access:public
_Base	include/tree.h	/^		typedef std::iterator<std::bidirectional_iterator_tag, _Tx> _Base;$/;"	t	struct:tree::_Const_iterator	access:public
_Base	include/tree.h	/^	typedef _tree_node<_Tx, _Alloc> _Base;$/;"	t	class:tree	access:public
_BaseType	include/iteratorX.h	/^	typedef std::pair<_Iter1, _Iter2> _BaseType;$/;"	t	struct:iterator_pair	access:public
_CATCH_IO_END	compiler/extract.cpp	18;"	d	file:
_COMPILER_H_SC_	compiler/compiler.h	5;"	d
_COMPILER_H_SC_	tmp/back/compiler.h	5;"	d
_CONTAINER_GROUP_SC_	tmp/back/container_group.h	5;"	d
_Cmp	syntax/symbol.h	/^	_CmpFunc _Cmp;$/;"	m	struct:symbolname_Cmp	access:public
_Const_base	include/tree.h	/^		typedef _Const_iterator<_Bidirection> _Const_base;$/;"	t	struct:tree::_Iterator	access:public
_Const_iterator	include/buckethash.h	/^		_Const_iterator()$/;"	f	struct:buckethash::_Const_iterator	access:public	signature:()
_Const_iterator	include/buckethash.h	/^		_Const_iterator(const buckethash<_K, _V, _K2I>* p)$/;"	f	struct:buckethash::_Const_iterator	access:private	signature:(const buckethash<_K, _V, _K2I>* p)
_Const_iterator	include/buckethash.h	/^	struct _Const_iterator$/;"	s	class:buckethash	access:public
_Const_iterator	include/stringXF.h	/^        _Const_iterator(const _Const_iterator& other)$/;"	f	struct:string_split_t::_Const_iterator	access:public	signature:(const _Const_iterator& other)
_Const_iterator	include/stringXF.h	/^        _Const_iterator(string_split_t<_Elem>* ref, size_t posB)$/;"	f	struct:string_split_t::_Const_iterator	access:public	signature:(string_split_t<_Elem>* ref, size_t posB)
_Const_iterator	include/stringXF.h	/^        _Const_iterator(string_split_t<_Elem>* ref, size_t posB, size_t posE)$/;"	f	struct:string_split_t::_Const_iterator	access:public	signature:(string_split_t<_Elem>* ref, size_t posB, size_t posE)
_Const_iterator	include/stringXF.h	/^    struct _Const_iterator$/;"	s	struct:string_split_t	access:public
_Const_iterator	include/tree.h	/^		_Const_iterator(link p)$/;"	f	struct:tree::_Const_iterator	access:public	signature:(link p)
_Const_iterator	include/tree.h	/^	struct _Const_iterator : public std::iterator<std::bidirectional_iterator_tag, _Tx>$/;"	s	class:tree	inherits:std::iterator	access:public
_Ctptr	include/stringX.h	/^	typedef typename _Mybase::const_pointer _Ctptr;$/;"	t	class:xstring_basic	access:public
_DEBUG_H_KOG_	include/debug.h	5;"	d
_DEBUG_TOOL_LINUX_H_KOG_	third_party/callstack/linux2/debug_tool.hpp	4;"	d
_DFA_TO_AUTOMACHINE_H_SC_	galgorithm/dfa2machine.h	5;"	d
_Diff_GT_0	include/iteratorX.h	/^	typedef mpl::fire_error<_ext::Diff_Mast_Grate_Than_Zero<_Diff> > _Diff_GT_0;$/;"	t	struct:array_iterator	access:public
_Dift	include/stringX.h	/^	typedef typename _Mybase::difference_type _Dift;$/;"	t	class:xstring_basic	access:public
_ECLOSURE_H_SC_	galgorithm/eclosures.h	5;"	d
_EXTRACT_H_SC_	compiler/extract.h	5;"	d
_FUNCTIONAL_H_HUXL_	include/functionalX.h	5;"	d
_FUNCTION_PARAMS_H_SC_	compiler/funcparams.h	5;"	d
_FunType	include/functionalX.h	/^	typedef _Result (*_FunType)(_Arg);$/;"	t	struct:unary_function_adptor_t	access:public
_FunType	include/functionalX.h	/^	typedef _Result (*_FunType)(_Arg1, _Arg2);$/;"	t	struct:binary_function_adptor_t	access:public
_FunType	include/functionalX.h	/^	typedef _Result (*_FunType)(_Arg1, _Arg2, _Arg3);$/;"	t	struct:triple_function_adptor_t	access:public
_GENSYNTAX_H_SC_	makecompiler/gensyntax.h	5;"	d
_GLOBAL_VALUES_H_HUXL_	syntax/global_values.h	5;"	d
_GRAMMAR_ALGORITHM_H_SC_	galgorithm/grammaralgorithm.h	5;"	d
_GRAMMAR_H_SC_	syntax/grammar.h	5;"	d
_GRAMMAR_IO_H_TEST_	test/gio.h	5;"	d
_HEAPX_H_HUXL_	include/heapX.h	5;"	d
_IFUNCTION_H_SC_	compiler/ifunction.h	5;"	d
_INSTRUCTION_H_SC_	compiler/instruction.h	5;"	d
_INTERMEDIATE_LANGUAGE_H_SC_	compiler/interlanguage.h	5;"	d
_IStream	include/stringX.h	/^	typedef std::basic_istringstream<_Elem, _Traits, _Ax> _IStream;$/;"	t	class:xstring_basic	access:public
_ITERATORX_H_HUXL_	include/iteratorX.h	5;"	d
_Iterator	include/tree.h	/^		_Iterator(link p)$/;"	f	struct:tree::_Iterator	access:public	signature:(link p)
_Iterator	include/tree.h	/^	struct _Iterator : public _Const_iterator<_Bidirection>$/;"	s	class:tree	inherits:_Const_iterator	access:public
_L	syntax/automachine.h	/^	_CmpFunc _L;$/;"	m	struct:intpair_cmp	access:public
_LALR1_MACHINE_H_	compiler/lalr1machine.h	5;"	d
_LALR1_MACHINE_H_SC_	syntax/lrmachine.h	5;"	d
_LOADER_H_SC_	syntax/loader.h	5;"	d
_LOG_H_HUXL_	include/logger.h	5;"	d
_LRANALYSE_H_SC_	galgorithm/lranalyse.h	5;"	d
_LRMIO_H_TEST_	test/lrmio.h	5;"	d
_MACROS_H_HUXL_	include/macros.h	5;"	d
_MARKUP_H_INCLUDED_	third_party/xml/Markup.h	10;"	d
_MARKUP_UTILS_H_SC_	include/markuputils.h	5;"	d
_MATHX_H_HUXL_	include/mathX.h	5;"	d
_MEMALLOC_H_SC_	compiler/memalloc.h	5;"	d
_MEMORYX_H_HUXL_	include/memoryX.h	5;"	d
_MODULE_H_SC_	compiler/module.h	5;"	d
_MPLX_H_HUXL_	include/mplX.h	5;"	d
_Mybase	include/functionalX.h	/^	typedef std::pair<_Iter, _Iter> _Mybase;$/;"	t	struct:range_t	access:public
_Mybase	include/stringX.h	/^	typedef std::basic_string<_Elem, _Traits, _Ax> _Mybase;$/;"	t	class:xstring_basic	access:public
_Myios	compiler/extract.cpp	/^	typedef std::istream _Myios;$/;"	t	class:iwordstream	file:	access:private
_Mysb	compiler/extract.cpp	/^	typedef std::streambuf _Mysb;$/;"	t	class:iwordstream	file:	access:private
_Myt	include/arrayX.h	/^	typedef SmartArray<_Ty, _Length> _Myt;$/;"	t	struct:SmartArray	access:public
_Myt	include/arrayX.h	/^	typedef SmartMatrix<_Ty, _Row, _Col> _Myt;$/;"	t	struct:SmartMatrix	access:public
_Myt	include/arrayX.h	/^	typedef smart_vector<_Tx> _Myt;$/;"	t	class:smart_vector	access:public
_Myt	include/functionalX.h	/^	typedef composite_function2_t<_Fx, _Fy, _Fz> _Myt;$/;"	t	struct:composite_function2_t	access:public
_Myt	include/functionalX.h	/^	typedef composite_function_t<_Fx, _Fy> _Myt;$/;"	t	struct:composite_function_t	access:public
_Myt	include/functionalX.h	/^	typedef mem_value_t<_Tc, _Ty> _Myt;$/;"	t	struct:mem_value_t	access:public
_Myt	include/functionalX.h	/^	typedef triple<_Ty1, _Ty2, _Ty3> _Myt;$/;"	t	struct:triple	access:public
_Myt	include/iteratorX.h	/^	typedef array_iterator<_Tx> _Myt;$/;"	t	struct:array_iterator	access:public
_Myt	include/iteratorX.h	/^	typedef iterator_pair<_Iter1, _Iter2> _Myt;$/;"	t	struct:iterator_pair	access:public
_Myt	include/stringX.h	/^	typedef xstring_basic<_Elem, _Traits, _Ax> _Myt;$/;"	t	class:xstring_basic	access:public
_Myt	include/tree.h	/^		typedef _Const_iterator<_Tx> _Myt;$/;"	t	struct:tree::_Const_iterator	access:public
_Myt	include/tree.h	/^		typedef _Iterator<_Tx> _Myt;$/;"	t	struct:tree::_Iterator	access:public
_NFA_TO_DFA_H_SC_	galgorithm/nfa2dfa.h	5;"	d
_OBJECT_H_SC_	compiler/object.h	5;"	d
_OPERATIONS_H_SC_	compiler/operation.h	5;"	d
_OStream	include/stringX.h	/^	typedef std::basic_ostringstream<_Elem, _Traits, _Ax> _OStream;$/;"	t	class:xstring_basic	access:public
_POINTER_HOLDER_H_HUXL_	include/pointholder.h	5;"	d
_PRODUCTION_H_SC_	syntax/production.h	5;"	d
_REGEX2NFA_H_SC_	galgorithm/regex2nfa.h	5;"	d
_Reft	include/stringX.h	/^	typedef typename _Mybase::reference _Reft;$/;"	t	class:xstring_basic	access:public
_SCERROR_H_SC_	include/scerror.h	5;"	d
_SCOPE_H_SC_	compiler/scope.h	5;"	d
_SHARED_PTR_H_	include/shared_ptr.h	20;"	d
_SIMPLE_POOL_H_HUXL_	tmp/back/simplepool.h	5;"	d
_SINGLETON_H_HUXL_	include/singleton.h	5;"	d
_SORTC_H_HUXL_	include/sortc.h	5;"	d
_STACK_TRACE_H_SC_	third_party/callstack/stacktrace.h	5;"	d
_STATE_MACHINE_H_SC_	syntax/statemachine.h	5;"	d
_STREAMX_H_HUXL_	include/streamX.h	5;"	d
_STRINGXF_H_HUXL_	include/stringXF.h	5;"	d
_STRINGX_H_HUXL_	include/stringX.h	5;"	d
_SYMBOL_H_SC_	syntax/symbol.h	5;"	d
_Str	compiler/word.h	/^	typedef sc::tstring _Str;$/;"	t	struct:word	access:public
_Str	include/basic_types.h	/^typedef tstring _Str;$/;"	t
_Str	syntax/word.h	/^	typedef sc::tstring _Str;$/;"	t	struct:word	access:public
_Stream	include/stringX.h	/^	typedef std::basic_stringstream<_Elem, _Traits, _Ax> _Stream;$/;"	t	class:xstring_basic	access:public
_TREEMAKER_H_SC_	compiler/treemaker.h	5;"	d
_TREE_H_HUXL_	include/tree.h	5;"	d
_TRY_IO_BEGIN	compiler/extract.cpp	14;"	d	file:
_TUPLE_H_SC_	compiler/tuple.h	5;"	d
_TYPES_H_SC_	compiler/type.h	5;"	d
_Tptr	include/stringX.h	/^	typedef typename _Mybase::pointer _Tptr;$/;"	t	class:xstring_basic	access:public
_UNITTEST_H_HUXL_	test/unittest.h	5;"	d
_VALUES_H_SC_	compiler/value.h	5;"	d
_VARIABLE_H_SC_	compiler/variable.h	5;"	d
_VHELP_H_TEST_	test/vhelp.h	5;"	d
_WORD_H_SC_	compiler/word.h	5;"	d
_WORD_H_SC_	syntax/word.h	5;"	d
_XREGEX_H_HUXL_	third_party/regex/xregex.h	4;"	d
_before	include/iteratorX.h	/^	difference_type _before;$/;"	m	struct:array_iterator	access:public
_bucket_Locate	include/buckethash.h	/^	bucket_const_iterator _bucket_Locate(size_t kid, const key& k) const$/;"	f	class:buckethash	access:private	signature:(size_t kid, const key& k) const
_bucket_Locate	include/buckethash.h	/^	bucket_iterator _bucket_Locate(size_t kid, const key& k)$/;"	f	class:buckethash	access:private	signature:(size_t kid, const key& k)
_bucket_index	include/buckethash.h	/^	size_t _bucket_index(const key& k) const$/;"	f	class:buckethash	access:private	signature:(const key& k) const
_buf	include/arrayX.h	/^	_Ty _buf[_Length];$/;"	m	struct:SmartArray	access:private
_first_nonzero_bit	tmp/back/simplepool.h	/^	size_t _first_nonzero_bit(bitmap v) const$/;"	f	class:mempool	access:private	signature:(bitmap v) const
_first_not_used	tmp/back/simplepool.h	/^	size_t _first_not_used()$/;"	f	class:mempool	access:private	signature:()
_follow	include/iteratorX.h	/^	difference_type _follow;$/;"	m	struct:array_iterator	access:public
_fseeki64	third_party/xml/Markup.h	/^extern "C" int __cdecl _fseeki64(FILE *, __int64, int);$/;"	p	signature:(FILE *, __int64, int)
_fun	include/stringXF.h	/^	_CmpFunc _fun;$/;"	m	struct:stringcmp	access:public
_func1	include/functionalX.h	/^	_Func1 _func1;$/;"	m	class:apply	access:private
_func2	include/functionalX.h	/^	_Func2 _func2;$/;"	m	class:apply	access:private
_fx	include/functionalX.h	/^	_Fx _fx;$/;"	m	struct:composite_function2_t	access:protected
_fx	include/functionalX.h	/^	_Fx _fx;$/;"	m	struct:composite_function_t	access:protected
_fy	include/functionalX.h	/^	_Fy _fy;$/;"	m	struct:composite_function2_t	access:protected
_fy	include/functionalX.h	/^	_Fy _fy;$/;"	m	struct:composite_function_t	access:protected
_fz	include/functionalX.h	/^	_Fz _fz;$/;"	m	struct:composite_function2_t	access:protected
_getfuncname	third_party/callstack/win32/debug_tool.cpp	/^			static func_name      _getfuncname( QWORD dwFunc );$/;"	p	class:dbsoft::detail::callstack_Imp	file:	access:protected	signature:( QWORD dwFunc )
_getfuncname	third_party/callstack/win32/debug_tool.cpp	/^		callstack_Imp::func_name callstack_Imp::_getfuncname( QWORD dwFunc )$/;"	f	class:dbsoft::detail::callstack_Imp	signature:( QWORD dwFunc )
_initialize	third_party/callstack/win32/debug_tool.cpp	/^			static void           _initialize();$/;"	p	class:dbsoft::detail::callstack_Imp	file:	access:protected	signature:()
_initialize	third_party/callstack/win32/debug_tool.cpp	/^		void callstack_Imp::_initialize()$/;"	f	class:dbsoft::detail::callstack_Imp	signature:()
_loadAllModules	third_party/callstack/win32/debug_tool.cpp	/^			static bool           _loadAllModules();$/;"	p	class:dbsoft::detail::callstack_Imp	file:	access:protected	signature:()
_loadAllModules	third_party/callstack/win32/debug_tool.cpp	/^		bool callstack_Imp::_loadAllModules()$/;"	f	class:dbsoft::detail::callstack_Imp	signature:()
_maxValue	include/functionalX.h	/^	const _Arg& _maxValue;$/;"	m	class:is_between_t	access:private
_minValue	include/functionalX.h	/^	const _Arg& _minValue;$/;"	m	class:is_between_t	access:private
_next	include/stringXF.h	/^        size_t _next(size_t posb)$/;"	f	struct:string_split_t::_Const_iterator	access:private	signature:(size_t posb)
_op	include/functionalX.h	/^	_Oper _op;$/;"	m	class:apply	access:private
_pFun	include/functionalX.h	/^	_FunType _pFun;$/;"	m	struct:binary_function_adptor_t	access:private
_pFun	include/functionalX.h	/^	_FunType _pFun;$/;"	m	struct:triple_function_adptor_t	access:private
_pFun	include/functionalX.h	/^	_FunType _pFun;$/;"	m	struct:unary_function_adptor_t	access:private
_p_value	include/functionalX.h	/^	mem_value_type _p_value;$/;"	m	struct:mem_value_t	access:protected
_ptr	include/iteratorX.h	/^	_Tx* _ptr;$/;"	m	struct:array_iterator	access:public
_reduce	compiler/lalr1machine.cpp	/^machine_meta* lalr1machine::_reduce(int32 pid, const kog::smart_vector<machine_meta*>& rights, machine_meta* result)$/;"	f	class:lalr1machine	signature:(int32 pid, const kog::smart_vector<machine_meta*>& rights, machine_meta* result)
_reduce	compiler/lalr1machine.h	/^	\/* overwrite *\/ virtual machine_meta* _reduce(int32 pid, const kog::smart_vector<machine_meta*>& rights, machine_meta* result);$/;"	p	class:lalr1machine	access:protected	signature:(int32 pid, const kog::smart_vector<machine_meta*>& rights, machine_meta* result)
_reduce	syntax/lrmachine.cpp	/^lrmachine::machine_meta* lrmachine::_reduce(int32 pid, const kog::smart_vector<machine_meta*>& rights, machine_meta* result)$/;"	f	class:lrmachine	signature:(int32 pid, const kog::smart_vector<machine_meta*>& rights, machine_meta* result)
_reduce	syntax/lrmachine.h	/^	virtual machine_meta* _reduce(int32 pid, const kog::smart_vector<machine_meta*>& rights, machine_meta* result);$/;"	p	class:lrmachine	access:protected	signature:(int32 pid, const kog::smart_vector<machine_meta*>& rights, machine_meta* result)
_ref_obj	include/functionalX.h	/^	T& _ref_obj;$/;"	m	class:ref_obj	access:private
_stackwalk	third_party/callstack/win32/debug_tool.cpp	/^			static void           _stackwalk( QWORD* pTrace, DWORD dwMaxDepth, CONTEXT* pContext );$/;"	p	class:dbsoft::detail::callstack_Imp	file:	access:protected	signature:( QWORD* pTrace, DWORD dwMaxDepth, CONTEXT* pContext )
_stackwalk	third_party/callstack/win32/debug_tool.cpp	/^		void callstack_Imp::_stackwalk(QWORD *pTrace, DWORD dwMaxDepth, CONTEXT *pContext)$/;"	f	class:dbsoft::detail::callstack_Imp	signature:(QWORD *pTrace, DWORD dwMaxDepth, CONTEXT *pContext)
_tree_node	include/tree.h	/^	_tree_node(_Alloc _Al = _Alloc())$/;"	f	class:_tree_node	access:protected	signature:(_Alloc _Al = _Alloc())
_tree_node	include/tree.h	/^class _tree_node$/;"	c
_tree_node::Allink_	include/tree.h	/^	_Allink Allink_;$/;"	m	class:_tree_node	access:public
_tree_node::Alval_	include/tree.h	/^	_Alnode Alval_;$/;"	m	class:_tree_node	access:public
_tree_node::_Allink	include/tree.h	/^	typedef typename _Alloc::template rebind<link>::other _Allink;$/;"	t	class:_tree_node	access:public
_tree_node::_Alnode	include/tree.h	/^	typedef typename _Alloc::template rebind<tnode>::other _Alnode;$/;"	t	class:_tree_node	access:public
_tree_node::_tree_node	include/tree.h	/^	_tree_node(_Alloc _Al = _Alloc())$/;"	f	class:_tree_node	access:protected	signature:(_Alloc _Al = _Alloc())
_tree_node::const_link	include/tree.h	/^	typedef const tnode* const_link;$/;"	t	class:_tree_node	access:protected
_tree_node::link	include/tree.h	/^	typedef tnode* link;$/;"	t	class:_tree_node	access:protected
_tree_node::tnode	include/tree.h	/^	struct tnode$/;"	s	class:_tree_node	access:protected
_tree_node::tnode::children	include/tree.h	/^		link* children;$/;"	m	struct:_tree_node::tnode	access:public
_tree_node::tnode::link	include/tree.h	/^		typedef tnode* link;$/;"	t	struct:_tree_node::tnode	access:public
_tree_node::tnode::nc	include/tree.h	/^		int nc;$/;"	m	struct:_tree_node::tnode	access:public
_tree_node::tnode::parent	include/tree.h	/^		link parent;$/;"	m	struct:_tree_node::tnode	access:public
_tree_node::tnode::v	include/tree.h	/^		value_type v;$/;"	m	struct:_tree_node::tnode	access:public
_tree_node::value_type	include/tree.h	/^	typedef _Tx value_type;$/;"	t	class:_tree_node	access:public
_values	include/arrayX.h	/^	_Ty _values[_Row][_Col];$/;"	m	struct:SmartMatrix	access:private
abs	include/mathX.h	/^	static T abs(const T value)$/;"	f	class:math	access:public	signature:(const T value)
accept_state	syntax/lrmachine.h	/^	enum { accept_state = 0}; \/\/ using state 0 as ending state$/;"	e	enum:lrmachine::__anon126
accumulate	include/functionalX.h	/^inline void accumulate(_InIt _First1, _InIt _Last, _InIt _First2, _Ty _Val, _Fn2 _Func)$/;"	f	signature:(_InIt _First1, _InIt _Last, _InIt _First2, _Ty _Val, _Fn2 _Func)
accumulate	include/functionalX.h	/^inline void accumulate(_InIt _First1, _InIt _Last, _InIt _First2, _Ty _Val, _Fn2 _Func, _Op _Opt)$/;"	f	signature:(_InIt _First1, _InIt _Last, _InIt _First2, _Ty _Val, _Fn2 _Func, _Op _Opt)
add	test/input/easy.c	/^int add(int a, int b)$/;"	f	signature:(int a, int b)
add_const	include/mplX.h	/^struct add_const$/;"	s
add_const	include/mplX.h	/^struct add_const<const _T>$/;"	s
add_const::nonconst_type	include/mplX.h	/^	typedef _T nonconst_type;$/;"	t	struct:add_const	access:public
add_const::type	include/mplX.h	/^	typedef const _T type;$/;"	t	struct:add_const	access:public
address	compiler/memalloc.cpp	/^void memalloc::address(scope* s)$/;"	f	class:memalloc	signature:(scope* s)
address	compiler/memalloc.h	/^   static void address(scope* s);  $/;"	p	class:memalloc	access:public	signature:(scope* s)
address	compiler/value.h	/^        uint32 address;$/;"	m	union:value::__anon131	access:public
all_scopes_	compiler/interlanguage.h	/^    std::deque<kog::shared_ptr<runtime::scope> > all_scopes_;$/;"	m	class:interlanguage	access:private
allocate	tmp/back/simplepool.h	/^	pointer allocate(size_type _Count)$/;"	f	class:mempool	access:public	signature:(size_type _Count)
anTable	third_party/xml/Markup.cpp	/^	int anTable[LS_TABLESIZE];$/;"	m	struct:ElemStack	file:	access:protected
analysestack	syntax/lrmachine.h	/^	typedef std::stack<machine_meta*> analysestack;$/;"	t	class:lrmachine	access:public
anychar	syntax/automachine.h	/^		enum { anychar, special, exclude };$/;"	e	enum:automachine::sheetrow::__anon127
apply	include/functionalX.h	/^	apply(){}$/;"	f	class:apply	access:public	signature:()
apply	include/functionalX.h	/^	apply(const _Oper& op, const _Func1& func1, const _Func2& func2)$/;"	f	class:apply	access:public	signature:(const _Oper& op, const _Func1& func1, const _Func2& func2)
apply	include/functionalX.h	/^class apply$/;"	c
apply::_func1	include/functionalX.h	/^	_Func1 _func1;$/;"	m	class:apply	access:private
apply::_func2	include/functionalX.h	/^	_Func2 _func2;$/;"	m	class:apply	access:private
apply::_op	include/functionalX.h	/^	_Oper _op;$/;"	m	class:apply	access:private
apply::apply	include/functionalX.h	/^	apply(){}$/;"	f	class:apply	access:public	signature:()
apply::apply	include/functionalX.h	/^	apply(const _Oper& op, const _Func1& func1, const _Func2& func2)$/;"	f	class:apply	access:public	signature:(const _Oper& op, const _Func1& func1, const _Func2& func2)
apply::argument_type	include/functionalX.h	/^	typedef typename _Oper::argument_type argument_type;$/;"	t	class:apply	access:public
apply::operator ()	include/functionalX.h	/^	result_type operator()(const argument_type& arg) const$/;"	f	class:apply	access:public	signature:(const argument_type& arg) const
apply::result_type	include/functionalX.h	/^	typedef typename _Oper::result_type result_type;$/;"	t	class:apply	access:public
are_equal	include/debug.h	/^    static void are_equal(const _Tx& v1, const _Tx& v2)$/;"	f	struct:assert	access:public	signature:(const _Tx& v1, const _Tx& v2)
argument_type	include/functionalX.h	/^	typedef typename _Fx::argument_type argument_type;$/;"	t	struct:composite_function_t	access:public
argument_type	include/functionalX.h	/^	typedef typename _Oper::argument_type argument_type;$/;"	t	class:apply	access:public
array_begin	include/iteratorX.h	/^array_iterator<_Tx, _Diff> array_begin(_Tx* _Begin_ptr, typename array_iterator<_Tx, _Diff>::difference_type _Length)$/;"	f	signature:(_Tx* _Begin_ptr, typename array_iterator<_Tx, _Diff>::difference_type _Length)
array_end	include/iteratorX.h	/^array_iterator<_Tx, _Diff> array_end(_Tx* _Begin_ptr, typename array_iterator<_Tx, _Diff>::difference_type _Length)$/;"	f	signature:(_Tx* _Begin_ptr, typename array_iterator<_Tx, _Diff>::difference_type _Length)
array_iterator	include/iteratorX.h	/^	array_iterator()$/;"	f	struct:array_iterator	access:public	signature:()
array_iterator	include/iteratorX.h	/^	array_iterator(_Tx* p, distance_type b, distance_type f)$/;"	f	struct:array_iterator	access:public	signature:(_Tx* p, distance_type b, distance_type f)
array_iterator	include/iteratorX.h	/^	array_iterator(_Tx*p, distance_type size)$/;"	f	struct:array_iterator	access:public	signature:(_Tx*p, distance_type size)
array_iterator	include/iteratorX.h	/^	array_iterator(const nonconst_type& aIter)$/;"	f	struct:array_iterator	access:public	signature:(const nonconst_type& aIter)
array_iterator	include/iteratorX.h	/^struct array_iterator : public std::iterator<std::random_access_iterator_tag, _Tx*>$/;"	s	inherits:std::iterator
array_iterator::_Base	include/iteratorX.h	/^	typedef std::iterator<std::random_access_iterator_tag, _Tx> _Base;$/;"	t	struct:array_iterator	access:public
array_iterator::_Diff_GT_0	include/iteratorX.h	/^	typedef mpl::fire_error<_ext::Diff_Mast_Grate_Than_Zero<_Diff> > _Diff_GT_0;$/;"	t	struct:array_iterator	access:public
array_iterator::_Myt	include/iteratorX.h	/^	typedef array_iterator<_Tx> _Myt;$/;"	t	struct:array_iterator	access:public
array_iterator::_before	include/iteratorX.h	/^	difference_type _before;$/;"	m	struct:array_iterator	access:public
array_iterator::_follow	include/iteratorX.h	/^	difference_type _follow;$/;"	m	struct:array_iterator	access:public
array_iterator::_ptr	include/iteratorX.h	/^	_Tx* _ptr;$/;"	m	struct:array_iterator	access:public
array_iterator::array_iterator	include/iteratorX.h	/^	array_iterator()$/;"	f	struct:array_iterator	access:public	signature:()
array_iterator::array_iterator	include/iteratorX.h	/^	array_iterator(_Tx* p, distance_type b, distance_type f)$/;"	f	struct:array_iterator	access:public	signature:(_Tx* p, distance_type b, distance_type f)
array_iterator::array_iterator	include/iteratorX.h	/^	array_iterator(_Tx*p, distance_type size)$/;"	f	struct:array_iterator	access:public	signature:(_Tx*p, distance_type size)
array_iterator::array_iterator	include/iteratorX.h	/^	array_iterator(const nonconst_type& aIter)$/;"	f	struct:array_iterator	access:public	signature:(const nonconst_type& aIter)
array_iterator::assert_invalidate	include/iteratorX.h	/^	array_iterator& assert_invalidate()$/;"	f	struct:array_iterator	access:protected	signature:()
array_iterator::assert_invalidate	include/iteratorX.h	/^	const array_iterator& assert_invalidate() const$/;"	f	struct:array_iterator	access:protected	signature:() const
array_iterator::backward	include/iteratorX.h	/^	static array_iterator& backward(array_iterator& aniterator, distance_type dis = 1)$/;"	f	struct:array_iterator	access:protected	signature:(array_iterator& aniterator, distance_type dis = 1)
array_iterator::const_type	include/iteratorX.h	/^	typedef array_iterator<typename mpl::add_const<_Tx>::type> const_type;$/;"	t	struct:array_iterator	access:public
array_iterator::difference_type	include/iteratorX.h	/^	typedef typename _Base::difference_type difference_type;$/;"	t	struct:array_iterator	access:public
array_iterator::distance_type	include/iteratorX.h	/^	typedef typename _Base::difference_type distance_type;	\/\/ retained$/;"	t	struct:array_iterator	access:public
array_iterator::forward	include/iteratorX.h	/^	static array_iterator& forward(array_iterator& aniterator, distance_type dis = 1)$/;"	f	struct:array_iterator	access:protected	signature:(array_iterator& aniterator, distance_type dis = 1)
array_iterator::get	include/iteratorX.h	/^	_Tx* get() const { return _ptr; }$/;"	f	struct:array_iterator	access:public	signature:() const
array_iterator::iterator_category	include/iteratorX.h	/^	typedef typename _Base::iterator_category iterator_category;$/;"	t	struct:array_iterator	access:public
array_iterator::nonconst_type	include/iteratorX.h	/^	typedef array_iterator<typename mpl::remove_const<_Tx>::type> nonconst_type;$/;"	t	struct:array_iterator	access:public
array_iterator::operator !=	include/iteratorX.h	/^	bool operator != (const _Myt& _Other) const$/;"	f	struct:array_iterator	access:public	signature:(const _Myt& _Other) const
array_iterator::operator *	include/iteratorX.h	/^	reference operator*() const { return *_ptr; }$/;"	f	struct:array_iterator	access:public	signature:() const
array_iterator::operator +	include/iteratorX.h	/^	_Myt operator +(distance_type _Dis) const$/;"	f	struct:array_iterator	access:public	signature:(distance_type _Dis) const
array_iterator::operator +	include/iteratorX.h	/^	friend _Myt operator+ (distance_type _Dis, const _Myt& _Iter)$/;"	f	struct:array_iterator	access:friend	signature:(distance_type _Dis, const _Myt& _Iter)
array_iterator::operator ++	include/iteratorX.h	/^	_Myt operator++(int) { _Myt temp(*this); forward(*this); return temp;}$/;"	f	struct:array_iterator	access:public	signature:(int)
array_iterator::operator ++	include/iteratorX.h	/^	_Myt& operator++() { return forward(*this); }$/;"	f	struct:array_iterator	access:public	signature:()
array_iterator::operator +=	include/iteratorX.h	/^	_Myt& operator +=(distance_type _Dis)$/;"	f	struct:array_iterator	access:public	signature:(distance_type _Dis)
array_iterator::operator -	include/iteratorX.h	/^	_Myt operator -(distance_type _Dis) const$/;"	f	struct:array_iterator	access:public	signature:(distance_type _Dis) const
array_iterator::operator -	include/iteratorX.h	/^	distance_type operator -(const _Myt& _PY) const$/;"	f	struct:array_iterator	access:public	signature:(const _Myt& _PY) const
array_iterator::operator --	include/iteratorX.h	/^	_Myt operator--(int) { _Myt temp(*this); backward(*this); return temp; }$/;"	f	struct:array_iterator	access:public	signature:(int)
array_iterator::operator --	include/iteratorX.h	/^	_Myt& operator--() { return backward(*this); }$/;"	f	struct:array_iterator	access:public	signature:()
array_iterator::operator -=	include/iteratorX.h	/^	_Myt& operator -=(distance_type _Dis)$/;"	f	struct:array_iterator	access:public	signature:(distance_type _Dis)
array_iterator::operator ->	include/iteratorX.h	/^	pointer operator->() const { return _ptr; }$/;"	f	struct:array_iterator	access:public	signature:() const
array_iterator::operator <	include/iteratorX.h	/^	bool operator <(const _Myt& _Other) const$/;"	f	struct:array_iterator	access:public	signature:(const _Myt& _Other) const
array_iterator::operator <=	include/iteratorX.h	/^	bool operator <=(const _Myt& _Other) const$/;"	f	struct:array_iterator	access:public	signature:(const _Myt& _Other) const
array_iterator::operator ==	include/iteratorX.h	/^	bool operator == (const _Myt& _Other) const$/;"	f	struct:array_iterator	access:public	signature:(const _Myt& _Other) const
array_iterator::operator >	include/iteratorX.h	/^	bool operator >(const _Myt& _Other) const$/;"	f	struct:array_iterator	access:public	signature:(const _Myt& _Other) const
array_iterator::operator >=	include/iteratorX.h	/^	bool operator >=(const _Myt& _Other) const$/;"	f	struct:array_iterator	access:public	signature:(const _Myt& _Other) const
array_iterator::operator []	include/iteratorX.h	/^	reference operator[](distance_type _Dis) { return _ptr[_Dis]; }$/;"	f	struct:array_iterator	access:public	signature:(distance_type _Dis)
array_iterator::pointer	include/iteratorX.h	/^	typedef typename _Base::pointer pointer;$/;"	t	struct:array_iterator	access:public
array_iterator::reference	include/iteratorX.h	/^	typedef typename _Base::reference reference;$/;"	t	struct:array_iterator	access:public
array_iterator::value_type	include/iteratorX.h	/^	typedef typename _Base::value_type value_type;$/;"	t	struct:array_iterator	access:public
as	compiler/object.h	/^    template<typename _Ty> _Ty* as()$/;"	f	struct:object	access:public	signature:()
as	compiler/object.h	/^    template<typename _Ty> const _Ty* as() const$/;"	f	struct:object	access:public	signature:() const
as	compiler/object.h	/^template<typename _Tx, typename _Ty> _Tx& as(_Ty& _v)$/;"	f	signature:(_Ty& _v)
as	compiler/object.h	/^template<typename _Tx, typename _Ty> _Tx* as(_Ty* _v)$/;"	f	signature:(_Ty* _v)
as	compiler/object.h	/^template<typename _Tx, typename _Ty> const _Tx& as(const _Ty& _v)$/;"	f	signature:(const _Ty& _v)
as	compiler/object.h	/^template<typename _Tx, typename _Ty> const _Tx* as(const _Ty* _v)$/;"	f	signature:(const _Ty* _v)
asmgenerate	asmgenerate.h	/^    asmgenerate(std::ostream& os);$/;"	p	class:asmgenerate	access:public	signature:(std::ostream& os)
asmgenerate	asmgenerate.h	/^class asmgenerate$/;"	c
asmgenerate	compiler/asmgenerate.cpp	/^asmgenerate::asmgenerate(std::ostream& os)$/;"	f	class:asmgenerate	signature:(std::ostream& os)
asmgenerate::asmgenerate	asmgenerate.h	/^    asmgenerate(std::ostream& os);$/;"	p	class:asmgenerate	access:public	signature:(std::ostream& os)
asmgenerate::asmgenerate	compiler/asmgenerate.cpp	/^asmgenerate::asmgenerate(std::ostream& os)$/;"	f	class:asmgenerate	signature:(std::ostream& os)
asmgenerate::os_	asmgenerate.h	/^    std::ostream* os_;$/;"	m	class:asmgenerate	access:private
asmgenerate::print	asmgenerate.h	/^    void print(scope* s);$/;"	p	class:asmgenerate	access:public	signature:(scope* s)
asmgenerate::print	compiler/asmgenerate.cpp	/^void asmgenerate::print(scope* s)$/;"	f	class:asmgenerate	signature:(scope* s)
assert	include/debug.h	/^struct assert$/;"	s
assert::are_equal	include/debug.h	/^    static void are_equal(const _Tx& v1, const _Tx& v2)$/;"	f	struct:assert	access:public	signature:(const _Tx& v1, const _Tx& v2)
assert::is_true	include/debug.h	/^    static void is_true(bool b)$/;"	f	struct:assert	access:public	signature:(bool b)
assert_invalidate	include/iteratorX.h	/^	array_iterator& assert_invalidate()$/;"	f	struct:array_iterator	access:protected	signature:()
assert_invalidate	include/iteratorX.h	/^	const array_iterator& assert_invalidate() const$/;"	f	struct:array_iterator	access:protected	signature:() const
assert_validate	include/arrayX.h	/^	void assert_validate() const$/;"	f	class:smart_vector	access:protected	signature:() const
assign	compiler/operation.h	/^	assign,$/;"	e	enum:op
assign	syntax/global_values.h	/^		object<_Tx>& assign(const holder& V)$/;"	f	class:refobject::object	access:public	signature:(const holder& V)
assign	syntax/global_values.h	/^		virtual holder& assign(const holder& V) = 0;$/;"	p	class:refobject::holder	access:public	signature:(const holder& V)
assign_t	include/functionalX.h	/^class assign_t : public std::binary_function<_Arg, _Arg, _Arg>$/;"	c	inherits:std::binary_function
assign_t::operator ()	include/functionalX.h	/^	_Arg& operator()(_Arg& _dstVal, const _Arg& _srcVal) const$/;"	f	class:assign_t	access:public	signature:(_Arg& _dstVal, const _Arg& _srcVal) const
at	include/arrayX.h	/^	const_reference at(size_type idx) const$/;"	f	class:smart_vector	access:public	signature:(size_type idx) const
at	include/arrayX.h	/^	const_reference at(size_type idx) const$/;"	f	struct:SmartArray	access:public	signature:(size_type idx) const
at	include/arrayX.h	/^	reference at(size_type idx)$/;"	f	class:smart_vector	access:public	signature:(size_type idx)
at	include/arrayX.h	/^	reference at(size_type idx)$/;"	f	struct:SmartArray	access:public	signature:(size_type idx)
atan	include/mathX.h	/^	static double atan(const T y, const T x)$/;"	f	class:math	access:public	signature:(const T y, const T x)
attach	include/arrayX.h	/^	smart_vector& attach(pointer _Ptr, size_type _N, bool _AutoDelete = true)$/;"	f	class:smart_vector	access:public	signature:(pointer _Ptr, size_type _N, bool _AutoDelete = true)
attach	include/arrayX.h	/^	static SmartArray<const value_type, _Length>* attach(const value_type anArray[_Length])$/;"	f	struct:SmartArray	access:public	signature:(const value_type anArray[_Length])
attach	include/arrayX.h	/^	static _Myt* attach(value_type anArray[_Length])$/;"	f	struct:SmartArray	access:public	signature:(value_type anArray[_Length])
automachine	compiler/compiler.h	/^	typedef compile::automachine automachine;$/;"	t	class:compiler	access:public
automachine	compiler/interlanguage.h	/^	typedef compile::automachine automachine;$/;"	t	class:interlanguage	access:public
automachine	syntax/automachine.cpp	/^automachine::automachine()$/;"	f	class:automachine	signature:()
automachine	syntax/automachine.cpp	/^automachine::automachine(const shared_sheet& asheet)$/;"	f	class:automachine	signature:(const shared_sheet& asheet)
automachine	syntax/automachine.h	/^	automachine();$/;"	p	class:automachine	access:public	signature:()
automachine	syntax/automachine.h	/^	automachine(const shared_sheet& asheet);$/;"	p	class:automachine	access:public	signature:(const shared_sheet& asheet)
automachine	syntax/automachine.h	/^class automachine$/;"	c
automachine::MEMBER_VARIABLE_GET_SET	syntax/automachine.h	/^	MEMBER_VARIABLE_GET_SET(int, sstate, sstate_);$/;"	p	class:automachine	access:public	signature:(int, sstate, sstate_)
automachine::MEMBER_VARIABLE_GET_SET	syntax/automachine.h	/^	MEMBER_VARIABLE_GET_SET(sparsesheet, sheet, *sheet_);$/;"	p	class:automachine	access:public	signature:(sparsesheet, sheet, *sheet_)
automachine::automachine	syntax/automachine.cpp	/^automachine::automachine()$/;"	f	class:automachine	signature:()
automachine::automachine	syntax/automachine.cpp	/^automachine::automachine(const shared_sheet& asheet)$/;"	f	class:automachine	signature:(const shared_sheet& asheet)
automachine::automachine	syntax/automachine.h	/^	automachine();$/;"	p	class:automachine	access:public	signature:()
automachine::automachine	syntax/automachine.h	/^	automachine(const shared_sheet& asheet);$/;"	p	class:automachine	access:public	signature:(const shared_sheet& asheet)
automachine::cstate_	syntax/automachine.h	/^	int cstate_; \/\/ current state$/;"	m	class:automachine	access:protected
automachine::eta	syntax/automachine.cpp	/^bool automachine::eta(machine_meta* meta)$/;"	f	class:automachine	signature:(machine_meta* meta)
automachine::eta	syntax/automachine.h	/^	virtual bool eta(machine_meta* meta);$/;"	p	class:automachine	access:public	signature:(machine_meta* meta)
automachine::gotoitem	syntax/automachine.h	/^	typedef std::pair<int, int> gotoitem;$/;"	t	class:automachine	access:public
automachine::init	syntax/automachine.cpp	/^void automachine::init()$/;"	f	class:automachine	signature:()
automachine::init	syntax/automachine.h	/^	virtual void init();$/;"	p	class:automachine	access:public	signature:()
automachine::isaccepted	syntax/automachine.h	/^	bool isaccepted() const$/;"	f	class:automachine	access:public	signature:() const
automachine::machine_meta	syntax/automachine.h	/^	struct machine_meta$/;"	s	class:automachine	access:public
automachine::machine_meta::machine_meta	syntax/automachine.h	/^		machine_meta(int32 meta = -1)$/;"	f	struct:automachine::machine_meta	access:public	signature:(int32 meta = -1)
automachine::machine_meta::sid	syntax/automachine.h	/^		int32 sid;$/;"	m	struct:automachine::machine_meta	access:public
automachine::shared_sheet	syntax/automachine.h	/^	typedef kog::shared_ptr<sparsesheet> shared_sheet;$/;"	t	class:automachine	access:public
automachine::sheet_	syntax/automachine.h	/^	shared_sheet sheet_;$/;"	m	class:automachine	access:private
automachine::sheetrow	syntax/automachine.h	/^	class sheetrow : public kog::smart_vector<gotoitem>$/;"	c	class:automachine	inherits:kog::smart_vector	access:public
automachine::sheetrow::anychar	syntax/automachine.h	/^		enum { anychar, special, exclude };$/;"	e	enum:automachine::sheetrow::__anon127
automachine::sheetrow::eattype_	syntax/automachine.h	/^		int32 eattype_;$/;"	m	class:automachine::sheetrow	access:private
automachine::sheetrow::endings	syntax/automachine.h	/^		int32 endings() const {return isendings_;}$/;"	f	class:automachine::sheetrow	access:public	signature:() const
automachine::sheetrow::endings	syntax/automachine.h	/^		void endings(int32 t) { isendings_ = t; }$/;"	f	class:automachine::sheetrow	access:public	signature:(int32 t)
automachine::sheetrow::exclude	syntax/automachine.h	/^		enum { anychar, special, exclude };$/;"	e	enum:automachine::sheetrow::__anon127
automachine::sheetrow::isendings_	syntax/automachine.h	/^		int32 isendings_;$/;"	m	class:automachine::sheetrow	access:private
automachine::sheetrow::more	syntax/automachine.h	/^		void more(void* m) { more_ = m;}$/;"	f	class:automachine::sheetrow	access:public	signature:(void* m)
automachine::sheetrow::more	syntax/automachine.h	/^		void* more() const { return more_; }$/;"	f	class:automachine::sheetrow	access:public	signature:() const
automachine::sheetrow::more_	syntax/automachine.h	/^		void* more_;$/;"	m	class:automachine::sheetrow	access:private
automachine::sheetrow::sheetrow	syntax/automachine.h	/^		sheetrow()$/;"	f	class:automachine::sheetrow	access:public	signature:()
automachine::sheetrow::sheetrow	syntax/automachine.h	/^		sheetrow(int32 etype, int32 ise, void* morei)$/;"	f	class:automachine::sheetrow	access:public	signature:(int32 etype, int32 ise, void* morei)
automachine::sheetrow::special	syntax/automachine.h	/^		enum { anychar, special, exclude };$/;"	e	enum:automachine::sheetrow::__anon127
automachine::sheetrow::type	syntax/automachine.h	/^		int32 type() const { return eattype_; }$/;"	f	class:automachine::sheetrow	access:public	signature:() const
automachine::sheetrow::type	syntax/automachine.h	/^		void type(int32 t) { eattype_ = t; }$/;"	f	class:automachine::sheetrow	access:public	signature:(int32 t)
automachine::sheetrow::v	syntax/automachine.h	/^		typedef kog::smart_vector<gotoitem> v;$/;"	t	class:automachine::sheetrow	access:private
automachine::sparsesheet	syntax/automachine.h	/^	typedef kog::smart_vector<sheetrow> sparsesheet;$/;"	t	class:automachine	access:public
automachine::sstate_	syntax/automachine.h	/^	int sstate_; \/\/ start state$/;"	m	class:automachine	access:protected
automachine::swap	syntax/automachine.h	/^	void swap(automachine& other)$/;"	f	class:automachine	access:public	signature:(automachine& other)
automachine::tstring	syntax/automachine.h	/^	typedef sc::tstring tstring;$/;"	t	class:automachine	access:public
automachine::~automachine	syntax/automachine.cpp	/^automachine::~automachine()$/;"	f	class:automachine	signature:()
automachine::~automachine	syntax/automachine.h	/^	virtual ~automachine();$/;"	p	class:automachine	access:public	signature:()
aword	compiler/compiler.cpp	/^	const tchar* aword;$/;"	m	struct:split_separators	file:	access:public
bReader	third_party/xml/Markup.cpp	/^	bool bReader;$/;"	m	struct:PathPos	file:	access:private
back	include/arrayX.h	/^	const_reference back() const { return _buf[_Length - 1]; }$/;"	f	struct:SmartArray	access:public	signature:() const
back	include/arrayX.h	/^	const_reference back() const$/;"	f	class:smart_vector	access:public	signature:() const
back	include/arrayX.h	/^	reference back() { return _buf[_Length - 1]; }$/;"	f	struct:SmartArray	access:public	signature:()
back	include/arrayX.h	/^	reference back()$/;"	f	class:smart_vector	access:public	signature:()
backward	include/iteratorX.h	/^	_Myt& backward()$/;"	f	struct:iterator_pair	access:protected	signature:()
backward	include/iteratorX.h	/^	static array_iterator& backward(array_iterator& aniterator, distance_type dis = 1)$/;"	f	struct:array_iterator	access:protected	signature:(array_iterator& aniterator, distance_type dis = 1)
backward	include/tree.h	/^		void backward(_Myt& iter)$/;"	f	struct:tree::_Const_iterator	access:protected	signature:(_Myt& iter)
base	include/stringX.h	/^	_Mybase& base()$/;"	f	class:xstring_basic	access:public	signature:()
base	include/stringX.h	/^	const _Mybase& base() const$/;"	f	class:xstring_basic	access:public	signature:() const
base	tmp/protected.cpp	/^class base$/;"	c	file:
base::f	tmp/protected.cpp	/^	void f()$/;"	f	class:base	access:public	signature:()
basic_stringbuffer	include/stringX.h	/^class basic_stringbuffer : public std::basic_ostringstream<_Elem, _Traits, _Ax>$/;"	c	inherits:std::basic_ostringstream
basicalg_test	test/basicalgorithmtest.cpp	/^NEW_UNITTEST(basicalg_test);$/;"	v
basicalg_test	test/basicalgorithmtest.cpp	/^class basicalg_test : public sc::unittest$/;"	c	file:	inherits:sc::unittest
basicalg_test::fin_	test/basicalgorithmtest.cpp	/^	std::string fin_;$/;"	m	class:basicalg_test	file:	access:private
basicalg_test::fout_	test/basicalgorithmtest.cpp	/^	std::string fout_;$/;"	m	class:basicalg_test	file:	access:private
basicalg_test::init	test/basicalgorithmtest.cpp	/^	\/* overwrite *\/ virtual void init(int argc, const char* argv[])$/;"	f	class:basicalg_test	file:	access:private	signature:(int argc, const char* argv[])
basicalg_test::run_test	test/basicalgorithmtest.cpp	/^	\/* overwrite *\/ virtual void run_test()$/;"	f	class:basicalg_test	file:	access:private	signature:()
basicalg_test::test_grammar	test/basicalgorithmtest.cpp	/^	void test_grammar(tinygrammar& gin)$/;"	f	class:basicalg_test	file:	access:private	signature:(tinygrammar& gin)
begin	include/arrayX.h	/^	const_iterator begin() const { return const_iterator(_buf, _Length); }$/;"	f	struct:SmartArray	access:public	signature:() const
begin	include/arrayX.h	/^	const_iterator begin() const { return const_iterator(_values[0], Length); }$/;"	f	struct:SmartMatrix	access:public	signature:() const
begin	include/arrayX.h	/^	const_iterator begin() const { return const_iterator(buf_.values, buf_.count); }$/;"	f	class:smart_vector	access:public	signature:() const
begin	include/arrayX.h	/^	iterator begin() { return iterator(_buf, _Length); }$/;"	f	struct:SmartArray	access:public	signature:()
begin	include/arrayX.h	/^	iterator begin() { return iterator(_values[0], Length); }$/;"	f	struct:SmartMatrix	access:public	signature:()
begin	include/arrayX.h	/^	iterator begin() { return iterator(buf_.values, buf_.count); }$/;"	f	class:smart_vector	access:public	signature:()
begin	include/functionalX.h	/^	iterator begin() const$/;"	f	struct:range_t	access:public	signature:() const
begin	include/heapX.h	/^	const_iterator begin() const { return c_.begin(); }$/;"	f	class:heap	access:public	signature:() const
begin	include/heapX.h	/^	iterator begin() { return c_.begin(); }$/;"	f	class:heap	access:public	signature:()
begin	include/sortc.h	/^	const_iterator begin() const { return c_.begin(); }$/;"	f	class:sortc	access:public	signature:() const
begin	include/sortc.h	/^	iterator begin() { return c_.begin(); }$/;"	f	class:sortc	access:public	signature:()
begin	include/stringXF.h	/^    const_iterator begin()$/;"	f	struct:string_split_t	access:public	signature:()
begin	third_party/callstack/stacktrace.h	/^		const_iterator  begin() const$/;"	f	class:kog::callstack::trace	access:public	signature:() const
begin	third_party/callstack/stacktrace.h	/^		const_iterator begin() const { return stack_.begin(); }$/;"	f	class:kog::callstack::trace	access:public	signature:() const
begin	third_party/callstack/win32/debug_tool.cpp	/^			const_iterator begin() const$/;"	f	class:dbsoft::detail::callstack_Imp	access:public	signature:() const
begin	third_party/callstack/win32/debug_tool.cpp	/^	callstack::const_iterator callstack::begin() const$/;"	f	class:dbsoft::callstack	signature:() const
begin	third_party/callstack/win32/debug_tool.hpp	/^		const_iterator  begin() const;$/;"	p	class:dbsoft::callstack	access:public	signature:() const
binary	include/functionalX.h	/^struct binary$/;"	s
binary	include/functionalX.h	/^struct binary<0>$/;"	s
binary::value	include/functionalX.h	/^	const static unsigned int value = 0;$/;"	m	struct:binary	access:public
binary::value	include/functionalX.h	/^	const static unsigned int value = binary<_BinaryValue \/ 10>::value * 2 + _BinaryValue % 10;$/;"	m	struct:binary	access:public
binary_function_adptor	include/functionalX.h	/^inline binary_function_adptor_t<_Arg1, _Arg2, _Result> binary_function_adptor(_Result (*_Func)(_Arg1, _Arg2))$/;"	f	signature:(_Result (_Func)_Arg1, _Arg2))
binary_function_adptor_t	include/functionalX.h	/^	binary_function_adptor_t(_FunType pfun)$/;"	f	struct:binary_function_adptor_t	access:public	signature:(_FunType pfun)
binary_function_adptor_t	include/functionalX.h	/^struct binary_function_adptor_t : public std::binary_function<_Arg1, _Arg2, _Result>$/;"	s	inherits:std::binary_function
binary_function_adptor_t::_FunType	include/functionalX.h	/^	typedef _Result (*_FunType)(_Arg1, _Arg2);$/;"	t	struct:binary_function_adptor_t	access:public
binary_function_adptor_t::_pFun	include/functionalX.h	/^	_FunType _pFun;$/;"	m	struct:binary_function_adptor_t	access:private
binary_function_adptor_t::binary_function_adptor_t	include/functionalX.h	/^	binary_function_adptor_t(_FunType pfun)$/;"	f	struct:binary_function_adptor_t	access:public	signature:(_FunType pfun)
binary_function_adptor_t::operator ()	include/functionalX.h	/^	_Result operator()(_Arg1 arg1, _Arg2 arg2) const$/;"	f	struct:binary_function_adptor_t	access:public	signature:(_Arg1 arg1, _Arg2 arg2) const
bitmap	tmp/back/simplepool.h	/^	typedef unsigned int bitmap;$/;"	t	class:mempool	access:public
block	include/arrayX.h	/^		block(pointer ptr = NULL, size_type c = 0, bool d = true)$/;"	f	struct:smart_vector::block	access:public	signature:(pointer ptr = NULL, size_type c = 0, bool d = true)
block	include/arrayX.h	/^	struct block$/;"	s	class:smart_vector	access:protected
brace_stage	galgorithm/regex2nfa.cpp	/^	int brace_stage(int L, char rc\/*, int& end*\/)$/;"	f	struct:parsecontent	access:public	signature:(int L, char rc )
brace_stage	tmp/back/regex2nfa.cpp	/^	int brace_stage(int L, char rc\/*, int& end*\/)$/;"	f	struct:parsecontent	access:public	signature:(int L, char rc )
bucket	include/buckethash.h	/^struct bucket : public std::list<_T>$/;"	s	inherits:std::list
bucket_const_iterator	include/buckethash.h	/^	typedef typename bucket<keyvalue>::const_iterator bucket_const_iterator;$/;"	t	class:buckethash	access:private
bucket_iterator	include/buckethash.h	/^	typedef typename bucket<keyvalue>::iterator bucket_iterator;$/;"	t	class:buckethash	access:private
buckethash	include/buckethash.h	/^	buckethash(std::size_t _MaxLength)$/;"	f	class:buckethash	access:public	signature:(std::size_t _MaxLength)
buckethash	include/buckethash.h	/^class buckethash$/;"	c
buckethash::_Const_iterator	include/buckethash.h	/^	struct _Const_iterator$/;"	s	class:buckethash	access:public
buckethash::_Const_iterator::_Const_iterator	include/buckethash.h	/^		_Const_iterator()$/;"	f	struct:buckethash::_Const_iterator	access:public	signature:()
buckethash::_Const_iterator::_Const_iterator	include/buckethash.h	/^		_Const_iterator(const buckethash<_K, _V, _K2I>* p)$/;"	f	struct:buckethash::_Const_iterator	access:private	signature:(const buckethash<_K, _V, _K2I>* p)
buckethash::_Const_iterator::iter	include/buckethash.h	/^		bucket_const_iterator iter;$/;"	m	struct:buckethash::_Const_iterator	access:private
buckethash::_Const_iterator::kid	include/buckethash.h	/^		size_t kid;$/;"	m	struct:buckethash::_Const_iterator	access:private
buckethash::_Const_iterator::ref	include/buckethash.h	/^		const buckethash<_K, _V, _K2I>* ref;$/;"	m	struct:buckethash::_Const_iterator	access:private
buckethash::_bucket_Locate	include/buckethash.h	/^	bucket_const_iterator _bucket_Locate(size_t kid, const key& k) const$/;"	f	class:buckethash	access:private	signature:(size_t kid, const key& k) const
buckethash::_bucket_Locate	include/buckethash.h	/^	bucket_iterator _bucket_Locate(size_t kid, const key& k)$/;"	f	class:buckethash	access:private	signature:(size_t kid, const key& k)
buckethash::_bucket_index	include/buckethash.h	/^	size_t _bucket_index(const key& k) const$/;"	f	class:buckethash	access:private	signature:(const key& k) const
buckethash::bucket_const_iterator	include/buckethash.h	/^	typedef typename bucket<keyvalue>::const_iterator bucket_const_iterator;$/;"	t	class:buckethash	access:private
buckethash::bucket_iterator	include/buckethash.h	/^	typedef typename bucket<keyvalue>::iterator bucket_iterator;$/;"	t	class:buckethash	access:private
buckethash::buckethash	include/buckethash.h	/^	buckethash(std::size_t _MaxLength)$/;"	f	class:buckethash	access:public	signature:(std::size_t _MaxLength)
buckethash::buckets_	include/buckethash.h	/^	kog::smart_vector<bucket<keyvalue> > buckets_;$/;"	m	class:buckethash	access:private
buckethash::find	include/buckethash.h	/^	const value* find(const key& k) const$/;"	f	class:buckethash	access:public	signature:(const key& k) const
buckethash::find	include/buckethash.h	/^	value* find(const key& k)$/;"	f	class:buckethash	access:public	signature:(const key& k)
buckethash::insert	include/buckethash.h	/^	void insert(const key& k, const value& v)$/;"	f	class:buckethash	access:public	signature:(const key& k, const value& v)
buckethash::insert	include/buckethash.h	/^	void insert(const keyvalue& kv)$/;"	f	class:buckethash	access:public	signature:(const keyvalue& kv)
buckethash::key	include/buckethash.h	/^	typedef  _K key;$/;"	t	class:buckethash	access:public
buckethash::keyvalue	include/buckethash.h	/^	typedef std::pair<key, value> keyvalue;$/;"	t	class:buckethash	access:private
buckethash::operator []	include/buckethash.h	/^	const value& operator[](const key& k) const$/;"	f	class:buckethash	access:public	signature:(const key& k) const
buckethash::operator []	include/buckethash.h	/^	value& operator[](const key& k)$/;"	f	class:buckethash	access:public	signature:(const key& k)
buckethash::remove	include/buckethash.h	/^	void remove(const key& k)$/;"	f	class:buckethash	access:public	signature:(const key& k)
buckethash::value	include/buckethash.h	/^	typedef  _V value;$/;"	t	class:buckethash	access:public
buckethash::value_reference	include/buckethash.h	/^	typedef  value& value_reference;$/;"	t	class:buckethash	access:public
buckets_	include/buckethash.h	/^	kog::smart_vector<bucket<keyvalue> > buckets_;$/;"	m	class:buckethash	access:private
buf	compiler/compiler.cpp	/^	tstring buf;$/;"	m	struct:split_separators	file:	access:public
buf	galgorithm/regex2nfa.cpp	/^	std::deque<int> buf;$/;"	m	struct:parsecontent	file:	access:public
buf	tmp/back/regex2nfa.cpp	/^	std::deque<int> buf;$/;"	m	struct:parsecontent	file:	access:public
buf_	include/arrayX.h	/^	block buf_;$/;"	m	class:smart_vector	access:private
byte	include/basic_types.h	/^typedef uchar byte;$/;"	t
c_	include/heapX.h	/^	_C c_;$/;"	m	class:heap	access:protected
c_	include/sortc.h	/^	_C c_;$/;"	m	class:sortc	access:protected
calculateValue	include/mathX.h	/^		static T calculateValue(const T* xBegin, const T* yBegin, const size_t nSize, int index, const T& val)$/;"	f	class:math::interpolate	access:public	signature:(const T* xBegin, const T* yBegin, const size_t nSize, int index, const T& val)
callstack	third_party/callstack/stacktrace.h	/^namespace callstack$/;"	n	namespace:kog
callstack	third_party/callstack/stacktrace.h	/^namespace callstack{$/;"	n	namespace:kog
callstack	third_party/callstack/win32/debug_tool.cpp	/^	callstack::callstack():m_spImp( new detail::callstack_Imp() )$/;"	f	class:dbsoft::callstack	signature:()
callstack	third_party/callstack/win32/debug_tool.hpp	/^		callstack();$/;"	p	class:dbsoft::callstack	access:public	signature:()
callstack	third_party/callstack/win32/debug_tool.hpp	/^	class callstack$/;"	c	namespace:dbsoft
callstack_Imp	third_party/callstack/win32/debug_tool.cpp	/^			callstack_Imp();$/;"	p	class:dbsoft::detail::callstack_Imp	file:	access:public	signature:()
callstack_Imp	third_party/callstack/win32/debug_tool.cpp	/^		callstack_Imp::callstack_Imp()$/;"	f	class:dbsoft::detail::callstack_Imp	signature:()
callstack_Imp	third_party/callstack/win32/debug_tool.cpp	/^		class callstack_Imp$/;"	c	namespace:dbsoft::detail	file:
callstack_ptr	third_party/callstack/win32/debug_tool.cpp	/^			typedef callstack::callstack_ptr                       callstack_ptr;$/;"	t	class:dbsoft::detail::callstack_Imp	file:	access:public
callstack_ptr	third_party/callstack/win32/debug_tool.hpp	/^		typedef kog::shared_ptr<callstack>        callstack_ptr;$/;"	t	class:dbsoft::callstack	access:public
char_type	third_party/regex/xregex.h	/^	typedef char char_type;$/;"	t	class:stringX::xregex	access:public
check	compiler/compiler.cpp	/^void compiler::check(const std::string& fname)$/;"	f	class:compiler	signature:(const std::string& fname)
check	compiler/compiler.h	/^	void check(const std::string& fname);$/;"	p	class:compiler	access:public	signature:(const std::string& fname)
children	include/tree.h	/^		link* children;$/;"	m	struct:_tree_node::tnode	access:public
choos_t	include/mplX.h	/^struct choos_t {};$/;"	s
choos_t	include/mplX.h	/^struct choos_t<false, _TrueType, _FalseType>$/;"	s
choos_t	include/mplX.h	/^struct choos_t<true, _TrueType, _FalseType>$/;"	s
choos_t::type	include/mplX.h	/^	typedef _FalseType type;$/;"	t	struct:choos_t	access:public
choos_t::type	include/mplX.h	/^	typedef _TrueType type;$/;"	t	struct:choos_t	access:public
class_type	include/functionalX.h	/^	typedef _Tc class_type;$/;"	t	struct:mem_value_t	access:public
class_type	include/mplX.h	/^	typedef _Tc class_type;$/;"	t	struct:parse_class_value_type	access:public
class_type	include/mplX.h	/^	typedef _Tx class_type;$/;"	t	struct:parse_class_value_type	access:public
clear	include/logger.h	/^	void clear()$/;"	f	class:logger	access:private	signature:()
clone	syntax/global_values.h	/^		object<_Tx>* clone() const$/;"	f	class:refobject::object	access:public	signature:() const
clone	syntax/global_values.h	/^		virtual holder* clone() const = 0;$/;"	p	class:refobject::holder	access:public	signature:() const
closure	galgorithm/eclosures.h	/^	typedef kog::smart_vector<int32> closure;$/;"	t	class:eclosure	access:public
closure_array	galgorithm/eclosures.h	/^	typedef kog::smart_vector<closure> closure_array;$/;"	t	class:eclosure	access:public
closures	galgorithm/lranalyse.cpp	/^	eclosure::closure_array closures;$/;"	m	struct:AlgorithmArg	file:	access:public
cnode_	include/markuputils.h	/^	node cnode_;$/;"	m	class:ifile	access:private
codemodule	compiler/module.h	/^class codemodule : virtual public module$/;"	c	inherits:module
codemodule::new_tuple	compiler/module.cpp	/^tuple* codemodule::new_tuple(const operation* oper, const object* src, const object* dst)$/;"	f	class:codemodule	signature:(const operation* oper, const object* src, const object* dst)
codemodule::new_tuple	compiler/module.cpp	/^tuple* codemodule::new_tuple(const operation* oper, const object* src1, const object* src2, const object* dst)$/;"	f	class:codemodule	signature:(const operation* oper, const object* src1, const object* src2, const object* dst)
codemodule::new_tuple	compiler/module.h	/^    tuple* new_tuple(const operation* oper, const object* src, const object* dst);$/;"	p	class:codemodule	access:public	signature:(const operation* oper, const object* src, const object* dst)
codemodule::new_tuple	compiler/module.h	/^    tuple* new_tuple(const operation* oper, const object* src1, const object* src2, const object* dst);$/;"	p	class:codemodule	access:public	signature:(const operation* oper, const object* src1, const object* src2, const object* dst)
codemodule::tuples_	compiler/module.h	/^    std::deque<tuple*> tuples_;$/;"	m	class:codemodule	access:protected
col	include/arrayX.h	/^	size_t col() const { return _Col; }$/;"	f	struct:SmartMatrix	access:public	signature:() const
compile	asmgenerate.h	/^NAMESPACE_BEGIN(compile);$/;"	v
compile::doc::streamsplit::streamsplit	compiler/extract.cpp	/^compile::doc::streamsplit::streamsplit()$/;"	f	class:compile::doc::streamsplit	signature:()
compile::doc::streamsplit::~streamsplit	compiler/extract.cpp	/^compile::doc::streamsplit::~streamsplit()$/;"	f	class:compile::doc::streamsplit	signature:()
compiler	compiler/compiler.cpp	/^compiler::compiler()$/;"	f	class:compiler	signature:()
compiler	compiler/compiler.h	/^	compiler();$/;"	p	class:compiler	access:public	signature:()
compiler	compiler/compiler.h	/^class compiler : public kog::singleton<compiler>$/;"	c	inherits:kog::singleton
compiler	tmp/back/compiler.h	/^class compiler : public kog::singleton<compiler>$/;"	c	inherits:kog::singleton
compiler::automachine	compiler/compiler.h	/^	typedef compile::automachine automachine;$/;"	t	class:compiler	access:public
compiler::check	compiler/compiler.cpp	/^void compiler::check(const std::string& fname)$/;"	f	class:compiler	signature:(const std::string& fname)
compiler::check	compiler/compiler.h	/^	void check(const std::string& fname);$/;"	p	class:compiler	access:public	signature:(const std::string& fname)
compiler::compiler	compiler/compiler.cpp	/^compiler::compiler()$/;"	f	class:compiler	signature:()
compiler::compiler	compiler/compiler.h	/^	compiler();$/;"	p	class:compiler	access:public	signature:()
compiler::generate_asm	compiler/compiler.cpp	/^void compiler::generate_asm(const std::string& asmfile)$/;"	f	class:compiler	signature:(const std::string& asmfile)
compiler::generate_asm	compiler/compiler.h	/^    void generate_asm(const std::string& asmfile);$/;"	p	class:compiler	access:public	signature:(const std::string& asmfile)
compiler::get_all_machines	compiler/compiler.cpp	/^int compiler::get_all_machines(std::list<machine>& mlist)$/;"	f	class:compiler	signature:(std::list<machine>& mlist)
compiler::get_all_machines	compiler/compiler.h	/^	static int get_all_machines(std::list<compile::doc::machine>& mlist);$/;"	p	class:compiler	access:public	signature:(std::list<compile::doc::machine>& mlist)
compiler::get_all_machines	tmp/back/compiler.cpp	/^int compiler::get_all_machines(std::list<state_machine*>& mlist)$/;"	f	class:compiler	signature:(std::list<state_machine*>& mlist)
compiler::get_all_machines	tmp/back/compiler.h	/^	static int get_all_machines(std::list<state_machine*>& mlist);$/;"	p	class:compiler	access:public	signature:(std::list<state_machine*>& mlist)
compiler::get_machine	compiler/compiler.cpp	/^automachine& compiler::get_machine(const std::string& machine_name)$/;"	f	class:compiler	signature:(const std::string& machine_name)
compiler::get_machine	compiler/compiler.h	/^    static automachine& get_machine(const std::string& machine_name);$/;"	p	class:compiler	access:public	signature:(const std::string& machine_name)
compiler::get_number_machine	compiler/compiler.cpp	/^state_machine compiler::get_number_machine()$/;"	f	class:compiler	signature:()
compiler::get_number_machine	compiler/compiler.h	/^	static state_machine get_number_machine();$/;"	p	class:compiler	access:public	signature:()
compiler::get_number_machine	tmp/back/compiler.cpp	/^state_machine compiler::get_number_machine()$/;"	f	class:compiler	signature:()
compiler::get_number_machine	tmp/back/compiler.h	/^	static state_machine get_number_machine();$/;"	p	class:compiler	access:public	signature:()
compiler::get_string_machine	compiler/compiler.cpp	/^state_machine compiler::get_string_machine()$/;"	f	class:compiler	signature:()
compiler::get_string_machine	compiler/compiler.h	/^	static state_machine get_string_machine();$/;"	p	class:compiler	access:public	signature:()
compiler::get_string_machine	tmp/back/compiler.cpp	/^state_machine compiler::get_string_machine()$/;"	f	class:compiler	signature:()
compiler::get_string_machine	tmp/back/compiler.h	/^	static state_machine get_string_machine();$/;"	p	class:compiler	access:public	signature:()
compiler::get_symbol_machine	compiler/compiler.cpp	/^state_machine compiler::get_symbol_machine()$/;"	f	class:compiler	signature:()
compiler::get_symbol_machine	compiler/compiler.h	/^	static state_machine get_symbol_machine();$/;"	p	class:compiler	access:public	signature:()
compiler::get_symbol_machine	tmp/back/compiler.cpp	/^state_machine compiler::get_symbol_machine()$/;"	f	class:compiler	signature:()
compiler::get_symbol_machine	tmp/back/compiler.h	/^	static state_machine get_symbol_machine();$/;"	p	class:compiler	access:public	signature:()
compiler::getiml	compiler/compiler.cpp	/^compile::interlanguage& compiler::getiml()$/;"	f	class:compiler	signature:()
compiler::getiml	compiler/compiler.h	/^    static compile::interlanguage& getiml();$/;"	p	class:compiler	access:public	signature:()
compiler::iml_	compiler/compiler.h	/^    kog::shared_ptr<compile::interlanguage> iml_;$/;"	m	class:compiler	access:private
compiler::initialization	compiler/compiler.cpp	/^void compiler::initialization()$/;"	f	class:compiler	signature:()
compiler::initialization	compiler/compiler.h	/^	void initialization();$/;"	p	class:compiler	access:public	signature:()
compiler::initmachines	tmp/back/compiler.cpp	/^void compiler::initmachines()$/;"	f	class:compiler	signature:()
compiler::initmachines	tmp/back/compiler.h	/^	void initmachines();$/;"	p	class:compiler	access:public	signature:()
compiler::is_keywords	compiler/compiler.cpp	/^int32 compiler::is_keywords(const std::string& s) const$/;"	f	class:compiler	signature:(const std::string& s) const
compiler::is_keywords	compiler/compiler.h	/^	sc::int32 is_keywords(const std::string& s) const;$/;"	p	class:compiler	access:private	signature:(const std::string& s) const
compiler::is_separator	compiler/compiler.cpp	/^bool compiler::is_separator(int32 elem)$/;"	f	class:compiler	signature:(int32 elem)
compiler::is_separator	compiler/compiler.h	/^	static bool is_separator(sc::int32 elem);$/;"	p	class:compiler	access:public	signature:(sc::int32 elem)
compiler::is_separator	tmp/back/compiler.cpp	/^bool compiler::is_separator(int32 elem)$/;"	f	class:compiler	signature:(int32 elem)
compiler::is_separator	tmp/back/compiler.h	/^	static bool is_separator(sc::int32 elem);$/;"	p	class:compiler	access:public	signature:(sc::int32 elem)
compiler::keywords	compiler/compiler.h	/^	kog::buckethash<std::string, sc::int32, string_2_int> keywords;$/;"	m	class:compiler	access:private
compiler::lalr1machine	compiler/compiler.h	/^	typedef compile::lalr1machine lalr1machine;$/;"	t	class:compiler	access:public
compiler::machines	compiler/compiler.h	/^	std::map<std::string, compile::doc::machine> machines;$/;"	m	class:compiler	access:private
compiler::machines	tmp/back/compiler.h	/^	std::map<std::string, state_machine> machines;$/;"	m	class:compiler	access:private
compiler::printablechars	compiler/compiler.h	/^	kog::smart_vector<sc::int32> printablechars;$/;"	m	class:compiler	access:private
compiler::printablechars	tmp/back/compiler.h	/^	kog::smart_vector<sc::int32> printablechars;$/;"	m	class:compiler	access:private
compiler::separators	compiler/compiler.h	/^	kog::smart_vector<sc::int32> separators;$/;"	m	class:compiler	access:private
compiler::separators	tmp/back/compiler.h	/^	kog::smart_vector<sc::int32> separators;$/;"	m	class:compiler	access:private
compiler::sepsid	compiler/compiler.h	/^	kog::tree<sc::int32> sepsid;$/;"	m	class:compiler	access:private
compiler::state_machine	compiler/compiler.h	/^	typedef compile::state_machine state_machine;$/;"	t	class:compiler	access:public
compiler::state_machine	tmp/back/compiler.h	/^	typedef compile::state_machine state_machine;$/;"	t	class:compiler	access:public
compiler::tg	compiler/compiler.h	/^	compile::tinygrammar tg;$/;"	m	class:compiler	access:private
compiler::~compiler	compiler/compiler.cpp	/^compiler::~compiler()$/;"	f	class:compiler	signature:()
compiler::~compiler	compiler/compiler.h	/^    ~compiler();$/;"	p	class:compiler	access:public	signature:()
composite_function	include/functionalX.h	/^composite_function2_t<_Fx, _Fy, _Fz> composite_function(const _Fx& fx, const _Fy& fy, const _Fz& fz)$/;"	f	signature:(const _Fx& fx, const _Fy& fy, const _Fz& fz)
composite_function	include/functionalX.h	/^composite_function_t<_Fx, _Fy> composite_function(const _Fx& fx, const _Fy& fy)$/;"	f	signature:(const _Fx& fx, const _Fy& fy)
composite_function2_t	include/functionalX.h	/^	composite_function2_t() {}$/;"	f	struct:composite_function2_t	access:public	signature:()
composite_function2_t	include/functionalX.h	/^	composite_function2_t(const _Fx& fx, const _Fy& fy, const _Fz& fz)$/;"	f	struct:composite_function2_t	access:public	signature:(const _Fx& fx, const _Fy& fy, const _Fz& fz)
composite_function2_t	include/functionalX.h	/^struct composite_function2_t :$/;"	s	inherits:std::binary_function
composite_function2_t::_Myt	include/functionalX.h	/^	typedef composite_function2_t<_Fx, _Fy, _Fz> _Myt;$/;"	t	struct:composite_function2_t	access:public
composite_function2_t::_fx	include/functionalX.h	/^	_Fx _fx;$/;"	m	struct:composite_function2_t	access:protected
composite_function2_t::_fy	include/functionalX.h	/^	_Fy _fy;$/;"	m	struct:composite_function2_t	access:protected
composite_function2_t::_fz	include/functionalX.h	/^	_Fz _fz;$/;"	m	struct:composite_function2_t	access:protected
composite_function2_t::composite_function2_t	include/functionalX.h	/^	composite_function2_t() {}$/;"	f	struct:composite_function2_t	access:public	signature:()
composite_function2_t::composite_function2_t	include/functionalX.h	/^	composite_function2_t(const _Fx& fx, const _Fy& fy, const _Fz& fz)$/;"	f	struct:composite_function2_t	access:public	signature:(const _Fx& fx, const _Fy& fy, const _Fz& fz)
composite_function2_t::first_argument_type	include/functionalX.h	/^	typedef typename _Fx::argument_type first_argument_type;$/;"	t	struct:composite_function2_t	access:public
composite_function2_t::operator ()	include/functionalX.h	/^	result_type operator()(const first_argument_type& _arg1, const second_argument_type& _arg2) const$/;"	f	struct:composite_function2_t	access:public	signature:(const first_argument_type& _arg1, const second_argument_type& _arg2) const
composite_function2_t::operator ()	include/functionalX.h	/^	result_type operator()(first_argument_type& _arg1, second_argument_type& _arg2) const$/;"	f	struct:composite_function2_t	access:public	signature:(first_argument_type& _arg1, second_argument_type& _arg2) const
composite_function2_t::result_type	include/functionalX.h	/^	typedef typename _Fz::result_type result_type;$/;"	t	struct:composite_function2_t	access:public
composite_function2_t::second_argument_type	include/functionalX.h	/^	typedef typename _Fy::argument_type second_argument_type;$/;"	t	struct:composite_function2_t	access:public
composite_function_t	include/functionalX.h	/^	composite_function_t() {}$/;"	f	struct:composite_function_t	access:public	signature:()
composite_function_t	include/functionalX.h	/^	composite_function_t(const _Fx& fx, const _Fy& fy)$/;"	f	struct:composite_function_t	access:public	signature:(const _Fx& fx, const _Fy& fy)
composite_function_t	include/functionalX.h	/^struct composite_function_t :$/;"	s	inherits:std::unary_function
composite_function_t::_Myt	include/functionalX.h	/^	typedef composite_function_t<_Fx, _Fy> _Myt;$/;"	t	struct:composite_function_t	access:public
composite_function_t::_fx	include/functionalX.h	/^	_Fx _fx;$/;"	m	struct:composite_function_t	access:protected
composite_function_t::_fy	include/functionalX.h	/^	_Fy _fy;$/;"	m	struct:composite_function_t	access:protected
composite_function_t::argument_type	include/functionalX.h	/^	typedef typename _Fx::argument_type argument_type;$/;"	t	struct:composite_function_t	access:public
composite_function_t::composite_function_t	include/functionalX.h	/^	composite_function_t() {}$/;"	f	struct:composite_function_t	access:public	signature:()
composite_function_t::composite_function_t	include/functionalX.h	/^	composite_function_t(const _Fx& fx, const _Fy& fy)$/;"	f	struct:composite_function_t	access:public	signature:(const _Fx& fx, const _Fy& fy)
composite_function_t::operator ()	include/functionalX.h	/^	result_type operator()(argument_type& _arg) const$/;"	f	struct:composite_function_t	access:public	signature:(argument_type& _arg) const
composite_function_t::operator ()	include/functionalX.h	/^	result_type operator()(const argument_type& _arg) const$/;"	f	struct:composite_function_t	access:public	signature:(const argument_type& _arg) const
composite_function_t::result_type	include/functionalX.h	/^	typedef typename _Fy::result_type result_type;$/;"	t	struct:composite_function_t	access:public
const_iterator	include/arrayX.h	/^	typedef array_iterator<const value_type> const_iterator;$/;"	t	class:smart_vector	access:public
const_iterator	include/arrayX.h	/^	typedef array_iterator<const value_type> const_iterator;$/;"	t	struct:SmartArray	access:public
const_iterator	include/arrayX.h	/^	typedef array_iterator<const value_type> const_iterator;$/;"	t	struct:SmartMatrix	access:public
const_iterator	include/functionalX.h	/^	typedef typename mpl::add_const<_Iter>::const_value_type const_iterator;$/;"	t	struct:range_t	access:public
const_iterator	include/heapX.h	/^	typedef typename _C::const_iterator const_iterator;$/;"	t	class:heap	access:public
const_iterator	include/memoryX.h	/^	typedef array_iterator<const value_type> const_iterator;$/;"	t	struct:memblock	access:public
const_iterator	include/sortc.h	/^	typedef typename _C::const_iterator const_iterator;$/;"	t	class:sortc	access:public
const_iterator	include/stringXF.h	/^    typedef _Const_iterator const_iterator;$/;"	t	struct:string_split_t	access:public
const_iterator	third_party/callstack/stacktrace.h	/^		typedef frame::const_iterator const_iterator;$/;"	t	class:kog::callstack::trace	access:public
const_iterator	third_party/callstack/stacktrace.h	/^		typedef std::vector<frame>::const_iterator const_iterator;$/;"	t	class:kog::callstack::trace	access:public
const_iterator	third_party/callstack/win32/debug_tool.cpp	/^			typedef callstack::const_iterator                      const_iterator;$/;"	t	class:dbsoft::detail::callstack_Imp	file:	access:public
const_iterator	third_party/callstack/win32/debug_tool.hpp	/^		typedef func_name_list::const_iterator         const_iterator;$/;"	t	class:dbsoft::callstack	access:public
const_link	include/tree.h	/^	typedef const tnode* const_link;$/;"	t	class:_tree_node	access:protected
const_link	include/tree.h	/^	typedef typename _Base::const_link const_link;$/;"	t	class:tree	access:public
const_pointer	include/arrayX.h	/^	typedef const _Ty* const_pointer;$/;"	t	struct:SmartArray	access:public
const_pointer	include/arrayX.h	/^	typedef const _Ty* const_pointer;$/;"	t	struct:SmartMatrix	access:public
const_pointer	include/arrayX.h	/^	typedef const value_type* const_pointer;$/;"	t	class:smart_vector	access:public
const_pointer	include/memoryX.h	/^	typedef const value_type* const_pointer;$/;"	t	struct:memblock	access:public
const_pointer	include/stringX.h	/^	typedef _Ctptr const_pointer;$/;"	t	class:xstring_basic	access:public
const_pointer	include/tree.h	/^		typedef const value_type* const_pointer;$/;"	t	struct:tree::_Const_iterator	access:public
const_ref_type	include/functionalX.h	/^	typedef const T& const_ref_type;$/;"	t	class:ref_obj	access:public
const_reference	include/arrayX.h	/^	typedef const value_type& const_reference;$/;"	t	class:smart_vector	access:public
const_reference	include/arrayX.h	/^	typedef const value_type& const_reference;$/;"	t	struct:SmartArray	access:public
const_reference	include/arrayX.h	/^	typedef const value_type& const_reference;$/;"	t	struct:SmartMatrix	access:public
const_reference	include/memoryX.h	/^	typedef const value_type& const_reference;$/;"	t	struct:memblock	access:public
const_reference	include/mplX.h	/^struct const_reference$/;"	s
const_reference	include/mplX.h	/^struct const_reference<_Tx&>$/;"	s
const_reference	include/mplX.h	/^struct const_reference<const _Tx&>$/;"	s
const_reference	include/mplX.h	/^struct const_reference<const _Tx>$/;"	s
const_reference	include/stringX.h	/^	typedef typename _Mybase::const_reference const_reference;$/;"	t	class:xstring_basic	access:public
const_reference	include/tree.h	/^		typedef const value_type& const_reference;$/;"	t	struct:tree::_Const_iterator	access:public
const_reference::type	include/mplX.h	/^	typedef const _Tx& type;$/;"	t	struct:const_reference	access:public
const_reference_type	include/functionalX.h	/^	typedef const _Ty& const_reference_type;$/;"	t	struct:mem_value_t	access:public
const_reverse_iterator	include/arrayX.h	/^	typedef std::reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:smart_vector	access:public
const_reverse_iterator	include/arrayX.h	/^	typedef std::reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	struct:SmartArray	access:public
const_reverse_iterator	include/arrayX.h	/^	typedef std::reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	struct:SmartMatrix	access:public
const_reverse_iterator	include/memoryX.h	/^	typedef std::reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	struct:memblock	access:public
const_type	include/iteratorX.h	/^	typedef array_iterator<typename mpl::add_const<_Tx>::type> const_type;$/;"	t	struct:array_iterator	access:public
const_type	include/mplX.h	/^	typedef const _Tx const_type;$/;"	t	struct:remove_const	access:public
const_type	include/tree.h	/^	typedef typename mpl::add_const<_Tx>::type const_type;$/;"	t	class:tree	access:public
contain	syntax/global_values.h	/^	bool contain(const std::string& name) const$/;"	f	class:global_values	access:public	signature:(const std::string& name) const
container_group	tmp/back/container_group.h	/^class container_group : public std::list<_Container>$/;"	c	inherits:std::list
container_group::invoke	tmp/back/container_group.h	/^	void invoke(_Fun _F) const$/;"	f	class:container_group	access:public	signature:(_Fun _F) const
container_group::invoke	tmp/back/container_group.h	/^	void invoke(_Fun _F)$/;"	f	class:container_group	access:public	signature:(_Fun _F)
content	compiler/lalr1machine.h	/^        const object* content;$/;"	m	struct:lalr1machine::lalr1meta	access:public
convert	include/stringXF.h	/^		static bool convert(const std::string& _Src, std::string& _Dst)$/;"	f	struct:Format::swcvt	access:public	signature:(const std::string& _Src, std::string& _Dst)
convert	include/stringXF.h	/^		static bool convert(const std::string& _Src, std::wstring& _Dst)$/;"	f	struct:Format::swcvt	access:public	signature:(const std::string& _Src, std::wstring& _Dst)
convert	include/stringXF.h	/^		static bool convert(const std::wstring& _Src, std::string& _Dst)$/;"	f	struct:Format::swcvt	access:public	signature:(const std::wstring& _Src, std::string& _Dst)
convert	include/stringXF.h	/^		static bool convert(const std::wstring& _Src, std::wstring& _Dst)$/;"	f	struct:Format::swcvt	access:public	signature:(const std::wstring& _Src, std::wstring& _Dst)
convert	include/stringXF.h	/^		static std::basic_string<_Dst_Elem> convert(const std::basic_string<_Src_Elem>& _Src)$/;"	f	struct:Format::swcvt	access:public	signature:(const std::basic_string<_Src_Elem>& _Src)
convert	include/stringXF.h	/^		static std::string convert(const std::wstring& _Src)$/;"	f	struct:Format::swcvt	access:public	signature:(const std::wstring& _Src)
convert	include/stringXF.h	/^		static std::wstring convert(const std::string& _Src)$/;"	f	struct:Format::swcvt	access:public	signature:(const std::string& _Src)
convert	syntax/global_values.cpp	/^_T convert(const std::basic_string<_Char>& v)$/;"	f	signature:(const std::basic_string<_Char>& v)
convert_error	third_party/regex/xregex.h	/^	convert_error(const _Tx& _Src, const _Ty& _Dst)$/;"	f	class:stringX::convert_error	access:public	signature:(const _Tx& _Src, const _Ty& _Dst)
convert_error	third_party/regex/xregex.h	/^	convert_error(const std::string& error_msg)$/;"	f	class:stringX::convert_error	access:public	signature:(const std::string& error_msg)
convert_error	third_party/regex/xregex.h	/^class convert_error : public std::runtime_error$/;"	c	namespace:stringX	inherits:std::runtime_error
count	include/arrayX.h	/^		size_t count;$/;"	m	struct:smart_vector::block	access:public
count	include/shared_ptr.h	/^		unsigned* count; \/\/$/;"	m	class:shared_ptr	access:private
count	include/shared_ptr.h	/^		unsigned* count;$/;"	m	class:weak_ptr	access:private
cpmoile	asmgenerate.h	/^NAMESPACE_END(cpmoile); $/;"	v
cppfile	test/tinygrammartest.cpp	/^	std::string cppfile;$/;"	m	class:simplegrammar_test	file:	access:private
cppfile_	makecompiler/gensyntax.h	/^	tstring cppfile_;$/;"	m	class:syntaxgenerator	access:public
cppstream_	makecompiler/gensyntax.h	/^	std::ostream* cppstream_;$/;"	m	class:syntaxgenerator	access:public
cppstream_	makecompiler/gensyntax.h	/^    std::ostream* cppstream_;$/;"	m	class:function_parser	access:private
cstate_	syntax/automachine.h	/^	int cstate_; \/\/ current state$/;"	m	class:automachine	access:protected
ctype	compiler/lalr1machine.h	/^        const type* ctype;$/;"	m	struct:lalr1machine::lalr1meta	access:public
current_scope	compiler/interlanguage.cpp	/^scope* interlanguage::current_scope() const$/;"	f	class:interlanguage	signature:() const
current_scope	compiler/interlanguage.h	/^    runtime::scope* current_scope() const;$/;"	p	class:interlanguage	access:public	signature:() const
current_scope_	compiler/interlanguage.h	/^    runtime::scope* current_scope_;$/;"	m	class:interlanguage	access:private
datamodule	compiler/module.h	/^class datamodule : virtual public module$/;"	c	inherits:module
datamodule::entry	compiler/module.cpp	/^variable* datamodule::entry(const variable& var)$/;"	f	class:datamodule	signature:(const variable& var)
datamodule::entry	compiler/module.h	/^	virtual variable* entry(const variable& v);$/;"	p	class:datamodule	access:public	signature:(const variable& v)
datamodule::find	compiler/module.cpp	/^variable* datamodule::find(const _Str& name)$/;"	f	class:datamodule	signature:(const _Str& name)
datamodule::find	compiler/module.h	/^    virtual variable* find(const _Str& name);$/;"	p	class:datamodule	access:public	signature:(const _Str& name)
datamodule::find_here	compiler/module.cpp	/^variable* datamodule::find_here(const _Str& name)$/;"	f	class:datamodule	signature:(const _Str& name)
datamodule::find_here	compiler/module.h	/^    variable* find_here(const _Str& name);$/;"	p	class:datamodule	access:protected	signature:(const _Str& name)
datamodule::isexist	compiler/module.cpp	/^bool datamodule::isexist(const _Str& name)$/;"	f	class:datamodule	signature:(const _Str& name)
datamodule::isexist	compiler/module.h	/^	bool isexist(const _Str& name);$/;"	p	class:datamodule	access:public	signature:(const _Str& name)
datamodule::varlist_	compiler/module.h	/^    std::deque<variable*> varlist_;$/;"	m	class:datamodule	access:protected
dbsoft	third_party/callstack/win32/debug_tool.cpp	/^namespace dbsoft$/;"	n	file:
dbsoft	third_party/callstack/win32/debug_tool.hpp	/^namespace dbsoft$/;"	n
dbsoft::callstack	third_party/callstack/win32/debug_tool.hpp	/^	class callstack$/;"	c	namespace:dbsoft
dbsoft::callstack::begin	third_party/callstack/win32/debug_tool.cpp	/^	callstack::const_iterator callstack::begin() const$/;"	f	class:dbsoft::callstack	signature:() const
dbsoft::callstack::begin	third_party/callstack/win32/debug_tool.hpp	/^		const_iterator  begin() const;$/;"	p	class:dbsoft::callstack	access:public	signature:() const
dbsoft::callstack::callstack	third_party/callstack/win32/debug_tool.cpp	/^	callstack::callstack():m_spImp( new detail::callstack_Imp() )$/;"	f	class:dbsoft::callstack	signature:()
dbsoft::callstack::callstack	third_party/callstack/win32/debug_tool.hpp	/^		callstack();$/;"	p	class:dbsoft::callstack	access:public	signature:()
dbsoft::callstack::callstack_ptr	third_party/callstack/win32/debug_tool.hpp	/^		typedef kog::shared_ptr<callstack>        callstack_ptr;$/;"	t	class:dbsoft::callstack	access:public
dbsoft::callstack::const_iterator	third_party/callstack/win32/debug_tool.hpp	/^		typedef func_name_list::const_iterator         const_iterator;$/;"	t	class:dbsoft::callstack	access:public
dbsoft::callstack::end	third_party/callstack/win32/debug_tool.cpp	/^	callstack::const_iterator callstack::end() const$/;"	f	class:dbsoft::callstack	signature:() const
dbsoft::callstack::end	third_party/callstack/win32/debug_tool.hpp	/^		const_iterator  end() const;$/;"	p	class:dbsoft::callstack	access:public	signature:() const
dbsoft::callstack::func_name	third_party/callstack/win32/debug_tool.hpp	/^		typedef std::string						       func_name;$/;"	t	class:dbsoft::callstack	access:public
dbsoft::callstack::func_name_list	third_party/callstack/win32/debug_tool.hpp	/^		typedef std::list< func_name >                 func_name_list;$/;"	t	class:dbsoft::callstack	access:public
dbsoft::callstack::generate	third_party/callstack/win32/debug_tool.cpp	/^	callstack::callstack_ptr callstack::generate( const void* pContext )$/;"	f	class:dbsoft::callstack	signature:( const void* pContext )
dbsoft::callstack::generate	third_party/callstack/win32/debug_tool.hpp	/^		static callstack_ptr generate( const void* pContext = NULL );$/;"	p	class:dbsoft::callstack	access:public	signature:( const void* pContext = NULL )
dbsoft::callstack::m_spImp	third_party/callstack/win32/debug_tool.hpp	/^		kog::shared_ptr<detail::callstack_Imp> m_spImp;$/;"	m	class:dbsoft::callstack	access:private
dbsoft::detail	third_party/callstack/win32/debug_tool.cpp	/^	namespace detail$/;"	n	namespace:dbsoft	file:
dbsoft::detail	third_party/callstack/win32/debug_tool.hpp	/^	namespace detail$/;"	n	namespace:dbsoft
dbsoft::detail::callstack_Imp	third_party/callstack/win32/debug_tool.cpp	/^		class callstack_Imp$/;"	c	namespace:dbsoft::detail	file:
dbsoft::detail::callstack_Imp::_getfuncname	third_party/callstack/win32/debug_tool.cpp	/^			static func_name      _getfuncname( QWORD dwFunc );$/;"	p	class:dbsoft::detail::callstack_Imp	file:	access:protected	signature:( QWORD dwFunc )
dbsoft::detail::callstack_Imp::_getfuncname	third_party/callstack/win32/debug_tool.cpp	/^		callstack_Imp::func_name callstack_Imp::_getfuncname( QWORD dwFunc )$/;"	f	class:dbsoft::detail::callstack_Imp	signature:( QWORD dwFunc )
dbsoft::detail::callstack_Imp::_initialize	third_party/callstack/win32/debug_tool.cpp	/^			static void           _initialize();$/;"	p	class:dbsoft::detail::callstack_Imp	file:	access:protected	signature:()
dbsoft::detail::callstack_Imp::_initialize	third_party/callstack/win32/debug_tool.cpp	/^		void callstack_Imp::_initialize()$/;"	f	class:dbsoft::detail::callstack_Imp	signature:()
dbsoft::detail::callstack_Imp::_loadAllModules	third_party/callstack/win32/debug_tool.cpp	/^			static bool           _loadAllModules();$/;"	p	class:dbsoft::detail::callstack_Imp	file:	access:protected	signature:()
dbsoft::detail::callstack_Imp::_loadAllModules	third_party/callstack/win32/debug_tool.cpp	/^		bool callstack_Imp::_loadAllModules()$/;"	f	class:dbsoft::detail::callstack_Imp	signature:()
dbsoft::detail::callstack_Imp::_stackwalk	third_party/callstack/win32/debug_tool.cpp	/^			static void           _stackwalk( QWORD* pTrace, DWORD dwMaxDepth, CONTEXT* pContext );$/;"	p	class:dbsoft::detail::callstack_Imp	file:	access:protected	signature:( QWORD* pTrace, DWORD dwMaxDepth, CONTEXT* pContext )
dbsoft::detail::callstack_Imp::_stackwalk	third_party/callstack/win32/debug_tool.cpp	/^		void callstack_Imp::_stackwalk(QWORD *pTrace, DWORD dwMaxDepth, CONTEXT *pContext)$/;"	f	class:dbsoft::detail::callstack_Imp	signature:(QWORD *pTrace, DWORD dwMaxDepth, CONTEXT *pContext)
dbsoft::detail::callstack_Imp::begin	third_party/callstack/win32/debug_tool.cpp	/^			const_iterator begin() const$/;"	f	class:dbsoft::detail::callstack_Imp	access:public	signature:() const
dbsoft::detail::callstack_Imp::callstack_Imp	third_party/callstack/win32/debug_tool.cpp	/^			callstack_Imp();$/;"	p	class:dbsoft::detail::callstack_Imp	file:	access:public	signature:()
dbsoft::detail::callstack_Imp::callstack_Imp	third_party/callstack/win32/debug_tool.cpp	/^		callstack_Imp::callstack_Imp()$/;"	f	class:dbsoft::detail::callstack_Imp	signature:()
dbsoft::detail::callstack_Imp::callstack_ptr	third_party/callstack/win32/debug_tool.cpp	/^			typedef callstack::callstack_ptr                       callstack_ptr;$/;"	t	class:dbsoft::detail::callstack_Imp	file:	access:public
dbsoft::detail::callstack_Imp::const_iterator	third_party/callstack/win32/debug_tool.cpp	/^			typedef callstack::const_iterator                      const_iterator;$/;"	t	class:dbsoft::detail::callstack_Imp	file:	access:public
dbsoft::detail::callstack_Imp::end	third_party/callstack/win32/debug_tool.cpp	/^			const_iterator end() const$/;"	f	class:dbsoft::detail::callstack_Imp	access:public	signature:() const
dbsoft::detail::callstack_Imp::func_name	third_party/callstack/win32/debug_tool.cpp	/^			typedef callstack::func_name					       func_name;$/;"	t	class:dbsoft::detail::callstack_Imp	file:	access:public
dbsoft::detail::callstack_Imp::func_name_list	third_party/callstack/win32/debug_tool.cpp	/^			typedef callstack::func_name_list                      func_name_list;$/;"	t	class:dbsoft::detail::callstack_Imp	file:	access:public
dbsoft::detail::callstack_Imp::generate	third_party/callstack/win32/debug_tool.cpp	/^			static callstack_ptr  generate( const void* pContext );$/;"	p	class:dbsoft::detail::callstack_Imp	file:	access:public	signature:( const void* pContext )
dbsoft::detail::callstack_Imp::generate	third_party/callstack/win32/debug_tool.cpp	/^		callstack_Imp::callstack_ptr callstack_Imp::generate( const void* pContext )$/;"	f	class:dbsoft::detail::callstack_Imp	signature:( const void* pContext )
dbsoft::detail::callstack_Imp::m_bInitialized	third_party/callstack/win32/debug_tool.cpp	/^			static bool           m_bInitialized;$/;"	m	class:dbsoft::detail::callstack_Imp	file:	access:private
dbsoft::detail::callstack_Imp::m_bInitialized	third_party/callstack/win32/debug_tool.cpp	/^		bool callstack_Imp::m_bInitialized = false;$/;"	m	class:dbsoft::detail::callstack_Imp	file:
dbsoft::detail::callstack_Imp::m_lstFunc	third_party/callstack/win32/debug_tool.cpp	/^			func_name_list   m_lstFunc;$/;"	m	class:dbsoft::detail::callstack_Imp	file:	access:private
decref	include/shared_ptr.h	/^		void decref() { if (--(*count) == 0) { delete ptr; delete count; }} $/;"	f	class:shared_ptr	access:private	signature:()
dectab	makecompiler/gensyntax.cpp	/^	static tabident dectab;$/;"	m	struct:tabident	file:	access:public
defvalue	compiler/type.h	/^	byte* defvalue;$/;"	m	struct:type	access:public
del	syntax/global_values.h	/^	void del(const std::string& name)$/;"	f	class:global_values	access:public	signature:(const std::string& name)
depointer	include/functionalX.h	/^depointer_t<_Tx> depointer(_Tx*)$/;"	f	signature:(_Tx*)
depointer_t	include/functionalX.h	/^struct depointer_t : public std::unary_function<_Tx*, _Tx>$/;"	s	inherits:std::unary_function
depointer_t	include/functionalX.h	/^struct depointer_t<const _Tx> : public std::unary_function<const _Tx*, const _Tx>$/;"	s	inherits:std::unary_function
depointer_t::operator ()	include/functionalX.h	/^	_Tx& operator()(_Tx* p) const$/;"	f	struct:depointer_t	access:public	signature:(_Tx* p) const
depointer_t::operator ()	include/functionalX.h	/^	const _Tx& operator()(const _Tx* p) const$/;"	f	struct:depointer_t	access:public	signature:(const _Tx* p) const
deqwords	compiler/extract.h	/^	typedef std::deque<word> deqwords;$/;"	t	class:streamsplit	access:public
dereference_t	include/functionalX.h	/^struct dereference_t :$/;"	s	inherits:std::unary_function
dereference_t::operator ()	include/functionalX.h	/^	reference operator()(_InIt _Iter) const$/;"	f	struct:dereference_t	access:public	signature:(_InIt _Iter) const
dereference_t::reference	include/functionalX.h	/^	typedef typename std::iterator_traits<_InIt>::reference reference;$/;"	t	struct:dereference_t	access:public
detach	include/arrayX.h	/^	smart_vector& detach()$/;"	f	class:smart_vector	access:public	signature:()
detail	third_party/callstack/win32/debug_tool.cpp	/^	namespace detail$/;"	n	namespace:dbsoft	file:
detail	third_party/callstack/win32/debug_tool.hpp	/^	namespace detail$/;"	n	namespace:dbsoft
dfa2machine	galgorithm/dfa2machine.h	/^	dfa2machine(const tinygrammar& gin, automachine& mot)$/;"	f	class:dfa2machine	access:public	signature:(const tinygrammar& gin, automachine& mot)
dfa2machine	galgorithm/dfa2machine.h	/^class dfa2machine : public grammar_algorithm$/;"	c	inherits:grammar_algorithm
dfa2machine::dfa2machine	galgorithm/dfa2machine.h	/^	dfa2machine(const tinygrammar& gin, automachine& mot)$/;"	f	class:dfa2machine	access:public	signature:(const tinygrammar& gin, automachine& mot)
dfa2machine::gin_	galgorithm/dfa2machine.h	/^	const tinygrammar* gin_;$/;"	m	class:dfa2machine	access:private
dfa2machine::invoke	galgorithm/dfa2machine.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:dfa2machine	access:public	signature:()
dfa2machine::make_sure_dfa	galgorithm/dfa2machine.cpp	/^void dfa2machine::make_sure_dfa(const tinygrammar& tig) const$/;"	f	class:dfa2machine	signature:(const tinygrammar& tig) const
dfa2machine::make_sure_dfa	galgorithm/dfa2machine.h	/^	void make_sure_dfa(const tinygrammar& input) const;$/;"	p	class:dfa2machine	access:private	signature:(const tinygrammar& input) const
dfa2machine::mot_	galgorithm/dfa2machine.h	/^	automachine* mot_;$/;"	m	class:dfa2machine	access:private
dfa2machine::operator ()	galgorithm/dfa2machine.cpp	/^void dfa2machine::operator()(const tinygrammar& tig, automachine& mot)$/;"	f	class:dfa2machine	signature:(const tinygrammar& tig, automachine& mot)
dfa2machine::operator ()	galgorithm/dfa2machine.h	/^	void operator()(const tinygrammar& input, automachine& otput);$/;"	p	class:dfa2machine	access:private	signature:(const tinygrammar& input, automachine& otput)
difference_type	include/iteratorX.h	/^	typedef typename _Base::difference_type difference_type;$/;"	t	struct:array_iterator	access:public
difference_type	include/stringX.h	/^	typedef _Dift difference_type;$/;"	t	class:xstring_basic	access:public
difference_type	include/tree.h	/^		typedef typename _Base::difference_type difference_type;$/;"	t	struct:tree::_Const_iterator	access:public
difference_type	include/tree.h	/^		typedef typename _Base::difference_type difference_type;$/;"	t	struct:tree::_Iterator	access:public
distance_type	include/iteratorX.h	/^	typedef typename _Base::difference_type distance_type;	\/\/ retained$/;"	t	struct:array_iterator	access:public
distance_type	include/tree.h	/^		typedef typename _Base::difference_type distance_type;	\/\/ retained$/;"	t	struct:tree::_Const_iterator	access:public
distance_type	include/tree.h	/^		typedef typename _Base::difference_type distance_type;	\/\/ retained$/;"	t	struct:tree::_Iterator	access:public
divid	compiler/operation.h	/^	divid,$/;"	e	enum:op
dot	galgorithm/lranalyse.cpp	/^	int32 dot; \/\/ dot position$/;"	m	struct:lrstateitem	file:	access:public
dot	syntax/lrmachine.h	/^		int32 dot;$/;"	m	struct:lrmachine::pinfo	access:public
double_type	compiler/type.cpp	/^const type* typesystem::double_type() const$/;"	f	class:typesystem	signature:() const
double_type	compiler/type.h	/^    const type* double_type() const;$/;"	p	class:typesystem	access:public	signature:() const
dst	compiler/tuple.h	/^    variable* dst;$/;"	m	struct:four_tuple	access:public
dthenu_	syntax/grammar.h	/^	bool dthenu_; \/\/ symbol need be defined before use?$/;"	m	class:grammar	access:protected
dump	include/logger.h	/^	loggermanager& dump(const std::string& content)$/;"	f	class:loggermanager	access:public	signature:(const std::string& content)
earse	include/heapX.h	/^	void earse(iterator _First, iterator _Last)$/;"	f	class:heap	access:public	signature:(iterator _First, iterator _Last)
earse	include/heapX.h	/^	void earse(iterator ei)$/;"	f	class:heap	access:public	signature:(iterator ei)
eattype_	syntax/automachine.h	/^		int32 eattype_;$/;"	m	class:automachine::sheetrow	access:private
eclosure	galgorithm/eclosures.h	/^	eclosure(const tinygrammar& tig, closure_array& ecls)$/;"	f	class:eclosure	access:public	signature:(const tinygrammar& tig, closure_array& ecls)
eclosure	galgorithm/eclosures.h	/^class eclosure : public grammar_algorithm$/;"	c	inherits:grammar_algorithm
eclosure::closure	galgorithm/eclosures.h	/^	typedef kog::smart_vector<int32> closure;$/;"	t	class:eclosure	access:public
eclosure::closure_array	galgorithm/eclosures.h	/^	typedef kog::smart_vector<closure> closure_array;$/;"	t	class:eclosure	access:public
eclosure::eclosure	galgorithm/eclosures.h	/^	eclosure(const tinygrammar& tig, closure_array& ecls)$/;"	f	class:eclosure	access:public	signature:(const tinygrammar& tig, closure_array& ecls)
eclosure::ecs_	galgorithm/eclosures.h	/^	closure_array* ecs_;$/;"	m	class:eclosure	access:private
eclosure::invoke	galgorithm/eclosures.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:eclosure	access:public	signature:()
eclosure::operator ()	galgorithm/eclosures.cpp	/^void eclosure::operator()(const tinygrammar& tig, closure_array& closures)$/;"	f	class:eclosure	signature:(const tinygrammar& tig, closure_array& closures)
eclosure::operator ()	galgorithm/eclosures.h	/^	void operator()(const tinygrammar& tig, closure_array& closures);$/;"	p	class:eclosure	access:private	signature:(const tinygrammar& tig, closure_array& closures)
eclosure::tig_	galgorithm/eclosures.h	/^	const tinygrammar* tig_;$/;"	m	class:eclosure	access:private
ecs_	galgorithm/eclosures.h	/^	closure_array* ecs_;$/;"	m	class:eclosure	access:private
eid	galgorithm/basicalgorithms.h	/^	int32 eid; \/\/ sid of eplison$/;"	m	class:eliminate_eplison	access:private
eid_	galgorithm/basicalgorithms.h	/^	int32* eid_;$/;"	m	class:symbol_to_eplison	access:private
eliminate_eplison	galgorithm/basicalgorithms.h	/^	eliminate_eplison(const tinygrammar& gin, tinygrammar& gout)$/;"	f	class:eliminate_eplison	access:public	signature:(const tinygrammar& gin, tinygrammar& gout)
eliminate_eplison	galgorithm/basicalgorithms.h	/^class eliminate_eplison : public grammar_algorithm$/;"	c	inherits:grammar_algorithm
eliminate_eplison::eid	galgorithm/basicalgorithms.h	/^	int32 eid; \/\/ sid of eplison$/;"	m	class:eliminate_eplison	access:private
eliminate_eplison::eliminate_eplison	galgorithm/basicalgorithms.h	/^	eliminate_eplison(const tinygrammar& gin, tinygrammar& gout)$/;"	f	class:eliminate_eplison	access:public	signature:(const tinygrammar& gin, tinygrammar& gout)
eliminate_eplison::findtoe	galgorithm/basicalgorithms.cpp	/^void eliminate_eplison::findtoe(const tinygrammar& tig)$/;"	f	class:eliminate_eplison	signature:(const tinygrammar& tig)
eliminate_eplison::findtoe	galgorithm/basicalgorithms.h	/^	void findtoe(const tinygrammar& tig);$/;"	p	class:eliminate_eplison	access:private	signature:(const tinygrammar& tig)
eliminate_eplison::gin_	galgorithm/basicalgorithms.h	/^	const tinygrammar* gin_;$/;"	m	class:eliminate_eplison	access:private
eliminate_eplison::gout_	galgorithm/basicalgorithms.h	/^	tinygrammar* gout_;$/;"	m	class:eliminate_eplison	access:private
eliminate_eplison::invoke	galgorithm/basicalgorithms.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:eliminate_eplison	access:public	signature:()
eliminate_eplison::is_start_in_right	galgorithm/basicalgorithms.cpp	/^bool eliminate_eplison::is_start_in_right(const tinygrammar& tig) const$/;"	f	class:eliminate_eplison	signature:(const tinygrammar& tig) const
eliminate_eplison::is_start_in_right	galgorithm/basicalgorithms.h	/^	bool is_start_in_right(const tinygrammar& tig) const;$/;"	p	class:eliminate_eplison	access:private	signature:(const tinygrammar& tig) const
eliminate_eplison::new_start_symbol	galgorithm/basicalgorithms.cpp	/^void eliminate_eplison::new_start_symbol(const tinygrammar& tig, tinygrammar& tog)$/;"	f	class:eliminate_eplison	signature:(const tinygrammar& tig, tinygrammar& tog)
eliminate_eplison::new_start_symbol	galgorithm/basicalgorithms.h	/^	void new_start_symbol(const tinygrammar& tig, tinygrammar& gout);$/;"	p	class:eliminate_eplison	access:private	signature:(const tinygrammar& tig, tinygrammar& gout)
eliminate_eplison::operator ()	galgorithm/basicalgorithms.cpp	/^void eliminate_eplison::operator()(const tinygrammar& tig, tinygrammar& tog)$/;"	f	class:eliminate_eplison	signature:(const tinygrammar& tig, tinygrammar& tog)
eliminate_eplison::operator ()	galgorithm/basicalgorithms.h	/^	void operator()(const tinygrammar& gin, tinygrammar& gout);$/;"	p	class:eliminate_eplison	access:private	signature:(const tinygrammar& gin, tinygrammar& gout)
eliminate_eplison::rmeplison	galgorithm/basicalgorithms.cpp	/^void eliminate_eplison::rmeplison(const tinygrammar& tig, tinygrammar& tog)$/;"	f	class:eliminate_eplison	signature:(const tinygrammar& tig, tinygrammar& tog)
eliminate_eplison::rmeplison	galgorithm/basicalgorithms.h	/^	void rmeplison(const tinygrammar& tig, tinygrammar& gout);$/;"	p	class:eliminate_eplison	access:private	signature:(const tinygrammar& tig, tinygrammar& gout)
eliminate_eplison::toe	galgorithm/basicalgorithms.h	/^	vecint toe; \/\/ symbol A->..->e?$/;"	m	class:eliminate_eplison	access:private
eliminate_eplison::vecint	galgorithm/basicalgorithms.h	/^	typedef kog::smart_vector<int32> vecint;$/;"	t	class:eliminate_eplison	access:private
empty	include/sortc.h	/^	bool empty() const { return c_.empty(); }$/;"	f	class:sortc	access:public	signature:() const
end	include/arrayX.h	/^	const_iterator end() const { return const_iterator(_buf + _Length, _Length, 0); }$/;"	f	struct:SmartArray	access:public	signature:() const
end	include/arrayX.h	/^	const_iterator end() const { return const_iterator(_values[0] + Length, Length, 0); }$/;"	f	struct:SmartMatrix	access:public	signature:() const
end	include/arrayX.h	/^	const_iterator end() const { return const_iterator(buf_.values + buf_.count, buf_.count, 0); }$/;"	f	class:smart_vector	access:public	signature:() const
end	include/arrayX.h	/^	iterator end() { return iterator(_buf + _Length, _Length, 0); }$/;"	f	struct:SmartArray	access:public	signature:()
end	include/arrayX.h	/^	iterator end() { return iterator(_values[0] + Length, Length, 0); }$/;"	f	struct:SmartMatrix	access:public	signature:()
end	include/arrayX.h	/^	iterator end() { return iterator(buf_.values + buf_.count, buf_.count, 0); }$/;"	f	class:smart_vector	access:public	signature:()
end	include/functionalX.h	/^	iterator end() const$/;"	f	struct:range_t	access:public	signature:() const
end	include/heapX.h	/^	const_iterator end() const { return c_.end(); }$/;"	f	class:heap	access:public	signature:() const
end	include/heapX.h	/^	iterator end() { return c_.end(); }$/;"	f	class:heap	access:public	signature:()
end	include/sortc.h	/^	const_iterator end() const { return c_.end(); }$/;"	f	class:sortc	access:public	signature:() const
end	include/sortc.h	/^	iterator end() { return c_.end(); }$/;"	f	class:sortc	access:public	signature:()
end	include/stringXF.h	/^    const_iterator end()$/;"	f	struct:string_split_t	access:public	signature:()
end	third_party/callstack/stacktrace.h	/^		const_iterator  end() const$/;"	f	class:kog::callstack::trace	access:public	signature:() const
end	third_party/callstack/stacktrace.h	/^		const_iterator end() const { return stack_.end(); }$/;"	f	class:kog::callstack::trace	access:public	signature:() const
end	third_party/callstack/win32/debug_tool.cpp	/^			const_iterator end() const$/;"	f	class:dbsoft::detail::callstack_Imp	access:public	signature:() const
end	third_party/callstack/win32/debug_tool.cpp	/^	callstack::const_iterator callstack::end() const$/;"	f	class:dbsoft::callstack	signature:() const
end	third_party/callstack/win32/debug_tool.hpp	/^		const_iterator  end() const;$/;"	p	class:dbsoft::callstack	access:public	signature:() const
ending_symbol_	syntax/grammar.h	/^	int32 ending_symbol_; \/\/ ending symbol sid: -1 no$/;"	m	class:tinygrammar	access:protected
endings	syntax/automachine.h	/^		int32 endings() const {return isendings_;}$/;"	f	class:automachine::sheetrow	access:public	signature:() const
endings	syntax/automachine.h	/^		void endings(int32 t) { isendings_ = t; }$/;"	f	class:automachine::sheetrow	access:public	signature:(int32 t)
entry	compiler/module.cpp	/^variable* datamodule::entry(const variable& var)$/;"	f	class:datamodule	signature:(const variable& var)
entry	compiler/module.h	/^	virtual variable* entry(const variable& v);$/;"	p	class:datamodule	access:public	signature:(const variable& v)
entry_function	compiler/scope.cpp	/^variable* scope::entry_function(const _Str& fname, const type* result_type, int32 nparams, ...)$/;"	f	class:scope	signature:(const _Str& fname, const type* result_type, int32 nparams, ...)
entry_function	compiler/scope.h	/^    variable* entry_function(const _Str& fname, const type* result_type, int32 nparams, ...);$/;"	p	class:scope	access:public	signature:(const _Str& fname, const type* result_type, int32 nparams, ...)
entry_value	compiler/scope.cpp	/^variable* scope::entry_value(const _Str& content, const type* canTypes[], int _C)$/;"	f	class:scope	signature:(const _Str& content, const type* canTypes[], int _C)
entry_value	compiler/scope.h	/^    variable* entry_value(const _Str& content, const type* canTypes[], int _N);$/;"	p	class:scope	access:public	signature:(const _Str& content, const type* canTypes[], int _N)
entry_variable	compiler/scope.cpp	/^variable* scope::entry_variable(const _Str& vname, const type* vtype, int32 vscope)$/;"	f	class:scope	signature:(const _Str& vname, const type* vtype, int32 vscope)
entry_variable	compiler/scope.h	/^    variable* entry_variable(const _Str& vname, const type* vtype, int32 vscope = varscope::stack);$/;"	p	class:scope	access:public	signature:(const _Str& vname, const type* vtype, int32 vscope = varscope::stack)
enum_string	compiler/operation.h	/^    static const _Str* enum_string()$/;"	f	struct:op_string	access:private	signature:()
env_	compiler/variable.h	/^    const scope* env_;$/;"	m	class:variable	access:private
eplison_symbol_	syntax/grammar.h	/^	int32 eplison_symbol_; \/\/ eplison symbol sid: -1 not in grammar$/;"	m	class:tinygrammar	access:protected
eq	compiler/operation.h	/^    eq,$/;"	e	enum:op
erase	include/sortc.h	/^	iterator erase(iterator _First, iterator _Last)$/;"	f	class:sortc	access:public	signature:(iterator _First, iterator _Last)
erase	include/sortc.h	/^	iterator erase(iterator ei)$/;"	f	class:sortc	access:public	signature:(iterator ei)
erase	include/stringX.h	/^	_Myt& erase(size_type _Off = 0, size_type _Count = _Mybase::npos)$/;"	f	class:xstring_basic	access:public	signature:(size_type _Off = 0, size_type _Count = _Mybase::npos)
eta	syntax/automachine.cpp	/^bool automachine::eta(machine_meta* meta)$/;"	f	class:automachine	signature:(machine_meta* meta)
eta	syntax/automachine.h	/^	virtual bool eta(machine_meta* meta);$/;"	p	class:automachine	access:public	signature:(machine_meta* meta)
eta	syntax/lrmachine.cpp	/^bool lrmachine::eta(machine_meta* meta)$/;"	f	class:lrmachine	signature:(machine_meta* meta)
eta	syntax/lrmachine.h	/^	\/* overwrite *\/ virtual bool eta(machine_meta* meta);$/;"	p	class:lrmachine	access:public	signature:(machine_meta* meta)
eta	syntax/statemachine.cpp	/^bool state_machine::eta(machine_meta* meta)$/;"	f	class:state_machine	signature:(machine_meta* meta)
eta	syntax/statemachine.h	/^	\/* overwrite *\/ virtual bool eta(machine_meta* meta);$/;"	p	class:state_machine	access:public	signature:(machine_meta* meta)
exclude	syntax/automachine.h	/^		enum { anychar, special, exclude };$/;"	e	enum:automachine::sheetrow::__anon127
exist	include/sortc.h	/^	bool exist(const value_type& v) const$/;"	f	class:sortc	access:public	signature:(const value_type& v) const
explicit_convert	include/functionalX.h	/^explicit_convert_t<_Tx, _Ty> explicit_convert(const _Tx&)$/;"	f	signature:(const _Tx&)
explicit_convert_t	include/functionalX.h	/^struct explicit_convert_t : public std::unary_function<_Tx, _Ty>$/;"	s	inherits:std::unary_function
explicit_convert_t::operator ()	include/functionalX.h	/^	_Ty operator()(const _Tx& _x) const$/;"	f	struct:explicit_convert_t	access:public	signature:(const _Tx& _x) const
f	tmp/coutfun.cpp	/^std::ostream& f(std::ostream& os)$/;"	f	signature:(std::ostream& os)
f	tmp/protected.cpp	/^	void f()$/;"	f	class:base	access:public	signature:()
f_	include/markuputils.h	/^	ifile* f_;$/;"	m	class:node	access:private
fadd	test/input/easy.c	/^float fadd(float a, float b)$/;"	f	signature:(float a, float b)
file	include/markuputils.h	/^	file(const std::string& fname, bool inORout)$/;"	f	class:file	access:public	signature:(const std::string& fname, bool inORout)
file	include/markuputils.h	/^class file$/;"	c
file::file	include/markuputils.h	/^	file(const std::string& fname, bool inORout)$/;"	f	class:file	access:public	signature:(const std::string& fname, bool inORout)
file::fname_	include/markuputils.h	/^	std::string fname_;$/;"	m	class:file	access:protected
file::fs_	include/markuputils.h	/^	std::auto_ptr<CMarkup> fs_;$/;"	m	class:file	access:protected
file::fstream	include/markuputils.h	/^	typedef std::fstream fstream;$/;"	t	class:file	access:private
file::in	include/markuputils.h	/^	enum {in = 0, out = 1};$/;"	e	enum:file::__anon3
file::inORout_	include/markuputils.h	/^	bool inORout_;$/;"	m	class:file	access:protected
file::into	include/markuputils.h	/^	void into()$/;"	f	class:file	access:public	signature:()
file::out	include/markuputils.h	/^	enum {in = 0, out = 1};$/;"	e	enum:file::__anon3
file::outof	include/markuputils.h	/^	void outof()$/;"	f	class:file	access:public	signature:()
file::swap	include/markuputils.h	/^	void swap(file& other)$/;"	f	class:file	access:public	signature:(file& other)
file::~file	include/markuputils.h	/^	virtual ~file()$/;"	f	class:file	access:public	signature:()
file_	syntax/loader.h	/^	xml::ifile file_;$/;"	m	class:loader	access:private
fin_	test/basicalgorithmtest.cpp	/^	std::string fin_;$/;"	m	class:basicalg_test	file:	access:private
find	compiler/module.cpp	/^variable* datamodule::find(const _Str& name)$/;"	f	class:datamodule	signature:(const _Str& name)
find	compiler/module.h	/^    virtual variable* find(const _Str& name);$/;"	p	class:datamodule	access:public	signature:(const _Str& name)
find	compiler/scope.cpp	/^variable* scope::find(const _Str& name)$/;"	f	class:scope	signature:(const _Str& name)
find	compiler/scope.h	/^	\/* overwrite *\/ virtual variable* find(const _Str& name);$/;"	p	class:scope	access:public	signature:(const _Str& name)
find	include/buckethash.h	/^	const value* find(const key& k) const$/;"	f	class:buckethash	access:public	signature:(const key& k) const
find	include/buckethash.h	/^	value* find(const key& k)$/;"	f	class:buckethash	access:public	signature:(const key& k)
find	include/heapX.h	/^	const_iterator find(const value_type& _v) const$/;"	f	class:heap	access:public	signature:(const value_type& _v) const
find	include/heapX.h	/^	iterator find(const value_type _v)$/;"	f	class:heap	access:public	signature:(const value_type _v)
find	include/sortc.h	/^	const_iterator find(const value_type& v) const$/;"	f	class:sortc	access:public	signature:(const value_type& v) const
find	include/sortc.h	/^	iterator find(const value_type& v)$/;"	f	class:sortc	access:public	signature:(const value_type& v)
find_here	compiler/module.cpp	/^variable* datamodule::find_here(const _Str& name)$/;"	f	class:datamodule	signature:(const _Str& name)
find_here	compiler/module.h	/^    variable* find_here(const _Str& name);$/;"	p	class:datamodule	access:protected	signature:(const _Str& name)
finds	test/gio.h	/^	compile::int32 finds(std::list<std::string>& bufs, std::deque<compile::symbol>& slist, const std::string& s) const$/;"	f	class:greader	access:private	signature:(std::list<std::string>& bufs, std::deque<compile::symbol>& slist, const std::string& s) const
findtoe	galgorithm/basicalgorithms.cpp	/^void eliminate_eplison::findtoe(const tinygrammar& tig)$/;"	f	class:eliminate_eplison	signature:(const tinygrammar& tig)
findtoe	galgorithm/basicalgorithms.h	/^	void findtoe(const tinygrammar& tig);$/;"	p	class:eliminate_eplison	access:private	signature:(const tinygrammar& tig)
fire	include/scerror.h	55;"	d
fire	include/scerror.h	58;"	d
fire_error	include/mplX.h	/^struct fire_error$/;"	s
fire_error::value	include/mplX.h	/^	const static int value = sizeof(_T);$/;"	m	struct:fire_error	access:public
first	include/functionalX.h	/^	_Ty1 first;	\/\/ the first stored value$/;"	m	struct:triple	access:public
first_argument_type	include/functionalX.h	/^	typedef _Arg1 first_argument_type;$/;"	t	struct:triple_function	access:public
first_argument_type	include/functionalX.h	/^	typedef typename _Fx::argument_type first_argument_type;$/;"	t	struct:composite_function2_t	access:public
first_order	include/tree.h	/^		first_order(link p) : p_(p) {}$/;"	f	struct:tree::first_order	access:public	signature:(link p)
first_order	include/tree.h	/^	struct first_order$/;"	s	class:tree	access:public
first_type	include/functionalX.h	/^	typedef _Ty1 first_type;$/;"	t	struct:triple	access:public
firstfollow_test	test/firstfollowtest.cpp	/^NEW_UNITTEST(firstfollow_test);$/;"	v
firstfollow_test	test/firstfollowtest.cpp	/^class firstfollow_test : public sc::unittest$/;"	c	file:	inherits:sc::unittest
firstfollow_test::ginfile_	test/firstfollowtest.cpp	/^	std::string ginfile_;$/;"	m	class:firstfollow_test	file:	access:private
firstfollow_test::init	test/firstfollowtest.cpp	/^	\/* overwrite *\/ virtual void init(int argc, const char* argv[])$/;"	f	class:firstfollow_test	file:	access:private	signature:(int argc, const char* argv[])
firstfollow_test::outputSets	test/firstfollowtest.cpp	/^	void outputSets(const firstset::vecintset& sets, const symholder& sholder, std::ostream& os, const std::string& sname)$/;"	f	class:firstfollow_test	file:	access:private	signature:(const firstset::vecintset& sets, const symholder& sholder, std::ostream& os, const std::string& sname)
firstfollow_test::output_first_follow_set	test/firstfollowtest.cpp	/^	void output_first_follow_set(const tinygrammar& g)$/;"	f	class:firstfollow_test	file:	access:private	signature:(const tinygrammar& g)
firstfollow_test::run_test	test/firstfollowtest.cpp	/^	\/* overwrite *\/ virtual void run_test()$/;"	f	class:firstfollow_test	file:	access:private	signature:()
firstfollow_test::sotfile_	test/firstfollowtest.cpp	/^	std::string sotfile_;$/;"	m	class:firstfollow_test	file:	access:private
firstset	galgorithm/firstfollow.h	/^	firstset(const tinygrammar& gin, vecintset& sets)$/;"	f	class:firstset	access:public	signature:(const tinygrammar& gin, vecintset& sets)
firstset	galgorithm/firstfollow.h	/^class firstset : public grammar_algorithm$/;"	c	inherits:grammar_algorithm
firstset::firstset	galgorithm/firstfollow.h	/^	firstset(const tinygrammar& gin, vecintset& sets)$/;"	f	class:firstset	access:public	signature:(const tinygrammar& gin, vecintset& sets)
firstset::gin_	galgorithm/firstfollow.h	/^	const tinygrammar* gin_;$/;"	m	class:firstset	access:private
firstset::invoke	galgorithm/firstfollow.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:firstset	access:public	signature:()
firstset::operator ()	galgorithm/firstfollow.cpp	/^void firstset::operator()(const tinygrammar& tig, vecintset& sets)$/;"	f	class:firstset	signature:(const tinygrammar& tig, vecintset& sets)
firstset::operator ()	galgorithm/firstfollow.h	/^	void operator()(const tinygrammar& gin, vecintset& sets);$/;"	p	class:firstset	access:private	signature:(const tinygrammar& gin, vecintset& sets)
firstset::sets_	galgorithm/firstfollow.h	/^	vecintset* sets_;$/;"	m	class:firstset	access:private
firstset::vecint	galgorithm/firstfollow.h	/^	typedef kog::smart_vector<int32> vecint;$/;"	t	class:firstset	access:public
firstset::vecintset	galgorithm/firstfollow.h	/^	typedef kog::smart_vector<vecint> vecintset;$/;"	t	class:firstset	access:public
firstsets	galgorithm/lranalyse.cpp	/^	firstset::vecintset firstsets;$/;"	m	struct:AlgorithmArg	file:	access:public
firstsets_	galgorithm/firstfollow.h	/^	const vecintset* firstsets_;$/;"	m	class:followset	access:private
fname_	include/markuputils.h	/^	std::string fname_;$/;"	m	class:file	access:protected
follow	galgorithm/lranalyse.cpp	/^	sfollowset follow;$/;"	m	struct:lrstateitem	file:	access:public
followset	galgorithm/firstfollow.h	/^	followset(const tinygrammar& gin, const vecintset& firstsets, vecintset& followsets)$/;"	f	class:followset	access:public	signature:(const tinygrammar& gin, const vecintset& firstsets, vecintset& followsets)
followset	galgorithm/firstfollow.h	/^class followset : public grammar_algorithm$/;"	c	inherits:grammar_algorithm
followset::firstsets_	galgorithm/firstfollow.h	/^	const vecintset* firstsets_;$/;"	m	class:followset	access:private
followset::followset	galgorithm/firstfollow.h	/^	followset(const tinygrammar& gin, const vecintset& firstsets, vecintset& followsets)$/;"	f	class:followset	access:public	signature:(const tinygrammar& gin, const vecintset& firstsets, vecintset& followsets)
followset::followsets_	galgorithm/firstfollow.h	/^	vecintset* followsets_;$/;"	m	class:followset	access:private
followset::gin_	galgorithm/firstfollow.h	/^	const tinygrammar* gin_;$/;"	m	class:followset	access:private
followset::invoke	galgorithm/firstfollow.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:followset	access:public	signature:()
followset::operator ()	galgorithm/firstfollow.cpp	/^void followset::operator()(const tinygrammar& tig, const vecintset& FirstSets, vecintset& FollowSets)$/;"	f	class:followset	signature:(const tinygrammar& tig, const vecintset& FirstSets, vecintset& FollowSets)
followset::operator ()	galgorithm/firstfollow.h	/^	void operator()(const tinygrammar& gin, const vecintset& firstsets, vecintset& followsets);$/;"	p	class:followset	access:private	signature:(const tinygrammar& gin, const vecintset& firstsets, vecintset& followsets)
followset::vecint	galgorithm/firstfollow.h	/^	typedef kog::smart_vector<int32> vecint;$/;"	t	class:followset	access:public
followset::vecintset	galgorithm/firstfollow.h	/^	typedef kog::smart_vector<vecint> vecintset;$/;"	t	class:followset	access:public
followsets_	galgorithm/firstfollow.h	/^	vecintset* followsets_;$/;"	m	class:followset	access:private
format	include/stringX.h	/^	static _Myt format(const _Elem* fmt, ...)$/;"	f	class:xstring_basic	access:public	signature:(const _Elem* fmt, ...)
format	include/stringXF.h	/^	static std::string format(const char* fmt, ...)$/;"	f	class:strformat	access:public	signature:(const char* fmt, ...)
format	include/stringXF.h	/^	static std::string& format(const char* fmt, va_list argptr, std::string& out_buf)$/;"	f	class:strformat	access:public	signature:(const char* fmt, va_list argptr, std::string& out_buf)
format	include/stringXF.h	/^	static std::wstring format(const wchar_t* fmt, ...)$/;"	f	class:strformat	access:public	signature:(const wchar_t* fmt, ...)
format	include/stringXF.h	/^	static std::wstring& format(const wchar_t* fmt, va_list argptr, std::wstring& out_buf)$/;"	f	class:strformat	access:public	signature:(const wchar_t* fmt, va_list argptr, std::wstring& out_buf)
format	include/stringXF.h	/^std::basic_string<_Elem> format(const _Elem* _fmt, ...)$/;"	f	signature:(const _Elem* _fmt, ...)
format	include/stringXF.h	/^std::basic_string<_Elem> format(const std::basic_string<_Elem>& _fmt, ...)$/;"	f	signature:(const std::basic_string<_Elem>& _fmt, ...)
forward	include/iteratorX.h	/^	_Myt& forward()$/;"	f	struct:iterator_pair	access:protected	signature:()
forward	include/iteratorX.h	/^	static array_iterator& forward(array_iterator& aniterator, distance_type dis = 1)$/;"	f	struct:array_iterator	access:protected	signature:(array_iterator& aniterator, distance_type dis = 1)
forward	include/tree.h	/^		void forward(_Myt& iter)$/;"	f	struct:tree::_Const_iterator	access:protected	signature:(_Myt& iter)
four_tuple	compiler/tuple.h	/^struct four_tuple : public tuple$/;"	s	inherits:tuple
four_tuple::dst	compiler/tuple.h	/^    variable* dst;$/;"	m	struct:four_tuple	access:public
four_tuple::oper	compiler/tuple.h	/^    operations::op oper;  $/;"	m	struct:four_tuple	access:public
four_tuple::src1	compiler/tuple.h	/^    variable* src1;$/;"	m	struct:four_tuple	access:public
four_tuple::src2	compiler/tuple.h	/^    variable* src2;$/;"	m	struct:four_tuple	access:public
fout_	test/basicalgorithmtest.cpp	/^	std::string fout_;$/;"	m	class:basicalg_test	file:	access:private
frame	third_party/callstack/stacktrace.h	/^	typedef dbsoft::callstack::func_name_list frame;$/;"	t	namespace:kog::callstack
frame	third_party/callstack/stacktrace.h	/^	typedef std::string frame;$/;"	t	namespace:kog::callstack
frames	third_party/callstack/linux2/debug_tool.cpp	/^void stacktrace::frames(std::vector<std::string>& trace)$/;"	f	class:stacktrace	signature:(std::vector<std::string>& trace)
frames	third_party/callstack/linux2/debug_tool.hpp	/^		static void frames(std::vector<std::string>& stack);$/;"	p	struct:kog::stacktrace	access:public	signature:(std::vector<std::string>& stack)
from_string	syntax/global_values.h	/^		object<_Tx>& from_string(const std::string& str)$/;"	f	class:refobject::object	access:public	signature:(const std::string& str)
from_string	syntax/global_values.h	/^		virtual holder& from_string(const std::string& str) = 0;$/;"	p	class:refobject::holder	access:public	signature:(const std::string& str)
front	include/arrayX.h	/^	const_reference front() const { return _buf[0]; }$/;"	f	struct:SmartArray	access:public	signature:() const
front	include/arrayX.h	/^	const_reference front() const$/;"	f	class:smart_vector	access:public	signature:() const
front	include/arrayX.h	/^	reference front() { return _buf[0]; }$/;"	f	struct:SmartArray	access:public	signature:()
front	include/arrayX.h	/^	reference front()$/;"	f	class:smart_vector	access:public	signature:()
fs_	include/markuputils.h	/^	std::auto_ptr<CMarkup> fs_;$/;"	m	class:file	access:protected
fstream	include/markuputils.h	/^	typedef std::fstream fstream;$/;"	t	class:file	access:private
func	syntax/symbol.h	/^	function func;$/;"	m	struct:symfunc	access:public
funcList_	compiler/lalr1machine.h	/^	kog::smart_vector<ifunction*> funcList_;$/;"	m	class:lalr1machine	access:private
func_	syntax/production.h	/^    _Str func_;$/;"	m	class:production	access:private
func_call	compiler/operation.h	/^	func_call,$/;"	e	enum:op
func_name	third_party/callstack/win32/debug_tool.cpp	/^			typedef callstack::func_name					       func_name;$/;"	t	class:dbsoft::detail::callstack_Imp	file:	access:public
func_name	third_party/callstack/win32/debug_tool.hpp	/^		typedef std::string						       func_name;$/;"	t	class:dbsoft::callstack	access:public
func_name_list	third_party/callstack/win32/debug_tool.cpp	/^			typedef callstack::func_name_list                      func_name_list;$/;"	t	class:dbsoft::detail::callstack_Imp	file:	access:public
func_name_list	third_party/callstack/win32/debug_tool.hpp	/^		typedef std::list< func_name >                 func_name_list;$/;"	t	class:dbsoft::callstack	access:public
func_ret	compiler/operation.h	/^    func_ret,$/;"	e	enum:op
funcarray	syntax/lrmachine.h	/^	typedef kog::smart_vector<symfunc*> funcarray;$/;"	t	class:lrmachine	access:public
funcparamlist	compiler/funcparams.h	/^    funcparamlist()$/;"	f	struct:funcparamlist	access:public	signature:()
funcparamlist	compiler/funcparams.h	/^    funcparamlist(int n, ...)$/;"	f	struct:funcparamlist	access:public	signature:(int n, ...)
funcparamlist	compiler/funcparams.h	/^    funcparamlist(object* param)$/;"	f	struct:funcparamlist	access:public	signature:(object* param)
funcparamlist	compiler/funcparams.h	/^    funcparamlist(object* param1, object* param2)$/;"	f	struct:funcparamlist	access:public	signature:(object* param1, object* param2)
funcparamlist	compiler/funcparams.h	/^struct funcparamlist : public object$/;"	s	inherits:object
funcparamlist::funcparamlist	compiler/funcparams.h	/^    funcparamlist()$/;"	f	struct:funcparamlist	access:public	signature:()
funcparamlist::funcparamlist	compiler/funcparams.h	/^    funcparamlist(int n, ...)$/;"	f	struct:funcparamlist	access:public	signature:(int n, ...)
funcparamlist::funcparamlist	compiler/funcparams.h	/^    funcparamlist(object* param)$/;"	f	struct:funcparamlist	access:public	signature:(object* param)
funcparamlist::funcparamlist	compiler/funcparams.h	/^    funcparamlist(object* param1, object* param2)$/;"	f	struct:funcparamlist	access:public	signature:(object* param1, object* param2)
funcparamlist::params_	compiler/funcparams.h	/^    vec_params params_;$/;"	m	struct:funcparamlist	access:public
funcparamlist::to_string	compiler/funcparams.h	/^    \/* overwrite *\/ virtual _Str to_string() const$/;"	f	struct:funcparamlist	access:public	signature:() const
funcparamlist::vec_params	compiler/funcparams.h	/^    typedef kog::smart_vector<object*> vec_params;$/;"	t	struct:funcparamlist	access:public
funcs	syntax/symbol.h	/^	symfunc* funcs;$/;"	m	struct:symbol	access:public
funcs_	syntax/lrmachine.h	/^	funcarray funcs_;$/;"	m	class:lrmachine	access:private
function	syntax/symbol.h	/^	typedef void* (*function)(void*);$/;"	t	struct:symfunc	access:public
function_parser	makecompiler/gensyntax.h	/^    function_parser(std::ostream& os)$/;"	f	class:function_parser	access:public	signature:(std::ostream& os)
function_parser	makecompiler/gensyntax.h	/^class function_parser$/;"	c
function_parser::cppstream_	makecompiler/gensyntax.h	/^    std::ostream* cppstream_;$/;"	m	class:function_parser	access:private
function_parser::function_parser	makecompiler/gensyntax.h	/^    function_parser(std::ostream& os)$/;"	f	class:function_parser	access:public	signature:(std::ostream& os)
function_parser::operator ()	makecompiler/gensyntax.cpp	/^function_parser& function_parser::operator()(const _Str& func, const _Str& name)$/;"	f	class:function_parser	signature:(const _Str& func, const _Str& name)
function_parser::operator ()	makecompiler/gensyntax.h	/^    function_parser& operator()(const _Str& func, const _Str& name);$/;"	p	class:function_parser	access:public	signature:(const _Str& func, const _Str& name)
function_type	compiler/type.h	/^    function_type(int32 id = -1)$/;"	f	struct:function_type	access:public	signature:(int32 id = -1)
function_type	compiler/type.h	/^struct function_type : public type$/;"	s	inherits:type
function_type::function_type	compiler/type.h	/^    function_type(int32 id = -1)$/;"	f	struct:function_type	access:public	signature:(int32 id = -1)
function_type::params_type	compiler/type.h	/^    kog::smart_vector<const type*> params_type;$/;"	m	struct:function_type	access:public
function_type::return_type	compiler/type.h	/^    const type* return_type;$/;"	m	struct:function_type	access:public
functiontype_type	compiler/type.cpp	/^const type* typesystem::functiontype_type() const$/;"	f	class:typesystem	signature:() const
functiontype_type	compiler/type.h	/^    const type* functiontype_type() const;$/;"	p	class:typesystem	access:public	signature:() const
ge	compiler/operation.h	/^    ge,$/;"	e	enum:op
genLinear	include/functionalX.h	/^inline _Iter genLinear(_T _From, _T _Diff, _T _To, _Iter _First)$/;"	f	signature:(_T _From, _T _Diff, _T _To, _Iter _First)
genLinearC	include/functionalX.h	/^inline _Iter genLinearC(_T _From, _T _To, size_t _Count, _Iter _First)$/;"	f	signature:(_T _From, _T _To, size_t _Count, _Iter _First)
generate	compiler/interlanguage.cpp	/^void interlanguage::generate(const std::string& finput_name, const std::string& fotput_name)$/;"	f	class:interlanguage	signature:(const std::string& finput_name, const std::string& fotput_name)
generate	compiler/interlanguage.h	/^	void generate(const std::string& finput_name, const std::string& fotput_name);$/;"	p	class:interlanguage	access:public	signature:(const std::string& finput_name, const std::string& fotput_name)
generate	third_party/callstack/win32/debug_tool.cpp	/^			static callstack_ptr  generate( const void* pContext );$/;"	p	class:dbsoft::detail::callstack_Imp	file:	access:public	signature:( const void* pContext )
generate	third_party/callstack/win32/debug_tool.cpp	/^		callstack_Imp::callstack_ptr callstack_Imp::generate( const void* pContext )$/;"	f	class:dbsoft::detail::callstack_Imp	signature:( const void* pContext )
generate	third_party/callstack/win32/debug_tool.cpp	/^	callstack::callstack_ptr callstack::generate( const void* pContext )$/;"	f	class:dbsoft::callstack	signature:( const void* pContext )
generate	third_party/callstack/win32/debug_tool.hpp	/^		static callstack_ptr generate( const void* pContext = NULL );$/;"	p	class:dbsoft::callstack	access:public	signature:( const void* pContext = NULL )
generate_asm	compiler/compiler.cpp	/^void compiler::generate_asm(const std::string& asmfile)$/;"	f	class:compiler	signature:(const std::string& asmfile)
generate_asm	compiler/compiler.h	/^    void generate_asm(const std::string& asmfile);$/;"	p	class:compiler	access:public	signature:(const std::string& asmfile)
get	compiler/compiler.cpp	/^	int32 get() const$/;"	f	struct:split_separators	access:public	signature:() const
get	include/arrayX.h	/^	const_pointer get() const { return buf_.values; }$/;"	f	class:smart_vector	access:public	signature:() const
get	include/arrayX.h	/^	pointer get() { return buf_.values; }$/;"	f	class:smart_vector	access:public	signature:()
get	include/iteratorX.h	/^	_Tx* get() const { return _ptr; }$/;"	f	struct:array_iterator	access:public	signature:() const
get	include/shared_ptr.h	/^		T* get() { return ptr; }$/;"	f	class:shared_ptr	access:public	signature:()
get	include/shared_ptr.h	/^		T* get() { return ptr; }$/;"	f	class:weak_ptr	access:public	signature:()
get	include/shared_ptr.h	/^		const T* get() const { return ptr; }$/;"	f	class:shared_ptr	access:public	signature:() const
get	include/shared_ptr.h	/^		const T* get() const { return ptr; }$/;"	f	class:weak_ptr	access:public	signature:() const
get	syntax/global_values.h	/^		_Tx& get()$/;"	f	class:refobject::object	access:public	signature:()
get	syntax/global_values.h	/^		const _Tx& get() const$/;"	f	class:refobject::object	access:public	signature:() const
get	syntax/global_values.h	/^	refobject& get(const std::string& name, const refobject& defaultV = refobject())$/;"	f	class:global_values	access:public	signature:(const std::string& name, const refobject& defaultV = refobject())
getIndex	include/mathX.h	/^		static int getIndex(const T* begin, const size_t nSize, const T& val)$/;"	f	class:math::interpolate	access:public	signature:(const T* begin, const size_t nSize, const T& val)
get_all_machines	compiler/compiler.cpp	/^int compiler::get_all_machines(std::list<machine>& mlist)$/;"	f	class:compiler	signature:(std::list<machine>& mlist)
get_all_machines	compiler/compiler.h	/^	static int get_all_machines(std::list<compile::doc::machine>& mlist);$/;"	p	class:compiler	access:public	signature:(std::list<compile::doc::machine>& mlist)
get_all_machines	tmp/back/compiler.cpp	/^int compiler::get_all_machines(std::list<state_machine*>& mlist)$/;"	f	class:compiler	signature:(std::list<state_machine*>& mlist)
get_all_machines	tmp/back/compiler.h	/^	static int get_all_machines(std::list<state_machine*>& mlist);$/;"	p	class:compiler	access:public	signature:(std::list<state_machine*>& mlist)
get_firsts	galgorithm/lranalyse.cpp	/^	void get_firsts(int32 x, const sfollowset& f, sfollowset& nf) const;$/;"	p	struct:AlgorithmArg	file:	access:public	signature:(int32 x, const sfollowset& f, sfollowset& nf) const
get_firsts	galgorithm/lranalyse.cpp	/^void AlgorithmArg::get_firsts(int32 x, const sfollowset& f, sfollowset& nf) const$/;"	f	class:AlgorithmArg	signature:(int32 x, const sfollowset& f, sfollowset& nf) const
get_func_type	compiler/type.cpp	/^const function_type* typesystem::get_func_type(int32 nparams, const type* params[]) const$/;"	f	class:typesystem	signature:(int32 nparams, const type* params[]) const
get_func_type	compiler/type.h	/^    const function_type* get_func_type(int32 nparams, const type* params[]) const;$/;"	p	class:typesystem	access:public	signature:(int32 nparams, const type* params[]) const
get_logger	include/logger.h	/^	logger& get_logger()$/;"	f	class:loggermanager	access:public	signature:()
get_lrsid	galgorithm/lranalyse.cpp	/^	int32 get_lrsid(const lrstate* p) const;$/;"	p	struct:AlgorithmArg	file:	access:public	signature:(const lrstate* p) const
get_lrsid	galgorithm/lranalyse.cpp	/^int32 AlgorithmArg::get_lrsid(const lrstate* p) const$/;"	f	class:AlgorithmArg	signature:(const lrstate* p) const
get_machine	compiler/compiler.cpp	/^automachine& compiler::get_machine(const std::string& machine_name)$/;"	f	class:compiler	signature:(const std::string& machine_name)
get_machine	compiler/compiler.h	/^    static automachine& get_machine(const std::string& machine_name);$/;"	p	class:compiler	access:public	signature:(const std::string& machine_name)
get_next_symbol	galgorithm/lranalyse.cpp	/^	int32 get_next_symbol(const production& p, int32 idot) const;$/;"	p	struct:AlgorithmArg	file:	access:public	signature:(const production& p, int32 idot) const
get_next_symbol	galgorithm/lranalyse.cpp	/^int32 AlgorithmArg::get_next_symbol(const production& p, int32 idot) const$/;"	f	class:AlgorithmArg	signature:(const production& p, int32 idot) const
get_number_machine	compiler/compiler.cpp	/^state_machine compiler::get_number_machine()$/;"	f	class:compiler	signature:()
get_number_machine	compiler/compiler.h	/^	static state_machine get_number_machine();$/;"	p	class:compiler	access:public	signature:()
get_number_machine	tmp/back/compiler.cpp	/^state_machine compiler::get_number_machine()$/;"	f	class:compiler	signature:()
get_number_machine	tmp/back/compiler.h	/^	static state_machine get_number_machine();$/;"	p	class:compiler	access:public	signature:()
get_pid	galgorithm/lranalyse.cpp	/^	int32 get_pid(const production* p) const;$/;"	p	struct:AlgorithmArg	file:	access:public	signature:(const production* p) const
get_pid	galgorithm/lranalyse.cpp	/^int32 AlgorithmArg::get_pid(const production* p) const$/;"	f	class:AlgorithmArg	signature:(const production* p) const
get_ptr_t	include/functionalX.h	/^struct get_ptr_t : public std::unary_function<_Tx, _Tx*>$/;"	s	inherits:std::unary_function
get_ptr_t::operator ()	include/functionalX.h	/^	_Tx* operator()(_Tx& _Arg) const$/;"	f	struct:get_ptr_t	access:public	signature:(_Tx& _Arg) const
get_ptr_t::operator ()	include/functionalX.h	/^	const _Tx* operator()(const _Tx& _Arg) const$/;"	f	struct:get_ptr_t	access:public	signature:(const _Tx& _Arg) const
get_r1	galgorithm/nfa2dfa.cpp	/^inline int32 get_r1(const production* p, int32 virtual_ending)$/;"	f	signature:(const production* p, int32 virtual_ending)
get_string_machine	compiler/compiler.cpp	/^state_machine compiler::get_string_machine()$/;"	f	class:compiler	signature:()
get_string_machine	compiler/compiler.h	/^	static state_machine get_string_machine();$/;"	p	class:compiler	access:public	signature:()
get_string_machine	tmp/back/compiler.cpp	/^state_machine compiler::get_string_machine()$/;"	f	class:compiler	signature:()
get_string_machine	tmp/back/compiler.h	/^	static state_machine get_string_machine();$/;"	p	class:compiler	access:public	signature:()
get_symbol_machine	compiler/compiler.cpp	/^state_machine compiler::get_symbol_machine()$/;"	f	class:compiler	signature:()
get_symbol_machine	compiler/compiler.h	/^	static state_machine get_symbol_machine();$/;"	p	class:compiler	access:public	signature:()
get_symbol_machine	tmp/back/compiler.cpp	/^state_machine compiler::get_symbol_machine()$/;"	f	class:compiler	signature:()
get_symbol_machine	tmp/back/compiler.h	/^	static state_machine get_symbol_machine();$/;"	p	class:compiler	access:public	signature:()
get_type	compiler/object.h	/^    const std::type_info& get_type() const$/;"	f	struct:object	access:public	signature:() const
getiml	compiler/compiler.cpp	/^compile::interlanguage& compiler::getiml()$/;"	f	class:compiler	signature:()
getiml	compiler/compiler.h	/^    static compile::interlanguage& getiml();$/;"	p	class:compiler	access:public	signature:()
getos	include/logger.h	/^	std::ostream& getos() const$/;"	f	class:logger	access:public	signature:() const
getstream	include/stringX.h	/^	bool getstream(_IStream& _istream)$/;"	f	class:xstring_basic	access:public	signature:(_IStream& _istream)
getstream	include/stringX.h	/^	bool getstream(_OStream& _ostream)$/;"	f	class:xstring_basic	access:public	signature:(_OStream& _ostream)
getstream	include/stringX.h	/^	bool getstream(_Stream& _stream)$/;"	f	class:xstring_basic	access:public	signature:(_Stream& _stream)
getstring	makecompiler/gensyntax.cpp	/^tstring getstring(const tstring& str, tchar warp = '\\"')$/;"	f	signature:(const tstring& str, tchar warp = Ã)
getstringptr	syntax/symbol.h	/^	const tchar* getstringptr() const$/;"	f	class:symholder	access:public	signature:() const
getsymbol	galgorithm/regex2nfa.cpp	/^	int getsymbol(int sid)$/;"	f	struct:parsecontent	access:public	signature:(int sid)
getsymbol	tmp/back/regex2nfa.cpp	/^	int getsymbol(int sid)$/;"	f	struct:parsecontent	access:public	signature:(int sid)
gettinyg	syntax/grammar.h	/^	const tinygrammar& gettinyg() const$/;"	f	class:grammar	access:public	signature:() const
gettype	compiler/type.h	/^	const type* gettype(int32 tid) const$/;"	f	class:typesystem	access:public	signature:(int32 tid) const
gfile_	test/lrmachinetest.cpp	/^	std::string gfile_;$/;"	m	class:lrmachine_test	file:	access:private
gin_	galgorithm/basicalgorithms.h	/^	const tinygrammar* gin_;$/;"	m	class:eliminate_eplison	access:private
gin_	galgorithm/basicalgorithms.h	/^	const tinygrammar* gin_;$/;"	m	class:removenotused	access:private
gin_	galgorithm/basicalgorithms.h	/^	const tinygrammar* gin_;$/;"	m	class:removesingle	access:private
gin_	galgorithm/basicalgorithms.h	/^	const tinygrammar* gin_;$/;"	m	class:simplegrammar	access:private
gin_	galgorithm/basicalgorithms.h	/^	const tinygrammar* gin_;$/;"	m	class:symbol_to_eplison	access:private
gin_	galgorithm/dfa2machine.h	/^	const tinygrammar* gin_;$/;"	m	class:dfa2machine	access:private
gin_	galgorithm/firstfollow.h	/^	const tinygrammar* gin_;$/;"	m	class:firstset	access:private
gin_	galgorithm/firstfollow.h	/^	const tinygrammar* gin_;$/;"	m	class:followset	access:private
gin_	galgorithm/lranalyse.h	/^	const tinygrammar* gin_;$/;"	m	class:lranalyse	access:private
gin_	galgorithm/nfa2dfa.h	/^	const tinygrammar* gin_;$/;"	m	class:nfa2dfa	access:private
ginfile_	test/firstfollowtest.cpp	/^	std::string ginfile_;$/;"	m	class:firstfollow_test	file:	access:private
ginfile_	test/nfa2dfatest.cpp	/^	std::string ginfile_;$/;"	m	class:nfa2dfa_test	file:	access:private
global	compiler/scope.h	/^        global,$/;"	e	enum:varscope::scope_defines
global_values	syntax/global_values.h	/^	global_values()$/;"	f	class:global_values	access:public	signature:()
global_values	syntax/global_values.h	/^class global_values : public kog::singleton<global_values>$/;"	c	inherits:kog::singleton
global_values::MEMBER_VARIABLE_GET_SET	syntax/global_values.h	/^	MEMBER_VARIABLE_GET_SET(std::string, LogFile, logFile_);$/;"	p	class:global_values	access:public	signature:(std::string, LogFile, logFile_)
global_values::contain	syntax/global_values.h	/^	bool contain(const std::string& name) const$/;"	f	class:global_values	access:public	signature:(const std::string& name) const
global_values::del	syntax/global_values.h	/^	void del(const std::string& name)$/;"	f	class:global_values	access:public	signature:(const std::string& name)
global_values::get	syntax/global_values.h	/^	refobject& get(const std::string& name, const refobject& defaultV = refobject())$/;"	f	class:global_values	access:public	signature:(const std::string& name, const refobject& defaultV = refobject())
global_values::global_values	syntax/global_values.h	/^	global_values()$/;"	f	class:global_values	access:public	signature:()
global_values::insert	syntax/global_values.h	/^	void insert(const std::string& name, const _Tx& value)$/;"	f	class:global_values	access:public	signature:(const std::string& name, const _Tx& value)
global_values::load_file_	syntax/global_values.cpp	/^std::string global_values::load_file_ = "";$/;"	m	class:global_values	file:
global_values::load_file_	syntax/global_values.h	/^	static std::string load_file_;$/;"	m	class:global_values	access:private
global_values::load_from_file	syntax/global_values.cpp	/^void global_values::load_from_file()$/;"	f	class:global_values	signature:()
global_values::load_from_file	syntax/global_values.h	/^	void load_from_file();$/;"	p	class:global_values	access:private	signature:()
global_values::logFile_	syntax/global_values.h	/^	std::string logFile_;$/;"	m	class:global_values	access:private
global_values::operator []	syntax/global_values.h	/^	refobject& operator[](const std::string& name)$/;"	f	class:global_values	access:public	signature:(const std::string& name)
global_values::setautoloadfile	syntax/global_values.h	/^	static std::string& setautoloadfile(const std::string& file)$/;"	f	class:global_values	access:public	signature:(const std::string& file)
global_values::values_	syntax/global_values.h	/^	std::map<std::string, refobject > values_;$/;"	m	class:global_values	access:private
global_values::~global_values	syntax/global_values.h	/^	~global_values()$/;"	f	class:global_values	access:public	signature:()
got_	galgorithm/nfa2dfa.h	/^	tinygrammar* got_;$/;"	m	class:nfa2dfa	access:private
gotfile_	test/nfa2dfatest.cpp	/^	std::string gotfile_;$/;"	m	class:nfa2dfa_test	file:	access:private
gotoitem	syntax/automachine.h	/^	typedef std::pair<int, int> gotoitem;$/;"	t	class:automachine	access:public
gout_	galgorithm/basicalgorithms.h	/^	tinygrammar* gout_;$/;"	m	class:eliminate_eplison	access:private
gout_	galgorithm/basicalgorithms.h	/^	tinygrammar* gout_;$/;"	m	class:removenotused	access:private
gout_	galgorithm/basicalgorithms.h	/^	tinygrammar* gout_;$/;"	m	class:removesingle	access:private
gout_	galgorithm/basicalgorithms.h	/^	tinygrammar* gout_;$/;"	m	class:simplegrammar	access:private
gout_	galgorithm/regex2nfa.h	/^	tinygrammar* gout_;$/;"	m	class:regex2nfa	access:private
grammar	syntax/grammar.cpp	/^grammar::grammar()$/;"	f	class:grammar	signature:()
grammar	syntax/grammar.cpp	/^grammar::grammar(const tinygrammar& atinyG)$/;"	f	class:grammar	signature:(const tinygrammar& atinyG)
grammar	syntax/grammar.h	/^	explicit grammar(const tinygrammar& atinyG);$/;"	p	class:grammar	access:public	signature:(const tinygrammar& atinyG)
grammar	syntax/grammar.h	/^	grammar();$/;"	p	class:grammar	access:public	signature:()
grammar	syntax/grammar.h	/^class grammar : protected tinygrammar$/;"	c	inherits:tinygrammar
grammar::dthenu_	syntax/grammar.h	/^	bool dthenu_; \/\/ symbol need be defined before use?$/;"	m	class:grammar	access:protected
grammar::gettinyg	syntax/grammar.h	/^	const tinygrammar& gettinyg() const$/;"	f	class:grammar	access:public	signature:() const
grammar::grammar	syntax/grammar.cpp	/^grammar::grammar()$/;"	f	class:grammar	signature:()
grammar::grammar	syntax/grammar.cpp	/^grammar::grammar(const tinygrammar& atinyG)$/;"	f	class:grammar	signature:(const tinygrammar& atinyG)
grammar::grammar	syntax/grammar.h	/^	explicit grammar(const tinygrammar& atinyG);$/;"	p	class:grammar	access:public	signature:(const tinygrammar& atinyG)
grammar::grammar	syntax/grammar.h	/^	grammar();$/;"	p	class:grammar	access:public	signature:()
grammar::keyword	syntax/grammar.h	/^		keyword = 2, \/\/ keyword$/;"	e	enum:grammar::symtype
grammar::keywords_	syntax/grammar.h	/^	veckeywords keywords_;$/;"	m	class:grammar	access:protected
grammar::nont	syntax/grammar.h	/^		nont = 0, \/\/non-terminate$/;"	e	enum:grammar::symtype
grammar::other_sym	syntax/grammar.h	/^		other_sym$/;"	e	enum:grammar::symtype
grammar::sep	syntax/grammar.h	/^		sep = 1, \/\/ seperators$/;"	e	enum:grammar::symtype
grammar::seperators_	syntax/grammar.h	/^	tstring seperators_;	\/\/ seperators: split word$/;"	m	class:grammar	access:protected
grammar::smac	syntax/grammar.h	/^		smac = 3,	\/\/ symbol match state machine$/;"	e	enum:grammar::symtype
grammar::smacs_	syntax/grammar.h	/^	vecsmacs smacs_; \/\/ state machines$/;"	m	class:grammar	access:protected
grammar::swap	syntax/grammar.cpp	/^void grammar::swap(grammar& other) throw ()$/;"	f	class:grammar	signature:(grammar& other)
grammar::swap	syntax/grammar.h	/^	void swap(grammar& other) throw ();$/;"	p	class:grammar	access:public	signature:(grammar& other)
grammar::swap_kernel	syntax/grammar.cpp	/^void grammar::swap_kernel(tinygrammar& other) throw ()$/;"	f	class:grammar	signature:(tinygrammar& other)
grammar::swap_kernel	syntax/grammar.h	/^	void swap_kernel(tinygrammar& tg) throw ();$/;"	p	class:grammar	access:public	signature:(tinygrammar& tg)
grammar::symtype	syntax/grammar.h	/^	enum symtype$/;"	g	class:grammar	access:public
grammar::veckeywords	syntax/grammar.h	/^	typedef kog::smart_vector<std::pair<tstring, int32> > veckeywords;$/;"	t	class:grammar	access:public
grammar::vecsmacs	syntax/grammar.h	/^	typedef kog::smart_vector<std::pair<tstring, int32> > vecsmacs; \/\/ first: symbol.sid, second: regex string$/;"	t	class:grammar	access:public
grammar::whitespaces_	syntax/grammar.h	/^	tstring whitespaces_;	\/\/ whitespace: space tab or some other charactors$/;"	m	class:grammar	access:protected
grammar::~grammar	syntax/grammar.cpp	/^grammar::~grammar()$/;"	f	class:grammar	signature:()
grammar::~grammar	syntax/grammar.h	/^	virtual ~grammar();$/;"	p	class:grammar	access:public	signature:()
grammar_algorithm	galgorithm/grammaralgorithm.h	/^	grammar_algorithm(const tstring& name)$/;"	f	class:grammar_algorithm	access:public	signature:(const tstring& name)
grammar_algorithm	galgorithm/grammaralgorithm.h	/^class grammar_algorithm$/;"	c
grammar_algorithm::grammar_algorithm	galgorithm/grammaralgorithm.h	/^	grammar_algorithm(const tstring& name)$/;"	f	class:grammar_algorithm	access:public	signature:(const tstring& name)
grammar_algorithm::invoke	galgorithm/grammaralgorithm.h	/^	virtual void invoke() = 0;$/;"	p	class:grammar_algorithm	access:public	signature:()
grammar_algorithm::name	galgorithm/grammaralgorithm.h	/^	const tstring& name() const$/;"	f	class:grammar_algorithm	access:public	signature:() const
grammar_algorithm::name_	galgorithm/grammaralgorithm.h	/^	tstring name_;$/;"	m	class:grammar_algorithm	access:private
grammar_wrapper	test/tinygrammartest.cpp	/^class grammar_wrapper : public grammar$/;"	c	file:	inherits:grammar
grammar_wrapper::init_funcs	test/tinygrammartest.cpp	/^    void init_funcs(std::vector<std::string>& funcs);$/;"	p	class:grammar_wrapper	file:	access:private	signature:(std::vector<std::string>& funcs)
grammar_wrapper::init_funcs	test/tinygrammartest.cpp	/^void grammar_wrapper::init_funcs(std::vector<std::string>& funcs)$/;"	f	class:grammar_wrapper	signature:(std::vector<std::string>& funcs)
grammar_wrapper::simple_grammar	test/tinygrammartest.cpp	/^	void simple_grammar();$/;"	p	class:grammar_wrapper	file:	access:public	signature:()
grammar_wrapper::simple_grammar	test/tinygrammartest.cpp	/^void grammar_wrapper::simple_grammar()$/;"	f	class:grammar_wrapper	signature:()
greader	test/gio.h	/^	greader(std::istream& is)$/;"	f	class:greader	access:public	signature:(std::istream& is)
greader	test/gio.h	/^class greader$/;"	c
greader::finds	test/gio.h	/^	compile::int32 finds(std::list<std::string>& bufs, std::deque<compile::symbol>& slist, const std::string& s) const$/;"	f	class:greader	access:private	signature:(std::list<std::string>& bufs, std::deque<compile::symbol>& slist, const std::string& s) const
greader::greader	test/gio.h	/^	greader(std::istream& is)$/;"	f	class:greader	access:public	signature:(std::istream& is)
greader::is_	test/gio.h	/^	std::istream& is_;$/;"	m	class:greader	access:private
greader::operator >>	test/gio.h	/^	greader& operator>>(compile::grammar& g)$/;"	f	class:greader	access:public	signature:(compile::grammar& g)
greader::operator >>	test/gio.h	/^	greader& operator>>(compile::tinygrammar& g)$/;"	f	class:greader	access:public	signature:(compile::tinygrammar& g)
greader::read_grammar	test/gio.h	/^	void read_grammar(std::istream& is, compile::tinygrammar& g, const std::string& start, const std::string& eplison, const std::string& ending) const$/;"	f	class:greader	access:private	signature:(std::istream& is, compile::tinygrammar& g, const std::string& start, const std::string& eplison, const std::string& ending) const
gt	compiler/operation.h	/^    gt,$/;"	e	enum:op
gv	syntax/global_values.h	/^inline global_values& gv()$/;"	f	signature:()
gwriter	test/gio.h	/^	gwriter(std::ostream& os)$/;"	f	class:gwriter	access:public	signature:(std::ostream& os)
gwriter	test/gio.h	/^class gwriter$/;"	c
gwriter::gwriter	test/gio.h	/^	gwriter(std::ostream& os)$/;"	f	class:gwriter	access:public	signature:(std::ostream& os)
gwriter::operator <<	test/gio.h	/^	gwriter& operator<<(const compile::grammar& g)$/;"	f	class:gwriter	access:public	signature:(const compile::grammar& g)
gwriter::operator <<	test/gio.h	/^	gwriter& operator<<(const compile::tinygrammar& tg)$/;"	f	class:gwriter	access:public	signature:(const compile::tinygrammar& tg)
gwriter::os_	test/gio.h	/^	std::ostream& os_;$/;"	m	class:gwriter	access:private
hash_error	include/buckethash.h	/^	hash_error()$/;"	f	class:hash_error	access:public	signature:()
hash_error	include/buckethash.h	/^	hash_error(const std::string& err)$/;"	f	class:hash_error	access:public	signature:(const std::string& err)
hash_error	include/buckethash.h	/^class hash_error : public std::runtime_error$/;"	c	inherits:std::runtime_error
hash_error::hash_error	include/buckethash.h	/^	hash_error()$/;"	f	class:hash_error	access:public	signature:()
hash_error::hash_error	include/buckethash.h	/^	hash_error(const std::string& err)$/;"	f	class:hash_error	access:public	signature:(const std::string& err)
heap	compiler/scope.h	/^        heap,$/;"	e	enum:varscope::scope_defines
heap	include/heapX.h	/^	heap()$/;"	f	class:heap	access:public	signature:()
heap	include/heapX.h	/^	heap(_Iter _First, _Iter _Last)$/;"	f	class:heap	access:public	signature:(_Iter _First, _Iter _Last)
heap	include/heapX.h	/^class heap$/;"	c
heap::begin	include/heapX.h	/^	const_iterator begin() const { return c_.begin(); }$/;"	f	class:heap	access:public	signature:() const
heap::begin	include/heapX.h	/^	iterator begin() { return c_.begin(); }$/;"	f	class:heap	access:public	signature:()
heap::c_	include/heapX.h	/^	_C c_;$/;"	m	class:heap	access:protected
heap::const_iterator	include/heapX.h	/^	typedef typename _C::const_iterator const_iterator;$/;"	t	class:heap	access:public
heap::earse	include/heapX.h	/^	void earse(iterator _First, iterator _Last)$/;"	f	class:heap	access:public	signature:(iterator _First, iterator _Last)
heap::earse	include/heapX.h	/^	void earse(iterator ei)$/;"	f	class:heap	access:public	signature:(iterator ei)
heap::end	include/heapX.h	/^	const_iterator end() const { return c_.end(); }$/;"	f	class:heap	access:public	signature:() const
heap::end	include/heapX.h	/^	iterator end() { return c_.end(); }$/;"	f	class:heap	access:public	signature:()
heap::find	include/heapX.h	/^	const_iterator find(const value_type& _v) const$/;"	f	class:heap	access:public	signature:(const value_type& _v) const
heap::find	include/heapX.h	/^	iterator find(const value_type _v)$/;"	f	class:heap	access:public	signature:(const value_type _v)
heap::heap	include/heapX.h	/^	heap()$/;"	f	class:heap	access:public	signature:()
heap::heap	include/heapX.h	/^	heap(_Iter _First, _Iter _Last)$/;"	f	class:heap	access:public	signature:(_Iter _First, _Iter _Last)
heap::insert	include/heapX.h	/^	void insert(_Iter _First, _Iter _Last)$/;"	f	class:heap	access:public	signature:(_Iter _First, _Iter _Last)
heap::insert	include/heapX.h	/^	void insert(const value_type& _v)$/;"	f	class:heap	access:public	signature:(const value_type& _v)
heap::isexist	include/heapX.h	/^	bool isexist(const value_type& _v) const$/;"	f	class:heap	access:public	signature:(const value_type& _v) const
heap::iterator	include/heapX.h	/^	typedef typename _C::iterator iterator;$/;"	t	class:heap	access:public
heap::remove	include/heapX.h	/^	void remove(const value_type& _v)$/;"	f	class:heap	access:public	signature:(const value_type& _v)
heap::update	include/heapX.h	/^	void update()$/;"	f	class:heap	access:protected	signature:()
heap::value_type	include/heapX.h	/^	typedef typename _C::value_type value_type;$/;"	t	class:heap	access:public
heap::~heap	include/heapX.h	/^	~heap()$/;"	f	class:heap	access:public	signature:()
holder	syntax/global_values.h	/^		holder() {}$/;"	f	class:refobject::holder	access:public	signature:()
holder	syntax/global_values.h	/^	class holder$/;"	c	class:refobject	access:private
holder_	syntax/production.h	/^	const symholder* holder_;$/;"	m	class:production	access:private
i	third_party/xml/Markup.cpp	/^	int i;$/;"	m	struct:PathPos	file:	access:private
iElemChild	third_party/xml/Markup.cpp	/^	int iElemChild; \/\/ first child$/;"	m	struct:ElemPos	file:	access:public
iElemNext	third_party/xml/Markup.cpp	/^	int iElemNext; \/\/ next sibling$/;"	m	struct:ElemPos	file:	access:public
iElemParent	third_party/xml/Markup.cpp	/^	int iElemParent;$/;"	m	struct:ElemPos	file:	access:public
iElemPrev	third_party/xml/Markup.cpp	/^	int iElemPrev; \/\/ if this is first, iElemPrev points to last$/;"	m	struct:ElemPos	file:	access:public
iNext	third_party/xml/Markup.cpp	/^	int iNext;$/;"	m	struct:TagPos	file:	access:public
iPar	third_party/xml/Markup.cpp	/^	int iPar;$/;"	m	struct:ElemStack	file:	access:public
iParent	third_party/xml/Markup.cpp	/^	int iParent;$/;"	m	struct:TagPos	file:	access:public
iPathAttribName	third_party/xml/Markup.cpp	/^	int iPathAttribName;$/;"	m	struct:PathPos	file:	access:private
iPos	third_party/xml/Markup.cpp	/^	int iPos;$/;"	m	struct:SavedPos	file:	access:public
iPrev	third_party/xml/Markup.cpp	/^	int iPrev;$/;"	m	struct:TagPos	file:	access:public
iR	galgorithm/regex2nfa.cpp	/^		int iR; \/\/ first right index$/;"	m	struct:parsecontent::prod	file:	access:public
iR	tmp/back/regex2nfa.cpp	/^		int iR; \/\/ first right index$/;"	m	struct:parsecontent::prod	file:	access:public
iS	galgorithm/regex2nfa.cpp	/^	int iS;$/;"	m	struct:parsecontent	file:	access:public
iS	tmp/back/regex2nfa.cpp	/^	int iS;$/;"	m	struct:parsecontent	file:	access:public
iSave	third_party/xml/Markup.cpp	/^	int iSave;$/;"	m	struct:PathPos	file:	access:private
iSlotNext	third_party/xml/Markup.cpp	/^	int iSlotNext;$/;"	m	struct:TagPos	file:	access:public
iSlotPrev	third_party/xml/Markup.cpp	/^	int iSlotPrev;$/;"	m	struct:TagPos	file:	access:public
iTop	third_party/xml/Markup.cpp	/^	int iTop;$/;"	m	struct:ElemStack	file:	access:public
iUsed	third_party/xml/Markup.cpp	/^	int iUsed;$/;"	m	struct:ElemStack	file:	access:protected
idx	test/vhelp.h	/^	int32 idx;$/;"	m	struct:symindex	access:public
ifile	include/markuputils.h	/^	ifile(const std::string& fname)$/;"	f	class:ifile	access:public	signature:(const std::string& fname)
ifile	include/markuputils.h	/^class ifile : public virtual utils::file$/;"	c	inherits:utils::file
ifile::cnode_	include/markuputils.h	/^	node cnode_;$/;"	m	class:ifile	access:private
ifile::ifile	include/markuputils.h	/^	ifile(const std::string& fname)$/;"	f	class:ifile	access:public	signature:(const std::string& fname)
ifile::swap	include/markuputils.h	/^	void swap(ifile& other)$/;"	f	class:ifile	access:public	signature:(ifile& other)
ifunction	compiler/ifunction.h	/^class ifunction$/;"	c
ifunction::machine_meta	compiler/ifunction.h	/^    typedef automachine::machine_meta machine_meta;$/;"	t	class:ifunction	access:public
ifunction::operator ()	compiler/ifunction.h	/^    virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result) = 0;$/;"	p	class:ifunction	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
iml_	compiler/compiler.h	/^    kog::shared_ptr<compile::interlanguage> iml_;$/;"	m	class:compiler	access:private
in	include/markuputils.h	/^	enum {in = 0, out = 1};$/;"	e	enum:file::__anon3
inORout_	include/markuputils.h	/^	bool inORout_;$/;"	m	class:file	access:protected
inc	makecompiler/gensyntax.cpp	/^	int inc;$/;"	m	struct:tabident	file:	access:private
inc	tmp/coutfun.cpp	/^	int inc;$/;"	m	struct:Ident	file:	access:public
incref	include/shared_ptr.h	/^		void incref() { ++(*count); }$/;"	f	class:shared_ptr	access:private	signature:()
inctab	makecompiler/gensyntax.cpp	/^	static tabident inctab;$/;"	m	struct:tabident	file:	access:public
index	syntax/symbol.cpp	/^int32 symholder::index(const tstring& name) const$/;"	f	class:symholder	signature:(const tstring& name) const
index	syntax/symbol.h	/^	int index(const tstring& name) const;$/;"	p	class:symholder	access:public	signature:(const tstring& name) const
index_sort	include/functionalX.h	/^std::vector<size_t> index_sort(_InIt _First, _InIt _Last)$/;"	f	signature:(_InIt _First, _InIt _Last)
index_sort	include/functionalX.h	/^std::vector<size_t> index_sort(_InIt _First, _InIt _Last, _Pr _pr)$/;"	f	signature:(_InIt _First, _InIt _Last, _Pr _pr)
init	syntax/automachine.cpp	/^void automachine::init()$/;"	f	class:automachine	signature:()
init	syntax/automachine.h	/^	virtual void init();$/;"	p	class:automachine	access:public	signature:()
init	syntax/lrmachine.cpp	/^void lrmachine::init()$/;"	f	class:lrmachine	signature:()
init	syntax/lrmachine.h	/^	\/* overwrite *\/ virtual void init();$/;"	p	class:lrmachine	access:public	signature:()
init	syntax/statemachine.cpp	/^void state_machine::init()$/;"	f	class:state_machine	signature:()
init	syntax/statemachine.h	/^	\/* overwrite *\/ virtual void init();$/;"	p	class:state_machine	access:public	signature:()
init	test/basicalgorithmtest.cpp	/^	\/* overwrite *\/ virtual void init(int argc, const char* argv[])$/;"	f	class:basicalg_test	file:	access:private	signature:(int argc, const char* argv[])
init	test/firstfollowtest.cpp	/^	\/* overwrite *\/ virtual void init(int argc, const char* argv[])$/;"	f	class:firstfollow_test	file:	access:private	signature:(int argc, const char* argv[])
init	test/lrmachinetest.cpp	/^	\/* overwrite *\/ virtual void init(int argc, const char* argv[])$/;"	f	class:lrmachine_test	file:	access:private	signature:(int argc, const char* argv[])
init	test/nfa2dfatest.cpp	/^	\/* overwrite *\/ virtual void init(int argc, const char* argv[])$/;"	f	class:nfa2dfa_test	file:	access:private	signature:(int argc, const char* argv[])
init	test/pascaltest.cpp	/^	\/* overwrite *\/ virtual void init(int argc, const char* argv[])$/;"	f	class:pascal_test	file:	access:private	signature:(int argc, const char* argv[])
init	test/regexnfatest.cpp	/^	\/* overwrite *\/ virtual void init(int argc, const char* argv[])$/;"	f	class:regex2nfa_test	file:	access:private	signature:(int argc, const char* argv[])
init	test/splitwords.cpp	/^	\/* overwrite *\/ virtual void init(int argc, const char* argv[])$/;"	f	class:splitwords_test	access:public	signature:(int argc, const char* argv[])
init	test/tinygrammar-compiler.cpp	/^	\/* overwrite *\/ virtual void init(int argc, const char* argv[])$/;"	f	class:tinyg_compiler_test	access:public	signature:(int argc, const char* argv[])
init	test/tinygrammartest.cpp	/^	\/* overwrite *\/ virtual void init(int argc, const char* argv[])$/;"	f	class:simplegrammar_test	access:public	signature:(int argc, const char* argv[])
init	test/unittest.h	/^	virtual void init(int argc, const char* argv[]) = 0;$/;"	p	class:unittest	access:public	signature:(int argc, const char* argv[])
init_funcs	test/tinygrammartest.cpp	/^    void init_funcs(std::vector<std::string>& funcs);$/;"	p	class:grammar_wrapper	file:	access:private	signature:(std::vector<std::string>& funcs)
init_funcs	test/tinygrammartest.cpp	/^void grammar_wrapper::init_funcs(std::vector<std::string>& funcs)$/;"	f	class:grammar_wrapper	signature:(std::vector<std::string>& funcs)
init_grammar	build/debug/test/tinyg.cpp	/^void init_grammar(tinygrammar& tig)$/;"	f	signature:(tinygrammar& tig)
init_grammar	build/debug/test/tmp.cpp	/^void init_grammar(tinygrammar& tig)$/;"	f	signature:(tinygrammar& tig)
init_grammar	build/debug/test/xxx.cpp	/^void init_grammar(tinygrammar& tig)$/;"	f	signature:(tinygrammar& tig)
init_grammar	compiler/compiler.cpp	/^extern void init_grammar(tinygrammar& tig);$/;"	p	file:	signature:(tinygrammar& tig)
init_grammar	test/output/tinyg.cpp	/^void init_grammar(tinygrammar& tig)$/;"	f	signature:(tinygrammar& tig)
init_grammar	test/output/tinyg/tinyg.cpp	/^void init_grammar(tinygrammar& tig)$/;"	f	signature:(tinygrammar& tig)
init_grammar	test/tinyg.cpp	/^void init_grammar(tinygrammar& tig)$/;"	f	signature:(tinygrammar& tig)
init_grammar	test/tinygrammartest.cpp	/^	void init_grammar(grammar& g);$/;"	p	class:simplegrammar_test	file:	access:private	signature:(grammar& g)
init_grammar	test/tinygrammartest.cpp	/^void simplegrammar_test::init_grammar(grammar& g)$/;"	f	class:simplegrammar_test	signature:(grammar& g)
init_grammar	test/usefullmachines.cpp	/^void init_grammar(tinygrammar& tig)$/;"	f	signature:(tinygrammar& tig)
init_keywords	build/debug/test/tinyg.cpp	/^void init_keywords(kog::buckethash<std::string, int32, string_2_int>& keywords)$/;"	f	signature:(kog::buckethash<std::string, int32, string_2_int>& keywords)
init_keywords	build/debug/test/tmp.cpp	/^void init_keywords(kog::buckethash<std::string, int32, string_2_int>& keywords)$/;"	f	signature:(kog::buckethash<std::string, int32, string_2_int>& keywords)
init_keywords	build/debug/test/xxx.cpp	/^void init_keywords(kog::buckethash<std::string, int32, string_2_int>& keywords)$/;"	f	signature:(kog::buckethash<std::string, int32, string_2_int>& keywords)
init_keywords	compiler/compiler.cpp	/^extern void init_keywords(kog::buckethash<std::string, int32, string_2_int>& keywords);$/;"	p	file:	signature:(kog::buckethash<std::string, int32, string_2_int>& keywords)
init_keywords	test/output/tinyg.cpp	/^void init_keywords(kog::buckethash<std::string, int32, string_2_int>& keywords)$/;"	f	signature:(kog::buckethash<std::string, int32, string_2_int>& keywords)
init_keywords	test/output/tinyg/tinyg.cpp	/^void init_keywords(kog::buckethash<std::string, int32, string_2_int>& keywords)$/;"	f	signature:(kog::buckethash<std::string, int32, string_2_int>& keywords)
init_keywords	test/output/tinyg/tinyg_bk.cpp	/^void init_keywords(kog::buckethash<std::string, int32, string_2_int>& keywords)$/;"	f	signature:(kog::buckethash<std::string, int32, string_2_int>& keywords)
init_keywords	test/tinyg.cpp	/^void init_keywords(kog::buckethash<std::string, int32, string_2_int>& keywords)$/;"	f	signature:(kog::buckethash<std::string, int32, string_2_int>& keywords)
init_keywords	test/usefullmachines.cpp	/^void init_keywords(kog::buckethash<std::string, int32, string_2_int>& keywords)$/;"	f	signature:(kog::buckethash<std::string, int32, string_2_int>& keywords)
init_machines	build/debug/test/tinyg.cpp	/^void init_machines(std::map<std::string, machine>& machines)$/;"	f	signature:(std::map<std::string, machine>& machines)
init_machines	build/debug/test/tmp.cpp	/^void init_machines(std::map<std::string, machine>& machines)$/;"	f	signature:(std::map<std::string, machine>& machines)
init_machines	build/debug/test/xxx.cpp	/^void init_machines(std::map<std::string, machine>& machines)$/;"	f	signature:(std::map<std::string, machine>& machines)
init_machines	compiler/compiler.cpp	/^extern void init_machines(std::map<std::string, machine>& machines);$/;"	p	file:	signature:(std::map<std::string, machine>& machines)
init_machines	test/output/tinyg.cpp	/^void init_machines(std::map<std::string, machine>& machines)$/;"	f	signature:(std::map<std::string, machine>& machines)
init_machines	test/output/tinyg/tinyg.cpp	/^void init_machines(std::map<std::string, machine>& machines)$/;"	f	signature:(std::map<std::string, machine>& machines)
init_machines	test/output/tinyg/tinyg_bk.cpp	/^void init_machines(std::map<std::string, kog::shared_ptr<automachine> >& machines)$/;"	f	signature:(std::map<std::string, kog::shared_ptr<automachine> >& machines)
init_machines	test/tinyg.cpp	/^void init_machines(std::map<std::string, machine>& machines)$/;"	f	signature:(std::map<std::string, machine>& machines)
init_machines	test/usefullmachines.cpp	/^void init_machines(std::map<std::string, machine>& machines)$/;"	f	signature:(std::map<std::string, machine>& machines)
init_printablechars	build/debug/test/tinyg.cpp	/^void init_printablechars(kog::smart_vector<sc::int32>& printablechars)$/;"	f	signature:(kog::smart_vector<sc::int32>& printablechars)
init_printablechars	build/debug/test/tmp.cpp	/^void init_printablechars(kog::smart_vector<sc::int32>& printablechars)$/;"	f	signature:(kog::smart_vector<sc::int32>& printablechars)
init_printablechars	build/debug/test/xxx.cpp	/^void init_printablechars(kog::smart_vector<sc::int32>& printablechars)$/;"	f	signature:(kog::smart_vector<sc::int32>& printablechars)
init_printablechars	compiler/compiler.cpp	/^extern void init_printablechars(kog::smart_vector<sc::int32>& printablechars);$/;"	p	file:	signature:(kog::smart_vector<sc::int32>& printablechars)
init_printablechars	test/output/tinyg.cpp	/^void init_printablechars(kog::smart_vector<sc::int32>& printablechars)$/;"	f	signature:(kog::smart_vector<sc::int32>& printablechars)
init_printablechars	test/output/tinyg/tinyg.cpp	/^void init_printablechars(kog::smart_vector<sc::int32>& printablechars)$/;"	f	signature:(kog::smart_vector<sc::int32>& printablechars)
init_printablechars	test/output/tinyg/tinyg_bk.cpp	/^void init_printablechars(kog::smart_vector<sc::int32>& printablechars)$/;"	f	signature:(kog::smart_vector<sc::int32>& printablechars)
init_printablechars	test/tinyg.cpp	/^void init_printablechars(kog::smart_vector<sc::int32>& printablechars)$/;"	f	signature:(kog::smart_vector<sc::int32>& printablechars)
init_printablechars	test/usefullmachines.cpp	/^void init_printablechars(kog::smart_vector<sc::int32>& printablechars)$/;"	f	signature:(kog::smart_vector<sc::int32>& printablechars)
init_production_functions	build/debug/test/initprodfuncs.cpp	/^void init_production_functions(kog::smart_vector<ifunction*>& pfuncs)$/;"	f	signature:(kog::smart_vector<ifunction*>& pfuncs)
init_production_functions	build/debug/test/prodfunc.cpp	/^void init_production_functions(kog::smart_vector<ifunction*>& pfuncs)$/;"	f	signature:(kog::smart_vector<ifunction*>& pfuncs)
init_production_functions	compiler/compiler.cpp	/^extern void init_production_functions(kog::smart_vector<ifunction*>& pfuncs);$/;"	p	file:	signature:(kog::smart_vector<ifunction*>& pfuncs)
init_production_functions	test/tinygprodfuncs.cpp	/^void init_production_functions(kog::smart_vector<ifunction*>& pfuncs)$/;"	f	signature:(kog::smart_vector<ifunction*>& pfuncs)
init_production_functions	test/usefullmachines.cpp	/^void init_production_functions(kog::smart_vector<ifunction*>& pfuncs)$/;"	f	signature:(kog::smart_vector<ifunction*>& pfuncs)
init_production_functions	tmp/prodfunc.cpp	/^void init_production_functions(kog::smart_vector<ifunction*>& pfuncs)$/;"	f	signature:(kog::smart_vector<ifunction*>& pfuncs)
init_separators	build/debug/test/tinyg.cpp	/^void init_separators(kog::smart_vector<sc::int32>& separators, kog::tree<int32>& sepsid)$/;"	f	signature:(kog::smart_vector<sc::int32>& separators, kog::tree<int32>& sepsid)
init_separators	build/debug/test/tmp.cpp	/^void init_separators(kog::smart_vector<sc::int32>& separators, kog::tree<int32>& sepsid)$/;"	f	signature:(kog::smart_vector<sc::int32>& separators, kog::tree<int32>& sepsid)
init_separators	build/debug/test/xxx.cpp	/^void init_separators(kog::smart_vector<sc::int32>& separators, kog::tree<int32>& sepsid)$/;"	f	signature:(kog::smart_vector<sc::int32>& separators, kog::tree<int32>& sepsid)
init_separators	compiler/compiler.cpp	/^extern void init_separators(kog::smart_vector<sc::int32>& separators, kog::tree<int32>& sepsid);$/;"	p	file:	signature:(kog::smart_vector<sc::int32>& separators, kog::tree<int32>& sepsid)
init_separators	test/output/tinyg.cpp	/^void init_separators(kog::smart_vector<sc::int32>& separators, kog::tree<int32>& sepsid)$/;"	f	signature:(kog::smart_vector<sc::int32>& separators, kog::tree<int32>& sepsid)
init_separators	test/output/tinyg/tinyg.cpp	/^void init_separators(kog::smart_vector<sc::int32>& separators, kog::tree<int32>& sepsid)$/;"	f	signature:(kog::smart_vector<sc::int32>& separators, kog::tree<int32>& sepsid)
init_separators	test/output/tinyg/tinyg_bk.cpp	/^void init_separators(kog::smart_vector<sc::int32>& separators, kog::tree<int32>& sepsid)$/;"	f	signature:(kog::smart_vector<sc::int32>& separators, kog::tree<int32>& sepsid)
init_separators	test/tinyg.cpp	/^void init_separators(kog::smart_vector<sc::int32>& separators, kog::tree<int32>& sepsid)$/;"	f	signature:(kog::smart_vector<sc::int32>& separators, kog::tree<int32>& sepsid)
init_separators	test/usefullmachines.cpp	/^void init_separators(kog::smart_vector<sc::int32>& separators, kog::tree<int32>& sepsid)$/;"	f	signature:(kog::smart_vector<sc::int32>& separators, kog::tree<int32>& sepsid)
init_syntax_machine	build/debug/test/tinyg.cpp	/^void init_syntax_machine(lalr1machine& lrm)$/;"	f	signature:(lalr1machine& lrm)
init_syntax_machine	build/debug/test/tmp.cpp	/^void init_syntax_machine(lalr1machine& lrm)$/;"	f	signature:(lalr1machine& lrm)
init_syntax_machine	build/debug/test/xxx.cpp	/^void init_syntax_machine(lalr1machine& lrm)$/;"	f	signature:(lalr1machine& lrm)
init_syntax_machine	compiler/compiler.cpp	/^extern void init_syntax_machine(lalr1machine& lrm);$/;"	p	file:	signature:(lalr1machine& lrm)
init_syntax_machine	test/output/tinyg.cpp	/^void init_syntax_machine(lalr1machine& lrm)$/;"	f	signature:(lalr1machine& lrm)
init_syntax_machine	test/output/tinyg/tinyg.cpp	/^void init_syntax_machine(lalr1machine& lrm)$/;"	f	signature:(lalr1machine& lrm)
init_syntax_machine	test/output/tinyg/tinyg_bk.cpp	/^void init_syntax_machine(lalr1machine& lrm)$/;"	f	signature:(lalr1machine& lrm)
init_syntax_machine	test/tinyg.cpp	/^void init_syntax_machine(lalr1machine& lrm)$/;"	f	signature:(lalr1machine& lrm)
init_syntax_machine	test/usefullmachines.cpp	/^void init_syntax_machine(lalr1machine& lrm)$/;"	f	signature:(lalr1machine& lrm)
initialization	compiler/compiler.cpp	/^void compiler::initialization()$/;"	f	class:compiler	signature:()
initialization	compiler/compiler.h	/^	void initialization();$/;"	p	class:compiler	access:public	signature:()
initmachines	tmp/back/compiler.cpp	/^void compiler::initmachines()$/;"	f	class:compiler	signature:()
initmachines	tmp/back/compiler.h	/^	void initmachines();$/;"	p	class:compiler	access:public	signature:()
initv	compiler/value.h	/^        byte* initv;$/;"	m	union:value::__anon131	access:public
initv_	compiler/variable.h	/^        value* initv_; \/\/ initial value$/;"	m	union:variable::__anon130	access:public
input	test/splitwords.cpp	/^	std::string input;$/;"	m	class:splitwords_test	file:	access:private
input	test/tinygrammar-compiler.cpp	/^	std::string input;$/;"	m	class:tinyg_compiler_test	file:	access:private
insert	galgorithm/regex2nfa.cpp	/^	void insert(list* ph, int v)$/;"	f	struct:parsecontent	access:public	signature:(list* ph, int v)
insert	include/buckethash.h	/^	void insert(const key& k, const value& v)$/;"	f	class:buckethash	access:public	signature:(const key& k, const value& v)
insert	include/buckethash.h	/^	void insert(const keyvalue& kv)$/;"	f	class:buckethash	access:public	signature:(const keyvalue& kv)
insert	include/heapX.h	/^	void insert(_Iter _First, _Iter _Last)$/;"	f	class:heap	access:public	signature:(_Iter _First, _Iter _Last)
insert	include/heapX.h	/^	void insert(const value_type& _v)$/;"	f	class:heap	access:public	signature:(const value_type& _v)
insert	include/sortc.h	/^	void insert(_Iter _First, _Iter _Last)$/;"	f	class:sortc	access:public	signature:(_Iter _First, _Iter _Last)
insert	include/sortc.h	/^	void insert(const value_type& v)$/;"	f	class:sortc	access:public	signature:(const value_type& v)
insert	syntax/global_values.h	/^	void insert(const std::string& name, const _Tx& value)$/;"	f	class:global_values	access:public	signature:(const std::string& name, const _Tx& value)
insert	tmp/back/regex2nfa.cpp	/^	void insert(list* ph, int v)$/;"	f	struct:parsecontent	access:public	signature:(list* ph, int v)
insert_new_prod	galgorithm/regex2nfa.cpp	/^	void insert_new_prod(int L, const int* R, int c, int prod_type)$/;"	f	struct:parsecontent	access:public	signature:(int L, const int* R, int c, int prod_type)
insert_new_prod	tmp/back/regex2nfa.cpp	/^	void insert_new_prod(int L, const int* R, int c, int prod_type)$/;"	f	struct:parsecontent	access:public	signature:(int L, const int* R, int c, int prod_type)
insert_new_state	galgorithm/lranalyse.cpp	/^	const lrstate* insert_new_state(const lrstate* A, int32 a, const lrstate* B);$/;"	p	struct:AlgorithmArg	file:	access:public	signature:(const lrstate* A, int32 a, const lrstate* B)
insert_new_state	galgorithm/lranalyse.cpp	/^const lrstate* AlgorithmArg::insert_new_state(const lrstate* A, int32 a, const lrstate* B)$/;"	f	class:AlgorithmArg	signature:(const lrstate* A, int32 a, const lrstate* B)
instance	include/singleton.h	/^	static value_type& instance()$/;"	f	class:singleton	access:public	signature:()
instructions	compiler/instruction.h	/^class instructions$/;"	c
int16	include/basic_types.h	/^typedef short int16;$/;"	t
int32	include/basic_types.h	/^typedef int int32;$/;"	t
int32	test/vhelp.h	/^	typedef compile::int32 int32;$/;"	t	class:Aproduction	access:private
int32	test/vhelp.h	/^	typedef compile::int32 int32;$/;"	t	class:Asymbol	access:private
int32	test/vhelp.h	/^	typedef compile::int32 int32;$/;"	t	class:V	access:private
int32	test/vhelp.h	/^	typedef compile::int32 int32;$/;"	t	struct:symindex	access:public
int32array	syntax/lrmachine.h	/^	typedef kog::smart_vector<int32> int32array;$/;"	t	class:lrmachine	access:public
int64	include/basic_types.h	/^typedef long int int64;$/;"	t
int8	include/basic_types.h	/^typedef char int8;$/;"	t
int_type	compiler/type.cpp	/^const type* typesystem::int_type() const$/;"	f	class:typesystem	signature:() const
int_type	compiler/type.h	/^    const type* int_type() const;$/;"	p	class:typesystem	access:public	signature:() const
interlanguage	compiler/interlanguage.cpp	/^interlanguage::interlanguage()$/;"	f	class:interlanguage	signature:()
interlanguage	compiler/interlanguage.h	/^	interlanguage();$/;"	p	class:interlanguage	access:public	signature:()
interlanguage	compiler/interlanguage.h	/^class interlanguage$/;"	c
interlanguage::all_scopes_	compiler/interlanguage.h	/^    std::deque<kog::shared_ptr<runtime::scope> > all_scopes_;$/;"	m	class:interlanguage	access:private
interlanguage::automachine	compiler/interlanguage.h	/^	typedef compile::automachine automachine;$/;"	t	class:interlanguage	access:public
interlanguage::current_scope	compiler/interlanguage.cpp	/^scope* interlanguage::current_scope() const$/;"	f	class:interlanguage	signature:() const
interlanguage::current_scope	compiler/interlanguage.h	/^    runtime::scope* current_scope() const;$/;"	p	class:interlanguage	access:public	signature:() const
interlanguage::current_scope_	compiler/interlanguage.h	/^    runtime::scope* current_scope_;$/;"	m	class:interlanguage	access:private
interlanguage::generate	compiler/interlanguage.cpp	/^void interlanguage::generate(const std::string& finput_name, const std::string& fotput_name)$/;"	f	class:interlanguage	signature:(const std::string& finput_name, const std::string& fotput_name)
interlanguage::generate	compiler/interlanguage.h	/^	void generate(const std::string& finput_name, const std::string& fotput_name);$/;"	p	class:interlanguage	access:public	signature:(const std::string& finput_name, const std::string& fotput_name)
interlanguage::interlanguage	compiler/interlanguage.cpp	/^interlanguage::interlanguage()$/;"	f	class:interlanguage	signature:()
interlanguage::interlanguage	compiler/interlanguage.h	/^	interlanguage();$/;"	p	class:interlanguage	access:public	signature:()
interlanguage::into_scope	compiler/interlanguage.cpp	/^scope* interlanguage::into_scope(runtime::scope* s)$/;"	f	class:interlanguage	signature:(runtime::scope* s)
interlanguage::into_scope	compiler/interlanguage.h	/^    runtime::scope* into_scope(runtime::scope* s);$/;"	p	class:interlanguage	access:public	signature:(runtime::scope* s)
interlanguage::lalr1machine	compiler/interlanguage.h	/^	typedef compile::lalr1machine lalr1machine;$/;"	t	class:interlanguage	access:public
interlanguage::main_scope_	compiler/interlanguage.h	/^    kog::shared_ptr<runtime::scope> main_scope_;$/;"	m	class:interlanguage	access:private
interlanguage::new_scope	compiler/interlanguage.cpp	/^scope* interlanguage::new_scope()$/;"	f	class:interlanguage	signature:()
interlanguage::new_scope	compiler/interlanguage.h	/^    runtime::scope* new_scope();$/;"	p	class:interlanguage	access:public	signature:()
interlanguage::otof_scope	compiler/interlanguage.cpp	/^scope* interlanguage::otof_scope()$/;"	f	class:interlanguage	signature:()
interlanguage::otof_scope	compiler/interlanguage.h	/^    runtime::scope* otof_scope();$/;"	p	class:interlanguage	access:public	signature:()
interlanguage::state_machine	compiler/interlanguage.h	/^	typedef compile::state_machine state_machine;$/;"	t	class:interlanguage	access:public
interlanguage::~interlanguage	compiler/interlanguage.cpp	/^interlanguage::~interlanguage()$/;"	f	class:interlanguage	signature:()
interlanguage::~interlanguage	compiler/interlanguage.h	/^    virtual ~interlanguage();$/;"	p	class:interlanguage	access:public	signature:()
internal	compiler/operation.h	/^    internal$/;"	e	enum:op
interp	include/mathX.h	/^		static T interp(const T* xBegin, const T* yBegin, const size_t nSize, const T& val)$/;"	f	class:math::interpolate	access:public	signature:(const T* xBegin, const T* yBegin, const size_t nSize, const T& val)
interpolate	include/mathX.h	/^	class interpolate$/;"	c	class:math	access:public
into	include/markuputils.h	/^	void into()$/;"	f	class:file	access:public	signature:()
into_scope	compiler/interlanguage.cpp	/^scope* interlanguage::into_scope(runtime::scope* s)$/;"	f	class:interlanguage	signature:(runtime::scope* s)
into_scope	compiler/interlanguage.h	/^    runtime::scope* into_scope(runtime::scope* s);$/;"	p	class:interlanguage	access:public	signature:(runtime::scope* s)
intpair_cmp	syntax/automachine.h	/^struct intpair_cmp : public std::binary_function<std::pair<int, int>, std::pair<int, int>, bool>$/;"	s	inherits:std::binary_function
intpair_cmp::_L	syntax/automachine.h	/^	_CmpFunc _L;$/;"	m	struct:intpair_cmp	access:public
intpair_cmp::operator ()	syntax/automachine.h	/^	bool operator()(const std::pair<int, int>& p1, const std::pair<int, int>& p2) const$/;"	f	struct:intpair_cmp	access:public	signature:(const std::pair<int, int>& p1, const std::pair<int, int>& p2) const
intpair_equal	syntax/automachine.h	/^typedef intpair_cmp<std::equal_to<int> > intpair_equal;$/;"	t
intpair_less	syntax/automachine.h	/^typedef intpair_cmp<std::less<int> > intpair_less;$/;"	t
invoke	galgorithm/basicalgorithms.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:eliminate_eplison	access:public	signature:()
invoke	galgorithm/basicalgorithms.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:removenotused	access:public	signature:()
invoke	galgorithm/basicalgorithms.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:removesingle	access:public	signature:()
invoke	galgorithm/basicalgorithms.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:simplegrammar	access:public	signature:()
invoke	galgorithm/basicalgorithms.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:symbol_to_eplison	access:public	signature:()
invoke	galgorithm/dfa2machine.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:dfa2machine	access:public	signature:()
invoke	galgorithm/eclosures.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:eclosure	access:public	signature:()
invoke	galgorithm/firstfollow.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:firstset	access:public	signature:()
invoke	galgorithm/firstfollow.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:followset	access:public	signature:()
invoke	galgorithm/grammaralgorithm.h	/^	virtual void invoke() = 0;$/;"	p	class:grammar_algorithm	access:public	signature:()
invoke	galgorithm/lranalyse.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:lranalyse	access:public	signature:()
invoke	galgorithm/nfa2dfa.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:nfa2dfa	access:public	signature:()
invoke	galgorithm/regex2nfa.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:regex2nfa	access:public	signature:()
invoke	tmp/back/container_group.h	/^	void invoke(_Fun _F) const$/;"	f	class:container_group	access:public	signature:(_Fun _F) const
invoke	tmp/back/container_group.h	/^	void invoke(_Fun _F)$/;"	f	class:container_group	access:public	signature:(_Fun _F)
is_	test/gio.h	/^	std::istream& is_;$/;"	m	class:greader	access:private
is_auto_delete	include/arrayX.h	/^		bool is_auto_delete;$/;"	m	struct:smart_vector::block	access:public
is_between_t	include/functionalX.h	/^	is_between_t(const _Arg& _min, const _Arg& _max)$/;"	f	class:is_between_t	access:public	signature:(const _Arg& _min, const _Arg& _max)
is_between_t	include/functionalX.h	/^class is_between_t : public std::unary_function<bool, _Arg>$/;"	c	inherits:std::unary_function
is_between_t::_maxValue	include/functionalX.h	/^	const _Arg& _maxValue;$/;"	m	class:is_between_t	access:private
is_between_t::_minValue	include/functionalX.h	/^	const _Arg& _minValue;$/;"	m	class:is_between_t	access:private
is_between_t::is_between_t	include/functionalX.h	/^	is_between_t(const _Arg& _min, const _Arg& _max)$/;"	f	class:is_between_t	access:public	signature:(const _Arg& _min, const _Arg& _max)
is_between_t::operator ()	include/functionalX.h	/^	bool operator()(const _Arg& val) const$/;"	f	class:is_between_t	access:public	signature:(const _Arg& val) const
is_const_t	include/mplX.h	/^struct is_const_t $/;"	s
is_const_t	include/mplX.h	/^struct is_const_t<const _T>$/;"	s
is_const_t::value	include/mplX.h	/^	const static bool value = false;$/;"	m	struct:is_const_t	access:public
is_const_t::value	include/mplX.h	/^	const static bool value = true;$/;"	m	struct:is_const_t	access:public
is_id	third_party/regex/xregex.cpp	/^bool xregex::is_id(const tstring& str)$/;"	f	class:stringX::xregex	signature:(const tstring& str)
is_id	third_party/regex/xregex.h	/^	static bool is_id(const tstring& str);$/;"	p	class:stringX::xregex	access:public	signature:(const tstring& str)
is_interge	third_party/regex/xregex.cpp	/^bool xregex::is_interge(const tstring& str)$/;"	f	class:stringX::xregex	signature:(const tstring& str)
is_interge	third_party/regex/xregex.h	/^	static bool is_interge(const tstring& str);$/;"	p	class:stringX::xregex	access:public	signature:(const tstring& str)
is_keywords	compiler/compiler.cpp	/^int32 compiler::is_keywords(const std::string& s) const$/;"	f	class:compiler	signature:(const std::string& s) const
is_keywords	compiler/compiler.h	/^	sc::int32 is_keywords(const std::string& s) const;$/;"	p	class:compiler	access:private	signature:(const std::string& s) const
is_match	third_party/regex/xregex.cpp	/^bool is_match(const boost::regex& regex, const xregex::tstring& content)$/;"	f	namespace:stringX	signature:(const boost::regex& regex, const xregex::tstring& content)
is_match	third_party/regex/xregex.cpp	/^bool xregex::is_match(const tstring& regex_str, const tstring& content)$/;"	f	class:stringX::xregex	signature:(const tstring& regex_str, const tstring& content)
is_match	third_party/regex/xregex.h	/^	static bool is_match(const tstring& regex_str, const tstring& content);$/;"	p	class:stringX::xregex	access:public	signature:(const tstring& regex_str, const tstring& content)
is_separator	compiler/compiler.cpp	/^bool compiler::is_separator(int32 elem)$/;"	f	class:compiler	signature:(int32 elem)
is_separator	compiler/compiler.h	/^	static bool is_separator(sc::int32 elem);$/;"	p	class:compiler	access:public	signature:(sc::int32 elem)
is_separator	tmp/back/compiler.cpp	/^bool compiler::is_separator(int32 elem)$/;"	f	class:compiler	signature:(int32 elem)
is_separator	tmp/back/compiler.h	/^	static bool is_separator(sc::int32 elem);$/;"	p	class:compiler	access:public	signature:(sc::int32 elem)
is_start_in_right	galgorithm/basicalgorithms.cpp	/^bool eliminate_eplison::is_start_in_right(const tinygrammar& tig) const$/;"	f	class:eliminate_eplison	signature:(const tinygrammar& tig) const
is_start_in_right	galgorithm/basicalgorithms.h	/^	bool is_start_in_right(const tinygrammar& tig) const;$/;"	p	class:eliminate_eplison	access:private	signature:(const tinygrammar& tig) const
is_token_keyword	makecompiler/gensyntax.cpp	/^bool syntaxgenerator::is_token_keyword(const tchar* name) const$/;"	f	class:syntaxgenerator	signature:(const tchar* name) const
is_token_keyword	makecompiler/gensyntax.h	/^	bool is_token_keyword(const tchar* name) const;$/;"	p	class:syntaxgenerator	access:private	signature:(const tchar* name) const
is_true	include/debug.h	/^    static void is_true(bool b)$/;"	f	struct:assert	access:public	signature:(bool b)
isaccepted	syntax/automachine.h	/^	bool isaccepted() const$/;"	f	class:automachine	access:public	signature:() const
isdigit	include/stringX.h	/^	static bool isdigit(_Elem _Ch)$/;"	f	class:xstring_basic	access:public	signature:(_Elem _Ch)
isendings_	syntax/automachine.h	/^		int32 isendings_;$/;"	m	class:automachine::sheetrow	access:private
isexist	compiler/module.cpp	/^bool datamodule::isexist(const _Str& name)$/;"	f	class:datamodule	signature:(const _Str& name)
isexist	compiler/module.h	/^	bool isexist(const _Str& name);$/;"	p	class:datamodule	access:public	signature:(const _Str& name)
isexist	include/heapX.h	/^	bool isexist(const value_type& _v) const$/;"	f	class:heap	access:public	signature:(const value_type& _v) const
isinteger	include/stringX.h	/^	static bool isinteger(const _Myt& _Str)$/;"	f	class:xstring_basic	access:public	signature:(const _Myt& _Str)
islatter	include/stringX.h	/^	static bool islatter(_Elem _Ch)$/;"	f	class:xstring_basic	access:public	signature:(_Elem _Ch)
isre_	include/stringXF.h	/^    bool isre_;$/;"	m	struct:string_split_t	access:private
isrealsep	galgorithm/regex2nfa.cpp	/^	bool isrealsep(const char* p, const char* s)$/;"	f	struct:parsecontent	access:public	signature:(const char* p, const char* s)
isrealsep	tmp/back/regex2nfa.cpp	/^	bool isrealsep(const char* p, const char* s)$/;"	f	struct:parsecontent	access:public	signature:(const char* p, const char* s)
isrepat	galgorithm/regex2nfa.cpp	/^	int isrepat(const char*& s)$/;"	f	struct:parsecontent	access:public	signature:(const char*& s)
isrepat	tmp/back/regex2nfa.cpp	/^	int isrepat(const char*& s)$/;"	f	struct:parsecontent	access:public	signature:(const char*& s)
isspace	include/stringX.h	/^	static bool isspace(_Elem _Ch)$/;"	f	class:xstring_basic	access:public	signature:(_Elem _Ch)
ist	syntax/symbol.h	/^	int8 ist;$/;"	m	struct:symbol	access:public
istoe_	galgorithm/basicalgorithms.h	/^	vecint* istoe_;$/;"	m	class:symbol_to_eplison	access:private
ists	galgorithm/lranalyse.cpp	/^	kog::smart_vector<int> ists; \/\/ is terminate symbol$/;"	m	struct:AlgorithmArg	file:	access:public
isused_	tmp/back/simplepool.h	/^	std::deque<bitmap> isused_;$/;"	m	class:mempool	access:private
iter	include/buckethash.h	/^		bucket_const_iterator iter;$/;"	m	struct:buckethash::_Const_iterator	access:private
iterator	include/arrayX.h	/^	typedef array_iterator<value_type> iterator;$/;"	t	class:smart_vector	access:public
iterator	include/arrayX.h	/^	typedef array_iterator<value_type> iterator;$/;"	t	struct:SmartArray	access:public
iterator	include/arrayX.h	/^	typedef array_iterator<value_type> iterator;$/;"	t	struct:SmartMatrix	access:public
iterator	include/functionalX.h	/^	typedef typename mpl::add_const<_Iter>::value_type iterator;$/;"	t	struct:range_t	access:public
iterator	include/heapX.h	/^	typedef typename _C::iterator iterator;$/;"	t	class:heap	access:public
iterator	include/memoryX.h	/^	typedef array_iterator<value_type> iterator;$/;"	t	struct:memblock	access:public
iterator	include/sortc.h	/^	typedef typename _C::iterator iterator;$/;"	t	class:sortc	access:public
iterator_category	include/iteratorX.h	/^	typedef typename _Base::iterator_category iterator_category;$/;"	t	struct:array_iterator	access:public
iterator_category	include/tree.h	/^		typedef typename _Base::iterator_category iterator_category;$/;"	t	struct:tree::_Const_iterator	access:public
iterator_category	include/tree.h	/^		typedef typename _Base::iterator_category iterator_category;$/;"	t	struct:tree::_Iterator	access:public
iterator_next	include/iteratorX.h	/^_Iter iterator_next(_Iter iter)$/;"	f	signature:(_Iter iter)
iterator_pair	include/iteratorX.h	/^	iterator_pair()$/;"	f	struct:iterator_pair	access:public	signature:()
iterator_pair	include/iteratorX.h	/^	iterator_pair(_Iter1 _It1, _Iter2 _It2)$/;"	f	struct:iterator_pair	access:public	signature:(_Iter1 _It1, _Iter2 _It2)
iterator_pair	include/iteratorX.h	/^	iterator_pair(const std::pair<_Other1, _Other2>& _Right)$/;"	f	struct:iterator_pair	access:public	signature:(const std::pair<_Other1, _Other2>& _Right)
iterator_pair	include/iteratorX.h	/^struct iterator_pair : public std::pair<_Iter1, _Iter2>$/;"	s	inherits:std::pair
iterator_pair::_BaseType	include/iteratorX.h	/^	typedef std::pair<_Iter1, _Iter2> _BaseType;$/;"	t	struct:iterator_pair	access:public
iterator_pair::_Myt	include/iteratorX.h	/^	typedef iterator_pair<_Iter1, _Iter2> _Myt;$/;"	t	struct:iterator_pair	access:public
iterator_pair::backward	include/iteratorX.h	/^	_Myt& backward()$/;"	f	struct:iterator_pair	access:protected	signature:()
iterator_pair::forward	include/iteratorX.h	/^	_Myt& forward()$/;"	f	struct:iterator_pair	access:protected	signature:()
iterator_pair::iterator_pair	include/iteratorX.h	/^	iterator_pair()$/;"	f	struct:iterator_pair	access:public	signature:()
iterator_pair::iterator_pair	include/iteratorX.h	/^	iterator_pair(_Iter1 _It1, _Iter2 _It2)$/;"	f	struct:iterator_pair	access:public	signature:(_Iter1 _It1, _Iter2 _It2)
iterator_pair::iterator_pair	include/iteratorX.h	/^	iterator_pair(const std::pair<_Other1, _Other2>& _Right)$/;"	f	struct:iterator_pair	access:public	signature:(const std::pair<_Other1, _Other2>& _Right)
iterator_pair::operator !=	include/iteratorX.h	/^	bool operator != (const _Myt& _Other) const$/;"	f	struct:iterator_pair	access:public	signature:(const _Myt& _Other) const
iterator_pair::operator ++	include/iteratorX.h	/^	_Myt operator++(int) { _Myt temp(*this); forward(); return temp;}$/;"	f	struct:iterator_pair	access:public	signature:(int)
iterator_pair::operator ++	include/iteratorX.h	/^	_Myt& operator++() { return forward(); }$/;"	f	struct:iterator_pair	access:public	signature:()
iterator_pair::operator --	include/iteratorX.h	/^	_Myt operator--(int) { _Myt temp(*this); backward(); return temp; }$/;"	f	struct:iterator_pair	access:public	signature:(int)
iterator_pair::operator --	include/iteratorX.h	/^	_Myt& operator--() { return backward(); }$/;"	f	struct:iterator_pair	access:public	signature:()
iterator_pair::operator ==	include/iteratorX.h	/^	bool operator == (const _Myt& _Other) const$/;"	f	struct:iterator_pair	access:public	signature:(const _Myt& _Other) const
iterator_prior	include/iteratorX.h	/^_Iter iterator_prior(_Iter iter)$/;"	f	signature:(_Iter iter)
iwordstream	compiler/extract.cpp	/^	iwordstream(_Mysb *_Strbuf = NULL)$/;"	f	class:iwordstream	access:public	signature:(_Mysb *_Strbuf = NULL)
iwordstream	compiler/extract.cpp	/^class iwordstream : public std::istream$/;"	c	file:	inherits:std::istream
iwordstream::_Myios	compiler/extract.cpp	/^	typedef std::istream _Myios;$/;"	t	class:iwordstream	file:	access:private
iwordstream::_Mysb	compiler/extract.cpp	/^	typedef std::streambuf _Mysb;$/;"	t	class:iwordstream	file:	access:private
iwordstream::iwordstream	compiler/extract.cpp	/^	iwordstream(_Mysb *_Strbuf = NULL)$/;"	f	class:iwordstream	access:public	signature:(_Mysb *_Strbuf = NULL)
iwordstream::match_machines	compiler/extract.cpp	/^	int32 match_machines(word& aword, int_type _Meta)$/;"	f	class:iwordstream	file:	access:private	signature:(word& aword, int_type _Meta)
iwordstream::operator >>	compiler/extract.cpp	/^	iwordstream& operator>>(word& aword)$/;"	f	class:iwordstream	access:public	signature:(word& aword)
iwordstream::read_content	compiler/extract.cpp	/^	bool read_content(_Str& txt, state_machine& nm)$/;"	f	class:iwordstream	file:	access:private	signature:(_Str& txt, state_machine& nm)
iwordstream::try_to_read_symbol	compiler/extract.cpp	/^	int try_to_read_symbol(word& aword, int_type _Meta)$/;"	f	class:iwordstream	file:	access:private	signature:(word& aword, int_type _Meta)
key	include/buckethash.h	/^	typedef  _K key;$/;"	t	class:buckethash	access:public
keyvalue	include/buckethash.h	/^	typedef std::pair<key, value> keyvalue;$/;"	t	class:buckethash	access:private
keyword	syntax/grammar.h	/^		keyword = 2, \/\/ keyword$/;"	e	enum:grammar::symtype
keywords	compiler/compiler.h	/^	kog::buckethash<std::string, sc::int32, string_2_int> keywords;$/;"	m	class:compiler	access:private
keywords	makecompiler/gensyntax.cpp	/^std::set<tstring>& keywords()$/;"	f	signature:()
keywords	test/tinygrammartest.cpp	/^std::deque<std::pair<tstring, int32> > Asymbol::keywords;$/;"	m	class:Asymbol	file:
keywords	test/vhelp.h	/^	static std::deque<std::pair<tstring, int32> > keywords;$/;"	m	class:Asymbol	access:public
keywords_	syntax/grammar.h	/^	veckeywords keywords_;$/;"	m	class:grammar	access:protected
kid	include/buckethash.h	/^		size_t kid;$/;"	m	struct:buckethash::_Const_iterator	access:private
kog	third_party/callstack/linux2/debug_tool.hpp	/^namespace kog$/;"	n
kog	third_party/callstack/stacktrace.h	/^namespace kog{$/;"	n
kog::callstack	third_party/callstack/stacktrace.h	/^namespace callstack$/;"	n	namespace:kog
kog::callstack	third_party/callstack/stacktrace.h	/^namespace callstack{$/;"	n	namespace:kog
kog::callstack::frame	third_party/callstack/stacktrace.h	/^	typedef dbsoft::callstack::func_name_list frame;$/;"	t	namespace:kog::callstack
kog::callstack::frame	third_party/callstack/stacktrace.h	/^	typedef std::string frame;$/;"	t	namespace:kog::callstack
kog::callstack::trace	third_party/callstack/stacktrace.h	/^	class trace$/;"	c	namespace:kog::callstack
kog::callstack::trace::begin	third_party/callstack/stacktrace.h	/^		const_iterator  begin() const$/;"	f	class:kog::callstack::trace	access:public	signature:() const
kog::callstack::trace::begin	third_party/callstack/stacktrace.h	/^		const_iterator begin() const { return stack_.begin(); }$/;"	f	class:kog::callstack::trace	access:public	signature:() const
kog::callstack::trace::const_iterator	third_party/callstack/stacktrace.h	/^		typedef frame::const_iterator const_iterator;$/;"	t	class:kog::callstack::trace	access:public
kog::callstack::trace::const_iterator	third_party/callstack/stacktrace.h	/^		typedef std::vector<frame>::const_iterator const_iterator;$/;"	t	class:kog::callstack::trace	access:public
kog::callstack::trace::end	third_party/callstack/stacktrace.h	/^		const_iterator  end() const$/;"	f	class:kog::callstack::trace	access:public	signature:() const
kog::callstack::trace::end	third_party/callstack/stacktrace.h	/^		const_iterator end() const { return stack_.end(); }$/;"	f	class:kog::callstack::trace	access:public	signature:() const
kog::callstack::trace::operator =	third_party/callstack/stacktrace.h	/^		trace& operator=(const trace&);$/;"	p	class:kog::callstack::trace	access:private	signature:(const trace&)
kog::callstack::trace::stack_	third_party/callstack/stacktrace.h	/^		dbsoft::callstack::callstack_ptr stack_;$/;"	m	class:kog::callstack::trace	access:private
kog::callstack::trace::stack_	third_party/callstack/stacktrace.h	/^		std::vector<frame> stack_;$/;"	m	class:kog::callstack::trace	access:private
kog::callstack::trace::trace	third_party/callstack/stacktrace.h	/^		trace()$/;"	f	class:kog::callstack::trace	access:public	signature:()
kog::callstack::trace::trace	third_party/callstack/stacktrace.h	/^		trace(const trace&);$/;"	p	class:kog::callstack::trace	access:private	signature:(const trace&)
kog::stacktrace	third_party/callstack/linux2/debug_tool.hpp	/^	struct stacktrace$/;"	s	namespace:kog
kog::stacktrace::frames	third_party/callstack/linux2/debug_tool.hpp	/^		static void frames(std::vector<std::string>& stack);$/;"	p	struct:kog::stacktrace	access:public	signature:(std::vector<std::string>& stack)
lalr1machine	compiler/compiler.h	/^	typedef compile::lalr1machine lalr1machine;$/;"	t	class:compiler	access:public
lalr1machine	compiler/interlanguage.h	/^	typedef compile::lalr1machine lalr1machine;$/;"	t	class:interlanguage	access:public
lalr1machine	compiler/lalr1machine.cpp	/^lalr1machine::lalr1machine()$/;"	f	class:lalr1machine	signature:()
lalr1machine	compiler/lalr1machine.cpp	/^lalr1machine::lalr1machine(const tinygrammar& g, const kog::smart_vector<ifunction*>& funclist)$/;"	f	class:lalr1machine	signature:(const tinygrammar& g, const kog::smart_vector<ifunction*>& funclist)
lalr1machine	compiler/lalr1machine.h	/^	lalr1machine();$/;"	p	class:lalr1machine	access:public	signature:()
lalr1machine	compiler/lalr1machine.h	/^	lalr1machine(const tinygrammar& g, const kog::smart_vector<ifunction*>& funclist);$/;"	p	class:lalr1machine	access:public	signature:(const tinygrammar& g, const kog::smart_vector<ifunction*>& funclist)
lalr1machine	compiler/lalr1machine.h	/^class lalr1machine : public compile::lrmachine$/;"	c	inherits:compile::lrmachine
lalr1machine::_reduce	compiler/lalr1machine.cpp	/^machine_meta* lalr1machine::_reduce(int32 pid, const kog::smart_vector<machine_meta*>& rights, machine_meta* result)$/;"	f	class:lalr1machine	signature:(int32 pid, const kog::smart_vector<machine_meta*>& rights, machine_meta* result)
lalr1machine::_reduce	compiler/lalr1machine.h	/^	\/* overwrite *\/ virtual machine_meta* _reduce(int32 pid, const kog::smart_vector<machine_meta*>& rights, machine_meta* result);$/;"	p	class:lalr1machine	access:protected	signature:(int32 pid, const kog::smart_vector<machine_meta*>& rights, machine_meta* result)
lalr1machine::funcList_	compiler/lalr1machine.h	/^	kog::smart_vector<ifunction*> funcList_;$/;"	m	class:lalr1machine	access:private
lalr1machine::lalr1machine	compiler/lalr1machine.cpp	/^lalr1machine::lalr1machine()$/;"	f	class:lalr1machine	signature:()
lalr1machine::lalr1machine	compiler/lalr1machine.cpp	/^lalr1machine::lalr1machine(const tinygrammar& g, const kog::smart_vector<ifunction*>& funclist)$/;"	f	class:lalr1machine	signature:(const tinygrammar& g, const kog::smart_vector<ifunction*>& funclist)
lalr1machine::lalr1machine	compiler/lalr1machine.h	/^	lalr1machine();$/;"	p	class:lalr1machine	access:public	signature:()
lalr1machine::lalr1machine	compiler/lalr1machine.h	/^	lalr1machine(const tinygrammar& g, const kog::smart_vector<ifunction*>& funclist);$/;"	p	class:lalr1machine	access:public	signature:(const tinygrammar& g, const kog::smart_vector<ifunction*>& funclist)
lalr1machine::lalr1meta	compiler/lalr1machine.h	/^    struct lalr1meta : public lrmeta$/;"	s	class:lalr1machine	inherits:lrmeta	access:public
lalr1machine::lalr1meta::content	compiler/lalr1machine.h	/^        const object* content;$/;"	m	struct:lalr1machine::lalr1meta	access:public
lalr1machine::lalr1meta::ctype	compiler/lalr1machine.h	/^        const type* ctype;$/;"	m	struct:lalr1machine::lalr1meta	access:public
lalr1machine::lalr1meta::lalr1meta	compiler/lalr1machine.h	/^        lalr1meta(const lalr1meta& other)$/;"	f	struct:lalr1machine::lalr1meta	access:public	signature:(const lalr1meta& other)
lalr1machine::lalr1meta::lalr1meta	compiler/lalr1machine.h	/^        lalr1meta(int32 meta = -1)$/;"	f	struct:lalr1machine::lalr1meta	access:public	signature:(int32 meta = -1)
lalr1machine::new_meta	compiler/lalr1machine.cpp	/^machine_meta* lalr1machine::new_meta(const machine_meta* meta)$/;"	f	class:lalr1machine	signature:(const machine_meta* meta)
lalr1machine::new_meta	compiler/lalr1machine.cpp	/^machine_meta* lalr1machine::new_meta(int32 meta)$/;"	f	class:lalr1machine	signature:(int32 meta)
lalr1machine::new_meta	compiler/lalr1machine.h	/^    \/* overwrite *\/ virtual machine_meta* new_meta(const machine_meta* meta);$/;"	p	class:lalr1machine	access:public	signature:(const machine_meta* meta)
lalr1machine::new_meta	compiler/lalr1machine.h	/^    \/* overwrite *\/ virtual machine_meta* new_meta(int meta);$/;"	p	class:lalr1machine	access:public	signature:(int meta)
lalr1machine::~lalr1machine	compiler/lalr1machine.cpp	/^lalr1machine::~lalr1machine()$/;"	f	class:lalr1machine	signature:()
lalr1machine::~lalr1machine	compiler/lalr1machine.h	/^	virtual ~lalr1machine();$/;"	p	class:lalr1machine	access:public	signature:()
lalr1meta	build/debug/test/prodfunc.cpp	/^typedef lalr1machine::lalr1meta lalr1meta;$/;"	t	file:
lalr1meta	compiler/lalr1machine.h	/^        lalr1meta(const lalr1meta& other)$/;"	f	struct:lalr1machine::lalr1meta	access:public	signature:(const lalr1meta& other)
lalr1meta	compiler/lalr1machine.h	/^        lalr1meta(int32 meta = -1)$/;"	f	struct:lalr1machine::lalr1meta	access:public	signature:(int32 meta = -1)
lalr1meta	compiler/lalr1machine.h	/^    struct lalr1meta : public lrmeta$/;"	s	class:lalr1machine	inherits:lrmeta	access:public
lalr1meta	test/tinygprodfuncs.cpp	/^typedef lalr1machine::lalr1meta lalr1meta;$/;"	t	file:
lalr1meta	tmp/prodfunc.cpp	/^typedef lalr1machine::lalr1meta lalr1meta;$/;"	t	file:
le	compiler/operation.h	/^    le,$/;"	e	enum:op
lf_	include/logger.h	/^	logger lf_;$/;"	m	class:loggermanager	access:private
link	include/tree.h	/^		typedef tnode* link;$/;"	t	struct:_tree_node::tnode	access:public
link	include/tree.h	/^		typedef typename tree<_Tx, _Alloc>::link link;$/;"	t	struct:tree::_Const_iterator	access:public
link	include/tree.h	/^	typedef tnode* link;$/;"	t	class:_tree_node	access:protected
link	include/tree.h	/^	typedef typename _Base::link link;$/;"	t	class:tree	access:public
list	galgorithm/regex2nfa.cpp	/^	struct list$/;"	s	struct:parsecontent	file:	access:public
list	tmp/back/regex2nfa.cpp	/^	struct list$/;"	s	struct:parsecontent	file:	access:public
ln	include/mathX.h	/^	static T ln(const T value)$/;"	f	class:math	access:public	signature:(const T value)
load_file_	syntax/global_values.cpp	/^std::string global_values::load_file_ = "";$/;"	m	class:global_values	file:
load_file_	syntax/global_values.h	/^	static std::string load_file_;$/;"	m	class:global_values	access:private
load_from_file	syntax/global_values.cpp	/^void global_values::load_from_file()$/;"	f	class:global_values	signature:()
load_from_file	syntax/global_values.h	/^	void load_from_file();$/;"	p	class:global_values	access:private	signature:()
load_grammar	test/pascaltest.cpp	/^	void load_grammar(grammar& gin)$/;"	f	class:pascal_test	file:	access:private	signature:(grammar& gin)
loader	syntax/loader.h	/^	loader();$/;"	p	class:loader	access:public	signature:()
loader	syntax/loader.h	/^	loader(const std::string& fname);$/;"	p	class:loader	access:public	signature:(const std::string& fname)
loader	syntax/loader.h	/^class loader$/;"	c
loader::file_	syntax/loader.h	/^	xml::ifile file_;$/;"	m	class:loader	access:private
loader::loader	syntax/loader.h	/^	loader();$/;"	p	class:loader	access:public	signature:()
loader::loader	syntax/loader.h	/^	loader(const std::string& fname);$/;"	p	class:loader	access:public	signature:(const std::string& fname)
loader::open	syntax/loader.h	/^	void open(const std::string& fname);$/;"	p	class:loader	access:public	signature:(const std::string& fname)
loader::operator >>	syntax/loader.h	/^	friend loader& operator>>(loader& Input, grammar& aGrammar);$/;"	p	class:loader	access:friend	signature:(loader& Input, grammar& aGrammar)
loader::readgrammar	syntax/loader.h	/^	void readgrammar(grammar& aGrammar);$/;"	p	class:loader	access:public	signature:(grammar& aGrammar)
loader::swap	syntax/loader.h	/^	void swap(loader& other);$/;"	p	class:loader	access:public	signature:(loader& other)
loader::~loader	syntax/loader.h	/^	virtual ~loader();$/;"	p	class:loader	access:public	signature:()
lock	include/shared_ptr.h	/^		shared_ptr<T> lock() const { return shared_ptr<T>(*this); }$/;"	f	class:weak_ptr	access:public	signature:() const
log	include/mathX.h	/^	static T log(const T value)$/;"	f	class:math	access:public	signature:(const T value)
log10	include/mathX.h	/^	static  T log10(const T value)$/;"	f	class:math	access:public	signature:(const T value)
log2	include/mathX.h	/^	static T log2(const T value)$/;"	f	class:math	access:public	signature:(const T value)
logFile_	syntax/global_values.h	/^	std::string logFile_;$/;"	m	class:global_values	access:private
logger	include/logger.h	/^	logger()$/;"	f	class:logger	access:public	signature:()
logger	include/logger.h	/^	logger(const std::string& log_file)$/;"	f	class:logger	access:public	signature:(const std::string& log_file)
logger	include/logger.h	/^class logger$/;"	c
logger::NON_COPYABLE_OBJECT	include/logger.h	/^	NON_COPYABLE_OBJECT(logger);$/;"	p	class:logger	access:private	signature:(logger)
logger::clear	include/logger.h	/^	void clear()$/;"	f	class:logger	access:private	signature:()
logger::getos	include/logger.h	/^	std::ostream& getos() const$/;"	f	class:logger	access:public	signature:() const
logger::logger	include/logger.h	/^	logger()$/;"	f	class:logger	access:public	signature:()
logger::logger	include/logger.h	/^	logger(const std::string& log_file)$/;"	f	class:logger	access:public	signature:(const std::string& log_file)
logger::need_clear_	include/logger.h	/^	bool need_clear_;$/;"	m	class:logger	access:private
logger::operator <<	include/logger.h	/^	logger& operator<<(const _Tx& v)$/;"	f	class:logger	access:public	signature:(const _Tx& v)
logger::os_	include/logger.h	/^	std::ostream* os_;$/;"	m	class:logger	access:private
logger::reset_log_file	include/logger.h	/^	void reset_log_file(const std::string& log_file)$/;"	f	class:logger	access:public	signature:(const std::string& log_file)
logger::reset_log_ostream	include/logger.h	/^	void reset_log_ostream(std::ostream& os)$/;"	f	class:logger	access:public	signature:(std::ostream& os)
logger::~logger	include/logger.h	/^	~logger()$/;"	f	class:logger	access:public	signature:()
loggermanager	include/logger.h	/^	loggermanager()$/;"	f	class:loggermanager	access:public	signature:()
loggermanager	include/logger.h	/^class loggermanager : public singleton<loggermanager>$/;"	c	inherits:singleton
loggermanager::dump	include/logger.h	/^	loggermanager& dump(const std::string& content)$/;"	f	class:loggermanager	access:public	signature:(const std::string& content)
loggermanager::get_logger	include/logger.h	/^	logger& get_logger()$/;"	f	class:loggermanager	access:public	signature:()
loggermanager::lf_	include/logger.h	/^	logger lf_;$/;"	m	class:loggermanager	access:private
loggermanager::loggermanager	include/logger.h	/^	loggermanager()$/;"	f	class:loggermanager	access:public	signature:()
loggermanager::~loggermanager	include/logger.h	/^	~loggermanager()$/;"	f	class:loggermanager	access:public	signature:()
logstring	include/logger.h	116;"	d
logstring	include/logger.h	119;"	d
logvalue	include/logger.h	123;"	d
lower_bound	include/sortc.h	/^	const_iterator lower_bound(const value_type& v) const$/;"	f	class:sortc	access:public	signature:(const value_type& v) const
lower_bound	include/sortc.h	/^	iterator lower_bound(const value_type& v)$/;"	f	class:sortc	access:public	signature:(const value_type& v)
lranalyse	galgorithm/lranalyse.h	/^	lranalyse(const tinygrammar& ing, lrmachine& lrm)$/;"	f	class:lranalyse	access:public	signature:(const tinygrammar& ing, lrmachine& lrm)
lranalyse	galgorithm/lranalyse.h	/^class lranalyse : public grammar_algorithm$/;"	c	inherits:grammar_algorithm
lranalyse::gin_	galgorithm/lranalyse.h	/^	const tinygrammar* gin_;$/;"	m	class:lranalyse	access:private
lranalyse::invoke	galgorithm/lranalyse.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:lranalyse	access:public	signature:()
lranalyse::lranalyse	galgorithm/lranalyse.h	/^	lranalyse(const tinygrammar& ing, lrmachine& lrm)$/;"	f	class:lranalyse	access:public	signature:(const tinygrammar& ing, lrmachine& lrm)
lranalyse::make_machine	galgorithm/lranalyse.cpp	/^void lranalyse::make_machine(AlgorithmArg& arg, const tinygrammar& tig, lrmachine& mot) const$/;"	f	class:lranalyse	signature:(AlgorithmArg& arg, const tinygrammar& tig, lrmachine& mot) const
lranalyse::make_machine	galgorithm/lranalyse.h	/^	void make_machine(AlgorithmArg& arg, const tinygrammar& tig, lrmachine& mot) const;$/;"	p	class:lranalyse	access:private	signature:(AlgorithmArg& arg, const tinygrammar& tig, lrmachine& mot) const
lranalyse::make_true_lr1	galgorithm/lranalyse.h	/^	void make_true_lr1(const tinygrammar& tig) const;$/;"	p	class:lranalyse	access:private	signature:(const tinygrammar& tig) const
lranalyse::mot_	galgorithm/lranalyse.h	/^	lrmachine* mot_;$/;"	m	class:lranalyse	access:private
lranalyse::operator ()	galgorithm/lranalyse.cpp	/^void lranalyse::operator()(const tinygrammar& tig, lrmachine& mot)$/;"	f	class:lranalyse	signature:(const tinygrammar& tig, lrmachine& mot)
lranalyse::operator ()	galgorithm/lranalyse.h	/^	void operator()(const tinygrammar& gin, lrmachine& mot);$/;"	p	class:lranalyse	access:private	signature:(const tinygrammar& gin, lrmachine& mot)
lrmachine	syntax/lrmachine.h	/^	lrmachine()$/;"	f	class:lrmachine	access:public	signature:()
lrmachine	syntax/lrmachine.h	/^	lrmachine(const tinygrammar& g)$/;"	f	class:lrmachine	access:public	signature:(const tinygrammar& g)
lrmachine	syntax/lrmachine.h	/^class lrmachine : public automachine$/;"	c	inherits:automachine
lrmachine::_reduce	syntax/lrmachine.cpp	/^lrmachine::machine_meta* lrmachine::_reduce(int32 pid, const kog::smart_vector<machine_meta*>& rights, machine_meta* result)$/;"	f	class:lrmachine	signature:(int32 pid, const kog::smart_vector<machine_meta*>& rights, machine_meta* result)
lrmachine::_reduce	syntax/lrmachine.h	/^	virtual machine_meta* _reduce(int32 pid, const kog::smart_vector<machine_meta*>& rights, machine_meta* result);$/;"	p	class:lrmachine	access:protected	signature:(int32 pid, const kog::smart_vector<machine_meta*>& rights, machine_meta* result)
lrmachine::accept_state	syntax/lrmachine.h	/^	enum { accept_state = 0}; \/\/ using state 0 as ending state$/;"	e	enum:lrmachine::__anon126
lrmachine::analysestack	syntax/lrmachine.h	/^	typedef std::stack<machine_meta*> analysestack;$/;"	t	class:lrmachine	access:public
lrmachine::eta	syntax/lrmachine.cpp	/^bool lrmachine::eta(machine_meta* meta)$/;"	f	class:lrmachine	signature:(machine_meta* meta)
lrmachine::eta	syntax/lrmachine.h	/^	\/* overwrite *\/ virtual bool eta(machine_meta* meta);$/;"	p	class:lrmachine	access:public	signature:(machine_meta* meta)
lrmachine::funcarray	syntax/lrmachine.h	/^	typedef kog::smart_vector<symfunc*> funcarray;$/;"	t	class:lrmachine	access:public
lrmachine::funcs_	syntax/lrmachine.h	/^	funcarray funcs_;$/;"	m	class:lrmachine	access:private
lrmachine::init	syntax/lrmachine.cpp	/^void lrmachine::init()$/;"	f	class:lrmachine	signature:()
lrmachine::init	syntax/lrmachine.h	/^	\/* overwrite *\/ virtual void init();$/;"	p	class:lrmachine	access:public	signature:()
lrmachine::int32array	syntax/lrmachine.h	/^	typedef kog::smart_vector<int32> int32array;$/;"	t	class:lrmachine	access:public
lrmachine::lrmachine	syntax/lrmachine.h	/^	lrmachine()$/;"	f	class:lrmachine	access:public	signature:()
lrmachine::lrmachine	syntax/lrmachine.h	/^	lrmachine(const tinygrammar& g)$/;"	f	class:lrmachine	access:public	signature:(const tinygrammar& g)
lrmachine::lrmeta	syntax/lrmachine.h	/^	struct lrmeta : public machine_meta$/;"	s	class:lrmachine	inherits:machine_meta	access:public
lrmachine::lrmeta::lrmeta	syntax/lrmachine.h	/^        lrmeta(const lrmeta& other)$/;"	f	struct:lrmachine::lrmeta	access:public	signature:(const lrmeta& other)
lrmachine::lrmeta::lrmeta	syntax/lrmachine.h	/^        lrmeta(int32 m = -1, int32 s = -1)$/;"	f	struct:lrmachine::lrmeta	access:public	signature:(int32 m = -1, int32 s = -1)
lrmachine::lrmeta::state	syntax/lrmachine.h	/^		int32 state;$/;"	m	struct:lrmachine::lrmeta	access:public
lrmachine::morelist	syntax/lrmachine.h	/^	std::list<pinfoarray>& morelist() $/;"	f	class:lrmachine	access:public	signature:()
lrmachine::morelist_	syntax/lrmachine.h	/^	std::list<pinfoarray> morelist_;$/;"	m	class:lrmachine	access:private
lrmachine::new_meta	syntax/lrmachine.cpp	/^automachine::machine_meta* lrmachine::new_meta(const automachine::machine_meta* meta)$/;"	f	class:lrmachine	signature:(const automachine::machine_meta* meta)
lrmachine::new_meta	syntax/lrmachine.cpp	/^automachine::machine_meta* lrmachine::new_meta(int meta)$/;"	f	class:lrmachine	signature:(int meta)
lrmachine::new_meta	syntax/lrmachine.h	/^	virtual machine_meta* new_meta(const machine_meta* meta);$/;"	p	class:lrmachine	access:public	signature:(const machine_meta* meta)
lrmachine::new_meta	syntax/lrmachine.h	/^	virtual machine_meta* new_meta(int meta);$/;"	p	class:lrmachine	access:public	signature:(int meta)
lrmachine::pg_	syntax/lrmachine.h	/^	const tinygrammar* pg_;$/;"	m	class:lrmachine	access:private
lrmachine::pinfo	syntax/lrmachine.h	/^	struct pinfo$/;"	s	class:lrmachine	access:public
lrmachine::pinfo::dot	syntax/lrmachine.h	/^		int32 dot;$/;"	m	struct:lrmachine::pinfo	access:public
lrmachine::pinfo::pid	syntax/lrmachine.h	/^		int32 pid;$/;"	m	struct:lrmachine::pinfo	access:public
lrmachine::pinfoarray	syntax/lrmachine.h	/^	typedef kog::smart_vector<pinfo> pinfoarray;$/;"	t	class:lrmachine	access:public
lrmachine::pstack_	syntax/lrmachine.h	/^	analysestack pstack_;$/;"	m	class:lrmachine	access:private
lrmachine::reduce	syntax/lrmachine.cpp	/^lrmachine::machine_meta* lrmachine::reduce(int32 pid)$/;"	f	class:lrmachine	signature:(int32 pid)
lrmachine::reduce	syntax/lrmachine.h	/^	machine_meta* reduce(int32 pid);$/;"	p	class:lrmachine	access:protected	signature:(int32 pid)
lrmachine::swap	syntax/lrmachine.cpp	/^void lrmachine::swap(lrmachine& other) throw()$/;"	f	class:lrmachine	signature:(lrmachine& other)
lrmachine::swap	syntax/lrmachine.h	/^	void swap(lrmachine& other) throw();$/;"	p	class:lrmachine	access:public	signature:(lrmachine& other)
lrmachine::tinyg	syntax/lrmachine.h	/^	const tinygrammar& tinyg() const$/;"	f	class:lrmachine	access:public	signature:() const
lrmachine_test	test/lrmachinetest.cpp	/^NEW_UNITTEST(lrmachine_test);/;"	v
lrmachine_test	test/lrmachinetest.cpp	/^class lrmachine_test : public sc::unittest$/;"	c	file:	inherits:sc::unittest
lrmachine_test::gfile_	test/lrmachinetest.cpp	/^	std::string gfile_;$/;"	m	class:lrmachine_test	file:	access:private
lrmachine_test::init	test/lrmachinetest.cpp	/^	\/* overwrite *\/ virtual void init(int argc, const char* argv[])$/;"	f	class:lrmachine_test	file:	access:private	signature:(int argc, const char* argv[])
lrmachine_test::mfile_	test/lrmachinetest.cpp	/^	std::string mfile_;$/;"	m	class:lrmachine_test	file:	access:private
lrmachine_test::output_machine	test/lrmachinetest.cpp	/^	void output_machine(const lrmachine& m)$/;"	f	class:lrmachine_test	file:	access:private	signature:(const lrmachine& m)
lrmachine_test::run_test	test/lrmachinetest.cpp	/^	\/* overwrite *\/ virtual void run_test()$/;"	f	class:lrmachine_test	file:	access:private	signature:()
lrmeta	syntax/lrmachine.h	/^	struct lrmeta : public machine_meta$/;"	s	class:lrmachine	inherits:machine_meta	access:public
lrmeta	syntax/lrmachine.h	/^        lrmeta(const lrmeta& other)$/;"	f	struct:lrmachine::lrmeta	access:public	signature:(const lrmeta& other)
lrmeta	syntax/lrmachine.h	/^        lrmeta(int32 m = -1, int32 s = -1)$/;"	f	struct:lrmachine::lrmeta	access:public	signature:(int32 m = -1, int32 s = -1)
lrmreader	test/lrmio.h	/^class lrmreader$/;"	c
lrmwriter	test/lrmio.h	/^	lrmwriter(std::ostream& os)$/;"	f	class:lrmwriter	access:public	signature:(std::ostream& os)
lrmwriter	test/lrmio.h	/^class lrmwriter$/;"	c
lrmwriter::lrmwriter	test/lrmio.h	/^	lrmwriter(std::ostream& os)$/;"	f	class:lrmwriter	access:public	signature:(std::ostream& os)
lrmwriter::operator <<	test/lrmio.h	/^	lrmwriter& operator<<(const compile::lrmachine& m)$/;"	f	class:lrmwriter	access:public	signature:(const compile::lrmachine& m)
lrmwriter::os_	test/lrmio.h	/^	std::ostream& os_;$/;"	m	class:lrmwriter	access:private
lrmwriter::output_state	test/lrmio.h	/^	std::ostream& output_state(std::ostream& os, const compile::lrmachine& m)$/;"	f	class:lrmwriter	access:public	signature:(std::ostream& os, const compile::lrmachine& m)
lrmwriter::output_table	test/lrmio.h	/^	std::ostream& output_table(std::ostream& os, const compile::lrmachine& m)$/;"	f	class:lrmwriter	access:public	signature:(std::ostream& os, const compile::lrmachine& m)
lrstate	galgorithm/lranalyse.cpp	/^class lrstate : public std::vector<lrstateitem>$/;"	c	file:	inherits:std::vector
lrstate::operator ==	galgorithm/lranalyse.cpp	/^	bool operator == (const lrstate& other) const$/;"	f	class:lrstate	access:public	signature:(const lrstate& other) const
lrstateitem	galgorithm/lranalyse.cpp	/^struct lrstateitem$/;"	s	file:
lrstateitem::dot	galgorithm/lranalyse.cpp	/^	int32 dot; \/\/ dot position$/;"	m	struct:lrstateitem	file:	access:public
lrstateitem::follow	galgorithm/lranalyse.cpp	/^	sfollowset follow;$/;"	m	struct:lrstateitem	file:	access:public
lrstateitem::operator ==	galgorithm/lranalyse.cpp	/^	bool operator == (const lrstateitem& other) const$/;"	f	struct:lrstateitem	access:public	signature:(const lrstateitem& other) const
lrstateitem::prod	galgorithm/lranalyse.cpp	/^	const production* prod; \/\/ ref production$/;"	m	struct:lrstateitem	file:	access:public
lrsts	galgorithm/lranalyse.cpp	/^	std::list<lrstate> lrsts;$/;"	m	struct:AlgorithmArg	file:	access:public
lt	compiler/operation.h	/^    lt,$/;"	e	enum:op
m	tmp/sizetest.cpp	/^	char m;$/;"	m	struct:A	file:	access:public
m_bInitialized	third_party/callstack/win32/debug_tool.cpp	/^			static bool           m_bInitialized;$/;"	m	class:dbsoft::detail::callstack_Imp	file:	access:private
m_bInitialized	third_party/callstack/win32/debug_tool.cpp	/^		bool callstack_Imp::m_bInitialized = false;$/;"	m	class:dbsoft::detail::callstack_Imp	file:
m_elemstack	third_party/xml/Markup.cpp	/^	ElemStack m_elemstack;$/;"	m	struct:FilePos	file:	access:public
m_fp	third_party/xml/Markup.cpp	/^	FILE* m_fp;$/;"	m	struct:FilePos	file:	access:public
m_iPos	third_party/xml/Markup.h	/^	int m_iPos;$/;"	m	class:CMarkup	access:protected
m_iPosChild	third_party/xml/Markup.h	/^	int m_iPosChild;$/;"	m	class:CMarkup	access:protected
m_iPosDeleted	third_party/xml/Markup.h	/^	int m_iPosDeleted;$/;"	m	class:CMarkup	access:protected
m_iPosFree	third_party/xml/Markup.h	/^	int m_iPosFree;$/;"	m	class:CMarkup	access:protected
m_iPosParent	third_party/xml/Markup.h	/^	int m_iPosParent;$/;"	m	class:CMarkup	access:protected
m_lstFunc	third_party/callstack/win32/debug_tool.cpp	/^			func_name_list   m_lstFunc;$/;"	m	class:dbsoft::detail::callstack_Imp	file:	access:private
m_nBlockSizeBasis	third_party/xml/Markup.cpp	/^	int m_nBlockSizeBasis;$/;"	m	struct:FilePos	file:	access:public
m_nDocFlags	third_party/xml/Markup.cpp	/^	int m_nDocFlags;$/;"	m	struct:FilePos	file:	access:public
m_nDocFlags	third_party/xml/Markup.h	/^	int m_nDocFlags;$/;"	m	class:CMarkup	access:protected
m_nFailedChars	third_party/xml/Markup.cpp	/^	int m_nFailedChars;$/;"	m	struct:TextEncoding	file:	access:public
m_nFileByteLen	third_party/xml/Markup.cpp	/^	MCD_INTFILEOFFSET m_nFileByteLen;$/;"	m	struct:FilePos	file:	access:public
m_nFileByteOffset	third_party/xml/Markup.cpp	/^	MCD_INTFILEOFFSET m_nFileByteOffset;$/;"	m	struct:FilePos	file:	access:public
m_nFileCharUnitSize	third_party/xml/Markup.cpp	/^	int m_nFileCharUnitSize;$/;"	m	struct:FilePos	file:	access:public
m_nFromLen	third_party/xml/Markup.cpp	/^	int m_nFromLen;$/;"	m	struct:TextEncoding	file:	access:public
m_nL	third_party/xml/Markup.cpp	/^	int m_nL;$/;"	m	struct:TokenPos	file:	access:public
m_nNext	third_party/xml/Markup.cpp	/^	int m_nNext;$/;"	m	struct:TokenPos	file:	access:public
m_nNodeLength	third_party/xml/Markup.h	/^	int m_nNodeLength;$/;"	m	class:CMarkup	access:protected
m_nNodeOffset	third_party/xml/Markup.h	/^	int m_nNodeOffset;$/;"	m	class:CMarkup	access:protected
m_nNodeType	third_party/xml/Markup.h	/^	int m_nNodeType;$/;"	m	class:CMarkup	access:protected
m_nOpFileByteLen	third_party/xml/Markup.cpp	/^	int m_nOpFileByteLen;$/;"	m	struct:FilePos	file:	access:public
m_nOpFileTextLen	third_party/xml/Markup.cpp	/^	int m_nOpFileTextLen;$/;"	m	struct:FilePos	file:	access:public
m_nPreSpaceLength	third_party/xml/Markup.cpp	/^	int m_nPreSpaceLength;$/;"	m	struct:TokenPos	file:	access:public
m_nPreSpaceStart	third_party/xml/Markup.cpp	/^	int m_nPreSpaceStart;$/;"	m	struct:TokenPos	file:	access:public
m_nR	third_party/xml/Markup.cpp	/^	int m_nR;$/;"	m	struct:TokenPos	file:	access:public
m_nReadBufferRemoved	third_party/xml/Markup.cpp	/^	int m_nReadBufferRemoved;$/;"	m	struct:FilePos	file:	access:public
m_nReadBufferStart	third_party/xml/Markup.cpp	/^	int m_nReadBufferStart;$/;"	m	struct:FilePos	file:	access:public
m_nReadGatherStart	third_party/xml/Markup.cpp	/^	int m_nReadGatherStart;$/;"	m	struct:FilePos	file:	access:public
m_nSegs	third_party/xml/Markup.cpp	/^	int m_nSegs;$/;"	m	struct:ElemPosTree	file:	access:private
m_nSize	third_party/xml/Markup.cpp	/^	int m_nSize;$/;"	m	struct:ElemPosTree	file:	access:private
m_nToCount	third_party/xml/Markup.cpp	/^	int m_nToCount;$/;"	m	struct:TextEncoding	file:	access:public
m_nTokenFlags	third_party/xml/Markup.cpp	/^	int m_nTokenFlags;$/;"	m	struct:TokenPos	file:	access:public
m_pDebugCur	third_party/xml/Markup.h	/^	MCD_PCSZ m_pDebugCur;$/;"	m	class:CMarkup	access:protected
m_pDebugPos	third_party/xml/Markup.h	/^	MCD_PCSZ m_pDebugPos;$/;"	m	class:CMarkup	access:protected
m_pDocText	third_party/xml/Markup.cpp	/^	MCD_PCSZ m_pDocText;$/;"	m	struct:TokenPos	file:	access:public
m_pElemPosTree	third_party/xml/Markup.h	/^	ElemPosTree* m_pElemPosTree;$/;"	m	class:CMarkup	access:protected
m_pFilePos	third_party/xml/Markup.h	/^	FilePos* m_pFilePos;$/;"	m	class:CMarkup	access:protected
m_pFrom	third_party/xml/Markup.cpp	/^	const void* m_pFrom;$/;"	m	struct:TextEncoding	file:	access:public
m_pMaps	third_party/xml/Markup.cpp	/^	SavedPosMap** m_pMaps; \/\/ NULL terminated array$/;"	m	struct:SavedPosMapArray	file:	access:public
m_pReaderFilePos	third_party/xml/Markup.cpp	/^	FilePos* m_pReaderFilePos;$/;"	m	struct:TokenPos	file:	access:public
m_pSavedPosMaps	third_party/xml/Markup.h	/^	SavedPosMapArray* m_pSavedPosMaps;$/;"	m	class:CMarkup	access:protected
m_pSegs	third_party/xml/Markup.cpp	/^	ElemPos** m_pSegs;$/;"	m	struct:ElemPosTree	file:	access:private
m_pstrBuffer	third_party/xml/Markup.cpp	/^	MCD_STR* m_pstrBuffer;$/;"	m	struct:FilePos	file:	access:public
m_spImp	third_party/callstack/win32/debug_tool.hpp	/^		kog::shared_ptr<detail::callstack_Imp> m_spImp;$/;"	m	class:dbsoft::callstack	access:private
m_strDoc	third_party/xml/Markup.h	/^	MCD_STR m_strDoc;$/;"	m	class:CMarkup	access:protected
m_strEncoding	third_party/xml/Markup.cpp	/^	MCD_STR m_strEncoding;$/;"	m	struct:FilePos	file:	access:public
m_strFromEncoding	third_party/xml/Markup.cpp	/^	MCD_STR m_strFromEncoding;$/;"	m	struct:TextEncoding	file:	access:public
m_strIOResult	third_party/xml/Markup.cpp	/^	MCD_STR m_strIOResult;$/;"	m	struct:FilePos	file:	access:public
m_strReadGatherMarkup	third_party/xml/Markup.cpp	/^	MCD_STR m_strReadGatherMarkup;$/;"	m	struct:FilePos	file:	access:public
m_strResult	third_party/xml/Markup.h	/^	MCD_STR m_strResult;$/;"	m	class:CMarkup	access:protected
m_strToEncoding	third_party/xml/Markup.cpp	/^	MCD_STR m_strToEncoding;$/;"	m	struct:TextEncoding	file:	access:public
mac	compiler/compiler.h	/^	kog::shared_ptr<compile::automachine> mac;$/;"	m	struct:machine	access:public
machine	compiler/compiler.h	/^	machine()$/;"	f	struct:machine	access:public	signature:()
machine	compiler/compiler.h	/^	machine(kog::shared_ptr<compile::automachine> m, int32 id)$/;"	f	struct:machine	access:public	signature:(kog::shared_ptr<compile::automachine> m, int32 id)
machine	compiler/compiler.h	/^struct machine$/;"	s
machine::mac	compiler/compiler.h	/^	kog::shared_ptr<compile::automachine> mac;$/;"	m	struct:machine	access:public
machine::machine	compiler/compiler.h	/^	machine()$/;"	f	struct:machine	access:public	signature:()
machine::machine	compiler/compiler.h	/^	machine(kog::shared_ptr<compile::automachine> m, int32 id)$/;"	f	struct:machine	access:public	signature:(kog::shared_ptr<compile::automachine> m, int32 id)
machine::sid	compiler/compiler.h	/^	int32 sid;$/;"	m	struct:machine	access:public
machine_meta	compiler/ifunction.h	/^    typedef automachine::machine_meta machine_meta;$/;"	t	class:ifunction	access:public
machine_meta	compiler/lalr1machine.cpp	/^typedef automachine::machine_meta machine_meta;$/;"	t	file:
machine_meta	syntax/automachine.h	/^		machine_meta(int32 meta = -1)$/;"	f	struct:automachine::machine_meta	access:public	signature:(int32 meta = -1)
machine_meta	syntax/automachine.h	/^	struct machine_meta$/;"	s	class:automachine	access:public
machines	compiler/compiler.h	/^	std::map<std::string, compile::doc::machine> machines;$/;"	m	class:compiler	access:private
machines	tmp/back/compiler.h	/^	std::map<std::string, state_machine> machines;$/;"	m	class:compiler	access:private
main	test/callstacktest.cpp	/^int main(int argc, const char* argv[])$/;"	f	signature:(int argc, const char* argv[])
main	test/input/easy.c	/^int main(int argc, const char* argv[])$/;"	f	signature:(int argc, const char* argv[])
main	test/unittest.cpp	/^int main(int argc, const char* argv[])$/;"	f	signature:(int argc, const char* argv[])
main	tmp/allchars.cpp	/^int main(int argc, const char* argv[])$/;"	f	signature:(int argc, const char* argv[])
main	tmp/boostregextest.cpp	/^int main(int argc, const char* argv[])$/;"	f	signature:(int argc, const char* argv[])
main	tmp/callstacktest.cpp	/^int main(int argc, const char* argv[])$/;"	f	signature:(int argc, const char* argv[])
main	tmp/coutfun.cpp	/^int main(int argc, const char* argv[])$/;"	f	signature:(int argc, const char* argv[])
main	tmp/iterXtest.cpp	/^int main(int argc, const char* argv[])$/;"	f	signature:(int argc, const char* argv[])
main	tmp/protected.cpp	/^int main(int argc, const char* argv[])$/;"	f	signature:(int argc, const char* argv[])
main	tmp/sizetest.cpp	/^int main(int argc, const char* argv[])$/;"	f	signature:(int argc, const char* argv[])
main	tmp/splittest.cpp	/^int main(int argc, const char* argv[])$/;"	f	signature:(int argc, const char* argv[])
main_	include/stringXF.h	/^    const std::basic_string<_Elem> main_;$/;"	m	struct:string_split_t	access:private
main_scope_	compiler/interlanguage.h	/^    kog::shared_ptr<runtime::scope> main_scope_;$/;"	m	class:interlanguage	access:private
make	build/debug/test/tinyg.cpp	/^	void make()$/;"	f	class:tree_wrap	access:public	signature:()
make	build/debug/test/tmp.cpp	/^	void make()$/;"	f	class:tree_wrap	access:public	signature:()
make	build/debug/test/xxx.cpp	/^	void make()$/;"	f	class:tree_wrap	access:public	signature:()
make	test/output/tinyg.cpp	/^	void make()$/;"	f	class:tree_wrap	access:public	signature:()
make	test/output/tinyg/tinyg.cpp	/^	void make()$/;"	f	class:tree_wrap	access:public	signature:()
make	test/output/tinyg/tinyg_bk.cpp	/^	void make()$/;"	f	class:tree_wrap	access:public	signature:()
make	test/tinyg.cpp	/^	void make()$/;"	f	class:tree_wrap	access:public	signature:()
make_index	syntax/symbol.cpp	/^void symholder::make_index()$/;"	f	class:symholder	signature:()
make_index	syntax/symbol.h	/^	void make_index();$/;"	p	class:symholder	access:public	signature:()
make_machine	galgorithm/lranalyse.cpp	/^void lranalyse::make_machine(AlgorithmArg& arg, const tinygrammar& tig, lrmachine& mot) const$/;"	f	class:lranalyse	signature:(AlgorithmArg& arg, const tinygrammar& tig, lrmachine& mot) const
make_machine	galgorithm/lranalyse.h	/^	void make_machine(AlgorithmArg& arg, const tinygrammar& tig, lrmachine& mot) const;$/;"	p	class:lranalyse	access:private	signature:(AlgorithmArg& arg, const tinygrammar& tig, lrmachine& mot) const
make_node	galgorithm/regex2nfa.cpp	/^	void make_node(const char* vs, const char* ve, int L)$/;"	f	struct:parsecontent	access:public	signature:(const char* vs, const char* ve, int L)
make_node	tmp/back/regex2nfa.cpp	/^	void make_node(const char* vs, const char* ve, int L)$/;"	f	struct:parsecontent	access:public	signature:(const char* vs, const char* ve, int L)
make_sure_dfa	galgorithm/dfa2machine.cpp	/^void dfa2machine::make_sure_dfa(const tinygrammar& tig) const$/;"	f	class:dfa2machine	signature:(const tinygrammar& tig) const
make_sure_dfa	galgorithm/dfa2machine.h	/^	void make_sure_dfa(const tinygrammar& input) const;$/;"	p	class:dfa2machine	access:private	signature:(const tinygrammar& input) const
make_sure_rg	galgorithm/nfa2dfa.cpp	/^void nfa2dfa::make_sure_rg(const tinygrammar& tig)$/;"	f	class:nfa2dfa	signature:(const tinygrammar& tig)
make_sure_rg	galgorithm/nfa2dfa.h	/^	void make_sure_rg(const tinygrammar& input);$/;"	p	class:nfa2dfa	access:private	signature:(const tinygrammar& input)
make_symbol	galgorithm/regex2nfa.cpp	/^	void make_symbol(const std::string& x, int L)$/;"	f	struct:parsecontent	access:public	signature:(const std::string& x, int L)
make_symbol	tmp/back/regex2nfa.cpp	/^	void make_symbol(const std::string& x, int L)$/;"	f	struct:parsecontent	access:public	signature:(const std::string& x, int L)
make_trace	include/scerror.h	/^	void make_trace()$/;"	f	class:scerror	access:private	signature:()
make_tree	compiler/treemaker.h	/^class make_tree : public kog::tree<int32>$/;"	c	inherits:kog::tree
make_tree::new_leaf	compiler/treemaker.h	/^	link new_leaf(int32 v, link parent)$/;"	f	class:make_tree	access:protected	signature:(int32 v, link parent)
make_tree::new_node	compiler/treemaker.h	/^	link new_node(link parent = NULL)$/;"	f	class:make_tree	access:protected	signature:(link parent = NULL)
make_triple	include/functionalX.h	/^inline triple<_Ty1, _Ty2, _Ty3> make_triple(_Ty1 _Val1, _Ty2 _Val2, _Ty3 _Val3)$/;"	f	signature:(_Ty1 _Val1, _Ty2 _Val2, _Ty3 _Val3)
make_true_lr1	galgorithm/lranalyse.h	/^	void make_true_lr1(const tinygrammar& tig) const;$/;"	p	class:lranalyse	access:private	signature:(const tinygrammar& tig) const
match_machines	compiler/extract.cpp	/^	int32 match_machines(word& aword, int_type _Meta)$/;"	f	class:iwordstream	file:	access:private	signature:(word& aword, int_type _Meta)
math	include/mathX.h	/^class math$/;"	c
math::abs	include/mathX.h	/^	static T abs(const T value)$/;"	f	class:math	access:public	signature:(const T value)
math::atan	include/mathX.h	/^	static double atan(const T y, const T x)$/;"	f	class:math	access:public	signature:(const T y, const T x)
math::interpolate	include/mathX.h	/^	class interpolate$/;"	c	class:math	access:public
math::interpolate::calculateValue	include/mathX.h	/^		static T calculateValue(const T* xBegin, const T* yBegin, const size_t nSize, int index, const T& val)$/;"	f	class:math::interpolate	access:public	signature:(const T* xBegin, const T* yBegin, const size_t nSize, int index, const T& val)
math::interpolate::getIndex	include/mathX.h	/^		static int getIndex(const T* begin, const size_t nSize, const T& val)$/;"	f	class:math::interpolate	access:public	signature:(const T* begin, const size_t nSize, const T& val)
math::interpolate::interp	include/mathX.h	/^		static T interp(const T* xBegin, const T* yBegin, const size_t nSize, const T& val)$/;"	f	class:math::interpolate	access:public	signature:(const T* xBegin, const T* yBegin, const size_t nSize, const T& val)
math::interpolate::operator ()	include/mathX.h	/^		T operator()(const T* xBegin, const T* yBegin, const size_t nSize, const T& val) const$/;"	f	class:math::interpolate	access:public	signature:(const T* xBegin, const T* yBegin, const size_t nSize, const T& val) const
math::ln	include/mathX.h	/^	static T ln(const T value)$/;"	f	class:math	access:public	signature:(const T value)
math::log	include/mathX.h	/^	static T log(const T value)$/;"	f	class:math	access:public	signature:(const T value)
math::log10	include/mathX.h	/^	static  T log10(const T value)$/;"	f	class:math	access:public	signature:(const T value)
math::log2	include/mathX.h	/^	static T log2(const T value)$/;"	f	class:math	access:public	signature:(const T value)
math::round	include/mathX.h	/^	static _Result round(const _Arg value)$/;"	f	class:math	access:public	signature:(const _Arg value)
math::sqrt	include/mathX.h	/^	static T sqrt(const T value)$/;"	f	class:math	access:public	signature:(const T value)
math::square	include/mathX.h	/^	static T square(const T value)$/;"	f	class:math	access:public	signature:(const T value)
max_int	compiler/compiler.h	/^	enum { max_int = 100 };$/;"	e	enum:string_2_int::__anon132
mem_value	include/functionalX.h	/^	typename mpl::parse_class_value_type<_Tx>::value_type> mem_value(_Tx _mp)$/;"	f	signature:(_Tx _mp)
mem_value_t	include/functionalX.h	/^	mem_value_t(mem_value_type _p)$/;"	f	struct:mem_value_t	access:public	signature:(mem_value_type _p)
mem_value_t	include/functionalX.h	/^struct mem_value_t : public std::unary_function<_Tc, _Ty>$/;"	s	inherits:std::unary_function
mem_value_t::_Myt	include/functionalX.h	/^	typedef mem_value_t<_Tc, _Ty> _Myt;$/;"	t	struct:mem_value_t	access:public
mem_value_t::_p_value	include/functionalX.h	/^	mem_value_type _p_value;$/;"	m	struct:mem_value_t	access:protected
mem_value_t::class_type	include/functionalX.h	/^	typedef _Tc class_type;$/;"	t	struct:mem_value_t	access:public
mem_value_t::class_type::mem_value_type	include/functionalX.h	/^	typedef value_type class_type::* mem_value_type;$/;"	t	class:mem_value_t::class_type	access:public
mem_value_t::const_reference_type	include/functionalX.h	/^	typedef const _Ty& const_reference_type;$/;"	t	struct:mem_value_t	access:public
mem_value_t::mem_value_t	include/functionalX.h	/^	mem_value_t(mem_value_type _p)$/;"	f	struct:mem_value_t	access:public	signature:(mem_value_type _p)
mem_value_t::operator ()	include/functionalX.h	/^	const_reference_type operator()(const class_type& _class) const$/;"	f	struct:mem_value_t	access:public	signature:(const class_type& _class) const
mem_value_t::operator ()	include/functionalX.h	/^	reference_type operator()(class_type& _class) const$/;"	f	struct:mem_value_t	access:public	signature:(class_type& _class) const
mem_value_t::reference_type	include/functionalX.h	/^	typedef _Ty& reference_type;$/;"	t	struct:mem_value_t	access:public
mem_value_t::value_type	include/functionalX.h	/^	typedef _Ty value_type;$/;"	t	struct:mem_value_t	access:public
mem_value_type	include/functionalX.h	/^	typedef value_type class_type::* mem_value_type;$/;"	t	class:mem_value_t::class_type	access:public
memalloc	compiler/memalloc.h	/^class memalloc : public kog::singleton<memalloc>$/;"	c	inherits:kog::singleton
memalloc::address	compiler/memalloc.cpp	/^void memalloc::address(scope* s)$/;"	f	class:memalloc	signature:(scope* s)
memalloc::address	compiler/memalloc.h	/^   static void address(scope* s);  $/;"	p	class:memalloc	access:public	signature:(scope* s)
memblock	include/memoryX.h	/^struct memblock$/;"	s
memblock::const_iterator	include/memoryX.h	/^	typedef array_iterator<const value_type> const_iterator;$/;"	t	struct:memblock	access:public
memblock::const_pointer	include/memoryX.h	/^	typedef const value_type* const_pointer;$/;"	t	struct:memblock	access:public
memblock::const_reference	include/memoryX.h	/^	typedef const value_type& const_reference;$/;"	t	struct:memblock	access:public
memblock::const_reverse_iterator	include/memoryX.h	/^	typedef std::reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	struct:memblock	access:public
memblock::iterator	include/memoryX.h	/^	typedef array_iterator<value_type> iterator;$/;"	t	struct:memblock	access:public
memblock::pointer	include/memoryX.h	/^	typedef value_type* pointer;$/;"	t	struct:memblock	access:public
memblock::reference	include/memoryX.h	/^	typedef value_type& reference;$/;"	t	struct:memblock	access:public
memblock::reverse_iterator	include/memoryX.h	/^	typedef std::reverse_iterator<iterator> reverse_iterator;$/;"	t	struct:memblock	access:public
memblock::size_type	include/memoryX.h	/^	typedef std::size_t size_type;$/;"	t	struct:memblock	access:public
memblock::v	include/memoryX.h	/^	_Tx* v;$/;"	m	struct:memblock	access:private
memblock::value_type	include/memoryX.h	/^	typedef _Tx value_type;$/;"	t	struct:memblock	access:public
mempool	tmp/back/simplepool.h	/^class mempool$/;"	c
mempool::_first_nonzero_bit	tmp/back/simplepool.h	/^	size_t _first_nonzero_bit(bitmap v) const$/;"	f	class:mempool	access:private	signature:(bitmap v) const
mempool::_first_not_used	tmp/back/simplepool.h	/^	size_t _first_not_used()$/;"	f	class:mempool	access:private	signature:()
mempool::allocate	tmp/back/simplepool.h	/^	pointer allocate(size_type _Count)$/;"	f	class:mempool	access:public	signature:(size_type _Count)
mempool::bitmap	tmp/back/simplepool.h	/^	typedef unsigned int bitmap;$/;"	t	class:mempool	access:public
mempool::isused_	tmp/back/simplepool.h	/^	std::deque<bitmap> isused_;$/;"	m	class:mempool	access:private
mempool::pool_	tmp/back/simplepool.h	/^	std::deque<_Tx> pool_;$/;"	m	class:mempool	access:private
meta	include/stringXF.h	/^	_Elem meta(unsigned short _ch)$/;"	f	namespace:Format	signature:(unsigned short _ch)
mfile_	test/lrmachinetest.cpp	/^	std::string mfile_;$/;"	m	class:lrmachine_test	file:	access:private
minargc_	test/unittest.h	/^	int minargc_;$/;"	m	class:unittest	access:private
mini_status	galgorithm/nfa2dfa.cpp	/^void nfa2dfa::mini_status(const tinygrammar& tig, tinygrammar& tog)$/;"	f	class:nfa2dfa	signature:(const tinygrammar& tig, tinygrammar& tog)
mini_status	galgorithm/nfa2dfa.h	/^	void mini_status(const tinygrammar& tig, tinygrammar& tog);$/;"	p	class:nfa2dfa	access:private	signature:(const tinygrammar& tig, tinygrammar& tog)
minus	compiler/operation.h	/^	minus,$/;"	e	enum:op
module	compiler/module.h	/^class module$/;"	c
module	compiler/scope.h	/^        module$/;"	e	enum:varscope::scope_defines
more	syntax/automachine.h	/^		void more(void* m) { more_ = m;}$/;"	f	class:automachine::sheetrow	access:public	signature:(void* m)
more	syntax/automachine.h	/^		void* more() const { return more_; }$/;"	f	class:automachine::sheetrow	access:public	signature:() const
more	syntax/global_values.cpp	/^	std::string more;$/;"	m	struct:value_t	file:	access:public
more_	syntax/automachine.h	/^		void* more_;$/;"	m	class:automachine::sheetrow	access:private
morelist	syntax/lrmachine.h	/^	std::list<pinfoarray>& morelist() $/;"	f	class:lrmachine	access:public	signature:()
morelist_	syntax/lrmachine.h	/^	std::list<pinfoarray> morelist_;$/;"	m	class:lrmachine	access:private
mot_	galgorithm/dfa2machine.h	/^	automachine* mot_;$/;"	m	class:dfa2machine	access:private
mot_	galgorithm/lranalyse.h	/^	lrmachine* mot_;$/;"	m	class:lranalyse	access:private
multi	compiler/operation.h	/^	multi,$/;"	e	enum:op
n	galgorithm/regex2nfa.cpp	/^		int n;$/;"	m	struct:parsecontent::list	file:	access:public
n	tmp/back/regex2nfa.cpp	/^		int n;$/;"	m	struct:parsecontent::list	file:	access:public
nBomFlag	third_party/xml/Markup.cpp	/^struct BomTableStruct { const char* pszBom; int nBomLen; MCD_PCSZ pszBomEnc; int nBomFlag; } BomTable[] =$/;"	m	struct:BomTableStruct	file:	access:public
nBomLen	third_party/xml/Markup.cpp	/^struct BomTableStruct { const char* pszBom; int nBomLen; MCD_PCSZ pszBomEnc; int nBomFlag; } BomTable[] =$/;"	m	struct:BomTableStruct	file:	access:public
nCount	third_party/xml/Markup.cpp	/^	int nCount;$/;"	m	struct:TagPos	file:	access:public
nEndTagLen	third_party/xml/Markup.cpp	/^	unsigned int nEndTagLen : 10; \/\/ 1K limit for end tag$/;"	m	struct:ElemPos	file:	access:public
nFlags	third_party/xml/Markup.cpp	/^    int nFlags; \/\/ 16 bits flags, 16 bits level 65536 depth limit$/;"	m	struct:ElemPos	file:	access:public
nLen	third_party/xml/Markup.cpp	/^	int nLen;$/;"	m	struct:PathPos	file:	access:private
nLength	third_party/xml/Markup.cpp	/^	int nLength;$/;"	m	struct:ElemPos	file:	access:public
nLength	third_party/xml/Markup.cpp	/^	int nLength;$/;"	m	struct:NodePos	file:	access:public
nLevel	third_party/xml/Markup.cpp	/^	int nLevel;$/;"	m	struct:ElemStack	file:	access:public
nMapSize	third_party/xml/Markup.cpp	/^	int nMapSize;$/;"	m	struct:SavedPosMap	file:	access:public
nNodeFlags	third_party/xml/Markup.cpp	/^	int nNodeFlags;$/;"	m	struct:NodePos	file:	access:public
nNodeType	third_party/xml/Markup.cpp	/^	int nNodeType;$/;"	m	struct:NodePos	file:	access:public
nPathType	third_party/xml/Markup.cpp	/^	int nPathType; \/\/ -1 invalid, 0 empty, 1 name, 2 absolute path, 3 anywhere path$/;"	m	struct:PathPos	file:	access:private
nR	galgorithm/regex2nfa.cpp	/^		int nR; \/\/ right count$/;"	m	struct:parsecontent::prod	file:	access:public
nR	tmp/back/regex2nfa.cpp	/^		int nR; \/\/ right count$/;"	m	struct:parsecontent::prod	file:	access:public
nSavedPosFlags	third_party/xml/Markup.cpp	/^	int nSavedPosFlags;$/;"	m	struct:SavedPos	file:	access:public
nSize	third_party/xml/Markup.cpp	/^	int nSize;$/;"	m	struct:ElemStack	file:	access:protected
nSlot	third_party/xml/Markup.cpp	/^	int nSlot;$/;"	m	struct:TagPos	file:	access:public
nStart	third_party/xml/Markup.cpp	/^	int nStart;$/;"	m	struct:ElemPos	file:	access:public
nStart	third_party/xml/Markup.cpp	/^	int nStart;$/;"	m	struct:NodePos	file:	access:public
nStartTagLen	third_party/xml/Markup.cpp	/^	unsigned int nStartTagLen : 22; \/\/ 4MB limit for start tag$/;"	m	struct:ElemPos	file:	access:public
nTagNames	third_party/xml/Markup.cpp	/^	int nTagNames;$/;"	m	struct:TagPos	file:	access:public
name	galgorithm/grammaralgorithm.h	/^	const tstring& name() const$/;"	f	class:grammar_algorithm	access:public	signature:() const
name	syntax/global_values.cpp	/^	std::string name; \/\/ name of value$/;"	m	struct:value_t	file:	access:public
name	syntax/symbol.h	/^	const tchar* name;$/;"	m	struct:symbol	access:public
name	syntax/symbol.h	/^	tstring name;$/;"	m	struct:symfunc	access:public
nameIndexer_	syntax/symbol.h	/^	std::map<const tchar*, const symbol*, stringless> nameIndexer_;$/;"	m	class:symholder	access:private
name_	compiler/variable.h	/^    _Str name_; \/\/ name of variable$/;"	m	class:variable	access:private
name_	galgorithm/grammaralgorithm.h	/^	tstring name_;$/;"	m	class:grammar_algorithm	access:private
nc	include/tree.h	/^		int nc;$/;"	m	struct:_tree_node::tnode	access:public
ne	compiler/operation.h	/^    ne,$/;"	e	enum:op
need_clear_	include/logger.h	/^	bool need_clear_;$/;"	m	class:logger	access:private
new	third_party/xml/Markup.cpp	38;"	d	file:
new_error_msg	third_party/regex/xregex.h	/^	static std::string new_error_msg(const _Tx& _Src, const _Ty& _Dst)$/;"	f	class:stringX::convert_error	access:private	signature:(const _Tx& _Src, const _Ty& _Dst)
new_func_type	compiler/type.cpp	/^const function_type* typesystem::new_func_type(int32 nparams, const type* params[], const type* return_type)$/;"	f	class:typesystem	signature:(int32 nparams, const type* params[], const type* return_type)
new_func_type	compiler/type.h	/^    const function_type* new_func_type(int32 nparams, const type* params[], const type* return_type);$/;"	p	class:typesystem	access:public	signature:(int32 nparams, const type* params[], const type* return_type)
new_grammar	galgorithm/basicalgorithms.cpp	/^void removenotused::new_grammar(const tinygrammar& tig, tinygrammar& tog)$/;"	f	class:removenotused	signature:(const tinygrammar& tig, tinygrammar& tog)
new_grammar	galgorithm/basicalgorithms.h	/^	void new_grammar(const tinygrammar& gin, tinygrammar& gout); \/\/ create new grammmar$/;"	p	class:removenotused	access:private	signature:(const tinygrammar& gin, tinygrammar& gout)
new_leaf	compiler/treemaker.h	/^	link new_leaf(int32 v, link parent)$/;"	f	class:make_tree	access:protected	signature:(int32 v, link parent)
new_leaf	test/output/tinyg/tinyg_bk.cpp	/^	link new_leaf(int32 v, link parent)$/;"	f	class:tree_wrap	access:public	signature:(int32 v, link parent)
new_list	galgorithm/regex2nfa.cpp	/^	list* new_list(list* pnext = NULL, int n = 0)$/;"	f	struct:parsecontent	access:public	signature:(list* pnext = NULL, int n = 0)
new_list	tmp/back/regex2nfa.cpp	/^	list* new_list(list* pnext = NULL, int n = 0)$/;"	f	struct:parsecontent	access:public	signature:(list* pnext = NULL, int n = 0)
new_meta	compiler/lalr1machine.cpp	/^machine_meta* lalr1machine::new_meta(const machine_meta* meta)$/;"	f	class:lalr1machine	signature:(const machine_meta* meta)
new_meta	compiler/lalr1machine.cpp	/^machine_meta* lalr1machine::new_meta(int32 meta)$/;"	f	class:lalr1machine	signature:(int32 meta)
new_meta	compiler/lalr1machine.h	/^    \/* overwrite *\/ virtual machine_meta* new_meta(const machine_meta* meta);$/;"	p	class:lalr1machine	access:public	signature:(const machine_meta* meta)
new_meta	compiler/lalr1machine.h	/^    \/* overwrite *\/ virtual machine_meta* new_meta(int meta);$/;"	p	class:lalr1machine	access:public	signature:(int meta)
new_meta	syntax/lrmachine.cpp	/^automachine::machine_meta* lrmachine::new_meta(const automachine::machine_meta* meta)$/;"	f	class:lrmachine	signature:(const automachine::machine_meta* meta)
new_meta	syntax/lrmachine.cpp	/^automachine::machine_meta* lrmachine::new_meta(int meta)$/;"	f	class:lrmachine	signature:(int meta)
new_meta	syntax/lrmachine.h	/^	virtual machine_meta* new_meta(const machine_meta* meta);$/;"	p	class:lrmachine	access:public	signature:(const machine_meta* meta)
new_meta	syntax/lrmachine.h	/^	virtual machine_meta* new_meta(int meta);$/;"	p	class:lrmachine	access:public	signature:(int meta)
new_node	compiler/treemaker.h	/^	link new_node(link parent = NULL)$/;"	f	class:make_tree	access:protected	signature:(link parent = NULL)
new_node	test/output/tinyg/tinyg_bk.cpp	/^	link new_node(link parent = NULL)$/;"	f	class:tree_wrap	access:public	signature:(link parent = NULL)
new_scope	compiler/interlanguage.cpp	/^scope* interlanguage::new_scope()$/;"	f	class:interlanguage	signature:()
new_scope	compiler/interlanguage.h	/^    runtime::scope* new_scope();$/;"	p	class:interlanguage	access:public	signature:()
new_start_symbol	galgorithm/basicalgorithms.cpp	/^void eliminate_eplison::new_start_symbol(const tinygrammar& tig, tinygrammar& tog)$/;"	f	class:eliminate_eplison	signature:(const tinygrammar& tig, tinygrammar& tog)
new_start_symbol	galgorithm/basicalgorithms.h	/^	void new_start_symbol(const tinygrammar& tig, tinygrammar& gout);$/;"	p	class:eliminate_eplison	access:private	signature:(const tinygrammar& tig, tinygrammar& gout)
new_tuple	compiler/module.cpp	/^tuple* codemodule::new_tuple(const operation* oper, const object* src, const object* dst)$/;"	f	class:codemodule	signature:(const operation* oper, const object* src, const object* dst)
new_tuple	compiler/module.cpp	/^tuple* codemodule::new_tuple(const operation* oper, const object* src1, const object* src2, const object* dst)$/;"	f	class:codemodule	signature:(const operation* oper, const object* src1, const object* src2, const object* dst)
new_tuple	compiler/module.h	/^    tuple* new_tuple(const operation* oper, const object* src, const object* dst);$/;"	p	class:codemodule	access:public	signature:(const operation* oper, const object* src, const object* dst)
new_tuple	compiler/module.h	/^    tuple* new_tuple(const operation* oper, const object* src1, const object* src2, const object* dst);$/;"	p	class:codemodule	access:public	signature:(const operation* oper, const object* src1, const object* src2, const object* dst)
newline	makecompiler/gensyntax.cpp	/^	static std::ostream& newline(std::ostream& os)$/;"	f	struct:tabident	access:public	signature:(std::ostream& os)
newline	tmp/coutfun.cpp	/^	static std::ostream& newline(std::ostream& os)$/;"	f	struct:Ident	access:public	signature:(std::ostream& os)
newv	compiler/operation.h	/^    newv,$/;"	e	enum:op
next	compiler/compiler.cpp	/^	int32 next()$/;"	f	struct:split_separators	access:public	signature:()
next	galgorithm/regex2nfa.cpp	/^		list* next;$/;"	m	struct:parsecontent::list	file:	access:public
next	tmp/back/regex2nfa.cpp	/^		list* next;$/;"	m	struct:parsecontent::list	file:	access:public
nextstate	galgorithm/lranalyse.cpp	/^	nextstate(const lrstate* p)$/;"	f	struct:nextstate	access:public	signature:(const lrstate* p)
nextstate	galgorithm/lranalyse.cpp	/^	nextstate(const production* p)$/;"	f	struct:nextstate	access:public	signature:(const production* p)
nextstate	galgorithm/lranalyse.cpp	/^struct nextstate$/;"	s	file:
nextstate::__anon2::pp	galgorithm/lranalyse.cpp	/^		const production* pp;$/;"	m	union:nextstate::__anon2	file:	access:public
nextstate::__anon2::ps	galgorithm/lranalyse.cpp	/^		const lrstate* ps;$/;"	m	union:nextstate::__anon2	file:	access:public
nextstate::nextstate	galgorithm/lranalyse.cpp	/^	nextstate(const lrstate* p)$/;"	f	struct:nextstate	access:public	signature:(const lrstate* p)
nextstate::nextstate	galgorithm/lranalyse.cpp	/^	nextstate(const production* p)$/;"	f	struct:nextstate	access:public	signature:(const production* p)
nextstate::sorp	galgorithm/lranalyse.cpp	/^	int32 sorp; \/\/ 0: s, 1: p$/;"	m	struct:nextstate	file:	access:public
nfa2dfa	galgorithm/nfa2dfa.h	/^	nfa2dfa(const tinygrammar& gin, tinygrammar& gout)$/;"	f	class:nfa2dfa	access:public	signature:(const tinygrammar& gin, tinygrammar& gout)
nfa2dfa	galgorithm/nfa2dfa.h	/^class nfa2dfa : public grammar_algorithm$/;"	c	inherits:grammar_algorithm
nfa2dfa::gin_	galgorithm/nfa2dfa.h	/^	const tinygrammar* gin_;$/;"	m	class:nfa2dfa	access:private
nfa2dfa::got_	galgorithm/nfa2dfa.h	/^	tinygrammar* got_;$/;"	m	class:nfa2dfa	access:private
nfa2dfa::invoke	galgorithm/nfa2dfa.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:nfa2dfa	access:public	signature:()
nfa2dfa::make_sure_rg	galgorithm/nfa2dfa.cpp	/^void nfa2dfa::make_sure_rg(const tinygrammar& tig)$/;"	f	class:nfa2dfa	signature:(const tinygrammar& tig)
nfa2dfa::make_sure_rg	galgorithm/nfa2dfa.h	/^	void make_sure_rg(const tinygrammar& input);$/;"	p	class:nfa2dfa	access:private	signature:(const tinygrammar& input)
nfa2dfa::mini_status	galgorithm/nfa2dfa.cpp	/^void nfa2dfa::mini_status(const tinygrammar& tig, tinygrammar& tog)$/;"	f	class:nfa2dfa	signature:(const tinygrammar& tig, tinygrammar& tog)
nfa2dfa::mini_status	galgorithm/nfa2dfa.h	/^	void mini_status(const tinygrammar& tig, tinygrammar& tog);$/;"	p	class:nfa2dfa	access:private	signature:(const tinygrammar& tig, tinygrammar& tog)
nfa2dfa::nfa2dfa	galgorithm/nfa2dfa.h	/^	nfa2dfa(const tinygrammar& gin, tinygrammar& gout)$/;"	f	class:nfa2dfa	access:public	signature:(const tinygrammar& gin, tinygrammar& gout)
nfa2dfa::operator ()	galgorithm/nfa2dfa.cpp	/^void nfa2dfa::operator()(const tinygrammar& minput, tinygrammar& motput)$/;"	f	class:nfa2dfa	signature:(const tinygrammar& minput, tinygrammar& motput)
nfa2dfa::operator ()	galgorithm/nfa2dfa.h	/^	void operator()(const tinygrammar& input, tinygrammar& otput);$/;"	p	class:nfa2dfa	access:private	signature:(const tinygrammar& input, tinygrammar& otput)
nfa2dfa::split	galgorithm/nfa2dfa.cpp	/^void nfa2dfa::split(const std::vector<const production*>& t, kog::smart_vector<int32>& smap, std::deque<std::set<int32> >& s) const$/;"	f	class:nfa2dfa	signature:(const std::vector<const production*>& t, kog::smart_vector<int32>& smap, std::deque<std::set<int32> >& s) const
nfa2dfa::split	galgorithm/nfa2dfa.h	/^	void split(const std::vector<const production*>& t, kog::smart_vector<int32>& smap, std::deque<std::set<int32> >& s) const;$/;"	p	class:nfa2dfa	access:private	signature:(const std::vector<const production*>& t, kog::smart_vector<int32>& smap, std::deque<std::set<int32> >& s) const
nfa2dfa::todfa	galgorithm/nfa2dfa.cpp	/^void nfa2dfa::todfa(const tinygrammar& tig, tinygrammar& tog)$/;"	f	class:nfa2dfa	signature:(const tinygrammar& tig, tinygrammar& tog)
nfa2dfa::todfa	galgorithm/nfa2dfa.h	/^	void todfa(const tinygrammar& tig, tinygrammar& tog);$/;"	p	class:nfa2dfa	access:private	signature:(const tinygrammar& tig, tinygrammar& tog)
nfa2dfa_test	test/nfa2dfatest.cpp	/^NEW_UNITTEST(nfa2dfa_test);$/;"	v
nfa2dfa_test	test/nfa2dfatest.cpp	/^class nfa2dfa_test : public sc::unittest$/;"	c	file:	inherits:sc::unittest
nfa2dfa_test::ginfile_	test/nfa2dfatest.cpp	/^	std::string ginfile_;$/;"	m	class:nfa2dfa_test	file:	access:private
nfa2dfa_test::gotfile_	test/nfa2dfatest.cpp	/^	std::string gotfile_;$/;"	m	class:nfa2dfa_test	file:	access:private
nfa2dfa_test::init	test/nfa2dfatest.cpp	/^	\/* overwrite *\/ virtual void init(int argc, const char* argv[])$/;"	f	class:nfa2dfa_test	file:	access:private	signature:(int argc, const char* argv[])
nfa2dfa_test::run_test	test/nfa2dfatest.cpp	/^	\/* overwrite *\/ virtual void run_test()$/;"	f	class:nfa2dfa_test	file:	access:private	signature:()
nfa2dfa_test::todfa	test/nfa2dfatest.cpp	/^	void todfa(const tinygrammar& gin)$/;"	f	class:nfa2dfa_test	file:	access:private	signature:(const tinygrammar& gin)
nil	include/shared_ptr.h	/^		static unsigned* nil() { static unsigned nil_counter(1); return &nil_counter; }$/;"	f	class:shared_ptr	access:private	signature:()
node	include/markuputils.h	/^	node(utils::ifile* f = NULL)$/;"	f	class:node	access:private	signature:(utils::ifile* f = NULL)
node	include/markuputils.h	/^class node$/;"	c
node::f_	include/markuputils.h	/^	ifile* f_;$/;"	m	class:node	access:private
node::node	include/markuputils.h	/^	node(utils::ifile* f = NULL)$/;"	f	class:node	access:private	signature:(utils::ifile* f = NULL)
node::operator []	include/markuputils.h	/^	tstring operator[](const tstring& tagname)$/;"	f	class:node	access:public	signature:(const tstring& tagname)
noname_idx_	compiler/scope.h	/^    int32 noname_idx_;$/;"	m	class:scope	access:private
nonconst_type	include/iteratorX.h	/^	typedef array_iterator<typename mpl::remove_const<_Tx>::type> nonconst_type;$/;"	t	struct:array_iterator	access:public
nonconst_type	include/mplX.h	/^	typedef _T nonconst_type;$/;"	t	struct:add_const	access:public
nont	syntax/grammar.h	/^		nont = 0, \/\/non-terminate$/;"	e	enum:grammar::symtype
ntpi	galgorithm/lranalyse.cpp	/^	kog::smart_vector<int32> ntpi;$/;"	m	struct:AlgorithmArg	file:	access:public
number	test/output/gen.cpp	/^	number()$/;"	f	struct:number	access:public	signature:()
number	test/output/gen.cpp	/^struct number : public type$/;"	s	file:	inherits:type
number	test/output/tinyg.cpp	/^	number()$/;"	f	struct:number	access:public	signature:()
number	test/output/tinyg.cpp	/^struct number : public type$/;"	s	file:	inherits:type
number	test/output/tinyg/tinyg.cpp	/^	number()$/;"	f	struct:number	access:public	signature:()
number	test/output/tinyg/tinyg.cpp	/^struct number : public type$/;"	s	file:	inherits:type
number	test/output/tinyg/tinyg_bk.cpp	/^	number()$/;"	f	struct:number	access:public	signature:()
number	test/output/tinyg/tinyg_bk.cpp	/^struct number : public type$/;"	s	file:	inherits:type
number::number	test/output/gen.cpp	/^	number()$/;"	f	struct:number	access:public	signature:()
number::number	test/output/tinyg.cpp	/^	number()$/;"	f	struct:number	access:public	signature:()
number::number	test/output/tinyg/tinyg.cpp	/^	number()$/;"	f	struct:number	access:public	signature:()
number::number	test/output/tinyg/tinyg_bk.cpp	/^	number()$/;"	f	struct:number	access:public	signature:()
number::sid	test/output/gen.cpp	/^	enum{ sid = 1014 };$/;"	e	enum:number::__anon109	file:
number::sid	test/output/tinyg.cpp	/^	enum{ sid = 9 };$/;"	e	enum:number::__anon14	file:
number::sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 9 };$/;"	e	enum:number::__anon45	file:
number::sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 9 };$/;"	e	enum:number::__anon76	file:
obj_	syntax/global_values.h	/^	std::auto_ptr<holder> obj_;$/;"	m	class:refobject	access:private
object	compiler/object.h	/^struct object$/;"	s
object	syntax/global_values.h	/^		object()$/;"	f	class:refobject::object	access:public	signature:()
object	syntax/global_values.h	/^		object(const _Tx& v)$/;"	f	class:refobject::object	access:public	signature:(const _Tx& v)
object	syntax/global_values.h	/^	class object : public holder$/;"	c	class:refobject	inherits:holder	access:private
object::as	compiler/object.h	/^    template<typename _Ty> _Ty* as()$/;"	f	struct:object	access:public	signature:()
object::as	compiler/object.h	/^    template<typename _Ty> const _Ty* as() const$/;"	f	struct:object	access:public	signature:() const
object::get_type	compiler/object.h	/^    const std::type_info& get_type() const$/;"	f	struct:object	access:public	signature:() const
object::to_string	compiler/object.h	/^    virtual _Str to_string() const$/;"	f	struct:object	access:public	signature:() const
object::~object	compiler/object.h	/^    virtual ~object()$/;"	f	struct:object	access:public	signature:()
ofolder_	test/pascaltest.cpp	/^	std::string ofolder_;$/;"	m	class:pascal_test	file:	access:private
op	compiler/operation.h	/^enum op$/;"	g
op	test/output/gen.cpp	/^	op()$/;"	f	struct:op	access:public	signature:()
op	test/output/gen.cpp	/^struct op : public type$/;"	s	file:	inherits:type
op::op	test/output/gen.cpp	/^	op()$/;"	f	struct:op	access:public	signature:()
op::sid	test/output/gen.cpp	/^	enum{ sid = 1015 };$/;"	e	enum:op::__anon110	file:
op_string	compiler/operation.h	/^struct op_string$/;"	s
op_string::enum_string	compiler/operation.h	/^    static const _Str* enum_string()$/;"	f	struct:op_string	access:private	signature:()
op_string::parse	compiler/operation.h	/^    static op parse(const _Str& str)$/;"	f	struct:op_string	access:public	signature:(const _Str& str)
op_string::to_string	compiler/operation.h	/^    static const _Str& to_string(op i)$/;"	f	struct:op_string	access:public	signature:(op i)
open	syntax/loader.h	/^	void open(const std::string& fname);$/;"	p	class:loader	access:public	signature:(const std::string& fname)
oper	compiler/operation.h	/^    operations::op oper;$/;"	m	struct:operation	access:public
oper	compiler/tuple.h	/^    operations::op oper;  $/;"	m	struct:four_tuple	access:public
operation	compiler/operation.h	/^    operation(const _Str& str)$/;"	f	struct:operation	access:public	signature:(const _Str& str)
operation	compiler/operation.h	/^    operation(operations::op _oper)$/;"	f	struct:operation	access:public	signature:(operations::op _oper)
operation	compiler/operation.h	/^struct operation : object$/;"	s	inherits:object
operation::oper	compiler/operation.h	/^    operations::op oper;$/;"	m	struct:operation	access:public
operation::operation	compiler/operation.h	/^    operation(const _Str& str)$/;"	f	struct:operation	access:public	signature:(const _Str& str)
operation::operation	compiler/operation.h	/^    operation(operations::op _oper)$/;"	f	struct:operation	access:public	signature:(operations::op _oper)
operation::to_string	compiler/operation.h	/^    \/* overwrite *\/ virtual _Str to_string() const$/;"	f	struct:operation	access:public	signature:() const
operator !=	include/iteratorX.h	/^	bool operator != (const _Myt& _Other) const$/;"	f	struct:array_iterator	access:public	signature:(const _Myt& _Other) const
operator !=	include/iteratorX.h	/^	bool operator != (const _Myt& _Other) const$/;"	f	struct:iterator_pair	access:public	signature:(const _Myt& _Other) const
operator !=	include/shared_ptr.h	/^		bool operator!=(const shared_ptr<T>& o) const { return ptr != o.ptr; }$/;"	f	class:shared_ptr	access:public	signature:(const shared_ptr<T>& o) const
operator !=	include/shared_ptr.h	/^		bool operator!=(const shared_ptr<T>& o) const { return ptr != o.ptr; }$/;"	f	class:weak_ptr	access:public	signature:(const shared_ptr<T>& o) const
operator !=	include/stringXF.h	/^        friend bool operator!= (const _Const_iterator& iter1, const _Const_iterator& iter2)$/;"	f	struct:string_split_t::_Const_iterator	access:friend	signature:(const _Const_iterator& iter1, const _Const_iterator& iter2)
operator ()	build/debug/test/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func12	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	build/debug/test/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func13	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	build/debug/test/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func14	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	build/debug/test/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func15	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	build/debug/test/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func16	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	build/debug/test/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func17	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	build/debug/test/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func20	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	build/debug/test/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func21	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	build/debug/test/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func22	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	build/debug/test/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func23	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	build/debug/test/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func24	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	build/debug/test/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func25	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	build/debug/test/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func26	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	build/debug/test/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func27	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	build/debug/test/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func4	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	build/debug/test/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func_default	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_0	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_1	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_10	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_11	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_12	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_13	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_14	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_15	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_16	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_17	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_18	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_19	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_2	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_20	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_21	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_22	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_23	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_24	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_25	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_26	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_27	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_3	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_4	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_5	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_6	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_7	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_8	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_9	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	build/debug/test/tmp.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:production_func_0	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	build/debug/test/xxx.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:production_func_0	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	compiler/compiler.h	/^	compile::int32 operator()(const std::string& s) const$/;"	f	struct:string_2_int	access:public	signature:(const std::string& s) const
operator ()	compiler/extract.cpp	/^streamsplit::deqwords& streamsplit::operator()(std::istream& is)$/;"	f	class:streamsplit	signature:(std::istream& is)
operator ()	compiler/extract.h	/^	deqwords& operator()(std::istream& is);$/;"	p	class:streamsplit	access:public	signature:(std::istream& is)
operator ()	compiler/ifunction.h	/^    virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result) = 0;$/;"	p	class:ifunction	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	galgorithm/basicalgorithms.cpp	/^void eliminate_eplison::operator()(const tinygrammar& tig, tinygrammar& tog)$/;"	f	class:eliminate_eplison	signature:(const tinygrammar& tig, tinygrammar& tog)
operator ()	galgorithm/basicalgorithms.cpp	/^void removenotused::operator()(const tinygrammar& tig, tinygrammar& tog)$/;"	f	class:removenotused	signature:(const tinygrammar& tig, tinygrammar& tog)
operator ()	galgorithm/basicalgorithms.cpp	/^void removesingle::operator()(const tinygrammar& tig, tinygrammar& tog)$/;"	f	class:removesingle	signature:(const tinygrammar& tig, tinygrammar& tog)
operator ()	galgorithm/basicalgorithms.cpp	/^void simplegrammar::operator()(const tinygrammar& gin, tinygrammar& tog)$/;"	f	class:simplegrammar	signature:(const tinygrammar& gin, tinygrammar& tog)
operator ()	galgorithm/basicalgorithms.cpp	/^void symbol_to_eplison::operator()(const tinygrammar& tig, vecint& istoe, int32& eid)$/;"	f	class:symbol_to_eplison	signature:(const tinygrammar& tig, vecint& istoe, int32& eid)
operator ()	galgorithm/basicalgorithms.h	/^	void operator()(const tinygrammar& gin, tinygrammar& gout);$/;"	p	class:eliminate_eplison	access:private	signature:(const tinygrammar& gin, tinygrammar& gout)
operator ()	galgorithm/basicalgorithms.h	/^	void operator()(const tinygrammar& gin, tinygrammar& gout);$/;"	p	class:removenotused	access:private	signature:(const tinygrammar& gin, tinygrammar& gout)
operator ()	galgorithm/basicalgorithms.h	/^	void operator()(const tinygrammar& gin, tinygrammar& gout);$/;"	p	class:removesingle	access:private	signature:(const tinygrammar& gin, tinygrammar& gout)
operator ()	galgorithm/basicalgorithms.h	/^	void operator()(const tinygrammar& gin, tinygrammar& gout);$/;"	p	class:simplegrammar	access:private	signature:(const tinygrammar& gin, tinygrammar& gout)
operator ()	galgorithm/basicalgorithms.h	/^	void operator()(const tinygrammar& tig, vecint& istoe, int32& eid);$/;"	p	class:symbol_to_eplison	access:private	signature:(const tinygrammar& tig, vecint& istoe, int32& eid)
operator ()	galgorithm/dfa2machine.cpp	/^void dfa2machine::operator()(const tinygrammar& tig, automachine& mot)$/;"	f	class:dfa2machine	signature:(const tinygrammar& tig, automachine& mot)
operator ()	galgorithm/dfa2machine.h	/^	void operator()(const tinygrammar& input, automachine& otput);$/;"	p	class:dfa2machine	access:private	signature:(const tinygrammar& input, automachine& otput)
operator ()	galgorithm/eclosures.cpp	/^void eclosure::operator()(const tinygrammar& tig, closure_array& closures)$/;"	f	class:eclosure	signature:(const tinygrammar& tig, closure_array& closures)
operator ()	galgorithm/eclosures.h	/^	void operator()(const tinygrammar& tig, closure_array& closures);$/;"	p	class:eclosure	access:private	signature:(const tinygrammar& tig, closure_array& closures)
operator ()	galgorithm/firstfollow.cpp	/^void firstset::operator()(const tinygrammar& tig, vecintset& sets)$/;"	f	class:firstset	signature:(const tinygrammar& tig, vecintset& sets)
operator ()	galgorithm/firstfollow.cpp	/^void followset::operator()(const tinygrammar& tig, const vecintset& FirstSets, vecintset& FollowSets)$/;"	f	class:followset	signature:(const tinygrammar& tig, const vecintset& FirstSets, vecintset& FollowSets)
operator ()	galgorithm/firstfollow.h	/^	void operator()(const tinygrammar& gin, const vecintset& firstsets, vecintset& followsets);$/;"	p	class:followset	access:private	signature:(const tinygrammar& gin, const vecintset& firstsets, vecintset& followsets)
operator ()	galgorithm/firstfollow.h	/^	void operator()(const tinygrammar& gin, vecintset& sets);$/;"	p	class:firstset	access:private	signature:(const tinygrammar& gin, vecintset& sets)
operator ()	galgorithm/lranalyse.cpp	/^void lranalyse::operator()(const tinygrammar& tig, lrmachine& mot)$/;"	f	class:lranalyse	signature:(const tinygrammar& tig, lrmachine& mot)
operator ()	galgorithm/lranalyse.h	/^	void operator()(const tinygrammar& gin, lrmachine& mot);$/;"	p	class:lranalyse	access:private	signature:(const tinygrammar& gin, lrmachine& mot)
operator ()	galgorithm/nfa2dfa.cpp	/^void nfa2dfa::operator()(const tinygrammar& minput, tinygrammar& motput)$/;"	f	class:nfa2dfa	signature:(const tinygrammar& minput, tinygrammar& motput)
operator ()	galgorithm/nfa2dfa.h	/^	void operator()(const tinygrammar& input, tinygrammar& otput);$/;"	p	class:nfa2dfa	access:private	signature:(const tinygrammar& input, tinygrammar& otput)
operator ()	galgorithm/regex2nfa.cpp	/^void regex2nfa::operator()(const tstring& input, tinygrammar& otput)$/;"	f	class:regex2nfa	signature:(const tstring& input, tinygrammar& otput)
operator ()	galgorithm/regex2nfa.h	/^	void operator()(const tstring& input, tinygrammar& otput);$/;"	p	class:regex2nfa	access:private	signature:(const tstring& input, tinygrammar& otput)
operator ()	include/arrayX.h	/^	const_reference operator()(size_type r, size_type c) const { return _values[r][c]; }$/;"	f	struct:SmartMatrix	access:public	signature:(size_type r, size_type c) const
operator ()	include/arrayX.h	/^	reference operator()(size_type r, size_type c) { return _values[r][c]; }$/;"	f	struct:SmartMatrix	access:public	signature:(size_type r, size_type c)
operator ()	include/functionalX.h	/^	_Arg& operator()(_Arg& _arg) const$/;"	f	struct:NonOp	access:public	signature:(_Arg& _arg) const
operator ()	include/functionalX.h	/^	_Arg& operator()(_Arg& _dstVal, const _Arg& _srcVal) const$/;"	f	class:assign_t	access:public	signature:(_Arg& _dstVal, const _Arg& _srcVal) const
operator ()	include/functionalX.h	/^	_Result operator()(_Arg arg) const$/;"	f	struct:unary_function_adptor_t	access:public	signature:(_Arg arg) const
operator ()	include/functionalX.h	/^	_Result operator()(_Arg1 arg1, _Arg2 arg2) const$/;"	f	struct:binary_function_adptor_t	access:public	signature:(_Arg1 arg1, _Arg2 arg2) const
operator ()	include/functionalX.h	/^	_Result operator()(_Arg1 arg1, _Arg2 arg2, _Arg3 arg3) const$/;"	f	struct:triple_function_adptor_t	access:public	signature:(_Arg1 arg1, _Arg2 arg2, _Arg3 arg3) const
operator ()	include/functionalX.h	/^	_Tx& operator()(_Tx* p) const$/;"	f	struct:depointer_t	access:public	signature:(_Tx* p) const
operator ()	include/functionalX.h	/^	_Tx* operator()(_Tx& _Arg) const$/;"	f	struct:get_ptr_t	access:public	signature:(_Tx& _Arg) const
operator ()	include/functionalX.h	/^	_Ty operator()(const _Tx& _x) const$/;"	f	struct:explicit_convert_t	access:public	signature:(const _Tx& _x) const
operator ()	include/functionalX.h	/^	bool operator()(const _Arg& val) const$/;"	f	class:is_between_t	access:public	signature:(const _Arg& val) const
operator ()	include/functionalX.h	/^	const _Arg& operator()(const _Arg& _arg) const$/;"	f	struct:NonOp	access:public	signature:(const _Arg& _arg) const
operator ()	include/functionalX.h	/^	const _Tx& operator()(const _Tx* p) const$/;"	f	struct:depointer_t	access:public	signature:(const _Tx* p) const
operator ()	include/functionalX.h	/^	const _Tx* operator()(const _Tx& _Arg) const$/;"	f	struct:get_ptr_t	access:public	signature:(const _Tx& _Arg) const
operator ()	include/functionalX.h	/^	const_reference_type operator()(const class_type& _class) const$/;"	f	struct:mem_value_t	access:public	signature:(const class_type& _class) const
operator ()	include/functionalX.h	/^	reference operator()(_InIt _Iter) const$/;"	f	struct:dereference_t	access:public	signature:(_InIt _Iter) const
operator ()	include/functionalX.h	/^	reference_type operator()(class_type& _class) const$/;"	f	struct:mem_value_t	access:public	signature:(class_type& _class) const
operator ()	include/functionalX.h	/^	result_type operator()(argument_type& _arg) const$/;"	f	struct:composite_function_t	access:public	signature:(argument_type& _arg) const
operator ()	include/functionalX.h	/^	result_type operator()(const argument_type& _arg) const$/;"	f	struct:composite_function_t	access:public	signature:(const argument_type& _arg) const
operator ()	include/functionalX.h	/^	result_type operator()(const argument_type& arg) const$/;"	f	class:apply	access:public	signature:(const argument_type& arg) const
operator ()	include/functionalX.h	/^	result_type operator()(const first_argument_type& _arg1, const second_argument_type& _arg2) const$/;"	f	struct:composite_function2_t	access:public	signature:(const first_argument_type& _arg1, const second_argument_type& _arg2) const
operator ()	include/functionalX.h	/^	result_type operator()(first_argument_type& _arg1, second_argument_type& _arg2) const$/;"	f	struct:composite_function2_t	access:public	signature:(first_argument_type& _arg1, second_argument_type& _arg2) const
operator ()	include/functionalX.h	/^	typename _Fun::result_type operator()(_Tx* _Arg1, _Tx* _Arg2) const$/;"	f	struct:pointer_binary_function	access:public	signature:(_Tx* _Arg1, _Tx* _Arg2) const
operator ()	include/mathX.h	/^		T operator()(const T* xBegin, const T* yBegin, const size_t nSize, const T& val) const$/;"	f	class:math::interpolate	access:public	signature:(const T* xBegin, const T* yBegin, const size_t nSize, const T& val) const
operator ()	include/stringXF.h	/^		bool operator()(char _Ch) const$/;"	f	struct:Format::IsDigit	access:public	signature:(char _Ch) const
operator ()	include/stringXF.h	/^		bool operator()(char _Ch) const$/;"	f	struct:Format::IsSpace	access:public	signature:(char _Ch) const
operator ()	include/stringXF.h	/^		bool operator()(wchar_t _Ch) const$/;"	f	struct:Format::IsDigit	access:public	signature:(wchar_t _Ch) const
operator ()	include/stringXF.h	/^		bool operator()(wchar_t _Ch) const$/;"	f	struct:Format::IsSpace	access:public	signature:(wchar_t _Ch) const
operator ()	include/stringXF.h	/^	bool operator()(const std::basic_string<_Elem>& str1, const std::basic_string<_Elem>& str2) const$/;"	f	struct:stringcmp	access:public	signature:(const std::basic_string<_Elem>& str1, const std::basic_string<_Elem>& str2) const
operator ()	makecompiler/gensyntax.cpp	/^function_parser& function_parser::operator()(const _Str& func, const _Str& name)$/;"	f	class:function_parser	signature:(const _Str& func, const _Str& name)
operator ()	makecompiler/gensyntax.cpp	/^void syntaxgenerator::operator()(const grammar* aGrammar, const tstring& outfile)$/;"	f	class:syntaxgenerator	signature:(const grammar* aGrammar, const tstring& outfile)
operator ()	makecompiler/gensyntax.h	/^	void operator()(const grammar* aGrammar, const tstring& outfile);$/;"	p	class:syntaxgenerator	access:public	signature:(const grammar* aGrammar, const tstring& outfile)
operator ()	makecompiler/gensyntax.h	/^    function_parser& operator()(const _Str& func, const _Str& name);$/;"	p	class:function_parser	access:public	signature:(const _Str& func, const _Str& name)
operator ()	syntax/automachine.h	/^	bool operator()(const std::pair<int, int>& p1, const std::pair<int, int>& p2) const$/;"	f	struct:intpair_cmp	access:public	signature:(const std::pair<int, int>& p1, const std::pair<int, int>& p2) const
operator ()	syntax/production.h	/^	bool operator()(const production& p1, const production& p2) const$/;"	f	struct:p_cmp	access:public	signature:(const production& p1, const production& p2) const
operator ()	syntax/production.h	/^	bool operator()(const production& p1, const production& p2) const$/;"	f	struct:pfirstright_cmp	access:public	signature:(const production& p1, const production& p2) const
operator ()	syntax/production.h	/^	bool operator()(const production& p1, const production& p2) const$/;"	f	struct:pleft_cmp	access:public	signature:(const production& p1, const production& p2) const
operator ()	syntax/production.h	/^	bool operator()(const production& p1, const production& p2) const$/;"	f	struct:pright_cmp	access:public	signature:(const production& p1, const production& p2) const
operator ()	syntax/production.h	/^	bool operator()(const production& p1, const production& p2) const$/;"	f	struct:prod_less	access:public	signature:(const production& p1, const production& p2) const
operator ()	syntax/symbol.h	/^	bool operator()(const symbol& s1, const symbol& s2) const$/;"	f	struct:symbolname_Cmp	access:public	signature:(const symbol& s1, const symbol& s2) const
operator ()	syntax/symbol.h	/^	bool operator()(const tchar* str1, const tchar* str2) const$/;"	f	struct:stringless	access:public	signature:(const tchar* str1, const tchar* str2) const
operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_0	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_1	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_10	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_11	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_12	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_13	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_14	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_15	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_16	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_17	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_18	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_19	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_2	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_20	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_21	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_22	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_23	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_24	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_25	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_26	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_27	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_3	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_4	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_5	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_6	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_7	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_8	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_9	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
operator ()	test/tinygprodfuncs.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func12	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	test/tinygprodfuncs.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func13	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	test/tinygprodfuncs.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func14	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	test/tinygprodfuncs.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func15	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	test/tinygprodfuncs.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func16	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	test/tinygprodfuncs.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func17	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	test/tinygprodfuncs.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func20	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	test/tinygprodfuncs.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func21	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	test/tinygprodfuncs.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func22	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	test/tinygprodfuncs.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func23	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	test/tinygprodfuncs.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func24	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	test/tinygprodfuncs.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func25	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	test/tinygprodfuncs.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func26	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	test/tinygprodfuncs.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func27	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	test/tinygprodfuncs.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func4	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	test/tinygprodfuncs.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func_default	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	tmp/back/regex2nfa.cpp	/^void regex2nfa::operator()(const tstring& input, grammar& otput)$/;"	f	class:regex2nfa	signature:(const tstring& input, grammar& otput)
operator ()	tmp/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func12	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	tmp/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func13	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	tmp/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func14	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	tmp/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func15	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	tmp/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func16	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	tmp/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func17	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	tmp/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func20	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	tmp/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func21	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	tmp/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func22	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	tmp/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func23	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	tmp/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func24	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	tmp/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func25	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	tmp/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func26	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	tmp/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func27	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	tmp/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func4	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator ()	tmp/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func_default	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
operator *	include/iteratorX.h	/^	reference operator*() const { return *_ptr; }$/;"	f	struct:array_iterator	access:public	signature:() const
operator *	include/shared_ptr.h	/^		T& operator*()  { return *ptr; }$/;"	f	class:shared_ptr	access:public	signature:()
operator *	include/shared_ptr.h	/^		T& operator*()  { return *ptr; }$/;"	f	class:weak_ptr	access:public	signature:()
operator *	include/shared_ptr.h	/^		const T& operator*() const { return *ptr; }$/;"	f	class:shared_ptr	access:public	signature:() const
operator *	include/shared_ptr.h	/^		const T& operator*() const { return *ptr; }$/;"	f	class:weak_ptr	access:public	signature:() const
operator *	include/stringXF.h	/^        std::basic_string<_Elem> operator*()$/;"	f	struct:string_split_t::_Const_iterator	access:public	signature:()
operator *	include/tree.h	/^		const_reference operator*() const { return self_->v; }$/;"	f	struct:tree::_Const_iterator	access:public	signature:() const
operator *	include/tree.h	/^		reference operator*() const { return _Const_base::self_->v; }$/;"	f	struct:tree::_Iterator	access:public	signature:() const
operator +	include/iteratorX.h	/^	_Myt operator +(distance_type _Dis) const$/;"	f	struct:array_iterator	access:public	signature:(distance_type _Dis) const
operator +	include/iteratorX.h	/^	friend _Myt operator+ (distance_type _Dis, const _Myt& _Iter)$/;"	f	struct:array_iterator	access:friend	signature:(distance_type _Dis, const _Myt& _Iter)
operator +	include/stringX.h	/^	_Myt operator +(const _Elem _Right) const$/;"	f	class:xstring_basic	access:public	signature:(const _Elem _Right) const
operator +	include/stringX.h	/^	_Myt operator +(const _Elem* _Right) const$/;"	f	class:xstring_basic	access:public	signature:(const _Elem* _Right) const
operator +	include/stringX.h	/^	_Myt operator +(const _Mybase& _Right) const$/;"	f	class:xstring_basic	access:public	signature:(const _Mybase& _Right) const
operator +	include/stringX.h	/^	_Myt operator +(const _Tz& _tz) const$/;"	f	class:xstring_basic	access:public	signature:(const _Tz& _tz) const
operator ++	include/iteratorX.h	/^	_Myt operator++(int) { _Myt temp(*this); forward(); return temp;}$/;"	f	struct:iterator_pair	access:public	signature:(int)
operator ++	include/iteratorX.h	/^	_Myt operator++(int) { _Myt temp(*this); forward(*this); return temp;}$/;"	f	struct:array_iterator	access:public	signature:(int)
operator ++	include/iteratorX.h	/^	_Myt& operator++() { return forward(); }$/;"	f	struct:iterator_pair	access:public	signature:()
operator ++	include/iteratorX.h	/^	_Myt& operator++() { return forward(*this); }$/;"	f	struct:array_iterator	access:public	signature:()
operator ++	include/stringXF.h	/^        _Const_iterator operator++(int)$/;"	f	struct:string_split_t::_Const_iterator	access:public	signature:(int)
operator ++	include/stringXF.h	/^        _Const_iterator& operator++()$/;"	f	struct:string_split_t::_Const_iterator	access:public	signature:()
operator ++	include/tree.h	/^		_Myt operator++(int) { _Myt temp(*this); forward(*this); return temp;}$/;"	f	struct:tree::_Const_iterator	access:public	signature:(int)
operator ++	include/tree.h	/^		_Myt& operator++() { return forward(*this); }$/;"	f	struct:tree::_Const_iterator	access:public	signature:()
operator ++	include/tree.h	/^		first_order& operator++() const $/;"	f	struct:tree::first_order	access:public	signature:() const
operator +=	include/iteratorX.h	/^	_Myt& operator +=(distance_type _Dis)$/;"	f	struct:array_iterator	access:public	signature:(distance_type _Dis)
operator +=	include/stringX.h	/^	_Myt& operator +=(const _Myt& _Right)$/;"	f	class:xstring_basic	access:public	signature:(const _Myt& _Right)
operator +=	include/stringX.h	/^	_Myt& operator +=(const _Tz& _tz)$/;"	f	class:xstring_basic	access:public	signature:(const _Tz& _tz)
operator -	include/iteratorX.h	/^	_Myt operator -(distance_type _Dis) const$/;"	f	struct:array_iterator	access:public	signature:(distance_type _Dis) const
operator -	include/iteratorX.h	/^	distance_type operator -(const _Myt& _PY) const$/;"	f	struct:array_iterator	access:public	signature:(const _Myt& _PY) const
operator --	include/iteratorX.h	/^	_Myt operator--(int) { _Myt temp(*this); backward(); return temp; }$/;"	f	struct:iterator_pair	access:public	signature:(int)
operator --	include/iteratorX.h	/^	_Myt operator--(int) { _Myt temp(*this); backward(*this); return temp; }$/;"	f	struct:array_iterator	access:public	signature:(int)
operator --	include/iteratorX.h	/^	_Myt& operator--() { return backward(); }$/;"	f	struct:iterator_pair	access:public	signature:()
operator --	include/iteratorX.h	/^	_Myt& operator--() { return backward(*this); }$/;"	f	struct:array_iterator	access:public	signature:()
operator --	include/tree.h	/^		_Myt operator--(int) { _Myt temp(*this); backward(*this); return temp; }$/;"	f	struct:tree::_Const_iterator	access:public	signature:(int)
operator --	include/tree.h	/^		_Myt& operator--() { return backward(*this); }$/;"	f	struct:tree::_Const_iterator	access:public	signature:()
operator -=	include/iteratorX.h	/^	_Myt& operator -=(distance_type _Dis)$/;"	f	struct:array_iterator	access:public	signature:(distance_type _Dis)
operator ->	include/functionalX.h	/^	T* operator->()$/;"	f	class:ref_obj	access:public	signature:()
operator ->	include/iteratorX.h	/^	pointer operator->() const { return _ptr; }$/;"	f	struct:array_iterator	access:public	signature:() const
operator ->	include/shared_ptr.h	/^		T* operator->() { return ptr; }$/;"	f	class:shared_ptr	access:public	signature:()
operator ->	include/shared_ptr.h	/^		T* operator->() { return ptr; }$/;"	f	class:weak_ptr	access:public	signature:()
operator ->	include/shared_ptr.h	/^		const T* operator->() const { return ptr; }$/;"	f	class:shared_ptr	access:public	signature:() const
operator ->	include/shared_ptr.h	/^		const T* operator->() const { return ptr; }$/;"	f	class:weak_ptr	access:public	signature:() const
operator ->	include/tree.h	/^		const_pointer operator ->() const { return &self_->v; }$/;"	f	struct:tree::_Const_iterator	access:public	signature:() const
operator ->	include/tree.h	/^		pointer operator ->() const { return &_Const_base::self_->v; }$/;"	f	struct:tree::_Iterator	access:public	signature:() const
operator <	include/iteratorX.h	/^	bool operator <(const _Myt& _Other) const$/;"	f	struct:array_iterator	access:public	signature:(const _Myt& _Other) const
operator <	include/shared_ptr.h	/^		bool operator<(const shared_ptr<T>& o) const { return ptr < o.ptr; }	$/;"	f	class:shared_ptr	access:public	signature:(const shared_ptr<T>& o) const
operator <	include/shared_ptr.h	/^		bool operator<(const shared_ptr<T>& o) const { return ptr < o.ptr; }	$/;"	f	class:weak_ptr	access:public	signature:(const shared_ptr<T>& o) const
operator <<	include/logger.h	/^	logger& operator<<(const _Tx& v)$/;"	f	class:logger	access:public	signature:(const _Tx& v)
operator <<	makecompiler/gensyntax.cpp	/^	friend std::ostream& operator<<(std::ostream& os, const tabident& a)$/;"	f	struct:tabident	access:friend	signature:(std::ostream& os, const tabident& a)
operator <<	syntax/global_values.h	/^	friend std::ostream& operator<<(std::ostream& os, const refobject& ref)$/;"	f	class:refobject	access:friend	signature:(std::ostream& os, const refobject& ref)
operator <<	test/gio.h	/^	gwriter& operator<<(const compile::grammar& g)$/;"	f	class:gwriter	access:public	signature:(const compile::grammar& g)
operator <<	test/gio.h	/^	gwriter& operator<<(const compile::tinygrammar& tg)$/;"	f	class:gwriter	access:public	signature:(const compile::tinygrammar& tg)
operator <<	test/lrmio.h	/^	lrmwriter& operator<<(const compile::lrmachine& m)$/;"	f	class:lrmwriter	access:public	signature:(const compile::lrmachine& m)
operator <<	tmp/coutfun.cpp	/^	friend std::ostream& operator<<(std::ostream& os, const Ident& a)$/;"	f	struct:Ident	access:friend	signature:(std::ostream& os, const Ident& a)
operator <=	include/iteratorX.h	/^	bool operator <=(const _Myt& _Other) const$/;"	f	struct:array_iterator	access:public	signature:(const _Myt& _Other) const
operator =	include/arrayX.h	/^	_Myt& operator=(const _Myt& _Other)$/;"	f	class:smart_vector	access:public	signature:(const _Myt& _Other)
operator =	include/arrayX.h	/^	_Myt& operator=(const _Tx& _val)$/;"	f	class:smart_vector	access:public	signature:(const _Tx& _val)
operator =	include/arrayX.h	/^	_Myt& operator=(const _Ty& val)$/;"	f	struct:SmartArray	access:public	signature:(const _Ty& val)
operator =	include/shared_ptr.h	/^		shared_ptr<T>& operator=(const shared_ptr<T>& o) {$/;"	f	class:shared_ptr	access:public	signature:(const shared_ptr<T>& o)
operator =	include/singleton.h	/^	singleton_type& operator=(const singleton_type& other);$/;"	p	class:singleton	access:private	signature:(const singleton_type& other)
operator =	syntax/global_values.h	/^	refobject& operator=(const _Ty& _V)$/;"	f	class:refobject	access:public	signature:(const _Ty& _V)
operator =	syntax/global_values.h	/^	refobject& operator=(const refobject& _Other)$/;"	f	class:refobject	access:public	signature:(const refobject& _Other)
operator =	third_party/callstack/stacktrace.h	/^		trace& operator=(const trace&);$/;"	p	class:kog::callstack::trace	access:private	signature:(const trace&)
operator =	third_party/xml/Markup.cpp	/^void CMarkup::operator=( const CMarkup& markup )$/;"	f	class:CMarkup	signature:( const CMarkup& markup )
operator =	third_party/xml/Markup.h	/^	void operator=( const CMarkup& markup );$/;"	p	class:CMarkup	access:public	signature:( const CMarkup& markup )
operator ==	galgorithm/lranalyse.cpp	/^	bool operator == (const lrstate& other) const$/;"	f	class:lrstate	access:public	signature:(const lrstate& other) const
operator ==	galgorithm/lranalyse.cpp	/^	bool operator == (const lrstateitem& other) const$/;"	f	struct:lrstateitem	access:public	signature:(const lrstateitem& other) const
operator ==	include/iteratorX.h	/^	bool operator == (const _Myt& _Other) const$/;"	f	struct:array_iterator	access:public	signature:(const _Myt& _Other) const
operator ==	include/iteratorX.h	/^	bool operator == (const _Myt& _Other) const$/;"	f	struct:iterator_pair	access:public	signature:(const _Myt& _Other) const
operator ==	include/shared_ptr.h	/^		bool operator==(const shared_ptr<T>& o) const { return ptr == o.ptr; }$/;"	f	class:shared_ptr	access:public	signature:(const shared_ptr<T>& o) const
operator ==	include/shared_ptr.h	/^		bool operator==(const shared_ptr<T>& o) const { return ptr == o.ptr; }$/;"	f	class:weak_ptr	access:public	signature:(const shared_ptr<T>& o) const
operator ==	include/stringXF.h	/^        friend bool operator== (const _Const_iterator& iter1, const _Const_iterator& iter2)$/;"	f	struct:string_split_t::_Const_iterator	access:friend	signature:(const _Const_iterator& iter1, const _Const_iterator& iter2)
operator >	include/iteratorX.h	/^	bool operator >(const _Myt& _Other) const$/;"	f	struct:array_iterator	access:public	signature:(const _Myt& _Other) const
operator >=	include/iteratorX.h	/^	bool operator >=(const _Myt& _Other) const$/;"	f	struct:array_iterator	access:public	signature:(const _Myt& _Other) const
operator >>	compiler/extract.cpp	/^	iwordstream& operator>>(word& aword)$/;"	f	class:iwordstream	access:public	signature:(word& aword)
operator >>	syntax/loader.h	/^	friend loader& operator>>(loader& Input, grammar& aGrammar);$/;"	p	class:loader	access:friend	signature:(loader& Input, grammar& aGrammar)
operator >>	test/gio.h	/^	greader& operator>>(compile::grammar& g)$/;"	f	class:greader	access:public	signature:(compile::grammar& g)
operator >>	test/gio.h	/^	greader& operator>>(compile::tinygrammar& g)$/;"	f	class:greader	access:public	signature:(compile::tinygrammar& g)
operator MCD_PCSZ	third_party/xml/Markup.h	/^	operator MCD_PCSZ() const { return pcsz; };$/;"	f	struct:MCD_CSTR	access:public	signature:() const
operator MCD_PCSZ_FILENAME	third_party/xml/Markup.h	/^	operator MCD_PCSZ_FILENAME() const { return pcsz; };$/;"	f	struct:MCD_CSTR_FILENAME	access:public	signature:() const
operator []	include/arrayX.h	/^	ConstRowVector operator[](size_type idx) const{return _values[idx];}$/;"	f	struct:SmartMatrix	access:public	signature:(size_type idx) const
operator []	include/arrayX.h	/^	RowVector operator[](size_type idx) {return _values[idx];}$/;"	f	struct:SmartMatrix	access:public	signature:(size_type idx)
operator []	include/arrayX.h	/^	const_reference operator[](size_type idx) const { return _buf[idx]; }$/;"	f	struct:SmartArray	access:public	signature:(size_type idx) const
operator []	include/arrayX.h	/^	const_reference operator[](size_type idx) const { return buf_.values[idx]; }$/;"	f	class:smart_vector	access:public	signature:(size_type idx) const
operator []	include/arrayX.h	/^	reference operator[](size_type idx) { return _buf[idx]; }$/;"	f	struct:SmartArray	access:public	signature:(size_type idx)
operator []	include/arrayX.h	/^	reference operator[](size_type idx) { return buf_.values[idx]; }$/;"	f	class:smart_vector	access:public	signature:(size_type idx)
operator []	include/buckethash.h	/^	const value& operator[](const key& k) const$/;"	f	class:buckethash	access:public	signature:(const key& k) const
operator []	include/buckethash.h	/^	value& operator[](const key& k)$/;"	f	class:buckethash	access:public	signature:(const key& k)
operator []	include/iteratorX.h	/^	reference operator[](distance_type _Dis) { return _ptr[_Dis]; }$/;"	f	struct:array_iterator	access:public	signature:(distance_type _Dis)
operator []	include/markuputils.h	/^	tstring operator[](const tstring& tagname)$/;"	f	class:node	access:public	signature:(const tstring& tagname)
operator []	syntax/global_values.h	/^	refobject& operator[](const std::string& name)$/;"	f	class:global_values	access:public	signature:(const std::string& name)
operator _Mybase&	include/stringX.h	/^	operator _Mybase&()$/;"	f	class:xstring_basic	access:public	signature:()
operator const _Mybase&	include/stringX.h	/^	operator const _Mybase&() const$/;"	f	class:xstring_basic	access:public	signature:() const
operator const_ref_type	include/functionalX.h	/^	operator const_ref_type() const$/;"	f	class:ref_obj	access:public	signature:() const
operator int32	test/vhelp.h	/^	operator int32() const$/;"	f	struct:symindex	access:public	signature:() const
operator ref_type	include/functionalX.h	/^	operator ref_type()$/;"	f	class:ref_obj	access:public	signature:()
operator_type	compiler/type.cpp	/^const type* typesystem::operator_type() const$/;"	f	class:typesystem	signature:() const
operator_type	compiler/type.h	/^    const type* operator_type() const;$/;"	p	class:typesystem	access:public	signature:() const
os_	asmgenerate.h	/^    std::ostream* os_;$/;"	m	class:asmgenerate	access:private
os_	include/logger.h	/^	std::ostream* os_;$/;"	m	class:logger	access:private
os_	test/gio.h	/^	std::ostream& os_;$/;"	m	class:gwriter	access:private
os_	test/lrmio.h	/^	std::ostream& os_;$/;"	m	class:lrmwriter	access:private
other_sym	syntax/grammar.h	/^		other_sym$/;"	e	enum:grammar::symtype
otof_scope	compiler/interlanguage.cpp	/^scope* interlanguage::otof_scope()$/;"	f	class:interlanguage	signature:()
otof_scope	compiler/interlanguage.h	/^    runtime::scope* otof_scope();$/;"	p	class:interlanguage	access:public	signature:()
otput	test/splitwords.cpp	/^	std::string otput;$/;"	m	class:splitwords_test	file:	access:private
out	include/markuputils.h	/^	enum {in = 0, out = 1};$/;"	e	enum:file::__anon3
outfile	test/regexnfatest.cpp	/^	std::string outfile;$/;"	m	class:regex2nfa_test	file:	access:private
outfolder_	test/unittest.h	/^	std::string outfolder_;$/;"	m	class:unittest	access:private
outof	include/markuputils.h	/^	void outof()$/;"	f	class:file	access:public	signature:()
outputSets	test/firstfollowtest.cpp	/^	void outputSets(const firstset::vecintset& sets, const symholder& sholder, std::ostream& os, const std::string& sname)$/;"	f	class:firstfollow_test	file:	access:private	signature:(const firstset::vecintset& sets, const symholder& sholder, std::ostream& os, const std::string& sname)
output_first_follow_set	test/firstfollowtest.cpp	/^	void output_first_follow_set(const tinygrammar& g)$/;"	f	class:firstfollow_test	file:	access:private	signature:(const tinygrammar& g)
output_machine	test/lrmachinetest.cpp	/^	void output_machine(const lrmachine& m)$/;"	f	class:lrmachine_test	file:	access:private	signature:(const lrmachine& m)
output_machine	test/pascaltest.cpp	/^	void output_machine(const lrmachine& m)$/;"	f	class:pascal_test	file:	access:private	signature:(const lrmachine& m)
output_state	test/lrmio.h	/^	std::ostream& output_state(std::ostream& os, const compile::lrmachine& m)$/;"	f	class:lrmwriter	access:public	signature:(std::ostream& os, const compile::lrmachine& m)
output_table	test/lrmio.h	/^	std::ostream& output_table(std::ostream& os, const compile::lrmachine& m)$/;"	f	class:lrmwriter	access:public	signature:(std::ostream& os, const compile::lrmachine& m)
p	third_party/xml/Markup.cpp	/^	MCD_PCSZ p;$/;"	m	struct:PathPos	file:	access:private
pL	third_party/xml/Markup.cpp	/^	TagPos* pL;$/;"	m	struct:ElemStack	file:	access:protected
pTable	third_party/xml/Markup.cpp	/^	SavedPos** pTable;$/;"	m	struct:SavedPosMap	file:	access:public
p_	include/tree.h	/^		link p_;$/;"	m	struct:tree::first_order	access:public
p_brace	galgorithm/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon1	file:
p_brace	tmp/back/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon128	file:
p_cmp	syntax/production.h	/^struct p_cmp<_Less, std::logical_and<bool> > : public std::binary_function<production, production, bool>$/;"	s	inherits:std::binary_function
p_cmp	syntax/production.h	/^struct p_cmp<_Less, std::logical_or<bool> > : public std::binary_function<production, production, bool>$/;"	s	inherits:std::binary_function
p_cmp::operator ()	syntax/production.h	/^	bool operator()(const production& p1, const production& p2) const$/;"	f	struct:p_cmp	access:public	signature:(const production& p1, const production& p2) const
p_equal	syntax/production.h	/^typedef p_cmp<std::equal_to<int32>, std::logical_and<bool> > p_equal;$/;"	t
p_or	galgorithm/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon1	file:
p_or	tmp/back/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon128	file:
p_rep	galgorithm/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon1	file:
p_rep	tmp/back/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon128	file:
p_seq	galgorithm/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon1	file:
p_seq	tmp/back/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon128	file:
p_switch	galgorithm/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon1	file:
p_switch	tmp/back/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon128	file:
params_	compiler/funcparams.h	/^    vec_params params_;$/;"	m	struct:funcparamlist	access:public
params_type	compiler/type.h	/^    kog::smart_vector<const type*> params_type;$/;"	m	struct:function_type	access:public
parent	include/tree.h	/^		link parent;$/;"	m	struct:_tree_node::tnode	access:public
parent_	compiler/scope.h	/^    scope* parent_;$/;"	m	class:scope	access:private
parse	compiler/operation.h	/^    static op parse(const _Str& str)$/;"	f	struct:op_string	access:public	signature:(const _Str& str)
parse	include/stringX.h	/^	static _Tz parse(const _Myt& str)$/;"	f	class:xstring_basic	access:public	signature:(const _Myt& str)
parse_class_value_type	include/mplX.h	/^struct parse_class_value_type$/;"	s
parse_class_value_type	include/mplX.h	/^struct parse_class_value_type<_Ty _Tc::*>$/;"	s
parse_class_value_type::class_type	include/mplX.h	/^	typedef _Tc class_type;$/;"	t	struct:parse_class_value_type	access:public
parse_class_value_type::class_type	include/mplX.h	/^	typedef _Tx class_type;$/;"	t	struct:parse_class_value_type	access:public
parse_class_value_type::value_type	include/mplX.h	/^	typedef _Tx value_type;$/;"	t	struct:parse_class_value_type	access:public
parse_class_value_type::value_type	include/mplX.h	/^	typedef _Ty value_type;$/;"	t	struct:parse_class_value_type	access:public
parsecontent	galgorithm/regex2nfa.cpp	/^	parsecontent(const char* p)$/;"	f	struct:parsecontent	access:public	signature:(const char* p)
parsecontent	galgorithm/regex2nfa.cpp	/^struct parsecontent$/;"	s	file:
parsecontent	tmp/back/regex2nfa.cpp	/^	parsecontent(const char* p)$/;"	f	struct:parsecontent	access:public	signature:(const char* p)
parsecontent	tmp/back/regex2nfa.cpp	/^struct parsecontent$/;"	s	file:
parsecontent::brace_stage	galgorithm/regex2nfa.cpp	/^	int brace_stage(int L, char rc\/*, int& end*\/)$/;"	f	struct:parsecontent	access:public	signature:(int L, char rc )
parsecontent::brace_stage	tmp/back/regex2nfa.cpp	/^	int brace_stage(int L, char rc\/*, int& end*\/)$/;"	f	struct:parsecontent	access:public	signature:(int L, char rc )
parsecontent::buf	galgorithm/regex2nfa.cpp	/^	std::deque<int> buf;$/;"	m	struct:parsecontent	file:	access:public
parsecontent::buf	tmp/back/regex2nfa.cpp	/^	std::deque<int> buf;$/;"	m	struct:parsecontent	file:	access:public
parsecontent::getsymbol	galgorithm/regex2nfa.cpp	/^	int getsymbol(int sid)$/;"	f	struct:parsecontent	access:public	signature:(int sid)
parsecontent::getsymbol	tmp/back/regex2nfa.cpp	/^	int getsymbol(int sid)$/;"	f	struct:parsecontent	access:public	signature:(int sid)
parsecontent::iS	galgorithm/regex2nfa.cpp	/^	int iS;$/;"	m	struct:parsecontent	file:	access:public
parsecontent::iS	tmp/back/regex2nfa.cpp	/^	int iS;$/;"	m	struct:parsecontent	file:	access:public
parsecontent::insert	galgorithm/regex2nfa.cpp	/^	void insert(list* ph, int v)$/;"	f	struct:parsecontent	access:public	signature:(list* ph, int v)
parsecontent::insert	tmp/back/regex2nfa.cpp	/^	void insert(list* ph, int v)$/;"	f	struct:parsecontent	access:public	signature:(list* ph, int v)
parsecontent::insert_new_prod	galgorithm/regex2nfa.cpp	/^	void insert_new_prod(int L, const int* R, int c, int prod_type)$/;"	f	struct:parsecontent	access:public	signature:(int L, const int* R, int c, int prod_type)
parsecontent::insert_new_prod	tmp/back/regex2nfa.cpp	/^	void insert_new_prod(int L, const int* R, int c, int prod_type)$/;"	f	struct:parsecontent	access:public	signature:(int L, const int* R, int c, int prod_type)
parsecontent::isrealsep	galgorithm/regex2nfa.cpp	/^	bool isrealsep(const char* p, const char* s)$/;"	f	struct:parsecontent	access:public	signature:(const char* p, const char* s)
parsecontent::isrealsep	tmp/back/regex2nfa.cpp	/^	bool isrealsep(const char* p, const char* s)$/;"	f	struct:parsecontent	access:public	signature:(const char* p, const char* s)
parsecontent::isrepat	galgorithm/regex2nfa.cpp	/^	int isrepat(const char*& s)$/;"	f	struct:parsecontent	access:public	signature:(const char*& s)
parsecontent::isrepat	tmp/back/regex2nfa.cpp	/^	int isrepat(const char*& s)$/;"	f	struct:parsecontent	access:public	signature:(const char*& s)
parsecontent::list	galgorithm/regex2nfa.cpp	/^	struct list$/;"	s	struct:parsecontent	file:	access:public
parsecontent::list	tmp/back/regex2nfa.cpp	/^	struct list$/;"	s	struct:parsecontent	file:	access:public
parsecontent::list::n	galgorithm/regex2nfa.cpp	/^		int n;$/;"	m	struct:parsecontent::list	file:	access:public
parsecontent::list::n	tmp/back/regex2nfa.cpp	/^		int n;$/;"	m	struct:parsecontent::list	file:	access:public
parsecontent::list::next	galgorithm/regex2nfa.cpp	/^		list* next;$/;"	m	struct:parsecontent::list	file:	access:public
parsecontent::list::next	tmp/back/regex2nfa.cpp	/^		list* next;$/;"	m	struct:parsecontent::list	file:	access:public
parsecontent::make_node	galgorithm/regex2nfa.cpp	/^	void make_node(const char* vs, const char* ve, int L)$/;"	f	struct:parsecontent	access:public	signature:(const char* vs, const char* ve, int L)
parsecontent::make_node	tmp/back/regex2nfa.cpp	/^	void make_node(const char* vs, const char* ve, int L)$/;"	f	struct:parsecontent	access:public	signature:(const char* vs, const char* ve, int L)
parsecontent::make_symbol	galgorithm/regex2nfa.cpp	/^	void make_symbol(const std::string& x, int L)$/;"	f	struct:parsecontent	access:public	signature:(const std::string& x, int L)
parsecontent::make_symbol	tmp/back/regex2nfa.cpp	/^	void make_symbol(const std::string& x, int L)$/;"	f	struct:parsecontent	access:public	signature:(const std::string& x, int L)
parsecontent::new_list	galgorithm/regex2nfa.cpp	/^	list* new_list(list* pnext = NULL, int n = 0)$/;"	f	struct:parsecontent	access:public	signature:(list* pnext = NULL, int n = 0)
parsecontent::new_list	tmp/back/regex2nfa.cpp	/^	list* new_list(list* pnext = NULL, int n = 0)$/;"	f	struct:parsecontent	access:public	signature:(list* pnext = NULL, int n = 0)
parsecontent::p_brace	galgorithm/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon1	file:
parsecontent::p_brace	tmp/back/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon128	file:
parsecontent::p_or	galgorithm/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon1	file:
parsecontent::p_or	tmp/back/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon128	file:
parsecontent::p_rep	galgorithm/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon1	file:
parsecontent::p_rep	tmp/back/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon128	file:
parsecontent::p_seq	galgorithm/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon1	file:
parsecontent::p_seq	tmp/back/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon128	file:
parsecontent::p_switch	galgorithm/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon1	file:
parsecontent::p_switch	tmp/back/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon128	file:
parsecontent::parsecontent	galgorithm/regex2nfa.cpp	/^	parsecontent(const char* p)$/;"	f	struct:parsecontent	access:public	signature:(const char* p)
parsecontent::parsecontent	tmp/back/regex2nfa.cpp	/^	parsecontent(const char* p)$/;"	f	struct:parsecontent	access:public	signature:(const char* p)
parsecontent::prod	galgorithm/regex2nfa.cpp	/^	struct prod$/;"	s	struct:parsecontent	file:	access:public
parsecontent::prod	tmp/back/regex2nfa.cpp	/^	struct prod$/;"	s	struct:parsecontent	file:	access:public
parsecontent::prod::L	galgorithm/regex2nfa.cpp	/^		int L; \/\/ left$/;"	m	struct:parsecontent::prod	file:	access:public
parsecontent::prod::L	tmp/back/regex2nfa.cpp	/^		int L; \/\/ left$/;"	m	struct:parsecontent::prod	file:	access:public
parsecontent::prod::iR	galgorithm/regex2nfa.cpp	/^		int iR; \/\/ first right index$/;"	m	struct:parsecontent::prod	file:	access:public
parsecontent::prod::iR	tmp/back/regex2nfa.cpp	/^		int iR; \/\/ first right index$/;"	m	struct:parsecontent::prod	file:	access:public
parsecontent::prod::nR	galgorithm/regex2nfa.cpp	/^		int nR; \/\/ right count$/;"	m	struct:parsecontent::prod	file:	access:public
parsecontent::prod::nR	tmp/back/regex2nfa.cpp	/^		int nR; \/\/ right count$/;"	m	struct:parsecontent::prod	file:	access:public
parsecontent::prod::pt	galgorithm/regex2nfa.cpp	/^		int pt; \/\/ production type: p_or, p_switch, p_seq$/;"	m	struct:parsecontent::prod	file:	access:public
parsecontent::prod::pt	tmp/back/regex2nfa.cpp	/^		int pt; \/\/ production type: p_or, p_switch, p_seq$/;"	m	struct:parsecontent::prod	file:	access:public
parsecontent::prods	galgorithm/regex2nfa.cpp	/^	std::deque<prod> prods;$/;"	m	struct:parsecontent	file:	access:public
parsecontent::prods	tmp/back/regex2nfa.cpp	/^	std::deque<prod> prods;$/;"	m	struct:parsecontent	file:	access:public
parsecontent::s	galgorithm/regex2nfa.cpp	/^	const char* s;$/;"	m	struct:parsecontent	file:	access:public
parsecontent::s	tmp/back/regex2nfa.cpp	/^	const char* s;$/;"	m	struct:parsecontent	file:	access:public
parsecontent::switch_brace_or	galgorithm/regex2nfa.cpp	/^	int switch_brace_or(std::vector<int>& R, const char* p, int L, char rc)$/;"	f	struct:parsecontent	access:public	signature:(std::vector<int>& R, const char* p, int L, char rc)
parsecontent::switch_brace_or	tmp/back/regex2nfa.cpp	/^	int switch_brace_or(std::vector<int>& R, const char* p, int L, char rc)$/;"	f	struct:parsecontent	access:public	signature:(std::vector<int>& R, const char* p, int L, char rc)
parsecontent::sym	galgorithm/regex2nfa.cpp	/^	struct sym$/;"	s	struct:parsecontent	file:	access:public
parsecontent::sym	tmp/back/regex2nfa.cpp	/^	struct sym$/;"	s	struct:parsecontent	file:	access:public
parsecontent::sym::s	galgorithm/regex2nfa.cpp	/^		std::string s;$/;"	m	struct:parsecontent::sym	file:	access:public
parsecontent::sym::s	tmp/back/regex2nfa.cpp	/^		std::string s;$/;"	m	struct:parsecontent::sym	file:	access:public
parsecontent::sym::sid	galgorithm/regex2nfa.cpp	/^		int sid;$/;"	m	struct:parsecontent::sym	file:	access:public
parsecontent::sym::sid	tmp/back/regex2nfa.cpp	/^		int sid;$/;"	m	struct:parsecontent::sym	file:	access:public
parsecontent::syms	galgorithm/regex2nfa.cpp	/^	std::deque<sym> syms;$/;"	m	struct:parsecontent	file:	access:public
parsecontent::syms	tmp/back/regex2nfa.cpp	/^	std::deque<sym> syms;$/;"	m	struct:parsecontent	file:	access:public
parsecontent::true_node	galgorithm/regex2nfa.cpp	/^	void true_node(const char* vs, const char* ve, int L)$/;"	f	struct:parsecontent	access:public	signature:(const char* vs, const char* ve, int L)
parsecontent::true_node	tmp/back/regex2nfa.cpp	/^	void true_node(const char* vs, const char* ve, int L)$/;"	f	struct:parsecontent	access:public	signature:(const char* vs, const char* ve, int L)
pascal_test	test/pascaltest.cpp	/^NEW_UNITTEST(pascal_test);/;"	v
pascal_test	test/pascaltest.cpp	/^class pascal_test : public sc::unittest$/;"	c	file:	inherits:sc::unittest
pascal_test::init	test/pascaltest.cpp	/^	\/* overwrite *\/ virtual void init(int argc, const char* argv[])$/;"	f	class:pascal_test	file:	access:private	signature:(int argc, const char* argv[])
pascal_test::load_grammar	test/pascaltest.cpp	/^	void load_grammar(grammar& gin)$/;"	f	class:pascal_test	file:	access:private	signature:(grammar& gin)
pascal_test::ofolder_	test/pascaltest.cpp	/^	std::string ofolder_;$/;"	m	class:pascal_test	file:	access:private
pascal_test::output_machine	test/pascaltest.cpp	/^	void output_machine(const lrmachine& m)$/;"	f	class:pascal_test	file:	access:private	signature:(const lrmachine& m)
pascal_test::run_test	test/pascaltest.cpp	/^	\/* overwrite *\/ virtual void run_test()$/;"	f	class:pascal_test	file:	access:private	signature:()
pcsz	third_party/xml/Markup.h	/^	MCD_PCSZ pcsz;$/;"	m	struct:MCD_CSTR	access:public
pcsz	third_party/xml/Markup.h	/^	MCD_PCSZ_FILENAME pcsz;$/;"	m	struct:MCD_CSTR_FILENAME	access:public
pfirstright_cmp	syntax/production.h	/^struct pfirstright_cmp : public std::binary_function<production, production, bool>$/;"	s	inherits:std::binary_function
pfirstright_cmp::operator ()	syntax/production.h	/^	bool operator()(const production& p1, const production& p2) const$/;"	f	struct:pfirstright_cmp	access:public	signature:(const production& p1, const production& p2) const
pfirstright_less	syntax/production.h	/^typedef pfirstright_cmp<std::less<int32> > pfirstright_less;$/;"	t
pg_	syntax/lrmachine.h	/^	const tinygrammar* pg_;$/;"	m	class:lrmachine	access:private
pid	syntax/lrmachine.h	/^		int32 pid;$/;"	m	struct:lrmachine::pinfo	access:public
pinfo	syntax/lrmachine.h	/^	struct pinfo$/;"	s	class:lrmachine	access:public
pinfoarray	syntax/lrmachine.h	/^	typedef kog::smart_vector<pinfo> pinfoarray;$/;"	t	class:lrmachine	access:public
pleft_cmp	syntax/production.h	/^struct pleft_cmp : public std::binary_function<production, production, bool>$/;"	s	inherits:std::binary_function
pleft_cmp::operator ()	syntax/production.h	/^	bool operator()(const production& p1, const production& p2) const$/;"	f	struct:pleft_cmp	access:public	signature:(const production& p1, const production& p2) const
pleft_less	syntax/production.h	/^typedef pleft_cmp<std::less<int32> > pleft_less;$/;"	t
plist	galgorithm/lranalyse.cpp	/^	kog::smart_vector<const production*> plist;$/;"	m	struct:AlgorithmArg	file:	access:public
plus	compiler/operation.h	/^	plus,$/;"	e	enum:op
pointer	include/arrayX.h	/^	typedef _Ty* pointer;$/;"	t	struct:SmartArray	access:public
pointer	include/arrayX.h	/^	typedef _Ty* pointer;$/;"	t	struct:SmartMatrix	access:public
pointer	include/arrayX.h	/^	typedef value_type* pointer;$/;"	t	class:smart_vector	access:public
pointer	include/iteratorX.h	/^	typedef typename _Base::pointer pointer;$/;"	t	struct:array_iterator	access:public
pointer	include/memoryX.h	/^	typedef value_type* pointer;$/;"	t	struct:memblock	access:public
pointer	include/stringX.h	/^	typedef _Tptr pointer;$/;"	t	class:xstring_basic	access:public
pointer	include/tree.h	/^		typedef typename _Base::pointer pointer;$/;"	t	struct:tree::_Const_iterator	access:public
pointer	include/tree.h	/^		typedef typename _Base::pointer pointer;$/;"	t	struct:tree::_Iterator	access:public
pointer_binary_function	include/functionalX.h	/^struct pointer_binary_function : public std::binary_function<_Tx*, _Tx*, typename _Fun::result_type>$/;"	s	inherits:std::binary_function
pointer_binary_function::operator ()	include/functionalX.h	/^	typename _Fun::result_type operator()(_Tx* _Arg1, _Tx* _Arg2) const$/;"	f	struct:pointer_binary_function	access:public	signature:(_Tx* _Arg1, _Tx* _Arg2) const
pool_	tmp/back/simplepool.h	/^	std::deque<_Tx> pool_;$/;"	m	class:mempool	access:private
posB_	include/stringXF.h	/^        size_t posB_;$/;"	m	struct:string_split_t::_Const_iterator	access:private
posE_	include/stringXF.h	/^        size_t posE_;$/;"	m	struct:string_split_t::_Const_iterator	access:private
pos_	compiler/variable.h	/^        uint32 pos_; \/\/ address in memory$/;"	m	union:variable::__anon130	access:public
pp	galgorithm/lranalyse.cpp	/^		const production* pp;$/;"	m	union:nextstate::__anon2	file:	access:public
pright_cmp	syntax/production.h	/^struct pright_cmp<_Less, std::logical_and<bool> > : public std::binary_function<production, production, bool>$/;"	s	inherits:std::binary_function
pright_cmp	syntax/production.h	/^struct pright_cmp<_Less, std::logical_or<bool> > : public std::binary_function<production, production, bool>$/;"	s	inherits:std::binary_function
pright_cmp::operator ()	syntax/production.h	/^	bool operator()(const production& p1, const production& p2) const$/;"	f	struct:pright_cmp	access:public	signature:(const production& p1, const production& p2) const
print	asmgenerate.h	/^    void print(scope* s);$/;"	p	class:asmgenerate	access:public	signature:(scope* s)
print	compiler/asmgenerate.cpp	/^void asmgenerate::print(scope* s)$/;"	f	class:asmgenerate	signature:(scope* s)
print	test/output/gen.cpp	/^	print()$/;"	f	struct:print	access:public	signature:()
print	test/output/gen.cpp	/^struct print : public type$/;"	s	file:	inherits:type
print	test/output/tinyg.cpp	/^	print()$/;"	f	struct:print	access:public	signature:()
print	test/output/tinyg.cpp	/^struct print : public type$/;"	s	file:	inherits:type
print	test/output/tinyg/tinyg.cpp	/^	print()$/;"	f	struct:print	access:public	signature:()
print	test/output/tinyg/tinyg.cpp	/^struct print : public type$/;"	s	file:	inherits:type
print	test/output/tinyg/tinyg_bk.cpp	/^	print()$/;"	f	struct:print	access:public	signature:()
print	test/output/tinyg/tinyg_bk.cpp	/^struct print : public type$/;"	s	file:	inherits:type
print::print	test/output/gen.cpp	/^	print()$/;"	f	struct:print	access:public	signature:()
print::print	test/output/tinyg.cpp	/^	print()$/;"	f	struct:print	access:public	signature:()
print::print	test/output/tinyg/tinyg.cpp	/^	print()$/;"	f	struct:print	access:public	signature:()
print::print	test/output/tinyg/tinyg_bk.cpp	/^	print()$/;"	f	struct:print	access:public	signature:()
print::sid	test/output/gen.cpp	/^	enum{ sid = 1016 };$/;"	e	enum:print::__anon111	file:
print::sid	test/output/tinyg.cpp	/^	enum{ sid = 13 };$/;"	e	enum:print::__anon18	file:
print::sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 13 };$/;"	e	enum:print::__anon49	file:
print::sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 13 };$/;"	e	enum:print::__anon80	file:
print_grammar	makecompiler/gensyntax.cpp	/^void syntaxgenerator::print_grammar()$/;"	f	class:syntaxgenerator	signature:()
print_grammar	makecompiler/gensyntax.h	/^	void print_grammar();$/;"	p	class:syntaxgenerator	access:private	signature:()
print_grammar_to_file	test/regexnfatest.cpp	/^	void print_grammar_to_file(const tinygrammar& g)$/;"	f	class:regex2nfa_test	file:	access:private	signature:(const tinygrammar& g)
print_includes	makecompiler/gensyntax.cpp	/^void syntaxgenerator::print_includes()$/;"	f	class:syntaxgenerator	signature:()
print_includes	makecompiler/gensyntax.h	/^	void print_includes();$/;"	p	class:syntaxgenerator	access:private	signature:()
print_item	galgorithm/lranalyse.cpp	/^std::ostream& print_item(std::ostream& os, const lrstateitem& itm, const symholder& sholder)$/;"	f	signature:(std::ostream& os, const lrstateitem& itm, const symholder& sholder)
print_keywords	makecompiler/gensyntax.cpp	/^void syntaxgenerator::print_keywords()$/;"	f	class:syntaxgenerator	signature:()
print_keywords	makecompiler/gensyntax.h	/^	void print_keywords();$/;"	p	class:syntaxgenerator	access:private	signature:()
print_machine	makecompiler/gensyntax.cpp	/^void syntaxgenerator::print_machine(std::ostream& os, const compile::automachine& mac)$/;"	f	class:syntaxgenerator	signature:(std::ostream& os, const compile::automachine& mac)
print_machine	makecompiler/gensyntax.h	/^	void print_machine(std::ostream& os, const compile::automachine& mac);$/;"	p	class:syntaxgenerator	access:private	signature:(std::ostream& os, const compile::automachine& mac)
print_printablechars	makecompiler/gensyntax.cpp	/^void syntaxgenerator::print_printablechars()$/;"	f	class:syntaxgenerator	signature:()
print_printablechars	makecompiler/gensyntax.h	/^	void print_printablechars();$/;"	p	class:syntaxgenerator	access:private	signature:()
print_productions	makecompiler/gensyntax.cpp	/^void syntaxgenerator::print_productions()$/;"	f	class:syntaxgenerator	signature:()
print_productions	makecompiler/gensyntax.h	/^    void print_productions();$/;"	p	class:syntaxgenerator	access:private	signature:()
print_separators	makecompiler/gensyntax.cpp	/^void syntaxgenerator::print_separators()$/;"	f	class:syntaxgenerator	signature:()
print_separators	makecompiler/gensyntax.h	/^	void print_separators();$/;"	p	class:syntaxgenerator	access:private	signature:()
print_statemachines	makecompiler/gensyntax.cpp	/^void syntaxgenerator::print_statemachines()$/;"	f	class:syntaxgenerator	signature:()
print_statemachines	makecompiler/gensyntax.h	/^	void print_statemachines();$/;"	p	class:syntaxgenerator	access:private	signature:()
print_symbols	makecompiler/gensyntax.cpp	/^void syntaxgenerator::print_symbols()$/;"	f	class:syntaxgenerator	signature:()
print_symbols	makecompiler/gensyntax.h	/^	void print_symbols();$/;"	p	class:syntaxgenerator	access:private	signature:()
printablechars	compiler/compiler.h	/^	kog::smart_vector<sc::int32> printablechars;$/;"	m	class:compiler	access:private
printablechars	tmp/back/compiler.h	/^	kog::smart_vector<sc::int32> printablechars;$/;"	m	class:compiler	access:private
prod	galgorithm/lranalyse.cpp	/^	const production* prod; \/\/ ref production$/;"	m	struct:lrstateitem	file:	access:public
prod	galgorithm/regex2nfa.cpp	/^	struct prod$/;"	s	struct:parsecontent	file:	access:public
prod	tmp/back/regex2nfa.cpp	/^	struct prod$/;"	s	struct:parsecontent	file:	access:public
prod_func12	build/debug/test/prodfunc.cpp	/^struct prod_func12 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func12	test/tinygprodfuncs.cpp	/^struct prod_func12 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func12	tmp/prodfunc.cpp	/^struct prod_func12 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func12::operator ()	build/debug/test/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func12	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func12::operator ()	test/tinygprodfuncs.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func12	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func12::operator ()	tmp/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func12	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func13	build/debug/test/prodfunc.cpp	/^struct prod_func13 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func13	test/tinygprodfuncs.cpp	/^struct prod_func13 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func13	tmp/prodfunc.cpp	/^struct prod_func13 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func13::operator ()	build/debug/test/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func13	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func13::operator ()	test/tinygprodfuncs.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func13	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func13::operator ()	tmp/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func13	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func14	build/debug/test/prodfunc.cpp	/^struct prod_func14 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func14	test/tinygprodfuncs.cpp	/^struct prod_func14 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func14	tmp/prodfunc.cpp	/^struct prod_func14 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func14::operator ()	build/debug/test/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func14	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func14::operator ()	test/tinygprodfuncs.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func14	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func14::operator ()	tmp/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func14	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func15	build/debug/test/prodfunc.cpp	/^struct prod_func15 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func15	test/tinygprodfuncs.cpp	/^struct prod_func15 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func15	tmp/prodfunc.cpp	/^struct prod_func15 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func15::operator ()	build/debug/test/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func15	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func15::operator ()	test/tinygprodfuncs.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func15	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func15::operator ()	tmp/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func15	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func16	build/debug/test/prodfunc.cpp	/^struct prod_func16 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func16	test/tinygprodfuncs.cpp	/^struct prod_func16 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func16	tmp/prodfunc.cpp	/^struct prod_func16 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func16::operator ()	build/debug/test/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func16	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func16::operator ()	test/tinygprodfuncs.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func16	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func16::operator ()	tmp/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func16	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func17	build/debug/test/prodfunc.cpp	/^struct prod_func17 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func17	test/tinygprodfuncs.cpp	/^struct prod_func17 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func17	tmp/prodfunc.cpp	/^struct prod_func17 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func17::operator ()	build/debug/test/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func17	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func17::operator ()	test/tinygprodfuncs.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func17	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func17::operator ()	tmp/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func17	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func20	build/debug/test/prodfunc.cpp	/^struct prod_func20 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func20	test/tinygprodfuncs.cpp	/^struct prod_func20 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func20	tmp/prodfunc.cpp	/^struct prod_func20 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func20::operator ()	build/debug/test/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func20	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func20::operator ()	test/tinygprodfuncs.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func20	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func20::operator ()	tmp/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func20	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func21	build/debug/test/prodfunc.cpp	/^struct prod_func21 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func21	test/tinygprodfuncs.cpp	/^struct prod_func21 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func21	tmp/prodfunc.cpp	/^struct prod_func21 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func21::operator ()	build/debug/test/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func21	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func21::operator ()	test/tinygprodfuncs.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func21	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func21::operator ()	tmp/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func21	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func22	build/debug/test/prodfunc.cpp	/^struct prod_func22 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func22	test/tinygprodfuncs.cpp	/^struct prod_func22 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func22	tmp/prodfunc.cpp	/^struct prod_func22 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func22::operator ()	build/debug/test/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func22	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func22::operator ()	test/tinygprodfuncs.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func22	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func22::operator ()	tmp/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func22	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func23	build/debug/test/prodfunc.cpp	/^struct prod_func23 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func23	test/tinygprodfuncs.cpp	/^struct prod_func23 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func23	tmp/prodfunc.cpp	/^struct prod_func23 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func23::operator ()	build/debug/test/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func23	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func23::operator ()	test/tinygprodfuncs.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func23	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func23::operator ()	tmp/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func23	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func24	build/debug/test/prodfunc.cpp	/^struct prod_func24 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func24	test/tinygprodfuncs.cpp	/^struct prod_func24 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func24	tmp/prodfunc.cpp	/^struct prod_func24 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func24::operator ()	build/debug/test/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func24	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func24::operator ()	test/tinygprodfuncs.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func24	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func24::operator ()	tmp/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func24	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func25	build/debug/test/prodfunc.cpp	/^struct prod_func25 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func25	test/tinygprodfuncs.cpp	/^struct prod_func25 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func25	tmp/prodfunc.cpp	/^struct prod_func25 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func25::operator ()	build/debug/test/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func25	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func25::operator ()	test/tinygprodfuncs.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func25	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func25::operator ()	tmp/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func25	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func26	build/debug/test/prodfunc.cpp	/^struct prod_func26 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func26	test/tinygprodfuncs.cpp	/^struct prod_func26 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func26	tmp/prodfunc.cpp	/^struct prod_func26 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func26::operator ()	build/debug/test/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func26	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func26::operator ()	test/tinygprodfuncs.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func26	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func26::operator ()	tmp/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func26	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func27	build/debug/test/prodfunc.cpp	/^struct prod_func27 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func27	test/tinygprodfuncs.cpp	/^struct prod_func27 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func27	tmp/prodfunc.cpp	/^struct prod_func27 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func27::operator ()	build/debug/test/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func27	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func27::operator ()	test/tinygprodfuncs.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func27	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func27::operator ()	tmp/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func27	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func4	build/debug/test/prodfunc.cpp	/^struct prod_func4 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func4	test/tinygprodfuncs.cpp	/^struct prod_func4 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func4	tmp/prodfunc.cpp	/^struct prod_func4 : public ifunction$/;"	s	file:	inherits:ifunction
prod_func4::operator ()	build/debug/test/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func4	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func4::operator ()	test/tinygprodfuncs.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func4	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func4::operator ()	tmp/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func4	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func_default	build/debug/test/prodfunc.cpp	/^struct prod_func_default : public ifunction$/;"	s	file:	inherits:ifunction
prod_func_default	test/tinygprodfuncs.cpp	/^struct prod_func_default : public ifunction$/;"	s	file:	inherits:ifunction
prod_func_default	tmp/prodfunc.cpp	/^struct prod_func_default : public ifunction$/;"	s	file:	inherits:ifunction
prod_func_default::operator ()	build/debug/test/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func_default	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func_default::operator ()	test/tinygprodfuncs.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func_default	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_func_default::operator ()	tmp/prodfunc.cpp	/^    \/*overwrite*\/ virtual automachine::machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:prod_func_default	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
prod_less	syntax/production.h	/^struct prod_less : public std::binary_function<production, production, bool>$/;"	s	inherits:std::binary_function
prod_less::operator ()	syntax/production.h	/^	bool operator()(const production& p1, const production& p2) const$/;"	f	struct:prod_less	access:public	signature:(const production& p1, const production& p2) const
prods	galgorithm/regex2nfa.cpp	/^	std::deque<prod> prods;$/;"	m	struct:parsecontent	file:	access:public
prods	tmp/back/regex2nfa.cpp	/^	std::deque<prod> prods;$/;"	m	struct:parsecontent	file:	access:public
production	syntax/production.cpp	/^production::production()$/;"	f	class:production	signature:()
production	syntax/production.cpp	/^production::production(const symholder& holder)$/;"	f	class:production	signature:(const symholder& holder)
production	syntax/production.cpp	/^production::production(const symholder& holder, int32 L, const int32* Rs, int N)$/;"	f	class:production	signature:(const symholder& holder, int32 L, const int32* Rs, int N)
production	syntax/production.cpp	/^production::production(int32 L, const int32* Rs, int32 N)$/;"	f	class:production	signature:(int32 L, const int32* Rs, int32 N)
production	syntax/production.h	/^	production();$/;"	p	class:production	access:public	signature:()
production	syntax/production.h	/^	production(const symholder& syms);$/;"	p	class:production	access:public	signature:(const symholder& syms)
production	syntax/production.h	/^	production(const symholder& syms, int32 L, const int32* Rs, int32 N);$/;"	p	class:production	access:public	signature:(const symholder& syms, int32 L, const int32* Rs, int32 N)
production	syntax/production.h	/^	production(int32 L, const int32* Rs, int32 N);$/;"	p	class:production	access:public	signature:(int32 L, const int32* Rs, int32 N)
production	syntax/production.h	/^class production$/;"	c
production::L_	syntax/production.h	/^	int32 L_;$/;"	m	class:production	access:private
production::MEMBER_VARIABLE_GET	syntax/production.h	/^	MEMBER_VARIABLE_GET(const right_array&, right, Rs_);$/;"	p	class:production	access:public	signature:(const right_array&, right, Rs_)
production::MEMBER_VARIABLE_GET	syntax/production.h	/^	MEMBER_VARIABLE_GET(int32, right_size, Rs_.size());$/;"	p	class:production	access:public	signature:(int32, right_size, Rs_.size())
production::MEMBER_VARIABLE_GET_SET	syntax/production.h	/^	MEMBER_VARIABLE_GET_SET(int32, left, L_);$/;"	p	class:production	access:public	signature:(int32, left, L_)
production::MEMBER_VARIABLE_GET_SET	syntax/production.h	/^    MEMBER_VARIABLE_GET_SET(_Str, func, func_);$/;"	p	class:production	access:public	signature:(_Str, func, func_)
production::MEMBER_VARIABLE_GET_SET_INDEXER	syntax/production.h	/^	MEMBER_VARIABLE_GET_SET_INDEXER(int32, std::size_t, Rs_);$/;"	p	class:production	access:public	signature:(int32, std::size_t, Rs_)
production::Rs_	syntax/production.h	/^	right_array Rs_;$/;"	m	class:production	access:private
production::func_	syntax/production.h	/^    _Str func_;$/;"	m	class:production	access:private
production::holder_	syntax/production.h	/^	const symholder* holder_;$/;"	m	class:production	access:private
production::production	syntax/production.cpp	/^production::production()$/;"	f	class:production	signature:()
production::production	syntax/production.cpp	/^production::production(const symholder& holder)$/;"	f	class:production	signature:(const symholder& holder)
production::production	syntax/production.cpp	/^production::production(const symholder& holder, int32 L, const int32* Rs, int N)$/;"	f	class:production	signature:(const symholder& holder, int32 L, const int32* Rs, int N)
production::production	syntax/production.cpp	/^production::production(int32 L, const int32* Rs, int32 N)$/;"	f	class:production	signature:(int32 L, const int32* Rs, int32 N)
production::production	syntax/production.h	/^	production();$/;"	p	class:production	access:public	signature:()
production::production	syntax/production.h	/^	production(const symholder& syms);$/;"	p	class:production	access:public	signature:(const symholder& syms)
production::production	syntax/production.h	/^	production(const symholder& syms, int32 L, const int32* Rs, int32 N);$/;"	p	class:production	access:public	signature:(const symholder& syms, int32 L, const int32* Rs, int32 N)
production::production	syntax/production.h	/^	production(int32 L, const int32* Rs, int32 N);$/;"	p	class:production	access:public	signature:(int32 L, const int32* Rs, int32 N)
production::reset_right	syntax/production.cpp	/^void production::reset_right(const int32* Rs, int N)$/;"	f	class:production	signature:(const int32* Rs, int N)
production::reset_right	syntax/production.h	/^	void reset_right(const int32* Rs, int N);$/;"	p	class:production	access:public	signature:(const int32* Rs, int N)
production::right_array	syntax/production.h	/^	typedef kog::smart_vector<int32> right_array;$/;"	t	class:production	access:public
production::swap	syntax/production.cpp	/^void production::swap(production& other)$/;"	f	class:production	signature:(production& other)
production::swap	syntax/production.h	/^	void swap(production& other);$/;"	p	class:production	access:public	signature:(production& other)
production_func_0	build/debug/test/tinyg.cpp	/^struct production_func_0 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_0	build/debug/test/tmp.cpp	/^struct production_func_0 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_0	build/debug/test/xxx.cpp	/^struct production_func_0 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_0	test/tinyg.cpp	/^struct production_func_0 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_0::operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_0	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_0::operator ()	build/debug/test/tmp.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:production_func_0	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
production_func_0::operator ()	build/debug/test/xxx.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)$/;"	f	struct:production_func_0	access:public	signature:(automachine::machine_meta*const* metas, int C, automachine::machine_meta* result)
production_func_0::operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_0	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_1	build/debug/test/tinyg.cpp	/^struct production_func_1 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_1	test/tinyg.cpp	/^struct production_func_1 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_10	build/debug/test/tinyg.cpp	/^struct production_func_10 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_10	test/tinyg.cpp	/^struct production_func_10 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_10::operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_10	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_10::operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_10	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_11	build/debug/test/tinyg.cpp	/^struct production_func_11 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_11	test/tinyg.cpp	/^struct production_func_11 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_11::operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_11	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_11::operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_11	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_12	build/debug/test/tinyg.cpp	/^struct production_func_12 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_12	test/tinyg.cpp	/^struct production_func_12 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_12::operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_12	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_12::operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_12	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_13	build/debug/test/tinyg.cpp	/^struct production_func_13 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_13	test/tinyg.cpp	/^struct production_func_13 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_13::operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_13	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_13::operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_13	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_14	build/debug/test/tinyg.cpp	/^struct production_func_14 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_14	test/tinyg.cpp	/^struct production_func_14 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_14::operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_14	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_14::operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_14	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_15	build/debug/test/tinyg.cpp	/^struct production_func_15 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_15	test/tinyg.cpp	/^struct production_func_15 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_15::operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_15	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_15::operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_15	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_16	build/debug/test/tinyg.cpp	/^struct production_func_16 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_16	test/tinyg.cpp	/^struct production_func_16 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_16::operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_16	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_16::operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_16	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_17	build/debug/test/tinyg.cpp	/^struct production_func_17 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_17	test/tinyg.cpp	/^struct production_func_17 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_17::operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_17	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_17::operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_17	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_18	build/debug/test/tinyg.cpp	/^struct production_func_18 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_18	test/tinyg.cpp	/^struct production_func_18 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_18::operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_18	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_18::operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_18	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_19	build/debug/test/tinyg.cpp	/^struct production_func_19 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_19	test/tinyg.cpp	/^struct production_func_19 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_19::operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_19	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_19::operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_19	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_1::operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_1	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_1::operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_1	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_2	build/debug/test/tinyg.cpp	/^struct production_func_2 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_2	test/tinyg.cpp	/^struct production_func_2 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_20	build/debug/test/tinyg.cpp	/^struct production_func_20 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_20	test/tinyg.cpp	/^struct production_func_20 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_20::operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_20	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_20::operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_20	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_21	build/debug/test/tinyg.cpp	/^struct production_func_21 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_21	test/tinyg.cpp	/^struct production_func_21 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_21::operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_21	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_21::operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_21	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_22	build/debug/test/tinyg.cpp	/^struct production_func_22 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_22	test/tinyg.cpp	/^struct production_func_22 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_22::operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_22	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_22::operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_22	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_23	build/debug/test/tinyg.cpp	/^struct production_func_23 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_23	test/tinyg.cpp	/^struct production_func_23 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_23::operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_23	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_23::operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_23	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_24	build/debug/test/tinyg.cpp	/^struct production_func_24 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_24	test/tinyg.cpp	/^struct production_func_24 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_24::operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_24	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_24::operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_24	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_25	build/debug/test/tinyg.cpp	/^struct production_func_25 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_25	test/tinyg.cpp	/^struct production_func_25 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_25::operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_25	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_25::operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_25	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_26	build/debug/test/tinyg.cpp	/^struct production_func_26 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_26	test/tinyg.cpp	/^struct production_func_26 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_26::operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_26	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_26::operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_26	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_27	build/debug/test/tinyg.cpp	/^struct production_func_27 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_27	test/tinyg.cpp	/^struct production_func_27 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_27::operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_27	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_27::operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_27	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_2::operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_2	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_2::operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_2	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_3	build/debug/test/tinyg.cpp	/^struct production_func_3 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_3	test/tinyg.cpp	/^struct production_func_3 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_3::operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_3	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_3::operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_3	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_4	build/debug/test/tinyg.cpp	/^struct production_func_4 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_4	test/tinyg.cpp	/^struct production_func_4 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_4::operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_4	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_4::operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_4	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_5	build/debug/test/tinyg.cpp	/^struct production_func_5 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_5	test/tinyg.cpp	/^struct production_func_5 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_5::operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_5	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_5::operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_5	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_6	build/debug/test/tinyg.cpp	/^struct production_func_6 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_6	test/tinyg.cpp	/^struct production_func_6 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_6::operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_6	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_6::operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_6	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_7	build/debug/test/tinyg.cpp	/^struct production_func_7 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_7	test/tinyg.cpp	/^struct production_func_7 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_7::operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_7	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_7::operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_7	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_8	build/debug/test/tinyg.cpp	/^struct production_func_8 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_8	test/tinyg.cpp	/^struct production_func_8 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_8::operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_8	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_8::operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_8	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_9	build/debug/test/tinyg.cpp	/^struct production_func_9 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_9	test/tinyg.cpp	/^struct production_func_9 : public ifunction$/;"	s	file:	inherits:ifunction
production_func_9::operator ()	build/debug/test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_9	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
production_func_9::operator ()	test/tinyg.cpp	/^	\/* overwrite *\/ virtual machine_meta* operator()(machine_meta*const* metas, int C, machine_meta* result)$/;"	f	struct:production_func_9	access:public	signature:(machine_meta*const* metas, int C, machine_meta* result)
productions_	syntax/grammar.h	/^	vecprods productions_; \/\/ productions$/;"	m	class:tinygrammar	access:protected
ps	galgorithm/lranalyse.cpp	/^		const lrstate* ps;$/;"	m	union:nextstate::__anon2	file:	access:public
pstack_	syntax/lrmachine.h	/^	analysestack pstack_;$/;"	m	class:lrmachine	access:private
pszBom	third_party/xml/Markup.cpp	/^struct BomTableStruct { const char* pszBom; int nBomLen; MCD_PCSZ pszBomEnc; int nBomFlag; } BomTable[] =$/;"	m	struct:BomTableStruct	file:	access:public
pszBomEnc	third_party/xml/Markup.cpp	/^struct BomTableStruct { const char* pszBom; int nBomLen; MCD_PCSZ pszBomEnc; int nBomFlag; } BomTable[] =$/;"	m	struct:BomTableStruct	file:	access:public
pt	galgorithm/regex2nfa.cpp	/^		int pt; \/\/ production type: p_or, p_switch, p_seq$/;"	m	struct:parsecontent::prod	file:	access:public
pt	tmp/back/regex2nfa.cpp	/^		int pt; \/\/ production type: p_or, p_switch, p_seq$/;"	m	struct:parsecontent::prod	file:	access:public
ptr	include/arrayX.h	/^	_Ty* ptr() { return _values[0]; }$/;"	f	struct:SmartMatrix	access:public	signature:()
ptr	include/arrayX.h	/^	const _Ty* ptr() const { return _values[0]; }$/;"	f	struct:SmartMatrix	access:public	signature:() const
ptr	include/arrayX.h	/^	const_pointer ptr() const { return _buf; }$/;"	f	struct:SmartArray	access:public	signature:() const
ptr	include/arrayX.h	/^	pointer ptr() { return _buf; }$/;"	f	struct:SmartArray	access:public	signature:()
ptr	include/shared_ptr.h	/^		T* ptr;$/;"	m	class:shared_ptr	access:private
ptr	include/shared_ptr.h	/^		T* ptr;$/;"	m	class:weak_ptr	access:private
ptr_container	include/pointholder.h	/^class ptr_container : public _Container$/;"	c	inherits:_Container
ptr_container::~ptr_container	include/pointholder.h	/^	~ptr_container()$/;"	f	class:ptr_container	access:public	signature:()
range	include/functionalX.h	/^range_t<_It> range(_It _First, _It _Last)$/;"	f	signature:(_It _First, _It _Last)
range_t	include/functionalX.h	/^	range_t(iterator first, iterator last)$/;"	f	struct:range_t	access:public	signature:(iterator first, iterator last)
range_t	include/functionalX.h	/^struct range_t : protected std::pair<_Iter, _Iter>$/;"	s	inherits:std::pair
range_t::_Base	include/functionalX.h	/^	typedef std::pair<_Iter, _Iter> _Base;$/;"	t	struct:range_t	access:public
range_t::_Mybase	include/functionalX.h	/^	typedef std::pair<_Iter, _Iter> _Mybase;$/;"	t	struct:range_t	access:public
range_t::begin	include/functionalX.h	/^	iterator begin() const$/;"	f	struct:range_t	access:public	signature:() const
range_t::const_iterator	include/functionalX.h	/^	typedef typename mpl::add_const<_Iter>::const_value_type const_iterator;$/;"	t	struct:range_t	access:public
range_t::end	include/functionalX.h	/^	iterator end() const$/;"	f	struct:range_t	access:public	signature:() const
range_t::iterator	include/functionalX.h	/^	typedef typename mpl::add_const<_Iter>::value_type iterator;$/;"	t	struct:range_t	access:public
range_t::range_t	include/functionalX.h	/^	range_t(iterator first, iterator last)$/;"	f	struct:range_t	access:public	signature:(iterator first, iterator last)
rbegin	include/arrayX.h	/^	const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); }$/;"	f	class:smart_vector	access:public	signature:() const
rbegin	include/arrayX.h	/^	const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); }$/;"	f	struct:SmartArray	access:public	signature:() const
rbegin	include/arrayX.h	/^	reverse_iterator rbegin() { return reverse_iterator(end()); }$/;"	f	class:smart_vector	access:public	signature:()
rbegin	include/arrayX.h	/^	reverse_iterator rbegin() { return reverse_iterator(end()); }$/;"	f	struct:SmartArray	access:public	signature:()
read_content	compiler/extract.cpp	/^	bool read_content(_Str& txt, state_machine& nm)$/;"	f	class:iwordstream	file:	access:private	signature:(_Str& txt, state_machine& nm)
read_grammar	test/gio.h	/^	void read_grammar(std::istream& is, compile::tinygrammar& g, const std::string& start, const std::string& eplison, const std::string& ending) const$/;"	f	class:greader	access:private	signature:(std::istream& is, compile::tinygrammar& g, const std::string& start, const std::string& eplison, const std::string& ending) const
readfile	syntax/global_values.cpp	/^void readfile(const std::string& file, std::deque<value_t>& values)$/;"	f	signature:(const std::string& file, std::deque<value_t>& values)
readgrammar	syntax/loader.h	/^	void readgrammar(grammar& aGrammar);$/;"	p	class:loader	access:public	signature:(grammar& aGrammar)
readxml	syntax/global_values.cpp	/^void readxml(xmlfile& doc, std::deque<value_t>& values)$/;"	f	signature:(xmlfile& doc, std::deque<value_t>& values)
reduce	syntax/lrmachine.cpp	/^lrmachine::machine_meta* lrmachine::reduce(int32 pid)$/;"	f	class:lrmachine	signature:(int32 pid)
reduce	syntax/lrmachine.h	/^	machine_meta* reduce(int32 pid);$/;"	p	class:lrmachine	access:protected	signature:(int32 pid)
ref	include/buckethash.h	/^		const buckethash<_K, _V, _K2I>* ref;$/;"	m	struct:buckethash::_Const_iterator	access:private
ref	include/functionalX.h	/^inline ref_obj<T> ref(T& obj)$/;"	f	signature:(T& obj)
ref_	include/stringXF.h	/^        string_split_t<_Elem>* ref_;$/;"	m	struct:string_split_t::_Const_iterator	access:private
ref_obj	include/functionalX.h	/^	ref_obj(T& obj)$/;"	f	class:ref_obj	access:public	signature:(T& obj)
ref_obj	include/functionalX.h	/^class ref_obj$/;"	c
ref_obj::_ref_obj	include/functionalX.h	/^	T& _ref_obj;$/;"	m	class:ref_obj	access:private
ref_obj::const_ref_type	include/functionalX.h	/^	typedef const T& const_ref_type;$/;"	t	class:ref_obj	access:public
ref_obj::operator ->	include/functionalX.h	/^	T* operator->()$/;"	f	class:ref_obj	access:public	signature:()
ref_obj::operator const_ref_type	include/functionalX.h	/^	operator const_ref_type() const$/;"	f	class:ref_obj	access:public	signature:() const
ref_obj::operator ref_type	include/functionalX.h	/^	operator ref_type()$/;"	f	class:ref_obj	access:public	signature:()
ref_obj::ref_obj	include/functionalX.h	/^	ref_obj(T& obj)$/;"	f	class:ref_obj	access:public	signature:(T& obj)
ref_obj::ref_type	include/functionalX.h	/^	typedef T& ref_type;$/;"	t	class:ref_obj	access:public
ref_type	include/functionalX.h	/^	typedef T& ref_type;$/;"	t	class:ref_obj	access:public
refcount	include/shared_ptr.h	/^		unsigned refcount() const { return *count; }$/;"	f	class:shared_ptr	access:public	signature:() const
refcount	include/shared_ptr.h	/^		unsigned refcount() const { return *count; }$/;"	f	class:weak_ptr	access:public	signature:() const
reference	include/arrayX.h	/^	typedef value_type& reference;$/;"	t	class:smart_vector	access:public
reference	include/arrayX.h	/^	typedef value_type& reference;$/;"	t	struct:SmartArray	access:public
reference	include/arrayX.h	/^	typedef value_type& reference;$/;"	t	struct:SmartMatrix	access:public
reference	include/functionalX.h	/^	typedef typename std::iterator_traits<_InIt>::reference reference;$/;"	t	struct:dereference_t	access:public
reference	include/iteratorX.h	/^	typedef typename _Base::reference reference;$/;"	t	struct:array_iterator	access:public
reference	include/memoryX.h	/^	typedef value_type& reference;$/;"	t	struct:memblock	access:public
reference	include/stringX.h	/^	typedef _Reft reference;$/;"	t	class:xstring_basic	access:public
reference	include/tree.h	/^		typedef typename _Base::reference reference;$/;"	t	struct:tree::_Const_iterator	access:public
reference	include/tree.h	/^		typedef typename _Base::reference reference;$/;"	t	struct:tree::_Iterator	access:public
reference_type	include/functionalX.h	/^	typedef _Ty& reference_type;$/;"	t	struct:mem_value_t	access:public
refine_machine	makecompiler/gensyntax.cpp	/^void syntaxgenerator::refine_machine(automachine& m) const$/;"	f	class:syntaxgenerator	signature:(automachine& m) const
refine_machine	makecompiler/gensyntax.h	/^	void refine_machine(automachine& m) const;$/;"	p	class:syntaxgenerator	access:private	signature:(automachine& m) const
refobject	syntax/global_values.h	/^	refobject()$/;"	f	class:refobject	access:public	signature:()
refobject	syntax/global_values.h	/^	refobject(const _Tx& v)$/;"	f	class:refobject	access:public	signature:(const _Tx& v)
refobject	syntax/global_values.h	/^	refobject(const refobject& v)$/;"	f	class:refobject	access:public	signature:(const refobject& v)
refobject	syntax/global_values.h	/^class refobject$/;"	c
refobject::holder	syntax/global_values.h	/^	class holder$/;"	c	class:refobject	access:private
refobject::holder::assign	syntax/global_values.h	/^		virtual holder& assign(const holder& V) = 0;$/;"	p	class:refobject::holder	access:public	signature:(const holder& V)
refobject::holder::clone	syntax/global_values.h	/^		virtual holder* clone() const = 0;$/;"	p	class:refobject::holder	access:public	signature:() const
refobject::holder::from_string	syntax/global_values.h	/^		virtual holder& from_string(const std::string& str) = 0;$/;"	p	class:refobject::holder	access:public	signature:(const std::string& str)
refobject::holder::holder	syntax/global_values.h	/^		holder() {}$/;"	f	class:refobject::holder	access:public	signature:()
refobject::holder::to_string	syntax/global_values.h	/^		virtual std::string to_string() const = 0;$/;"	p	class:refobject::holder	access:public	signature:() const
refobject::holder::type	syntax/global_values.h	/^		virtual const std::type_info& type() const = 0;$/;"	p	class:refobject::holder	access:public	signature:() const
refobject::holder::~holder	syntax/global_values.h	/^		virtual ~holder() = 0 {};$/;"	p	class:refobject::holder	access:public	signature:()
refobject::holder::~holder	syntax/global_values.h	/^		virtual ~holder() {};$/;"	f	class:refobject::holder	access:public	signature:()
refobject::obj_	syntax/global_values.h	/^	std::auto_ptr<holder> obj_;$/;"	m	class:refobject	access:private
refobject::object	syntax/global_values.h	/^	class object : public holder$/;"	c	class:refobject	inherits:holder	access:private
refobject::object::assign	syntax/global_values.h	/^		object<_Tx>& assign(const holder& V)$/;"	f	class:refobject::object	access:public	signature:(const holder& V)
refobject::object::clone	syntax/global_values.h	/^		object<_Tx>* clone() const$/;"	f	class:refobject::object	access:public	signature:() const
refobject::object::from_string	syntax/global_values.h	/^		object<_Tx>& from_string(const std::string& str)$/;"	f	class:refobject::object	access:public	signature:(const std::string& str)
refobject::object::get	syntax/global_values.h	/^		_Tx& get()$/;"	f	class:refobject::object	access:public	signature:()
refobject::object::get	syntax/global_values.h	/^		const _Tx& get() const$/;"	f	class:refobject::object	access:public	signature:() const
refobject::object::object	syntax/global_values.h	/^		object()$/;"	f	class:refobject::object	access:public	signature:()
refobject::object::object	syntax/global_values.h	/^		object(const _Tx& v)$/;"	f	class:refobject::object	access:public	signature:(const _Tx& v)
refobject::object::to_string	syntax/global_values.h	/^		std::string to_string() const$/;"	f	class:refobject::object	access:public	signature:() const
refobject::object::type	syntax/global_values.h	/^		const std::type_info& type() const$/;"	f	class:refobject::object	access:public	signature:() const
refobject::object::value_	syntax/global_values.h	/^		_Tx value_;$/;"	m	class:refobject::object	access:private
refobject::operator <<	syntax/global_values.h	/^	friend std::ostream& operator<<(std::ostream& os, const refobject& ref)$/;"	f	class:refobject	access:friend	signature:(std::ostream& os, const refobject& ref)
refobject::operator =	syntax/global_values.h	/^	refobject& operator=(const _Ty& _V)$/;"	f	class:refobject	access:public	signature:(const _Ty& _V)
refobject::operator =	syntax/global_values.h	/^	refobject& operator=(const refobject& _Other)$/;"	f	class:refobject	access:public	signature:(const refobject& _Other)
refobject::refobject	syntax/global_values.h	/^	refobject()$/;"	f	class:refobject	access:public	signature:()
refobject::refobject	syntax/global_values.h	/^	refobject(const _Tx& v)$/;"	f	class:refobject	access:public	signature:(const _Tx& v)
refobject::refobject	syntax/global_values.h	/^	refobject(const refobject& v)$/;"	f	class:refobject	access:public	signature:(const refobject& v)
refobject::toValue	syntax/global_values.h	/^	_Tx& toValue()$/;"	f	class:refobject	access:public	signature:()
refobject::toValue	syntax/global_values.h	/^	const _Tx& toValue() const$/;"	f	class:refobject	access:public	signature:() const
refobject::~refobject	syntax/global_values.h	/^	~refobject()$/;"	f	class:refobject	access:public	signature:()
regex2nfa	galgorithm/regex2nfa.h	/^	regex2nfa(const tstring& regexstr, tinygrammar& otput)$/;"	f	class:regex2nfa	access:public	signature:(const tstring& regexstr, tinygrammar& otput)
regex2nfa	galgorithm/regex2nfa.h	/^class regex2nfa : public grammar_algorithm$/;"	c	inherits:grammar_algorithm
regex2nfa::gout_	galgorithm/regex2nfa.h	/^	tinygrammar* gout_;$/;"	m	class:regex2nfa	access:private
regex2nfa::invoke	galgorithm/regex2nfa.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:regex2nfa	access:public	signature:()
regex2nfa::operator ()	galgorithm/regex2nfa.cpp	/^void regex2nfa::operator()(const tstring& input, tinygrammar& otput)$/;"	f	class:regex2nfa	signature:(const tstring& input, tinygrammar& otput)
regex2nfa::operator ()	galgorithm/regex2nfa.h	/^	void operator()(const tstring& input, tinygrammar& otput);$/;"	p	class:regex2nfa	access:private	signature:(const tstring& input, tinygrammar& otput)
regex2nfa::operator ()	tmp/back/regex2nfa.cpp	/^void regex2nfa::operator()(const tstring& input, grammar& otput)$/;"	f	class:regex2nfa	signature:(const tstring& input, grammar& otput)
regex2nfa::regex2nfa	galgorithm/regex2nfa.h	/^	regex2nfa(const tstring& regexstr, tinygrammar& otput)$/;"	f	class:regex2nfa	access:public	signature:(const tstring& regexstr, tinygrammar& otput)
regex2nfa::regexstr_	galgorithm/regex2nfa.h	/^	tstring regexstr_;$/;"	m	class:regex2nfa	access:private
regex2nfa::tocfg	galgorithm/regex2nfa.cpp	/^void regex2nfa::tocfg(const tstring& input, tinygrammar& otput)$/;"	f	class:regex2nfa	signature:(const tstring& input, tinygrammar& otput)
regex2nfa::tocfg	galgorithm/regex2nfa.h	/^	void tocfg(const tstring& input, tinygrammar& otput);$/;"	p	class:regex2nfa	access:private	signature:(const tstring& input, tinygrammar& otput)
regex2nfa::tocfg	tmp/back/regex2nfa.cpp	/^void regex2nfa::tocfg(const tstring& input, grammar& otput)$/;"	f	class:regex2nfa	signature:(const tstring& input, grammar& otput)
regex2nfa::tonfa	galgorithm/regex2nfa.cpp	/^void regex2nfa::tonfa(const tinygrammar& input, tinygrammar& otput)$/;"	f	class:regex2nfa	signature:(const tinygrammar& input, tinygrammar& otput)
regex2nfa::tonfa	galgorithm/regex2nfa.h	/^	void tonfa(const tinygrammar& input, tinygrammar& otput);$/;"	p	class:regex2nfa	access:private	signature:(const tinygrammar& input, tinygrammar& otput)
regex2nfa::tonfa	tmp/back/regex2nfa.cpp	/^void regex2nfa::tonfa(const grammar& input, grammar& otput)$/;"	f	class:regex2nfa	signature:(const grammar& input, grammar& otput)
regex2nfa_test	test/regexnfatest.cpp	/^NEW_UNITTEST(regex2nfa_test);$/;"	v
regex2nfa_test	test/regexnfatest.cpp	/^class regex2nfa_test : public sc::unittest$/;"	c	file:	inherits:sc::unittest
regex2nfa_test::init	test/regexnfatest.cpp	/^	\/* overwrite *\/ virtual void init(int argc, const char* argv[])$/;"	f	class:regex2nfa_test	file:	access:private	signature:(int argc, const char* argv[])
regex2nfa_test::outfile	test/regexnfatest.cpp	/^	std::string outfile;$/;"	m	class:regex2nfa_test	file:	access:private
regex2nfa_test::print_grammar_to_file	test/regexnfatest.cpp	/^	void print_grammar_to_file(const tinygrammar& g)$/;"	f	class:regex2nfa_test	file:	access:private	signature:(const tinygrammar& g)
regex2nfa_test::run_test	test/regexnfatest.cpp	/^	\/* overwrite *\/ virtual void run_test()$/;"	f	class:regex2nfa_test	file:	access:private	signature:()
regex_str_to_machine	makecompiler/gensyntax.cpp	/^void syntaxgenerator::regex_str_to_machine(const std::string& regexstr, automachine& m)$/;"	f	class:syntaxgenerator	signature:(const std::string& regexstr, automachine& m)
regex_str_to_machine	makecompiler/gensyntax.h	/^	void regex_str_to_machine(const std::string& regexstr, automachine& m);$/;"	p	class:syntaxgenerator	access:private	signature:(const std::string& regexstr, automachine& m)
regexstr_	galgorithm/regex2nfa.h	/^	tstring regexstr_;$/;"	m	class:regex2nfa	access:private
release	include/arrayX.h	/^	pointer release()$/;"	f	class:smart_vector	access:public	signature:()
remove	include/buckethash.h	/^	void remove(const key& k)$/;"	f	class:buckethash	access:public	signature:(const key& k)
remove	include/heapX.h	/^	void remove(const value_type& _v)$/;"	f	class:heap	access:public	signature:(const value_type& _v)
remove_const	include/mplX.h	/^struct remove_const$/;"	s
remove_const	include/mplX.h	/^struct remove_const<const _Tx>$/;"	s
remove_const::const_type	include/mplX.h	/^	typedef const _Tx const_type;$/;"	t	struct:remove_const	access:public
remove_const::type	include/mplX.h	/^	typedef _Tx type;$/;"	t	struct:remove_const	access:public
remove_duplicate	galgorithm/basicalgorithms.cpp	/^void removesingle::remove_duplicate(std::list<production>& plist)$/;"	f	class:removesingle	signature:(std::list<production>& plist)
remove_duplicate	galgorithm/basicalgorithms.h	/^	void remove_duplicate(std::list<production>& plist);$/;"	p	class:removesingle	access:private	signature:(std::list<production>& plist)
removenotused	galgorithm/basicalgorithms.h	/^	removenotused(const tinygrammar& gin, tinygrammar& gout)$/;"	f	class:removenotused	access:public	signature:(const tinygrammar& gin, tinygrammar& gout)
removenotused	galgorithm/basicalgorithms.h	/^class removenotused : public grammar_algorithm$/;"	c	inherits:grammar_algorithm
removenotused::gin_	galgorithm/basicalgorithms.h	/^	const tinygrammar* gin_;$/;"	m	class:removenotused	access:private
removenotused::gout_	galgorithm/basicalgorithms.h	/^	tinygrammar* gout_;$/;"	m	class:removenotused	access:private
removenotused::invoke	galgorithm/basicalgorithms.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:removenotused	access:public	signature:()
removenotused::new_grammar	galgorithm/basicalgorithms.cpp	/^void removenotused::new_grammar(const tinygrammar& tig, tinygrammar& tog)$/;"	f	class:removenotused	signature:(const tinygrammar& tig, tinygrammar& tog)
removenotused::new_grammar	galgorithm/basicalgorithms.h	/^	void new_grammar(const tinygrammar& gin, tinygrammar& gout); \/\/ create new grammmar$/;"	p	class:removenotused	access:private	signature:(const tinygrammar& gin, tinygrammar& gout)
removenotused::operator ()	galgorithm/basicalgorithms.cpp	/^void removenotused::operator()(const tinygrammar& tig, tinygrammar& tog)$/;"	f	class:removenotused	signature:(const tinygrammar& tig, tinygrammar& tog)
removenotused::operator ()	galgorithm/basicalgorithms.h	/^	void operator()(const tinygrammar& gin, tinygrammar& gout);$/;"	p	class:removenotused	access:private	signature:(const tinygrammar& gin, tinygrammar& gout)
removenotused::removenotused	galgorithm/basicalgorithms.h	/^	removenotused(const tinygrammar& gin, tinygrammar& gout)$/;"	f	class:removenotused	access:public	signature:(const tinygrammar& gin, tinygrammar& gout)
removenotused::rm_Snofm	galgorithm/basicalgorithms.cpp	/^void removenotused::rm_Snofm(const tinygrammar& tig)$/;"	f	class:removenotused	signature:(const tinygrammar& tig)
removenotused::rm_Snofm	galgorithm/basicalgorithms.h	/^	void rm_Snofm(const tinygrammar& tig);\/\/ remove symbols and productions can't start from StartSymbol$/;"	p	class:removenotused	access:private	signature:(const tinygrammar& tig)
removenotused::rm_notoT	galgorithm/basicalgorithms.cpp	/^void removenotused::rm_notoT(const tinygrammar& tig)$/;"	f	class:removenotused	signature:(const tinygrammar& tig)
removenotused::rm_notoT	galgorithm/basicalgorithms.h	/^	void rm_notoT(const tinygrammar& tig);\/\/ remove symbols and productions can't to be a terminate symbol$/;"	p	class:removenotused	access:private	signature:(const tinygrammar& tig)
removenotused::usedp	galgorithm/basicalgorithms.h	/^	vecint usedp;$/;"	m	class:removenotused	access:private
removenotused::useds	galgorithm/basicalgorithms.h	/^	vecint useds;$/;"	m	class:removenotused	access:private
removenotused::vecint	galgorithm/basicalgorithms.h	/^	typedef kog::smart_vector<int32> vecint;$/;"	t	class:removenotused	access:private
removesingle	galgorithm/basicalgorithms.h	/^	removesingle(const tinygrammar& gin, tinygrammar& gout)$/;"	f	class:removesingle	access:public	signature:(const tinygrammar& gin, tinygrammar& gout)
removesingle	galgorithm/basicalgorithms.h	/^class removesingle : public grammar_algorithm$/;"	c	inherits:grammar_algorithm
removesingle::gin_	galgorithm/basicalgorithms.h	/^	const tinygrammar* gin_;$/;"	m	class:removesingle	access:private
removesingle::gout_	galgorithm/basicalgorithms.h	/^	tinygrammar* gout_;$/;"	m	class:removesingle	access:private
removesingle::invoke	galgorithm/basicalgorithms.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:removesingle	access:public	signature:()
removesingle::operator ()	galgorithm/basicalgorithms.cpp	/^void removesingle::operator()(const tinygrammar& tig, tinygrammar& tog)$/;"	f	class:removesingle	signature:(const tinygrammar& tig, tinygrammar& tog)
removesingle::operator ()	galgorithm/basicalgorithms.h	/^	void operator()(const tinygrammar& gin, tinygrammar& gout);$/;"	p	class:removesingle	access:private	signature:(const tinygrammar& gin, tinygrammar& gout)
removesingle::remove_duplicate	galgorithm/basicalgorithms.cpp	/^void removesingle::remove_duplicate(std::list<production>& plist)$/;"	f	class:removesingle	signature:(std::list<production>& plist)
removesingle::remove_duplicate	galgorithm/basicalgorithms.h	/^	void remove_duplicate(std::list<production>& plist);$/;"	p	class:removesingle	access:private	signature:(std::list<production>& plist)
removesingle::removesingle	galgorithm/basicalgorithms.h	/^	removesingle(const tinygrammar& gin, tinygrammar& gout)$/;"	f	class:removesingle	access:public	signature:(const tinygrammar& gin, tinygrammar& gout)
rend	include/arrayX.h	/^	const_reverse_iterator rend() const { return const_reverse_iterator(begin()); }$/;"	f	class:smart_vector	access:public	signature:() const
rend	include/arrayX.h	/^	const_reverse_iterator rend() const { return const_reverse_iterator(begin()); }$/;"	f	struct:SmartArray	access:public	signature:() const
rend	include/arrayX.h	/^	reverse_iterator rend() { return reverse_iterator(begin()); }$/;"	f	class:smart_vector	access:public	signature:()
rend	include/arrayX.h	/^	reverse_iterator rend() { return reverse_iterator(begin()); }$/;"	f	struct:SmartArray	access:public	signature:()
replace	include/stringX.h	/^	_Myt& replace(size_type _Off,$/;"	f	class:xstring_basic	access:public	signature:(size_type _Off, size_type _N0, const _Mybase& _Right, size_type _Roff, size_type _Count)
replace_all	third_party/regex/xregex.cpp	/^xregex::tstring xregex::replace_all(const tstring& regex_str, $/;"	f	class:stringX::xregex	signature:(const tstring& regex_str, const tstring& replace_str, const tstring& org_str)
replace_all	third_party/regex/xregex.h	/^	static tstring replace_all(const tstring& regex_str, $/;"	p	class:stringX::xregex	access:public	signature:(const tstring& regex_str, const tstring& replace_str, const tstring& org_str)
replaceall	include/stringXF.h	/^std::basic_string<_Elem> replaceall(const std::basic_string<_Elem>& str, const std::basic_string<_Elem>& oldString, const std::basic_string<_Elem>& newString)$/;"	f	signature:(const std::basic_string<_Elem>& str, const std::basic_string<_Elem>& oldString, const std::basic_string<_Elem>& newString)
replacefirst	include/stringXF.h	/^std::basic_string<_Elem> replacefirst(const std::basic_string<_Elem>& str, const std::basic_string<_Elem>& oldString, const std::basic_string<_Elem>& newString, size_t pos = 0)$/;"	f	signature:(const std::basic_string<_Elem>& str, const std::basic_string<_Elem>& oldString, const std::basic_string<_Elem>& newString, size_t pos = 0)
reset	include/arrayX.h	/^	smart_vector& reset(size_type _N)$/;"	f	class:smart_vector	access:public	signature:(size_type _N)
reset_log_file	include/logger.h	/^	void reset_log_file(const std::string& log_file)$/;"	f	class:logger	access:public	signature:(const std::string& log_file)
reset_log_ostream	include/logger.h	/^	void reset_log_ostream(std::ostream& os)$/;"	f	class:logger	access:public	signature:(std::ostream& os)
reset_right	syntax/production.cpp	/^void production::reset_right(const int32* Rs, int N)$/;"	f	class:production	signature:(const int32* Rs, int N)
reset_right	syntax/production.h	/^	void reset_right(const int32* Rs, int N);$/;"	p	class:production	access:public	signature:(const int32* Rs, int N)
reset_root	include/tree.h	/^	void reset_root(link r)$/;"	f	class:tree	access:protected	signature:(link r)
result_type	include/functionalX.h	/^	typedef _Result result_type;$/;"	t	struct:triple_function	access:public
result_type	include/functionalX.h	/^	typedef typename _Fy::result_type result_type;$/;"	t	struct:composite_function_t	access:public
result_type	include/functionalX.h	/^	typedef typename _Fz::result_type result_type;$/;"	t	struct:composite_function2_t	access:public
result_type	include/functionalX.h	/^	typedef typename _Oper::result_type result_type;$/;"	t	class:apply	access:public
return_type	compiler/type.h	/^    const type* return_type;$/;"	m	struct:function_type	access:public
reverse_iterator	include/arrayX.h	/^	typedef std::reverse_iterator<iterator> reverse_iterator;$/;"	t	class:smart_vector	access:public
reverse_iterator	include/arrayX.h	/^	typedef std::reverse_iterator<iterator> reverse_iterator;$/;"	t	struct:SmartArray	access:public
reverse_iterator	include/arrayX.h	/^	typedef std::reverse_iterator<iterator> reverse_iterator;$/;"	t	struct:SmartMatrix	access:public
reverse_iterator	include/memoryX.h	/^	typedef std::reverse_iterator<iterator> reverse_iterator;$/;"	t	struct:memblock	access:public
right_array	syntax/production.h	/^	typedef kog::smart_vector<int32> right_array;$/;"	t	class:production	access:public
rm_Snofm	galgorithm/basicalgorithms.cpp	/^void removenotused::rm_Snofm(const tinygrammar& tig)$/;"	f	class:removenotused	signature:(const tinygrammar& tig)
rm_Snofm	galgorithm/basicalgorithms.h	/^	void rm_Snofm(const tinygrammar& tig);\/\/ remove symbols and productions can't start from StartSymbol$/;"	p	class:removenotused	access:private	signature:(const tinygrammar& tig)
rm_notoT	galgorithm/basicalgorithms.cpp	/^void removenotused::rm_notoT(const tinygrammar& tig)$/;"	f	class:removenotused	signature:(const tinygrammar& tig)
rm_notoT	galgorithm/basicalgorithms.h	/^	void rm_notoT(const tinygrammar& tig);\/\/ remove symbols and productions can't to be a terminate symbol$/;"	p	class:removenotused	access:private	signature:(const tinygrammar& tig)
rmeplison	galgorithm/basicalgorithms.cpp	/^void eliminate_eplison::rmeplison(const tinygrammar& tig, tinygrammar& tog)$/;"	f	class:eliminate_eplison	signature:(const tinygrammar& tig, tinygrammar& tog)
rmeplison	galgorithm/basicalgorithms.h	/^	void rmeplison(const tinygrammar& tig, tinygrammar& gout);$/;"	p	class:eliminate_eplison	access:private	signature:(const tinygrammar& tig, tinygrammar& gout)
root	include/tree.h	/^	const_link root() const { return root_; }$/;"	f	class:tree	access:public	signature:() const
root	include/tree.h	/^	link root() { return root_; }$/;"	f	class:tree	access:public	signature:()
root_	include/tree.h	/^	link root_;$/;"	m	class:tree	access:private
round	include/mathX.h	/^	static _Result round(const _Arg value)$/;"	f	class:math	access:public	signature:(const _Arg value)
row	include/arrayX.h	/^	size_t row() const { return _Row; }$/;"	f	struct:SmartMatrix	access:public	signature:() const
run	test/unittest.cpp	/^void unittest::run()$/;"	f	class:unittest	signature:()
run	test/unittest.cpp	/^void unittest::run(const std::string& outfolder)$/;"	f	class:unittest	signature:(const std::string& outfolder)
run	test/unittest.h	/^	void run();$/;"	p	class:unittest	access:public	signature:()
run	test/unittest.h	/^	void run(const std::string& outfolder);$/;"	p	class:unittest	access:public	signature:(const std::string& outfolder)
run_all_unittest	test/unittest.cpp	/^	int run_all_unittest(int argc, const char* argv[])$/;"	f	class:unittest_list	access:public	signature:(int argc, const char* argv[])
run_test	test/basicalgorithmtest.cpp	/^	\/* overwrite *\/ virtual void run_test()$/;"	f	class:basicalg_test	file:	access:private	signature:()
run_test	test/firstfollowtest.cpp	/^	\/* overwrite *\/ virtual void run_test()$/;"	f	class:firstfollow_test	file:	access:private	signature:()
run_test	test/lrmachinetest.cpp	/^	\/* overwrite *\/ virtual void run_test()$/;"	f	class:lrmachine_test	file:	access:private	signature:()
run_test	test/nfa2dfatest.cpp	/^	\/* overwrite *\/ virtual void run_test()$/;"	f	class:nfa2dfa_test	file:	access:private	signature:()
run_test	test/pascaltest.cpp	/^	\/* overwrite *\/ virtual void run_test()$/;"	f	class:pascal_test	file:	access:private	signature:()
run_test	test/regexnfatest.cpp	/^	\/* overwrite *\/ virtual void run_test()$/;"	f	class:regex2nfa_test	file:	access:private	signature:()
run_test	test/splitwords.cpp	/^	\/* overwrite *\/ virtual void run_test()$/;"	f	class:splitwords_test	access:public	signature:()
run_test	test/tinygrammar-compiler.cpp	/^	\/* overwrite *\/ virtual void run_test()$/;"	f	class:tinyg_compiler_test	access:public	signature:()
run_test	test/tinygrammartest.cpp	/^	\/* overwrite *\/ virtual void run_test()$/;"	f	class:simplegrammar_test	access:public	signature:()
run_test	test/unittest.h	/^	virtual void run_test() = 0;$/;"	p	class:unittest	access:private	signature:()
runtime	asmgenerate.h	/^NAMESPACE_BEGIN(runtime);$/;"	v
runtime	asmgenerate.h	/^NAMESPACE_END(runtime);$/;"	v
runtime	compiler/module.h	/^NAMESPACE_END(runtime);$/;"	v
s	galgorithm/regex2nfa.cpp	/^		std::string s;$/;"	m	struct:parsecontent::sym	file:	access:public
s	galgorithm/regex2nfa.cpp	/^	const char* s;$/;"	m	struct:parsecontent	file:	access:public
s	tmp/back/regex2nfa.cpp	/^		std::string s;$/;"	m	struct:parsecontent::sym	file:	access:public
s	tmp/back/regex2nfa.cpp	/^	const char* s;$/;"	m	struct:parsecontent	file:	access:public
safe_delete	include/functionalX.h	/^inline void safe_delete(Ptr_Type& ptr)$/;"	f	signature:(Ptr_Type& ptr)
safe_delete_vec	include/functionalX.h	/^inline void safe_delete_vec(Ptr_Type& ptr)$/;"	f	signature:(Ptr_Type& ptr)
scerror	include/scerror.h	/^	scerror()$/;"	f	class:scerror	access:public	signature:()
scerror	include/scerror.h	/^	scerror(const tstring& err)$/;"	f	class:scerror	access:public	signature:(const tstring& err)
scerror	include/scerror.h	/^class scerror : public std::runtime_error$/;"	c	inherits:std::runtime_error
scerror::make_trace	include/scerror.h	/^	void make_trace()$/;"	f	class:scerror	access:private	signature:()
scerror::scerror	include/scerror.h	/^	scerror()$/;"	f	class:scerror	access:public	signature:()
scerror::scerror	include/scerror.h	/^	scerror(const tstring& err)$/;"	f	class:scerror	access:public	signature:(const tstring& err)
scerror::trace_	include/scerror.h	/^	kog::shared_ptr<kog::callstack::trace> trace_;$/;"	m	class:scerror	access:private
scerror::trace_message	include/scerror.h	/^	tstring trace_message() const$/;"	f	class:scerror	access:public	signature:() const
scerror::~scerror	include/scerror.h	/^	~scerror() throw()$/;"	f	class:scerror	access:public	signature:()
scope	compiler/scope.cpp	/^scope::scope()$/;"	f	class:scope	signature:()
scope	compiler/scope.cpp	/^scope::scope(scope* parent)$/;"	f	class:scope	signature:(scope* parent)
scope	compiler/scope.h	/^    scope();$/;"	p	class:scope	access:public	signature:()
scope	compiler/scope.h	/^    scope(scope* parent);$/;"	p	class:scope	access:public	signature:(scope* parent)
scope	compiler/scope.h	/^class scope : public datamodule, public codemodule$/;"	c	inherits:datamodule,codemodule
scope::MEMBER_VARIABLE_GET	compiler/scope.h	/^    MEMBER_VARIABLE_GET(scope*, parent, parent_);$/;"	p	class:scope	access:public	signature:(scope*, parent, parent_)
scope::entry_function	compiler/scope.cpp	/^variable* scope::entry_function(const _Str& fname, const type* result_type, int32 nparams, ...)$/;"	f	class:scope	signature:(const _Str& fname, const type* result_type, int32 nparams, ...)
scope::entry_function	compiler/scope.h	/^    variable* entry_function(const _Str& fname, const type* result_type, int32 nparams, ...);$/;"	p	class:scope	access:public	signature:(const _Str& fname, const type* result_type, int32 nparams, ...)
scope::entry_value	compiler/scope.cpp	/^variable* scope::entry_value(const _Str& content, const type* canTypes[], int _C)$/;"	f	class:scope	signature:(const _Str& content, const type* canTypes[], int _C)
scope::entry_value	compiler/scope.h	/^    variable* entry_value(const _Str& content, const type* canTypes[], int _N);$/;"	p	class:scope	access:public	signature:(const _Str& content, const type* canTypes[], int _N)
scope::entry_variable	compiler/scope.cpp	/^variable* scope::entry_variable(const _Str& vname, const type* vtype, int32 vscope)$/;"	f	class:scope	signature:(const _Str& vname, const type* vtype, int32 vscope)
scope::entry_variable	compiler/scope.h	/^    variable* entry_variable(const _Str& vname, const type* vtype, int32 vscope = varscope::stack);$/;"	p	class:scope	access:public	signature:(const _Str& vname, const type* vtype, int32 vscope = varscope::stack)
scope::find	compiler/scope.cpp	/^variable* scope::find(const _Str& name)$/;"	f	class:scope	signature:(const _Str& name)
scope::find	compiler/scope.h	/^	\/* overwrite *\/ virtual variable* find(const _Str& name);$/;"	p	class:scope	access:public	signature:(const _Str& name)
scope::noname_idx_	compiler/scope.h	/^    int32 noname_idx_;$/;"	m	class:scope	access:private
scope::parent_	compiler/scope.h	/^    scope* parent_;$/;"	m	class:scope	access:private
scope::scope	compiler/scope.cpp	/^scope::scope()$/;"	f	class:scope	signature:()
scope::scope	compiler/scope.cpp	/^scope::scope(scope* parent)$/;"	f	class:scope	signature:(scope* parent)
scope::scope	compiler/scope.h	/^    scope();$/;"	p	class:scope	access:public	signature:()
scope::scope	compiler/scope.h	/^    scope(scope* parent);$/;"	p	class:scope	access:public	signature:(scope* parent)
scope::staticdata_	compiler/scope.h	/^    kog::shared_ptr<datamodule> staticdata_;$/;"	m	class:scope	access:private
scope::usingList_	compiler/scope.h	/^    std::vector<scope*> usingList_;$/;"	m	class:scope	access:private
scope::~scope	compiler/scope.cpp	/^scope::~scope()$/;"	f	class:scope	signature:()
scope::~scope	compiler/scope.h	/^    ~scope();$/;"	p	class:scope	access:public	signature:()
scope_defines	compiler/scope.h	/^    enum scope_defines$/;"	g	namespace:varscope
second	include/functionalX.h	/^	_Ty2 second;	\/\/ the second stored value$/;"	m	struct:triple	access:public
second_argument_type	include/functionalX.h	/^	typedef _Arg2 second_argument_type;$/;"	t	struct:triple_function	access:public
second_argument_type	include/functionalX.h	/^	typedef typename _Fy::argument_type second_argument_type;$/;"	t	struct:composite_function2_t	access:public
second_type	include/functionalX.h	/^	typedef _Ty2 second_type;$/;"	t	struct:triple	access:public
self_	include/tree.h	/^		link self_;$/;"	m	struct:tree::_Const_iterator	access:protected
sep	syntax/grammar.h	/^		sep = 1, \/\/ seperators$/;"	e	enum:grammar::symtype
separators	compiler/compiler.h	/^	kog::smart_vector<sc::int32> separators;$/;"	m	class:compiler	access:private
separators	tmp/back/compiler.h	/^	kog::smart_vector<sc::int32> separators;$/;"	m	class:compiler	access:private
seperator0	test/output/gen.cpp	/^	seperator0()$/;"	f	struct:seperator0	access:public	signature:()
seperator0	test/output/gen.cpp	/^struct seperator0 : public type$/;"	s	file:	inherits:type
seperator0::seperator0	test/output/gen.cpp	/^	seperator0()$/;"	f	struct:seperator0	access:public	signature:()
seperator0::sid	test/output/gen.cpp	/^	enum{ sid = 1018 };$/;"	e	enum:seperator0::__anon112	file:
seperator1	test/output/gen.cpp	/^	seperator1()$/;"	f	struct:seperator1	access:public	signature:()
seperator1	test/output/gen.cpp	/^struct seperator1 : public type$/;"	s	file:	inherits:type
seperator10	test/output/gen.cpp	/^	seperator10()$/;"	f	struct:seperator10	access:public	signature:()
seperator10	test/output/gen.cpp	/^struct seperator10 : public type$/;"	s	file:	inherits:type
seperator10::seperator10	test/output/gen.cpp	/^	seperator10()$/;"	f	struct:seperator10	access:public	signature:()
seperator10::sid	test/output/gen.cpp	/^	enum{ sid = 1020 };$/;"	e	enum:seperator10::__anon114	file:
seperator1::seperator1	test/output/gen.cpp	/^	seperator1()$/;"	f	struct:seperator1	access:public	signature:()
seperator1::sid	test/output/gen.cpp	/^	enum{ sid = 1019 };$/;"	e	enum:seperator1::__anon113	file:
seperator2	test/output/gen.cpp	/^	seperator2()$/;"	f	struct:seperator2	access:public	signature:()
seperator2	test/output/gen.cpp	/^struct seperator2 : public type$/;"	s	file:	inherits:type
seperator2::seperator2	test/output/gen.cpp	/^	seperator2()$/;"	f	struct:seperator2	access:public	signature:()
seperator2::sid	test/output/gen.cpp	/^	enum{ sid = 1021 };$/;"	e	enum:seperator2::__anon115	file:
seperator3	test/output/gen.cpp	/^	seperator3()$/;"	f	struct:seperator3	access:public	signature:()
seperator3	test/output/gen.cpp	/^struct seperator3 : public type$/;"	s	file:	inherits:type
seperator3::seperator3	test/output/gen.cpp	/^	seperator3()$/;"	f	struct:seperator3	access:public	signature:()
seperator3::sid	test/output/gen.cpp	/^	enum{ sid = 1022 };$/;"	e	enum:seperator3::__anon116	file:
seperator4	test/output/gen.cpp	/^	seperator4()$/;"	f	struct:seperator4	access:public	signature:()
seperator4	test/output/gen.cpp	/^struct seperator4 : public type$/;"	s	file:	inherits:type
seperator4::seperator4	test/output/gen.cpp	/^	seperator4()$/;"	f	struct:seperator4	access:public	signature:()
seperator4::sid	test/output/gen.cpp	/^	enum{ sid = 1023 };$/;"	e	enum:seperator4::__anon117	file:
seperator5	test/output/gen.cpp	/^	seperator5()$/;"	f	struct:seperator5	access:public	signature:()
seperator5	test/output/gen.cpp	/^struct seperator5 : public type$/;"	s	file:	inherits:type
seperator5::seperator5	test/output/gen.cpp	/^	seperator5()$/;"	f	struct:seperator5	access:public	signature:()
seperator5::sid	test/output/gen.cpp	/^	enum{ sid = 1024 };$/;"	e	enum:seperator5::__anon118	file:
seperator6	test/output/gen.cpp	/^	seperator6()$/;"	f	struct:seperator6	access:public	signature:()
seperator6	test/output/gen.cpp	/^struct seperator6 : public type$/;"	s	file:	inherits:type
seperator6::seperator6	test/output/gen.cpp	/^	seperator6()$/;"	f	struct:seperator6	access:public	signature:()
seperator6::sid	test/output/gen.cpp	/^	enum{ sid = 1025 };$/;"	e	enum:seperator6::__anon119	file:
seperator7	test/output/gen.cpp	/^	seperator7()$/;"	f	struct:seperator7	access:public	signature:()
seperator7	test/output/gen.cpp	/^struct seperator7 : public type$/;"	s	file:	inherits:type
seperator7::seperator7	test/output/gen.cpp	/^	seperator7()$/;"	f	struct:seperator7	access:public	signature:()
seperator7::sid	test/output/gen.cpp	/^	enum{ sid = 1026 };$/;"	e	enum:seperator7::__anon120	file:
seperator8	test/output/gen.cpp	/^	seperator8()$/;"	f	struct:seperator8	access:public	signature:()
seperator8	test/output/gen.cpp	/^struct seperator8 : public type$/;"	s	file:	inherits:type
seperator8::seperator8	test/output/gen.cpp	/^	seperator8()$/;"	f	struct:seperator8	access:public	signature:()
seperator8::sid	test/output/gen.cpp	/^	enum{ sid = 1027 };$/;"	e	enum:seperator8::__anon121	file:
seperator9	test/output/gen.cpp	/^	seperator9()$/;"	f	struct:seperator9	access:public	signature:()
seperator9	test/output/gen.cpp	/^struct seperator9 : public type$/;"	s	file:	inherits:type
seperator9::seperator9	test/output/gen.cpp	/^	seperator9()$/;"	f	struct:seperator9	access:public	signature:()
seperator9::sid	test/output/gen.cpp	/^	enum{ sid = 1028 };$/;"	e	enum:seperator9::__anon122	file:
seperators_	syntax/grammar.h	/^	tstring seperators_;	\/\/ seperators: split word$/;"	m	class:grammar	access:protected
sepsid	compiler/compiler.h	/^	kog::tree<sc::int32> sepsid;$/;"	m	class:compiler	access:private
set_grammar_production	galgorithm/regex2nfa.cpp	/^void set_grammar_production(tinygrammar::vecprods& productions, parsecontent& pc, int gending)$/;"	f	signature:(tinygrammar::vecprods& productions, parsecontent& pc, int gending)
set_grammar_production	tmp/back/regex2nfa.cpp	/^void set_grammar_production(tinygrammar::vecprods& productions, parsecontent& pc)$/;"	f	signature:(tinygrammar::vecprods& productions, parsecontent& pc)
set_grammar_symbol	galgorithm/regex2nfa.cpp	/^void set_grammar_symbol(symholder& sholder, parsecontent& pc)$/;"	f	signature:(symholder& sholder, parsecontent& pc)
set_grammar_symbol	tmp/back/regex2nfa.cpp	/^void set_grammar_symbol(symholder& sholder, parsecontent& pc)$/;"	f	signature:(symholder& sholder, parsecontent& pc)
setautoloadfile	syntax/global_values.h	/^	static std::string& setautoloadfile(const std::string& file)$/;"	f	class:global_values	access:public	signature:(const std::string& file)
sets_	galgorithm/firstfollow.h	/^	vecintset* sets_;$/;"	m	class:firstset	access:private
sfollowset	galgorithm/lranalyse.cpp	/^typedef kog::sortc<std::vector<int32>, std::less<int32> > sfollowset;$/;"	t	file:
shared_ptr	include/shared_ptr.h	/^		explicit shared_ptr(const weak_ptr<T>& w) : ptr(w.ptr), count(w.count) { incref(); }$/;"	f	class:shared_ptr	access:public	signature:(const weak_ptr<T>& w)
shared_ptr	include/shared_ptr.h	/^		shared_ptr() : ptr(0), count(nil()) { incref(); }$/;"	f	class:shared_ptr	access:public	signature:()
shared_ptr	include/shared_ptr.h	/^		shared_ptr(T* p) : ptr(p), count(new unsigned(1)) {}$/;"	f	class:shared_ptr	access:public	signature:(T* p)
shared_ptr	include/shared_ptr.h	/^		shared_ptr(const shared_ptr<T>& o) : ptr(o.ptr), count(o.count) { incref(); }$/;"	f	class:shared_ptr	access:public	signature:(const shared_ptr<T>& o)
shared_ptr	include/shared_ptr.h	/^class shared_ptr {$/;"	c
shared_ptr::count	include/shared_ptr.h	/^		unsigned* count; \/\/$/;"	m	class:shared_ptr	access:private
shared_ptr::decref	include/shared_ptr.h	/^		void decref() { if (--(*count) == 0) { delete ptr; delete count; }} $/;"	f	class:shared_ptr	access:private	signature:()
shared_ptr::get	include/shared_ptr.h	/^		T* get() { return ptr; }$/;"	f	class:shared_ptr	access:public	signature:()
shared_ptr::get	include/shared_ptr.h	/^		const T* get() const { return ptr; }$/;"	f	class:shared_ptr	access:public	signature:() const
shared_ptr::incref	include/shared_ptr.h	/^		void incref() { ++(*count); }$/;"	f	class:shared_ptr	access:private	signature:()
shared_ptr::nil	include/shared_ptr.h	/^		static unsigned* nil() { static unsigned nil_counter(1); return &nil_counter; }$/;"	f	class:shared_ptr	access:private	signature:()
shared_ptr::operator !=	include/shared_ptr.h	/^		bool operator!=(const shared_ptr<T>& o) const { return ptr != o.ptr; }$/;"	f	class:shared_ptr	access:public	signature:(const shared_ptr<T>& o) const
shared_ptr::operator *	include/shared_ptr.h	/^		T& operator*()  { return *ptr; }$/;"	f	class:shared_ptr	access:public	signature:()
shared_ptr::operator *	include/shared_ptr.h	/^		const T& operator*() const { return *ptr; }$/;"	f	class:shared_ptr	access:public	signature:() const
shared_ptr::operator ->	include/shared_ptr.h	/^		T* operator->() { return ptr; }$/;"	f	class:shared_ptr	access:public	signature:()
shared_ptr::operator ->	include/shared_ptr.h	/^		const T* operator->() const { return ptr; }$/;"	f	class:shared_ptr	access:public	signature:() const
shared_ptr::operator <	include/shared_ptr.h	/^		bool operator<(const shared_ptr<T>& o) const { return ptr < o.ptr; }	$/;"	f	class:shared_ptr	access:public	signature:(const shared_ptr<T>& o) const
shared_ptr::operator =	include/shared_ptr.h	/^		shared_ptr<T>& operator=(const shared_ptr<T>& o) {$/;"	f	class:shared_ptr	access:public	signature:(const shared_ptr<T>& o)
shared_ptr::operator ==	include/shared_ptr.h	/^		bool operator==(const shared_ptr<T>& o) const { return ptr == o.ptr; }$/;"	f	class:shared_ptr	access:public	signature:(const shared_ptr<T>& o) const
shared_ptr::ptr	include/shared_ptr.h	/^		T* ptr;$/;"	m	class:shared_ptr	access:private
shared_ptr::refcount	include/shared_ptr.h	/^		unsigned refcount() const { return *count; }$/;"	f	class:shared_ptr	access:public	signature:() const
shared_ptr::shared_ptr	include/shared_ptr.h	/^		explicit shared_ptr(const weak_ptr<T>& w) : ptr(w.ptr), count(w.count) { incref(); }$/;"	f	class:shared_ptr	access:public	signature:(const weak_ptr<T>& w)
shared_ptr::shared_ptr	include/shared_ptr.h	/^		shared_ptr() : ptr(0), count(nil()) { incref(); }$/;"	f	class:shared_ptr	access:public	signature:()
shared_ptr::shared_ptr	include/shared_ptr.h	/^		shared_ptr(T* p) : ptr(p), count(new unsigned(1)) {}$/;"	f	class:shared_ptr	access:public	signature:(T* p)
shared_ptr::shared_ptr	include/shared_ptr.h	/^		shared_ptr(const shared_ptr<T>& o) : ptr(o.ptr), count(o.count) { incref(); }$/;"	f	class:shared_ptr	access:public	signature:(const shared_ptr<T>& o)
shared_ptr::swap	include/shared_ptr.h	/^		void swap(shared_ptr<T>& other) throw ()$/;"	f	class:shared_ptr	access:public	signature:(shared_ptr<T>& other)
shared_ptr::~shared_ptr	include/shared_ptr.h	/^		~shared_ptr() { decref(); }$/;"	f	class:shared_ptr	access:public	signature:()
shared_sheet	syntax/automachine.h	/^	typedef kog::shared_ptr<sparsesheet> shared_sheet;$/;"	t	class:automachine	access:public
sheet_	syntax/automachine.h	/^	shared_sheet sheet_;$/;"	m	class:automachine	access:private
sheetrow	syntax/automachine.h	/^		sheetrow()$/;"	f	class:automachine::sheetrow	access:public	signature:()
sheetrow	syntax/automachine.h	/^		sheetrow(int32 etype, int32 ise, void* morei)$/;"	f	class:automachine::sheetrow	access:public	signature:(int32 etype, int32 ise, void* morei)
sheetrow	syntax/automachine.h	/^	class sheetrow : public kog::smart_vector<gotoitem>$/;"	c	class:automachine	inherits:kog::smart_vector	access:public
sid	compiler/compiler.h	/^	int32 sid;$/;"	m	struct:machine	access:public
sid	galgorithm/regex2nfa.cpp	/^		int sid;$/;"	m	struct:parsecontent::sym	file:	access:public
sid	syntax/automachine.h	/^		int32 sid;$/;"	m	struct:automachine::machine_meta	access:public
sid	syntax/symbol.h	/^	int32 sid; \/\/ symbol id: used to index symbol$/;"	m	struct:symbol	access:public
sid	test/output/gen.cpp	/^	enum{ sid = 1001 };$/;"	e	enum:AExpression::__anon98	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1002 };$/;"	e	enum:AProgramItem::__anon99	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1003 };$/;"	e	enum:AValue::__anon100	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1004 };$/;"	e	enum:Expression::__anon101	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1005 };$/;"	e	enum:FuncCall::__anon102	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1006 };$/;"	e	enum:Function::__anon103	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1007 };$/;"	e	enum:FunctionContent::__anon104	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1008 };$/;"	e	enum:Print::__anon105	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1009 };$/;"	e	enum:Program::__anon106	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1010 };$/;"	e	enum:ReturnExp::__anon107	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1011 };$/;"	e	enum:ValueDeclear::__anon108	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1014 };$/;"	e	enum:number::__anon109	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1015 };$/;"	e	enum:op::__anon110	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1016 };$/;"	e	enum:print::__anon111	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1018 };$/;"	e	enum:seperator0::__anon112	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1019 };$/;"	e	enum:seperator1::__anon113	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1020 };$/;"	e	enum:seperator10::__anon114	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1021 };$/;"	e	enum:seperator2::__anon115	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1022 };$/;"	e	enum:seperator3::__anon116	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1023 };$/;"	e	enum:seperator4::__anon117	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1024 };$/;"	e	enum:seperator5::__anon118	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1025 };$/;"	e	enum:seperator6::__anon119	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1026 };$/;"	e	enum:seperator7::__anon120	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1027 };$/;"	e	enum:seperator8::__anon121	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1028 };$/;"	e	enum:seperator9::__anon122	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1029 };$/;"	e	enum:symbol::__anon123	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1030 };$/;"	e	enum:valuetype::__anon124	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 0 };$/;"	e	enum:Program::__anon5	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 1 };$/;"	e	enum:AProgramItem::__anon6	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 10 };$/;"	e	enum:FuncCall::__anon15	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 11 };$/;"	e	enum:Op::__anon16	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 12 };$/;"	e	enum:PrintFunc::__anon17	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 13 };$/;"	e	enum:print::__anon18	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 14 };$/;"	e	enum:FunctionContent::__anon19	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 15 };$/;"	e	enum:ReturnExp::__anon20	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 16 };$/;"	e	enum:NoName0::__anon21	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 17 };$/;"	e	enum:NoName1::__anon22	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 18 };$/;"	e	enum:NoName2::__anon23	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 19 };$/;"	e	enum:Assignment::__anon24	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 2 };$/;"	e	enum:ValueDeclear::__anon7	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 20 };$/;"	e	enum:NoName3::__anon25	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 21 };$/;"	e	enum:NoName4::__anon26	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 22 };$/;"	e	enum:NoName5::__anon27	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 23 };$/;"	e	enum:NoName6::__anon28	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 24 };$/;"	e	enum:NoName7::__anon29	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 25 };$/;"	e	enum:NoName8::__anon30	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 26 };$/;"	e	enum:NoName9::__anon31	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 27 };$/;"	e	enum:NoName10::__anon32	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 28 };$/;"	e	enum:NoName11::__anon33	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 29 };$/;"	e	enum:NoName12::__anon34	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 3 };$/;"	e	enum:Function::__anon8	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 30 };$/;"	e	enum:NoName13::__anon35	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 4 };$/;"	e	enum:Expressions::__anon9	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 5 };$/;"	e	enum:Valuetype::__anon10	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 6 };$/;"	e	enum:symbol::__anon11	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 7 };$/;"	e	enum:AExpression::__anon12	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 8 };$/;"	e	enum:AValue::__anon13	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 9 };$/;"	e	enum:number::__anon14	file:
sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 0 };$/;"	e	enum:Program::__anon36	file:
sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 1 };$/;"	e	enum:AProgramItem::__anon37	file:
sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 10 };$/;"	e	enum:FuncCall::__anon46	file:
sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 11 };$/;"	e	enum:Op::__anon47	file:
sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 12 };$/;"	e	enum:PrintFunc::__anon48	file:
sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 13 };$/;"	e	enum:print::__anon49	file:
sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 14 };$/;"	e	enum:FunctionContent::__anon50	file:
sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 15 };$/;"	e	enum:ReturnExp::__anon51	file:
sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 16 };$/;"	e	enum:NoName0::__anon52	file:
sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 17 };$/;"	e	enum:NoName1::__anon53	file:
sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 18 };$/;"	e	enum:NoName2::__anon54	file:
sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 19 };$/;"	e	enum:Assignment::__anon55	file:
sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 2 };$/;"	e	enum:ValueDeclear::__anon38	file:
sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 20 };$/;"	e	enum:NoName3::__anon56	file:
sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 21 };$/;"	e	enum:NoName4::__anon57	file:
sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 22 };$/;"	e	enum:NoName5::__anon58	file:
sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 23 };$/;"	e	enum:NoName6::__anon59	file:
sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 24 };$/;"	e	enum:NoName7::__anon60	file:
sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 25 };$/;"	e	enum:NoName8::__anon61	file:
sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 26 };$/;"	e	enum:NoName9::__anon62	file:
sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 27 };$/;"	e	enum:NoName10::__anon63	file:
sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 28 };$/;"	e	enum:NoName11::__anon64	file:
sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 29 };$/;"	e	enum:NoName12::__anon65	file:
sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 3 };$/;"	e	enum:Function::__anon39	file:
sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 30 };$/;"	e	enum:NoName13::__anon66	file:
sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 4 };$/;"	e	enum:Expressions::__anon40	file:
sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 5 };$/;"	e	enum:Valuetype::__anon41	file:
sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 6 };$/;"	e	enum:symbol::__anon42	file:
sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 7 };$/;"	e	enum:AExpression::__anon43	file:
sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 8 };$/;"	e	enum:AValue::__anon44	file:
sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 9 };$/;"	e	enum:number::__anon45	file:
sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 0 };$/;"	e	enum:Program::__anon67	file:
sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 1 };$/;"	e	enum:AProgramItem::__anon68	file:
sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 10 };$/;"	e	enum:FuncCall::__anon77	file:
sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 11 };$/;"	e	enum:Op::__anon78	file:
sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 12 };$/;"	e	enum:PrintFunc::__anon79	file:
sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 13 };$/;"	e	enum:print::__anon80	file:
sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 14 };$/;"	e	enum:FunctionContent::__anon81	file:
sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 15 };$/;"	e	enum:ReturnExp::__anon82	file:
sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 16 };$/;"	e	enum:NoName0::__anon83	file:
sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 17 };$/;"	e	enum:NoName1::__anon84	file:
sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 18 };$/;"	e	enum:NoName2::__anon85	file:
sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 2 };$/;"	e	enum:ValueDeclear::__anon69	file:
sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 20 };$/;"	e	enum:Assignment::__anon86	file:
sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 21 };$/;"	e	enum:NoName3::__anon87	file:
sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 22 };$/;"	e	enum:NoName4::__anon88	file:
sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 23 };$/;"	e	enum:NoName5::__anon89	file:
sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 24 };$/;"	e	enum:NoName6::__anon90	file:
sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 25 };$/;"	e	enum:NoName7::__anon91	file:
sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 26 };$/;"	e	enum:NoName8::__anon92	file:
sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 27 };$/;"	e	enum:NoName9::__anon93	file:
sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 28 };$/;"	e	enum:NoName10::__anon94	file:
sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 29 };$/;"	e	enum:NoName11::__anon95	file:
sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 3 };$/;"	e	enum:Function::__anon70	file:
sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 30 };$/;"	e	enum:NoName12::__anon96	file:
sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 31 };$/;"	e	enum:NoName13::__anon97	file:
sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 4 };$/;"	e	enum:Expressions::__anon71	file:
sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 5 };$/;"	e	enum:Valuetype::__anon72	file:
sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 6 };$/;"	e	enum:symbol::__anon73	file:
sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 7 };$/;"	e	enum:AExpression::__anon74	file:
sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 8 };$/;"	e	enum:AValue::__anon75	file:
sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 9 };$/;"	e	enum:number::__anon76	file:
sid	tmp/back/regex2nfa.cpp	/^		int sid;$/;"	m	struct:parsecontent::sym	file:	access:public
simple_grammar	test/tinygrammartest.cpp	/^	void simple_grammar();$/;"	p	class:grammar_wrapper	file:	access:public	signature:()
simple_grammar	test/tinygrammartest.cpp	/^void grammar_wrapper::simple_grammar()$/;"	f	class:grammar_wrapper	signature:()
simplegrammar	galgorithm/basicalgorithms.h	/^	simplegrammar(const tinygrammar& gin, tinygrammar& gout)$/;"	f	class:simplegrammar	access:public	signature:(const tinygrammar& gin, tinygrammar& gout)
simplegrammar	galgorithm/basicalgorithms.h	/^class simplegrammar : public grammar_algorithm$/;"	c	inherits:grammar_algorithm
simplegrammar::gin_	galgorithm/basicalgorithms.h	/^	const tinygrammar* gin_;$/;"	m	class:simplegrammar	access:private
simplegrammar::gout_	galgorithm/basicalgorithms.h	/^	tinygrammar* gout_;$/;"	m	class:simplegrammar	access:private
simplegrammar::invoke	galgorithm/basicalgorithms.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:simplegrammar	access:public	signature:()
simplegrammar::operator ()	galgorithm/basicalgorithms.cpp	/^void simplegrammar::operator()(const tinygrammar& gin, tinygrammar& tog)$/;"	f	class:simplegrammar	signature:(const tinygrammar& gin, tinygrammar& tog)
simplegrammar::operator ()	galgorithm/basicalgorithms.h	/^	void operator()(const tinygrammar& gin, tinygrammar& gout);$/;"	p	class:simplegrammar	access:private	signature:(const tinygrammar& gin, tinygrammar& gout)
simplegrammar::simplegrammar	galgorithm/basicalgorithms.h	/^	simplegrammar(const tinygrammar& gin, tinygrammar& gout)$/;"	f	class:simplegrammar	access:public	signature:(const tinygrammar& gin, tinygrammar& gout)
simplegrammar_test	test/tinygrammartest.cpp	/^NEW_UNITTEST(simplegrammar_test);$/;"	v
simplegrammar_test	test/tinygrammartest.cpp	/^class simplegrammar_test : public unittest$/;"	c	file:	inherits:unittest
simplegrammar_test::cppfile	test/tinygrammartest.cpp	/^	std::string cppfile;$/;"	m	class:simplegrammar_test	file:	access:private
simplegrammar_test::init	test/tinygrammartest.cpp	/^	\/* overwrite *\/ virtual void init(int argc, const char* argv[])$/;"	f	class:simplegrammar_test	access:public	signature:(int argc, const char* argv[])
simplegrammar_test::init_grammar	test/tinygrammartest.cpp	/^	void init_grammar(grammar& g);$/;"	p	class:simplegrammar_test	file:	access:private	signature:(grammar& g)
simplegrammar_test::init_grammar	test/tinygrammartest.cpp	/^void simplegrammar_test::init_grammar(grammar& g)$/;"	f	class:simplegrammar_test	signature:(grammar& g)
simplegrammar_test::run_test	test/tinygrammartest.cpp	/^	\/* overwrite *\/ virtual void run_test()$/;"	f	class:simplegrammar_test	access:public	signature:()
singleton	include/singleton.h	/^	singleton(){}$/;"	f	class:singleton	access:protected	signature:()
singleton	include/singleton.h	/^	singleton(const singleton_type& other);$/;"	p	class:singleton	access:private	signature:(const singleton_type& other)
singleton	include/singleton.h	/^class singleton$/;"	c
singleton::instance	include/singleton.h	/^	static value_type& instance()$/;"	f	class:singleton	access:public	signature:()
singleton::operator =	include/singleton.h	/^	singleton_type& operator=(const singleton_type& other);$/;"	p	class:singleton	access:private	signature:(const singleton_type& other)
singleton::singleton	include/singleton.h	/^	singleton(){}$/;"	f	class:singleton	access:protected	signature:()
singleton::singleton	include/singleton.h	/^	singleton(const singleton_type& other);$/;"	p	class:singleton	access:private	signature:(const singleton_type& other)
singleton::singleton_type	include/singleton.h	/^	typedef singleton<_T> singleton_type;$/;"	t	class:singleton	access:public
singleton::value_type	include/singleton.h	/^	typedef _T value_type;$/;"	t	class:singleton	access:public
singleton::~singleton	include/singleton.h	/^	virtual ~singleton(){} \/\/ make sure correct deconstruct$/;"	f	class:singleton	access:protected	signature:()
singleton_type	include/singleton.h	/^	typedef singleton<_T> singleton_type;$/;"	t	class:singleton	access:public
size	compiler/value.h	/^    uint32 size;$/;"	m	struct:value	access:public
size	include/arrayX.h	/^	size_t size() const {return Length; }$/;"	f	struct:SmartMatrix	access:public	signature:() const
size	include/arrayX.h	/^	size_t size() const {return _Length;}$/;"	f	struct:SmartArray	access:public	signature:() const
size	include/arrayX.h	/^	size_t size() const {return buf_.count;}$/;"	f	class:smart_vector	access:public	signature:() const
size	include/sortc.h	/^	size_t size() const { return c_.size(); }	$/;"	f	class:sortc	access:public	signature:() const
size_in_bytes	include/arrayX.h	/^	size_t size_in_bytes() const {return size() * sizeof(_Tx); }$/;"	f	class:smart_vector	access:public	signature:() const
size_type	include/arrayX.h	/^	typedef std::size_t size_type;$/;"	t	class:smart_vector	access:public
size_type	include/arrayX.h	/^	typedef std::size_t size_type;$/;"	t	struct:SmartArray	access:public
size_type	include/arrayX.h	/^	typedef std::size_t size_type;$/;"	t	struct:SmartMatrix	access:public
size_type	include/memoryX.h	/^	typedef std::size_t size_type;$/;"	t	struct:memblock	access:public
size_type	include/stringX.h	/^	typedef typename _Mybase::size_type size_type;$/;"	t	class:xstring_basic	access:public
smac	syntax/grammar.h	/^		smac = 3,	\/\/ symbol match state machine$/;"	e	enum:grammar::symtype
smacs	test/tinygrammartest.cpp	/^std::deque<std::pair<tstring, int32> > Asymbol::smacs;$/;"	m	class:Asymbol	file:
smacs	test/vhelp.h	/^	static std::deque<std::pair<tstring, int32> > smacs;$/;"	m	class:Asymbol	access:public
smacs_	syntax/grammar.h	/^	vecsmacs smacs_; \/\/ state machines$/;"	m	class:grammar	access:protected
smart_matrix	include/arrayX.h	/^class smart_matrix$/;"	c
smart_vector	include/arrayX.h	/^	smart_vector()$/;"	f	class:smart_vector	access:public	signature:()
smart_vector	include/arrayX.h	/^	smart_vector(_InIt _First, _InIt _Last)$/;"	f	class:smart_vector	access:public	signature:(_InIt _First, _InIt _Last)
smart_vector	include/arrayX.h	/^	smart_vector(const smart_vector& _Other)$/;"	f	class:smart_vector	access:public	signature:(const smart_vector& _Other)
smart_vector	include/arrayX.h	/^	smart_vector(const_pointer _Buf, std::size_t _N)$/;"	f	class:smart_vector	access:public	signature:(const_pointer _Buf, std::size_t _N)
smart_vector	include/arrayX.h	/^	smart_vector(pointer _Buf, std::size_t _N)$/;"	f	class:smart_vector	access:public	signature:(pointer _Buf, std::size_t _N)
smart_vector	include/arrayX.h	/^	smart_vector(size_type _N)$/;"	f	class:smart_vector	access:public	signature:(size_type _N)
smart_vector	include/arrayX.h	/^	smart_vector(size_type _N, const_reference _Val)$/;"	f	class:smart_vector	access:public	signature:(size_type _N, const_reference _Val)
smart_vector	include/arrayX.h	/^class smart_vector$/;"	c
smart_vector::_Myt	include/arrayX.h	/^	typedef smart_vector<_Tx> _Myt;$/;"	t	class:smart_vector	access:public
smart_vector::assert_validate	include/arrayX.h	/^	void assert_validate() const$/;"	f	class:smart_vector	access:protected	signature:() const
smart_vector::at	include/arrayX.h	/^	const_reference at(size_type idx) const$/;"	f	class:smart_vector	access:public	signature:(size_type idx) const
smart_vector::at	include/arrayX.h	/^	reference at(size_type idx)$/;"	f	class:smart_vector	access:public	signature:(size_type idx)
smart_vector::attach	include/arrayX.h	/^	smart_vector& attach(pointer _Ptr, size_type _N, bool _AutoDelete = true)$/;"	f	class:smart_vector	access:public	signature:(pointer _Ptr, size_type _N, bool _AutoDelete = true)
smart_vector::back	include/arrayX.h	/^	const_reference back() const$/;"	f	class:smart_vector	access:public	signature:() const
smart_vector::back	include/arrayX.h	/^	reference back()$/;"	f	class:smart_vector	access:public	signature:()
smart_vector::begin	include/arrayX.h	/^	const_iterator begin() const { return const_iterator(buf_.values, buf_.count); }$/;"	f	class:smart_vector	access:public	signature:() const
smart_vector::begin	include/arrayX.h	/^	iterator begin() { return iterator(buf_.values, buf_.count); }$/;"	f	class:smart_vector	access:public	signature:()
smart_vector::block	include/arrayX.h	/^	struct block$/;"	s	class:smart_vector	access:protected
smart_vector::block::block	include/arrayX.h	/^		block(pointer ptr = NULL, size_type c = 0, bool d = true)$/;"	f	struct:smart_vector::block	access:public	signature:(pointer ptr = NULL, size_type c = 0, bool d = true)
smart_vector::block::count	include/arrayX.h	/^		size_t count;$/;"	m	struct:smart_vector::block	access:public
smart_vector::block::is_auto_delete	include/arrayX.h	/^		bool is_auto_delete;$/;"	m	struct:smart_vector::block	access:public
smart_vector::block::swap	include/arrayX.h	/^		void swap(block& _Other) throw()$/;"	f	struct:smart_vector::block	access:public	signature:(block& _Other)
smart_vector::block::values	include/arrayX.h	/^		pointer values;$/;"	m	struct:smart_vector::block	access:public
smart_vector::block::~block	include/arrayX.h	/^		~block()$/;"	f	struct:smart_vector::block	access:public	signature:()
smart_vector::buf_	include/arrayX.h	/^	block buf_;$/;"	m	class:smart_vector	access:private
smart_vector::const_iterator	include/arrayX.h	/^	typedef array_iterator<const value_type> const_iterator;$/;"	t	class:smart_vector	access:public
smart_vector::const_pointer	include/arrayX.h	/^	typedef const value_type* const_pointer;$/;"	t	class:smart_vector	access:public
smart_vector::const_reference	include/arrayX.h	/^	typedef const value_type& const_reference;$/;"	t	class:smart_vector	access:public
smart_vector::const_reverse_iterator	include/arrayX.h	/^	typedef std::reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:smart_vector	access:public
smart_vector::detach	include/arrayX.h	/^	smart_vector& detach()$/;"	f	class:smart_vector	access:public	signature:()
smart_vector::end	include/arrayX.h	/^	const_iterator end() const { return const_iterator(buf_.values + buf_.count, buf_.count, 0); }$/;"	f	class:smart_vector	access:public	signature:() const
smart_vector::end	include/arrayX.h	/^	iterator end() { return iterator(buf_.values + buf_.count, buf_.count, 0); }$/;"	f	class:smart_vector	access:public	signature:()
smart_vector::front	include/arrayX.h	/^	const_reference front() const$/;"	f	class:smart_vector	access:public	signature:() const
smart_vector::front	include/arrayX.h	/^	reference front()$/;"	f	class:smart_vector	access:public	signature:()
smart_vector::get	include/arrayX.h	/^	const_pointer get() const { return buf_.values; }$/;"	f	class:smart_vector	access:public	signature:() const
smart_vector::get	include/arrayX.h	/^	pointer get() { return buf_.values; }$/;"	f	class:smart_vector	access:public	signature:()
smart_vector::iterator	include/arrayX.h	/^	typedef array_iterator<value_type> iterator;$/;"	t	class:smart_vector	access:public
smart_vector::operator =	include/arrayX.h	/^	_Myt& operator=(const _Myt& _Other)$/;"	f	class:smart_vector	access:public	signature:(const _Myt& _Other)
smart_vector::operator =	include/arrayX.h	/^	_Myt& operator=(const _Tx& _val)$/;"	f	class:smart_vector	access:public	signature:(const _Tx& _val)
smart_vector::operator []	include/arrayX.h	/^	const_reference operator[](size_type idx) const { return buf_.values[idx]; }$/;"	f	class:smart_vector	access:public	signature:(size_type idx) const
smart_vector::operator []	include/arrayX.h	/^	reference operator[](size_type idx) { return buf_.values[idx]; }$/;"	f	class:smart_vector	access:public	signature:(size_type idx)
smart_vector::pointer	include/arrayX.h	/^	typedef value_type* pointer;$/;"	t	class:smart_vector	access:public
smart_vector::rbegin	include/arrayX.h	/^	const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); }$/;"	f	class:smart_vector	access:public	signature:() const
smart_vector::rbegin	include/arrayX.h	/^	reverse_iterator rbegin() { return reverse_iterator(end()); }$/;"	f	class:smart_vector	access:public	signature:()
smart_vector::reference	include/arrayX.h	/^	typedef value_type& reference;$/;"	t	class:smart_vector	access:public
smart_vector::release	include/arrayX.h	/^	pointer release()$/;"	f	class:smart_vector	access:public	signature:()
smart_vector::rend	include/arrayX.h	/^	const_reverse_iterator rend() const { return const_reverse_iterator(begin()); }$/;"	f	class:smart_vector	access:public	signature:() const
smart_vector::rend	include/arrayX.h	/^	reverse_iterator rend() { return reverse_iterator(begin()); }$/;"	f	class:smart_vector	access:public	signature:()
smart_vector::reset	include/arrayX.h	/^	smart_vector& reset(size_type _N)$/;"	f	class:smart_vector	access:public	signature:(size_type _N)
smart_vector::reverse_iterator	include/arrayX.h	/^	typedef std::reverse_iterator<iterator> reverse_iterator;$/;"	t	class:smart_vector	access:public
smart_vector::size	include/arrayX.h	/^	size_t size() const {return buf_.count;}$/;"	f	class:smart_vector	access:public	signature:() const
smart_vector::size_in_bytes	include/arrayX.h	/^	size_t size_in_bytes() const {return size() * sizeof(_Tx); }$/;"	f	class:smart_vector	access:public	signature:() const
smart_vector::size_type	include/arrayX.h	/^	typedef std::size_t size_type;$/;"	t	class:smart_vector	access:public
smart_vector::smart_vector	include/arrayX.h	/^	smart_vector()$/;"	f	class:smart_vector	access:public	signature:()
smart_vector::smart_vector	include/arrayX.h	/^	smart_vector(_InIt _First, _InIt _Last)$/;"	f	class:smart_vector	access:public	signature:(_InIt _First, _InIt _Last)
smart_vector::smart_vector	include/arrayX.h	/^	smart_vector(const smart_vector& _Other)$/;"	f	class:smart_vector	access:public	signature:(const smart_vector& _Other)
smart_vector::smart_vector	include/arrayX.h	/^	smart_vector(const_pointer _Buf, std::size_t _N)$/;"	f	class:smart_vector	access:public	signature:(const_pointer _Buf, std::size_t _N)
smart_vector::smart_vector	include/arrayX.h	/^	smart_vector(pointer _Buf, std::size_t _N)$/;"	f	class:smart_vector	access:public	signature:(pointer _Buf, std::size_t _N)
smart_vector::smart_vector	include/arrayX.h	/^	smart_vector(size_type _N)$/;"	f	class:smart_vector	access:public	signature:(size_type _N)
smart_vector::smart_vector	include/arrayX.h	/^	smart_vector(size_type _N, const_reference _Val)$/;"	f	class:smart_vector	access:public	signature:(size_type _N, const_reference _Val)
smart_vector::swap	include/arrayX.h	/^	void swap(_Myt& _Other)$/;"	f	class:smart_vector	access:public	signature:(_Myt& _Other)
smart_vector::value_type	include/arrayX.h	/^	typedef _Tx value_type;$/;"	t	class:smart_vector	access:public
sorp	galgorithm/lranalyse.cpp	/^	int32 sorp; \/\/ 0: s, 1: p$/;"	m	struct:nextstate	file:	access:public
sortc	include/sortc.h	/^	sortc()$/;"	f	class:sortc	access:public	signature:()
sortc	include/sortc.h	/^	sortc(_Iter _First, _Iter _Last)$/;"	f	class:sortc	access:public	signature:(_Iter _First, _Iter _Last)
sortc	include/sortc.h	/^	sortc(const sortc<_C, _Pred>& _Other)$/;"	f	class:sortc	access:public	signature:(const sortc<_C, _Pred>& _Other)
sortc	include/sortc.h	/^class sortc$/;"	c
sortc::begin	include/sortc.h	/^	const_iterator begin() const { return c_.begin(); }$/;"	f	class:sortc	access:public	signature:() const
sortc::begin	include/sortc.h	/^	iterator begin() { return c_.begin(); }$/;"	f	class:sortc	access:public	signature:()
sortc::c_	include/sortc.h	/^	_C c_;$/;"	m	class:sortc	access:protected
sortc::const_iterator	include/sortc.h	/^	typedef typename _C::const_iterator const_iterator;$/;"	t	class:sortc	access:public
sortc::empty	include/sortc.h	/^	bool empty() const { return c_.empty(); }$/;"	f	class:sortc	access:public	signature:() const
sortc::end	include/sortc.h	/^	const_iterator end() const { return c_.end(); }$/;"	f	class:sortc	access:public	signature:() const
sortc::end	include/sortc.h	/^	iterator end() { return c_.end(); }$/;"	f	class:sortc	access:public	signature:()
sortc::erase	include/sortc.h	/^	iterator erase(iterator _First, iterator _Last)$/;"	f	class:sortc	access:public	signature:(iterator _First, iterator _Last)
sortc::erase	include/sortc.h	/^	iterator erase(iterator ei)$/;"	f	class:sortc	access:public	signature:(iterator ei)
sortc::exist	include/sortc.h	/^	bool exist(const value_type& v) const$/;"	f	class:sortc	access:public	signature:(const value_type& v) const
sortc::find	include/sortc.h	/^	const_iterator find(const value_type& v) const$/;"	f	class:sortc	access:public	signature:(const value_type& v) const
sortc::find	include/sortc.h	/^	iterator find(const value_type& v)$/;"	f	class:sortc	access:public	signature:(const value_type& v)
sortc::insert	include/sortc.h	/^	void insert(_Iter _First, _Iter _Last)$/;"	f	class:sortc	access:public	signature:(_Iter _First, _Iter _Last)
sortc::insert	include/sortc.h	/^	void insert(const value_type& v)$/;"	f	class:sortc	access:public	signature:(const value_type& v)
sortc::iterator	include/sortc.h	/^	typedef typename _C::iterator iterator;$/;"	t	class:sortc	access:public
sortc::lower_bound	include/sortc.h	/^	const_iterator lower_bound(const value_type& v) const$/;"	f	class:sortc	access:public	signature:(const value_type& v) const
sortc::lower_bound	include/sortc.h	/^	iterator lower_bound(const value_type& v)$/;"	f	class:sortc	access:public	signature:(const value_type& v)
sortc::size	include/sortc.h	/^	size_t size() const { return c_.size(); }	$/;"	f	class:sortc	access:public	signature:() const
sortc::sortc	include/sortc.h	/^	sortc()$/;"	f	class:sortc	access:public	signature:()
sortc::sortc	include/sortc.h	/^	sortc(_Iter _First, _Iter _Last)$/;"	f	class:sortc	access:public	signature:(_Iter _First, _Iter _Last)
sortc::sortc	include/sortc.h	/^	sortc(const sortc<_C, _Pred>& _Other)$/;"	f	class:sortc	access:public	signature:(const sortc<_C, _Pred>& _Other)
sortc::swap	include/sortc.h	/^	void swap(sortc<_C, _Pred>& _Other)$/;"	f	class:sortc	access:public	signature:(sortc<_C, _Pred>& _Other)
sortc::update	include/sortc.h	/^	void update()$/;"	f	class:sortc	access:protected	signature:()
sortc::upper_bound	include/sortc.h	/^	const_iterator upper_bound(const value_type& v) const$/;"	f	class:sortc	access:public	signature:(const value_type& v) const
sortc::upper_bound	include/sortc.h	/^	iterator upper_bound(const value_type& v)$/;"	f	class:sortc	access:public	signature:(const value_type& v)
sortc::value_type	include/sortc.h	/^	typedef typename _C::value_type value_type;$/;"	t	class:sortc	access:public
sotfile_	test/firstfollowtest.cpp	/^	std::string sotfile_;$/;"	m	class:firstfollow_test	file:	access:private
space_	include/stringXF.h	/^    const std::basic_string<_Elem> space_;$/;"	m	struct:string_split_t	access:private
sparsesheet	galgorithm/lranalyse.cpp	/^	std::list<kog::triple<const lrstate*, int32, nextstate> > sparsesheet;$/;"	m	struct:AlgorithmArg	file:	access:public
sparsesheet	syntax/automachine.h	/^	typedef kog::smart_vector<sheetrow> sparsesheet;$/;"	t	class:automachine	access:public
special	syntax/automachine.h	/^		enum { anychar, special, exclude };$/;"	e	enum:automachine::sheetrow::__anon127
split	galgorithm/nfa2dfa.cpp	/^void nfa2dfa::split(const std::vector<const production*>& t, kog::smart_vector<int32>& smap, std::deque<std::set<int32> >& s) const$/;"	f	class:nfa2dfa	signature:(const std::vector<const production*>& t, kog::smart_vector<int32>& smap, std::deque<std::set<int32> >& s) const
split	galgorithm/nfa2dfa.h	/^	void split(const std::vector<const production*>& t, kog::smart_vector<int32>& smap, std::deque<std::set<int32> >& s) const;$/;"	p	class:nfa2dfa	access:private	signature:(const std::vector<const production*>& t, kog::smart_vector<int32>& smap, std::deque<std::set<int32> >& s) const
split	include/stringXF.h	/^std::vector<std::basic_string<_Elem> > split(const std::basic_string<_Elem>& str, const std::basic_string<_Elem>& space, bool is_remove_empty = false)$/;"	f	signature:(const std::basic_string<_Elem>& str, const std::basic_string<_Elem>& space, bool is_remove_empty = false)
split_separators	compiler/compiler.cpp	/^	split_separators(const tchar* w)$/;"	f	struct:split_separators	access:public	signature:(const tchar* w)
split_separators	compiler/compiler.cpp	/^struct split_separators$/;"	s	file:
split_separators::aword	compiler/compiler.cpp	/^	const tchar* aword;$/;"	m	struct:split_separators	file:	access:public
split_separators::buf	compiler/compiler.cpp	/^	tstring buf;$/;"	m	struct:split_separators	file:	access:public
split_separators::get	compiler/compiler.cpp	/^	int32 get() const$/;"	f	struct:split_separators	access:public	signature:() const
split_separators::next	compiler/compiler.cpp	/^	int32 next()$/;"	f	struct:split_separators	access:public	signature:()
split_separators::split_separators	compiler/compiler.cpp	/^	split_separators(const tchar* w)$/;"	f	struct:split_separators	access:public	signature:(const tchar* w)
split_separators::x	compiler/compiler.cpp	/^	int32 x;$/;"	m	struct:split_separators	file:	access:public
splitwords_test	test/splitwords.cpp	/^NEW_UNITTEST(splitwords_test);$/;"	v
splitwords_test	test/splitwords.cpp	/^class splitwords_test : public sc::unittest$/;"	c	file:	inherits:sc::unittest
splitwords_test::init	test/splitwords.cpp	/^	\/* overwrite *\/ virtual void init(int argc, const char* argv[])$/;"	f	class:splitwords_test	access:public	signature:(int argc, const char* argv[])
splitwords_test::input	test/splitwords.cpp	/^	std::string input;$/;"	m	class:splitwords_test	file:	access:private
splitwords_test::otput	test/splitwords.cpp	/^	std::string otput;$/;"	m	class:splitwords_test	file:	access:private
splitwords_test::run_test	test/splitwords.cpp	/^	\/* overwrite *\/ virtual void run_test()$/;"	f	class:splitwords_test	access:public	signature:()
sqrt	include/mathX.h	/^	static T sqrt(const T value)$/;"	f	class:math	access:public	signature:(const T value)
square	include/mathX.h	/^	static T square(const T value)$/;"	f	class:math	access:public	signature:(const T value)
src1	compiler/tuple.h	/^    variable* src1;$/;"	m	struct:four_tuple	access:public
src2	compiler/tuple.h	/^    variable* src2;$/;"	m	struct:four_tuple	access:public
sstate_	syntax/automachine.h	/^	int sstate_; \/\/ start state$/;"	m	class:automachine	access:protected
stack	compiler/scope.h	/^        stack,$/;"	e	enum:varscope::scope_defines
stack_	third_party/callstack/stacktrace.h	/^		dbsoft::callstack::callstack_ptr stack_;$/;"	m	class:kog::callstack::trace	access:private
stack_	third_party/callstack/stacktrace.h	/^		std::vector<frame> stack_;$/;"	m	class:kog::callstack::trace	access:private
stacktrace	third_party/callstack/linux2/debug_tool.hpp	/^	struct stacktrace$/;"	s	namespace:kog
stacktrace::frames	third_party/callstack/linux2/debug_tool.cpp	/^void stacktrace::frames(std::vector<std::string>& trace)$/;"	f	class:stacktrace	signature:(std::vector<std::string>& trace)
start_symbol_	syntax/grammar.h	/^	int32 start_symbol_; \/\/ start symbol sid$/;"	m	class:tinygrammar	access:protected
state	syntax/lrmachine.h	/^		int32 state;$/;"	m	struct:lrmachine::lrmeta	access:public
state_machine	compiler/compiler.h	/^	typedef compile::state_machine state_machine;$/;"	t	class:compiler	access:public
state_machine	compiler/interlanguage.h	/^	typedef compile::state_machine state_machine;$/;"	t	class:interlanguage	access:public
state_machine	syntax/statemachine.cpp	/^state_machine::state_machine()$/;"	f	class:state_machine	signature:()
state_machine	syntax/statemachine.cpp	/^state_machine::state_machine(const shared_sheet& asheet)$/;"	f	class:state_machine	signature:(const shared_sheet& asheet)
state_machine	syntax/statemachine.h	/^	state_machine();$/;"	p	class:state_machine	access:public	signature:()
state_machine	syntax/statemachine.h	/^	state_machine(const shared_sheet& asheet);$/;"	p	class:state_machine	access:public	signature:(const shared_sheet& asheet)
state_machine	syntax/statemachine.h	/^class state_machine : public automachine$/;"	c	inherits:automachine
state_machine	tmp/back/compiler.h	/^	typedef compile::state_machine state_machine;$/;"	t	class:compiler	access:public
state_machine::MEMBER_VARIABLE_GET_SET	syntax/statemachine.h	/^	MEMBER_VARIABLE_GET_SET(tstring, str, str_);$/;"	p	class:state_machine	access:public	signature:(tstring, str, str_)
state_machine::eta	syntax/statemachine.cpp	/^bool state_machine::eta(machine_meta* meta)$/;"	f	class:state_machine	signature:(machine_meta* meta)
state_machine::eta	syntax/statemachine.h	/^	\/* overwrite *\/ virtual bool eta(machine_meta* meta);$/;"	p	class:state_machine	access:public	signature:(machine_meta* meta)
state_machine::init	syntax/statemachine.cpp	/^void state_machine::init()$/;"	f	class:state_machine	signature:()
state_machine::init	syntax/statemachine.h	/^	\/* overwrite *\/ virtual void init();$/;"	p	class:state_machine	access:public	signature:()
state_machine::state_machine	syntax/statemachine.cpp	/^state_machine::state_machine()$/;"	f	class:state_machine	signature:()
state_machine::state_machine	syntax/statemachine.cpp	/^state_machine::state_machine(const shared_sheet& asheet)$/;"	f	class:state_machine	signature:(const shared_sheet& asheet)
state_machine::state_machine	syntax/statemachine.h	/^	state_machine();$/;"	p	class:state_machine	access:public	signature:()
state_machine::state_machine	syntax/statemachine.h	/^	state_machine(const shared_sheet& asheet);$/;"	p	class:state_machine	access:public	signature:(const shared_sheet& asheet)
state_machine::str_	syntax/statemachine.h	/^	tstring str_;$/;"	m	class:state_machine	access:private
state_machine::swap	syntax/statemachine.h	/^	void swap(state_machine& other)$/;"	f	class:state_machine	access:public	signature:(state_machine& other)
state_machine::~state_machine	syntax/statemachine.cpp	/^state_machine::~state_machine()$/;"	f	class:state_machine	signature:()
state_machine::~state_machine	syntax/statemachine.h	/^	virtual ~state_machine();$/;"	p	class:state_machine	access:public	signature:()
staticdata_	compiler/scope.h	/^    kog::shared_ptr<datamodule> staticdata_;$/;"	m	class:scope	access:private
strMeta	third_party/xml/Markup.cpp	/^	MCD_STR strMeta;$/;"	m	struct:NodePos	file:	access:public
strName	third_party/xml/Markup.cpp	/^	MCD_STR strName;$/;"	m	struct:SavedPos	file:	access:public
strTagName	third_party/xml/Markup.cpp	/^	MCD_STR strTagName;$/;"	m	struct:TagPos	file:	access:public
str_	syntax/statemachine.h	/^	tstring str_;$/;"	m	class:state_machine	access:private
streamsplit	compiler/extract.cpp	/^compile::doc::streamsplit::streamsplit()$/;"	f	class:compile::doc::streamsplit	signature:()
streamsplit	compiler/extract.h	/^	streamsplit();$/;"	p	class:streamsplit	access:public	signature:()
streamsplit	compiler/extract.h	/^class streamsplit$/;"	c
streamsplit::MEMBER_VARIABLE_GET	compiler/extract.h	/^	MEMBER_VARIABLE_GET(const deqwords&, words, words_);$/;"	p	class:streamsplit	access:public	signature:(const deqwords&, words, words_)
streamsplit::deqwords	compiler/extract.h	/^	typedef std::deque<word> deqwords;$/;"	t	class:streamsplit	access:public
streamsplit::operator ()	compiler/extract.cpp	/^streamsplit::deqwords& streamsplit::operator()(std::istream& is)$/;"	f	class:streamsplit	signature:(std::istream& is)
streamsplit::operator ()	compiler/extract.h	/^	deqwords& operator()(std::istream& is);$/;"	p	class:streamsplit	access:public	signature:(std::istream& is)
streamsplit::streamsplit	compiler/extract.h	/^	streamsplit();$/;"	p	class:streamsplit	access:public	signature:()
streamsplit::words_	compiler/extract.h	/^	deqwords words_;$/;"	m	class:streamsplit	access:private
streamsplit::~streamsplit	compiler/extract.h	/^	virtual ~streamsplit();$/;"	p	class:streamsplit	access:public	signature:()
strformat	include/stringXF.h	/^class strformat$/;"	c
strformat::format	include/stringXF.h	/^	static std::string format(const char* fmt, ...)$/;"	f	class:strformat	access:public	signature:(const char* fmt, ...)
strformat::format	include/stringXF.h	/^	static std::string& format(const char* fmt, va_list argptr, std::string& out_buf)$/;"	f	class:strformat	access:public	signature:(const char* fmt, va_list argptr, std::string& out_buf)
strformat::format	include/stringXF.h	/^	static std::wstring format(const wchar_t* fmt, ...)$/;"	f	class:strformat	access:public	signature:(const wchar_t* fmt, ...)
strformat::format	include/stringXF.h	/^	static std::wstring& format(const wchar_t* fmt, va_list argptr, std::wstring& out_buf)$/;"	f	class:strformat	access:public	signature:(const wchar_t* fmt, va_list argptr, std::wstring& out_buf)
stringBuf	test/tinygrammartest.cpp	/^std::deque<tchar> Asymbol::stringBuf;$/;"	m	class:Asymbol	file:
stringBuf	test/vhelp.h	/^	static std::deque<tchar> stringBuf;$/;"	m	class:Asymbol	access:public
stringX	third_party/regex/xregex.cpp	/^namespace stringX{$/;"	n	file:
stringX	third_party/regex/xregex.h	/^namespace stringX{$/;"	n
stringX::convert_error	third_party/regex/xregex.h	/^class convert_error : public std::runtime_error$/;"	c	namespace:stringX	inherits:std::runtime_error
stringX::convert_error::convert_error	third_party/regex/xregex.h	/^	convert_error(const _Tx& _Src, const _Ty& _Dst)$/;"	f	class:stringX::convert_error	access:public	signature:(const _Tx& _Src, const _Ty& _Dst)
stringX::convert_error::convert_error	third_party/regex/xregex.h	/^	convert_error(const std::string& error_msg)$/;"	f	class:stringX::convert_error	access:public	signature:(const std::string& error_msg)
stringX::convert_error::new_error_msg	third_party/regex/xregex.h	/^	static std::string new_error_msg(const _Tx& _Src, const _Ty& _Dst)$/;"	f	class:stringX::convert_error	access:private	signature:(const _Tx& _Src, const _Ty& _Dst)
stringX::is_match	third_party/regex/xregex.cpp	/^bool is_match(const boost::regex& regex, const xregex::tstring& content)$/;"	f	namespace:stringX	signature:(const boost::regex& regex, const xregex::tstring& content)
stringX::xregex	third_party/regex/xregex.h	/^class xregex$/;"	c	namespace:stringX
stringX::xregex::char_type	third_party/regex/xregex.h	/^	typedef char char_type;$/;"	t	class:stringX::xregex	access:public
stringX::xregex::is_id	third_party/regex/xregex.cpp	/^bool xregex::is_id(const tstring& str)$/;"	f	class:stringX::xregex	signature:(const tstring& str)
stringX::xregex::is_id	third_party/regex/xregex.h	/^	static bool is_id(const tstring& str);$/;"	p	class:stringX::xregex	access:public	signature:(const tstring& str)
stringX::xregex::is_interge	third_party/regex/xregex.cpp	/^bool xregex::is_interge(const tstring& str)$/;"	f	class:stringX::xregex	signature:(const tstring& str)
stringX::xregex::is_interge	third_party/regex/xregex.h	/^	static bool is_interge(const tstring& str);$/;"	p	class:stringX::xregex	access:public	signature:(const tstring& str)
stringX::xregex::is_match	third_party/regex/xregex.cpp	/^bool xregex::is_match(const tstring& regex_str, const tstring& content)$/;"	f	class:stringX::xregex	signature:(const tstring& regex_str, const tstring& content)
stringX::xregex::is_match	third_party/regex/xregex.h	/^	static bool is_match(const tstring& regex_str, const tstring& content);$/;"	p	class:stringX::xregex	access:public	signature:(const tstring& regex_str, const tstring& content)
stringX::xregex::replace_all	third_party/regex/xregex.cpp	/^xregex::tstring xregex::replace_all(const tstring& regex_str, $/;"	f	class:stringX::xregex	signature:(const tstring& regex_str, const tstring& replace_str, const tstring& org_str)
stringX::xregex::replace_all	third_party/regex/xregex.h	/^	static tstring replace_all(const tstring& regex_str, $/;"	p	class:stringX::xregex	access:public	signature:(const tstring& regex_str, const tstring& replace_str, const tstring& org_str)
stringX::xregex::tstring	third_party/regex/xregex.h	/^	typedef std::basic_string<char_type> tstring;$/;"	t	class:stringX::xregex	access:public
stringX::xregex::xregex	third_party/regex/xregex.cpp	/^xregex::xregex(void)$/;"	f	class:stringX::xregex	signature:(void)
stringX::xregex::xregex	third_party/regex/xregex.h	/^	xregex(void);$/;"	p	class:stringX::xregex	access:public	signature:(void)
stringX::xregex::~xregex	third_party/regex/xregex.cpp	/^xregex::~xregex(void)$/;"	f	class:stringX::xregex	signature:(void)
stringX::xregex::~xregex	third_party/regex/xregex.h	/^	~xregex(void);$/;"	p	class:stringX::xregex	access:public	signature:(void)
string_2_int	compiler/compiler.h	/^struct string_2_int$/;"	s
string_2_int::max_int	compiler/compiler.h	/^	enum { max_int = 100 };$/;"	e	enum:string_2_int::__anon132
string_2_int::operator ()	compiler/compiler.h	/^	compile::int32 operator()(const std::string& s) const$/;"	f	struct:string_2_int	access:public	signature:(const std::string& s) const
string_split_t	include/stringXF.h	/^    string_split_t(const std::basic_string<_Elem>& str, const std::basic_string<_Elem>& space, bool is_remove_empty = true)$/;"	f	struct:string_split_t	access:public	signature:(const std::basic_string<_Elem>& str, const std::basic_string<_Elem>& space, bool is_remove_empty = true)
string_split_t	include/stringXF.h	/^struct string_split_t$/;"	s
string_split_t::_Const_iterator	include/stringXF.h	/^    struct _Const_iterator$/;"	s	struct:string_split_t	access:public
string_split_t::_Const_iterator::_Const_iterator	include/stringXF.h	/^        _Const_iterator(const _Const_iterator& other)$/;"	f	struct:string_split_t::_Const_iterator	access:public	signature:(const _Const_iterator& other)
string_split_t::_Const_iterator::_Const_iterator	include/stringXF.h	/^        _Const_iterator(string_split_t<_Elem>* ref, size_t posB)$/;"	f	struct:string_split_t::_Const_iterator	access:public	signature:(string_split_t<_Elem>* ref, size_t posB)
string_split_t::_Const_iterator::_Const_iterator	include/stringXF.h	/^        _Const_iterator(string_split_t<_Elem>* ref, size_t posB, size_t posE)$/;"	f	struct:string_split_t::_Const_iterator	access:public	signature:(string_split_t<_Elem>* ref, size_t posB, size_t posE)
string_split_t::_Const_iterator::_next	include/stringXF.h	/^        size_t _next(size_t posb)$/;"	f	struct:string_split_t::_Const_iterator	access:private	signature:(size_t posb)
string_split_t::_Const_iterator::operator !=	include/stringXF.h	/^        friend bool operator!= (const _Const_iterator& iter1, const _Const_iterator& iter2)$/;"	f	struct:string_split_t::_Const_iterator	access:friend	signature:(const _Const_iterator& iter1, const _Const_iterator& iter2)
string_split_t::_Const_iterator::operator *	include/stringXF.h	/^        std::basic_string<_Elem> operator*()$/;"	f	struct:string_split_t::_Const_iterator	access:public	signature:()
string_split_t::_Const_iterator::operator ++	include/stringXF.h	/^        _Const_iterator operator++(int)$/;"	f	struct:string_split_t::_Const_iterator	access:public	signature:(int)
string_split_t::_Const_iterator::operator ++	include/stringXF.h	/^        _Const_iterator& operator++()$/;"	f	struct:string_split_t::_Const_iterator	access:public	signature:()
string_split_t::_Const_iterator::operator ==	include/stringXF.h	/^        friend bool operator== (const _Const_iterator& iter1, const _Const_iterator& iter2)$/;"	f	struct:string_split_t::_Const_iterator	access:friend	signature:(const _Const_iterator& iter1, const _Const_iterator& iter2)
string_split_t::_Const_iterator::posB_	include/stringXF.h	/^        size_t posB_;$/;"	m	struct:string_split_t::_Const_iterator	access:private
string_split_t::_Const_iterator::posE_	include/stringXF.h	/^        size_t posE_;$/;"	m	struct:string_split_t::_Const_iterator	access:private
string_split_t::_Const_iterator::ref_	include/stringXF.h	/^        string_split_t<_Elem>* ref_;$/;"	m	struct:string_split_t::_Const_iterator	access:private
string_split_t::begin	include/stringXF.h	/^    const_iterator begin()$/;"	f	struct:string_split_t	access:public	signature:()
string_split_t::const_iterator	include/stringXF.h	/^    typedef _Const_iterator const_iterator;$/;"	t	struct:string_split_t	access:public
string_split_t::end	include/stringXF.h	/^    const_iterator end()$/;"	f	struct:string_split_t	access:public	signature:()
string_split_t::isre_	include/stringXF.h	/^    bool isre_;$/;"	m	struct:string_split_t	access:private
string_split_t::main_	include/stringXF.h	/^    const std::basic_string<_Elem> main_;$/;"	m	struct:string_split_t	access:private
string_split_t::space_	include/stringXF.h	/^    const std::basic_string<_Elem> space_;$/;"	m	struct:string_split_t	access:private
string_split_t::string_split_t	include/stringXF.h	/^    string_split_t(const std::basic_string<_Elem>& str, const std::basic_string<_Elem>& space, bool is_remove_empty = true)$/;"	f	struct:string_split_t	access:public	signature:(const std::basic_string<_Elem>& str, const std::basic_string<_Elem>& space, bool is_remove_empty = true)
stringbuffer	include/stringX.h	/^typedef basic_stringbuffer<char> stringbuffer;$/;"	t
stringcmp	include/stringXF.h	/^struct stringcmp : public std::binary_function<std::basic_string<_Elem>, std::basic_string<_Elem>, bool>$/;"	s	inherits:std::binary_function
stringcmp::_fun	include/stringXF.h	/^	_CmpFunc _fun;$/;"	m	struct:stringcmp	access:public
stringcmp::operator ()	include/stringXF.h	/^	bool operator()(const std::basic_string<_Elem>& str1, const std::basic_string<_Elem>& str2) const$/;"	f	struct:stringcmp	access:public	signature:(const std::basic_string<_Elem>& str1, const std::basic_string<_Elem>& str2) const
stringless	include/stringXF.h	/^typedef stringcmp<std::less<std::string>, char> stringless; $/;"	t
stringless	syntax/symbol.h	/^struct stringless : public std::binary_function<const tchar*, const tchar*, bool>$/;"	s	inherits:std::binary_function
stringless::operator ()	syntax/symbol.h	/^	bool operator()(const tchar* str1, const tchar* str2) const$/;"	f	struct:stringless	access:public	signature:(const tchar* str1, const tchar* str2) const
substr	include/stringX.h	/^	_Myt substr(size_type _Off = 0, size_type _Count = _Mybase::npos) const$/;"	f	class:xstring_basic	access:public	signature:(size_type _Off = 0, size_type _Count = _Mybase::npos) const
swap	compiler/word.h	/^	void swap(word& aword)$/;"	f	struct:word	access:public	signature:(word& aword)
swap	include/arrayX.h	/^		void swap(block& _Other) throw()$/;"	f	struct:smart_vector::block	access:public	signature:(block& _Other)
swap	include/arrayX.h	/^	void swap(_Myt& _Other)$/;"	f	class:smart_vector	access:public	signature:(_Myt& _Other)
swap	include/functionalX.h	/^	void swap(_Myt& _Right)$/;"	f	struct:triple	access:public	signature:(_Myt& _Right)
swap	include/markuputils.h	/^	void swap(file& other)$/;"	f	class:file	access:public	signature:(file& other)
swap	include/markuputils.h	/^	void swap(ifile& other)$/;"	f	class:ifile	access:public	signature:(ifile& other)
swap	include/shared_ptr.h	/^		void swap(shared_ptr<T>& other) throw ()$/;"	f	class:shared_ptr	access:public	signature:(shared_ptr<T>& other)
swap	include/sortc.h	/^	void swap(sortc<_C, _Pred>& _Other)$/;"	f	class:sortc	access:public	signature:(sortc<_C, _Pred>& _Other)
swap	syntax/automachine.h	/^	void swap(automachine& other)$/;"	f	class:automachine	access:public	signature:(automachine& other)
swap	syntax/grammar.cpp	/^void grammar::swap(grammar& other) throw ()$/;"	f	class:grammar	signature:(grammar& other)
swap	syntax/grammar.cpp	/^void tinygrammar::swap(tinygrammar& other) throw()$/;"	f	class:tinygrammar	signature:(tinygrammar& other)
swap	syntax/grammar.h	/^	void swap(grammar& other) throw ();$/;"	p	class:grammar	access:public	signature:(grammar& other)
swap	syntax/grammar.h	/^	void swap(tinygrammar& other) throw();$/;"	p	class:tinygrammar	access:public	signature:(tinygrammar& other)
swap	syntax/loader.h	/^	void swap(loader& other);$/;"	p	class:loader	access:public	signature:(loader& other)
swap	syntax/lrmachine.cpp	/^void lrmachine::swap(lrmachine& other) throw()$/;"	f	class:lrmachine	signature:(lrmachine& other)
swap	syntax/lrmachine.h	/^	void swap(lrmachine& other) throw();$/;"	p	class:lrmachine	access:public	signature:(lrmachine& other)
swap	syntax/production.cpp	/^void production::swap(production& other)$/;"	f	class:production	signature:(production& other)
swap	syntax/production.h	/^	void swap(production& other);$/;"	p	class:production	access:public	signature:(production& other)
swap	syntax/statemachine.h	/^	void swap(state_machine& other)$/;"	f	class:state_machine	access:public	signature:(state_machine& other)
swap	syntax/symbol.h	/^	void swap(symholder& other)$/;"	f	class:symholder	access:public	signature:(symholder& other)
swap	syntax/word.h	/^	void swap(word& aword)$/;"	f	struct:word	access:public	signature:(word& aword)
swap_kernel	syntax/grammar.cpp	/^void grammar::swap_kernel(tinygrammar& other) throw ()$/;"	f	class:grammar	signature:(tinygrammar& other)
swap_kernel	syntax/grammar.h	/^	void swap_kernel(tinygrammar& tg) throw ();$/;"	p	class:grammar	access:public	signature:(tinygrammar& tg)
swcvt	include/stringXF.h	/^	struct swcvt$/;"	s	namespace:Format
switch_brace_or	galgorithm/regex2nfa.cpp	/^	int switch_brace_or(std::vector<int>& R, const char* p, int L, char rc)$/;"	f	struct:parsecontent	access:public	signature:(std::vector<int>& R, const char* p, int L, char rc)
switch_brace_or	tmp/back/regex2nfa.cpp	/^	int switch_brace_or(std::vector<int>& R, const char* p, int L, char rc)$/;"	f	struct:parsecontent	access:public	signature:(std::vector<int>& R, const char* p, int L, char rc)
sym	galgorithm/regex2nfa.cpp	/^	struct sym$/;"	s	struct:parsecontent	file:	access:public
sym	tmp/back/regex2nfa.cpp	/^	struct sym$/;"	s	struct:parsecontent	file:	access:public
symbol	syntax/symbol.h	/^struct symbol$/;"	s
symbol	test/output/gen.cpp	/^	symbol()$/;"	f	struct:symbol	access:public	signature:()
symbol	test/output/gen.cpp	/^struct symbol : public type$/;"	s	file:	inherits:type
symbol	test/output/tinyg.cpp	/^	symbol()$/;"	f	struct:symbol	access:public	signature:()
symbol	test/output/tinyg.cpp	/^struct symbol : public type$/;"	s	file:	inherits:type
symbol	test/output/tinyg/tinyg.cpp	/^	symbol()$/;"	f	struct:symbol	access:public	signature:()
symbol	test/output/tinyg/tinyg.cpp	/^struct symbol : public type$/;"	s	file:	inherits:type
symbol	test/output/tinyg/tinyg_bk.cpp	/^	symbol()$/;"	f	struct:symbol	access:public	signature:()
symbol	test/output/tinyg/tinyg_bk.cpp	/^struct symbol : public type$/;"	s	file:	inherits:type
symbol::Lfuncs	syntax/symbol.h	/^	int8 Lfuncs;$/;"	m	struct:symbol	access:public
symbol::Lname	syntax/symbol.h	/^	int16 Lname;$/;"	m	struct:symbol	access:public
symbol::funcs	syntax/symbol.h	/^	symfunc* funcs;$/;"	m	struct:symbol	access:public
symbol::ist	syntax/symbol.h	/^	int8 ist;$/;"	m	struct:symbol	access:public
symbol::name	syntax/symbol.h	/^	const tchar* name;$/;"	m	struct:symbol	access:public
symbol::sid	syntax/symbol.h	/^	int32 sid; \/\/ symbol id: used to index symbol$/;"	m	struct:symbol	access:public
symbol::sid	test/output/gen.cpp	/^	enum{ sid = 1029 };$/;"	e	enum:symbol::__anon123	file:
symbol::sid	test/output/tinyg.cpp	/^	enum{ sid = 6 };$/;"	e	enum:symbol::__anon11	file:
symbol::sid	test/output/tinyg/tinyg.cpp	/^	enum{ sid = 6 };$/;"	e	enum:symbol::__anon42	file:
symbol::sid	test/output/tinyg/tinyg_bk.cpp	/^	enum{ sid = 6 };$/;"	e	enum:symbol::__anon73	file:
symbol::symbol	test/output/gen.cpp	/^	symbol()$/;"	f	struct:symbol	access:public	signature:()
symbol::symbol	test/output/tinyg.cpp	/^	symbol()$/;"	f	struct:symbol	access:public	signature:()
symbol::symbol	test/output/tinyg/tinyg.cpp	/^	symbol()$/;"	f	struct:symbol	access:public	signature:()
symbol::symbol	test/output/tinyg/tinyg_bk.cpp	/^	symbol()$/;"	f	struct:symbol	access:public	signature:()
symbol_to_eplison	galgorithm/basicalgorithms.h	/^	symbol_to_eplison(const tinygrammar& gin, vecint& istoe, int32& eid)$/;"	f	class:symbol_to_eplison	access:public	signature:(const tinygrammar& gin, vecint& istoe, int32& eid)
symbol_to_eplison	galgorithm/basicalgorithms.h	/^class symbol_to_eplison : public grammar_algorithm$/;"	c	inherits:grammar_algorithm
symbol_to_eplison::eid_	galgorithm/basicalgorithms.h	/^	int32* eid_;$/;"	m	class:symbol_to_eplison	access:private
symbol_to_eplison::gin_	galgorithm/basicalgorithms.h	/^	const tinygrammar* gin_;$/;"	m	class:symbol_to_eplison	access:private
symbol_to_eplison::invoke	galgorithm/basicalgorithms.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:symbol_to_eplison	access:public	signature:()
symbol_to_eplison::istoe_	galgorithm/basicalgorithms.h	/^	vecint* istoe_;$/;"	m	class:symbol_to_eplison	access:private
symbol_to_eplison::operator ()	galgorithm/basicalgorithms.cpp	/^void symbol_to_eplison::operator()(const tinygrammar& tig, vecint& istoe, int32& eid)$/;"	f	class:symbol_to_eplison	signature:(const tinygrammar& tig, vecint& istoe, int32& eid)
symbol_to_eplison::operator ()	galgorithm/basicalgorithms.h	/^	void operator()(const tinygrammar& tig, vecint& istoe, int32& eid);$/;"	p	class:symbol_to_eplison	access:private	signature:(const tinygrammar& tig, vecint& istoe, int32& eid)
symbol_to_eplison::symbol_to_eplison	galgorithm/basicalgorithms.h	/^	symbol_to_eplison(const tinygrammar& gin, vecint& istoe, int32& eid)$/;"	f	class:symbol_to_eplison	access:public	signature:(const tinygrammar& gin, vecint& istoe, int32& eid)
symbol_to_eplison::vecint	galgorithm/basicalgorithms.h	/^	typedef kog::smart_vector<int32> vecint;$/;"	t	class:symbol_to_eplison	access:public
symbolname_Cmp	syntax/symbol.h	/^struct symbolname_Cmp : public std::binary_function<symbol, symbol, bool>$/;"	s	inherits:std::binary_function
symbolname_Cmp::_Cmp	syntax/symbol.h	/^	_CmpFunc _Cmp;$/;"	m	struct:symbolname_Cmp	access:public
symbolname_Cmp::operator ()	syntax/symbol.h	/^	bool operator()(const symbol& s1, const symbol& s2) const$/;"	f	struct:symbolname_Cmp	access:public	signature:(const symbol& s1, const symbol& s2) const
symbolname_Less	syntax/symbol.h	/^typedef symbolname_Cmp<stringless> symbolname_Less;$/;"	t
symbols	test/vhelp.h	/^	static const compile::symholder*& symbols()$/;"	f	class:V	access:public	signature:()
symbols	test/vhelp.h	/^	static const compile::symholder*& symbols()$/;"	f	struct:symindex	access:public	signature:()
symbols_	syntax/grammar.h	/^	symholder symbols_; \/\/ all symbols$/;"	m	class:tinygrammar	access:protected
symcontentstring_	syntax/symbol.h	/^	kog::smart_vector<tchar> symcontentstring_;$/;"	m	class:symholder	access:private
symfunc	syntax/symbol.h	/^struct symfunc$/;"	s
symfunc::func	syntax/symbol.h	/^	function func;$/;"	m	struct:symfunc	access:public
symfunc::function	syntax/symbol.h	/^	typedef void* (*function)(void*);$/;"	t	struct:symfunc	access:public
symfunc::name	syntax/symbol.h	/^	tstring name;$/;"	m	struct:symfunc	access:public
symholder	syntax/symbol.h	/^	symholder()$/;"	f	class:symholder	access:public	signature:()
symholder	syntax/symbol.h	/^	symholder(_Iter_Sym _First, _Iter_Sym _End) $/;"	f	class:symholder	access:public	signature:(_Iter_Sym _First, _Iter_Sym _End)
symholder	syntax/symbol.h	/^	symholder(_StrIter _First_Str, _StrIter _End_Str, _SymIter _First_Sym, _SymIter _End_Sym)$/;"	f	class:symholder	access:public	signature:(_StrIter _First_Str, _StrIter _End_Str, _SymIter _First_Sym, _SymIter _End_Sym)
symholder	syntax/symbol.h	/^class symholder : public kog::smart_vector<symbol>$/;"	c	inherits:kog::smart_vector
symholder::getstringptr	syntax/symbol.h	/^	const tchar* getstringptr() const$/;"	f	class:symholder	access:public	signature:() const
symholder::index	syntax/symbol.cpp	/^int32 symholder::index(const tstring& name) const$/;"	f	class:symholder	signature:(const tstring& name) const
symholder::index	syntax/symbol.h	/^	int index(const tstring& name) const;$/;"	p	class:symholder	access:public	signature:(const tstring& name) const
symholder::make_index	syntax/symbol.cpp	/^void symholder::make_index()$/;"	f	class:symholder	signature:()
symholder::make_index	syntax/symbol.h	/^	void make_index();$/;"	p	class:symholder	access:public	signature:()
symholder::nameIndexer_	syntax/symbol.h	/^	std::map<const tchar*, const symbol*, stringless> nameIndexer_;$/;"	m	class:symholder	access:private
symholder::swap	syntax/symbol.h	/^	void swap(symholder& other)$/;"	f	class:symholder	access:public	signature:(symholder& other)
symholder::symcontentstring_	syntax/symbol.h	/^	kog::smart_vector<tchar> symcontentstring_;$/;"	m	class:symholder	access:private
symholder::symholder	syntax/symbol.h	/^	symholder()$/;"	f	class:symholder	access:public	signature:()
symholder::symholder	syntax/symbol.h	/^	symholder(_Iter_Sym _First, _Iter_Sym _End) $/;"	f	class:symholder	access:public	signature:(_Iter_Sym _First, _Iter_Sym _End)
symholder::symholder	syntax/symbol.h	/^	symholder(_StrIter _First_Str, _StrIter _End_Str, _SymIter _First_Sym, _SymIter _End_Sym)$/;"	f	class:symholder	access:public	signature:(_StrIter _First_Str, _StrIter _End_Str, _SymIter _First_Sym, _SymIter _End_Sym)
symholder::updata_sys_symbols	syntax/symbol.h	/^	void updata_sys_symbols();$/;"	p	class:symholder	access:private	signature:()
symindex	test/vhelp.h	/^	symindex(const compile::tchar* name)$/;"	f	struct:symindex	access:public	signature:(const compile::tchar* name)
symindex	test/vhelp.h	/^	symindex(const tstring& name)$/;"	f	struct:symindex	access:public	signature:(const tstring& name)
symindex	test/vhelp.h	/^	symindex(int32 u)$/;"	f	struct:symindex	access:public	signature:(int32 u)
symindex	test/vhelp.h	/^struct symindex$/;"	s
symindex::idx	test/vhelp.h	/^	int32 idx;$/;"	m	struct:symindex	access:public
symindex::int32	test/vhelp.h	/^	typedef compile::int32 int32;$/;"	t	struct:symindex	access:public
symindex::operator int32	test/vhelp.h	/^	operator int32() const$/;"	f	struct:symindex	access:public	signature:() const
symindex::symbols	test/vhelp.h	/^	static const compile::symholder*& symbols()$/;"	f	struct:symindex	access:public	signature:()
symindex::symindex	test/vhelp.h	/^	symindex(const compile::tchar* name)$/;"	f	struct:symindex	access:public	signature:(const compile::tchar* name)
symindex::symindex	test/vhelp.h	/^	symindex(const tstring& name)$/;"	f	struct:symindex	access:public	signature:(const tstring& name)
symindex::symindex	test/vhelp.h	/^	symindex(int32 u)$/;"	f	struct:symindex	access:public	signature:(int32 u)
symindex::tstring	test/vhelp.h	/^	typedef compile::tstring tstring;$/;"	t	struct:symindex	access:public
syms	galgorithm/regex2nfa.cpp	/^	std::deque<sym> syms;$/;"	m	struct:parsecontent	file:	access:public
syms	tmp/back/regex2nfa.cpp	/^	std::deque<sym> syms;$/;"	m	struct:parsecontent	file:	access:public
symtype	syntax/grammar.h	/^	enum symtype$/;"	g	class:grammar	access:public
syntax_	makecompiler/gensyntax.h	/^	const grammar* syntax_;$/;"	m	class:syntaxgenerator	access:public
syntaxgenerator	makecompiler/gensyntax.cpp	/^syntaxgenerator::syntaxgenerator()$/;"	f	class:syntaxgenerator	signature:()
syntaxgenerator	makecompiler/gensyntax.h	/^	syntaxgenerator();$/;"	p	class:syntaxgenerator	access:public	signature:()
syntaxgenerator	makecompiler/gensyntax.h	/^class syntaxgenerator$/;"	c
syntaxgenerator::cppfile_	makecompiler/gensyntax.h	/^	tstring cppfile_;$/;"	m	class:syntaxgenerator	access:public
syntaxgenerator::cppstream_	makecompiler/gensyntax.h	/^	std::ostream* cppstream_;$/;"	m	class:syntaxgenerator	access:public
syntaxgenerator::is_token_keyword	makecompiler/gensyntax.cpp	/^bool syntaxgenerator::is_token_keyword(const tchar* name) const$/;"	f	class:syntaxgenerator	signature:(const tchar* name) const
syntaxgenerator::is_token_keyword	makecompiler/gensyntax.h	/^	bool is_token_keyword(const tchar* name) const;$/;"	p	class:syntaxgenerator	access:private	signature:(const tchar* name) const
syntaxgenerator::operator ()	makecompiler/gensyntax.cpp	/^void syntaxgenerator::operator()(const grammar* aGrammar, const tstring& outfile)$/;"	f	class:syntaxgenerator	signature:(const grammar* aGrammar, const tstring& outfile)
syntaxgenerator::operator ()	makecompiler/gensyntax.h	/^	void operator()(const grammar* aGrammar, const tstring& outfile);$/;"	p	class:syntaxgenerator	access:public	signature:(const grammar* aGrammar, const tstring& outfile)
syntaxgenerator::print_grammar	makecompiler/gensyntax.cpp	/^void syntaxgenerator::print_grammar()$/;"	f	class:syntaxgenerator	signature:()
syntaxgenerator::print_grammar	makecompiler/gensyntax.h	/^	void print_grammar();$/;"	p	class:syntaxgenerator	access:private	signature:()
syntaxgenerator::print_includes	makecompiler/gensyntax.cpp	/^void syntaxgenerator::print_includes()$/;"	f	class:syntaxgenerator	signature:()
syntaxgenerator::print_includes	makecompiler/gensyntax.h	/^	void print_includes();$/;"	p	class:syntaxgenerator	access:private	signature:()
syntaxgenerator::print_keywords	makecompiler/gensyntax.cpp	/^void syntaxgenerator::print_keywords()$/;"	f	class:syntaxgenerator	signature:()
syntaxgenerator::print_keywords	makecompiler/gensyntax.h	/^	void print_keywords();$/;"	p	class:syntaxgenerator	access:private	signature:()
syntaxgenerator::print_machine	makecompiler/gensyntax.cpp	/^void syntaxgenerator::print_machine(std::ostream& os, const compile::automachine& mac)$/;"	f	class:syntaxgenerator	signature:(std::ostream& os, const compile::automachine& mac)
syntaxgenerator::print_machine	makecompiler/gensyntax.h	/^	void print_machine(std::ostream& os, const compile::automachine& mac);$/;"	p	class:syntaxgenerator	access:private	signature:(std::ostream& os, const compile::automachine& mac)
syntaxgenerator::print_printablechars	makecompiler/gensyntax.cpp	/^void syntaxgenerator::print_printablechars()$/;"	f	class:syntaxgenerator	signature:()
syntaxgenerator::print_printablechars	makecompiler/gensyntax.h	/^	void print_printablechars();$/;"	p	class:syntaxgenerator	access:private	signature:()
syntaxgenerator::print_productions	makecompiler/gensyntax.cpp	/^void syntaxgenerator::print_productions()$/;"	f	class:syntaxgenerator	signature:()
syntaxgenerator::print_productions	makecompiler/gensyntax.h	/^    void print_productions();$/;"	p	class:syntaxgenerator	access:private	signature:()
syntaxgenerator::print_separators	makecompiler/gensyntax.cpp	/^void syntaxgenerator::print_separators()$/;"	f	class:syntaxgenerator	signature:()
syntaxgenerator::print_separators	makecompiler/gensyntax.h	/^	void print_separators();$/;"	p	class:syntaxgenerator	access:private	signature:()
syntaxgenerator::print_statemachines	makecompiler/gensyntax.cpp	/^void syntaxgenerator::print_statemachines()$/;"	f	class:syntaxgenerator	signature:()
syntaxgenerator::print_statemachines	makecompiler/gensyntax.h	/^	void print_statemachines();$/;"	p	class:syntaxgenerator	access:private	signature:()
syntaxgenerator::print_symbols	makecompiler/gensyntax.cpp	/^void syntaxgenerator::print_symbols()$/;"	f	class:syntaxgenerator	signature:()
syntaxgenerator::print_symbols	makecompiler/gensyntax.h	/^	void print_symbols();$/;"	p	class:syntaxgenerator	access:private	signature:()
syntaxgenerator::refine_machine	makecompiler/gensyntax.cpp	/^void syntaxgenerator::refine_machine(automachine& m) const$/;"	f	class:syntaxgenerator	signature:(automachine& m) const
syntaxgenerator::refine_machine	makecompiler/gensyntax.h	/^	void refine_machine(automachine& m) const;$/;"	p	class:syntaxgenerator	access:private	signature:(automachine& m) const
syntaxgenerator::regex_str_to_machine	makecompiler/gensyntax.cpp	/^void syntaxgenerator::regex_str_to_machine(const std::string& regexstr, automachine& m)$/;"	f	class:syntaxgenerator	signature:(const std::string& regexstr, automachine& m)
syntaxgenerator::regex_str_to_machine	makecompiler/gensyntax.h	/^	void regex_str_to_machine(const std::string& regexstr, automachine& m);$/;"	p	class:syntaxgenerator	access:private	signature:(const std::string& regexstr, automachine& m)
syntaxgenerator::syntax_	makecompiler/gensyntax.h	/^	const grammar* syntax_;$/;"	m	class:syntaxgenerator	access:public
syntaxgenerator::syntaxgenerator	makecompiler/gensyntax.cpp	/^syntaxgenerator::syntaxgenerator()$/;"	f	class:syntaxgenerator	signature:()
syntaxgenerator::syntaxgenerator	makecompiler/gensyntax.h	/^	syntaxgenerator();$/;"	p	class:syntaxgenerator	access:public	signature:()
syntaxgenerator::~syntaxgenerator	makecompiler/gensyntax.cpp	/^syntaxgenerator::~syntaxgenerator()$/;"	f	class:syntaxgenerator	signature:()
syntaxgenerator::~syntaxgenerator	makecompiler/gensyntax.h	/^	virtual ~syntaxgenerator();$/;"	p	class:syntaxgenerator	access:public	signature:()
tabident	makecompiler/gensyntax.cpp	/^	tabident(int i = 0)$/;"	f	struct:tabident	access:public	signature:(int i = 0)
tabident	makecompiler/gensyntax.cpp	/^struct tabident$/;"	s	file:
tabident::dectab	makecompiler/gensyntax.cpp	/^	static tabident dectab;$/;"	m	struct:tabident	file:	access:public
tabident::inc	makecompiler/gensyntax.cpp	/^	int inc;$/;"	m	struct:tabident	file:	access:private
tabident::inctab	makecompiler/gensyntax.cpp	/^	static tabident inctab;$/;"	m	struct:tabident	file:	access:public
tabident::newline	makecompiler/gensyntax.cpp	/^	static std::ostream& newline(std::ostream& os)$/;"	f	struct:tabident	access:public	signature:(std::ostream& os)
tabident::operator <<	makecompiler/gensyntax.cpp	/^	friend std::ostream& operator<<(std::ostream& os, const tabident& a)$/;"	f	struct:tabident	access:friend	signature:(std::ostream& os, const tabident& a)
tabident::tabident	makecompiler/gensyntax.cpp	/^	tabident(int i = 0)$/;"	f	struct:tabident	access:public	signature:(int i = 0)
tabident::tabs	makecompiler/gensyntax.cpp	/^	static int tabs;$/;"	m	struct:tabident	file:	access:private
tabident::tabs	makecompiler/gensyntax.cpp	/^int tabident::tabs = 0;$/;"	m	class:tabident	file:
tabs	makecompiler/gensyntax.cpp	/^	static int tabs;$/;"	m	struct:tabident	file:	access:private
tabs	makecompiler/gensyntax.cpp	/^int tabident::tabs = 0;$/;"	m	class:tabident	file:
tabs	tmp/coutfun.cpp	/^	static int tabs;$/;"	m	struct:Ident	file:	access:public
tabs	tmp/coutfun.cpp	/^int Ident::tabs = 0;$/;"	m	class:Ident	file:
tchar	include/basic_types.h	/^typedef char tchar;$/;"	t
tchar	test/vhelp.h	/^	typedef compile::tchar tchar;$/;"	t	class:Asymbol	access:private
test_grammar	test/basicalgorithmtest.cpp	/^	void test_grammar(tinygrammar& gin)$/;"	f	class:basicalg_test	file:	access:private	signature:(tinygrammar& gin)
tg	compiler/compiler.h	/^	compile::tinygrammar tg;$/;"	m	class:compiler	access:private
third	include/functionalX.h	/^	_Ty3 third; \/\/ the third stored value$/;"	m	struct:triple	access:public
third_argument_type	include/functionalX.h	/^	typedef _Arg3 third_argument_type;$/;"	t	struct:triple_function	access:public
third_type	include/functionalX.h	/^	typedef _Ty3 third_type;$/;"	t	struct:triple	access:public
tid	compiler/type.h	/^	int32 tid; \/\/ type id$/;"	m	struct:type	access:public
tig	galgorithm/lranalyse.cpp	/^	const tinygrammar* tig;$/;"	m	struct:AlgorithmArg	file:	access:public
tig_	galgorithm/eclosures.h	/^	const tinygrammar* tig_;$/;"	m	class:eclosure	access:private
tinyg	syntax/lrmachine.h	/^	const tinygrammar& tinyg() const$/;"	f	class:lrmachine	access:public	signature:() const
tinyg_compiler_test	test/tinygrammar-compiler.cpp	/^NEW_UNITTEST(tinyg_compiler_test);/;"	v
tinyg_compiler_test	test/tinygrammar-compiler.cpp	/^class tinyg_compiler_test : public sc::unittest$/;"	c	file:	inherits:sc::unittest
tinyg_compiler_test::init	test/tinygrammar-compiler.cpp	/^	\/* overwrite *\/ virtual void init(int argc, const char* argv[])$/;"	f	class:tinyg_compiler_test	access:public	signature:(int argc, const char* argv[])
tinyg_compiler_test::input	test/tinygrammar-compiler.cpp	/^	std::string input;$/;"	m	class:tinyg_compiler_test	file:	access:private
tinyg_compiler_test::run_test	test/tinygrammar-compiler.cpp	/^	\/* overwrite *\/ virtual void run_test()$/;"	f	class:tinyg_compiler_test	access:public	signature:()
tinygrammar	syntax/grammar.cpp	/^tinygrammar::tinygrammar()$/;"	f	class:tinygrammar	signature:()
tinygrammar	syntax/grammar.cpp	/^tinygrammar::tinygrammar(const tinygrammar& other)$/;"	f	class:tinygrammar	signature:(const tinygrammar& other)
tinygrammar	syntax/grammar.h	/^	tinygrammar();$/;"	p	class:tinygrammar	access:public	signature:()
tinygrammar	syntax/grammar.h	/^	tinygrammar(_Iter_Sym _First_Sym, _Iter_Sym _Last_Sym, _Iter_Prod _First_Prod, _Iter_Prod _Last_Prod, int32 _Start, int32 _Eplison = -1, int32 _Ending = -1)$/;"	f	class:tinygrammar	access:public	signature:(_Iter_Sym _First_Sym, _Iter_Sym _Last_Sym, _Iter_Prod _First_Prod, _Iter_Prod _Last_Prod, int32 _Start, int32 _Eplison = -1, int32 _Ending = -1)
tinygrammar	syntax/grammar.h	/^	tinygrammar(const tinygrammar& other);$/;"	p	class:tinygrammar	access:public	signature:(const tinygrammar& other)
tinygrammar	syntax/grammar.h	/^class tinygrammar$/;"	c
tinygrammar::MEMBER_VARIABLE_GET_SET	syntax/grammar.h	/^	MEMBER_VARIABLE_GET_SET(int32, endings, ending_symbol_);$/;"	p	class:tinygrammar	access:public	signature:(int32, endings, ending_symbol_)
tinygrammar::MEMBER_VARIABLE_GET_SET	syntax/grammar.h	/^	MEMBER_VARIABLE_GET_SET(int32, eplisons, eplison_symbol_);$/;"	p	class:tinygrammar	access:public	signature:(int32, eplisons, eplison_symbol_)
tinygrammar::MEMBER_VARIABLE_GET_SET	syntax/grammar.h	/^	MEMBER_VARIABLE_GET_SET(int32, starts, start_symbol_);$/;"	p	class:tinygrammar	access:public	signature:(int32, starts, start_symbol_)
tinygrammar::MEMBER_VARIABLE_GET_SET	syntax/grammar.h	/^	MEMBER_VARIABLE_GET_SET(symholder, symbols, symbols_);$/;"	p	class:tinygrammar	access:public	signature:(symholder, symbols, symbols_)
tinygrammar::MEMBER_VARIABLE_GET_SET	syntax/grammar.h	/^	MEMBER_VARIABLE_GET_SET(vecprods, productions, productions_);$/;"	p	class:tinygrammar	access:public	signature:(vecprods, productions, productions_)
tinygrammar::ending_symbol_	syntax/grammar.h	/^	int32 ending_symbol_; \/\/ ending symbol sid: -1 no$/;"	m	class:tinygrammar	access:protected
tinygrammar::eplison_symbol_	syntax/grammar.h	/^	int32 eplison_symbol_; \/\/ eplison symbol sid: -1 not in grammar$/;"	m	class:tinygrammar	access:protected
tinygrammar::productions_	syntax/grammar.h	/^	vecprods productions_; \/\/ productions$/;"	m	class:tinygrammar	access:protected
tinygrammar::start_symbol_	syntax/grammar.h	/^	int32 start_symbol_; \/\/ start symbol sid$/;"	m	class:tinygrammar	access:protected
tinygrammar::swap	syntax/grammar.cpp	/^void tinygrammar::swap(tinygrammar& other) throw()$/;"	f	class:tinygrammar	signature:(tinygrammar& other)
tinygrammar::swap	syntax/grammar.h	/^	void swap(tinygrammar& other) throw();$/;"	p	class:tinygrammar	access:public	signature:(tinygrammar& other)
tinygrammar::symbols_	syntax/grammar.h	/^	symholder symbols_; \/\/ all symbols$/;"	m	class:tinygrammar	access:protected
tinygrammar::tinygrammar	syntax/grammar.cpp	/^tinygrammar::tinygrammar()$/;"	f	class:tinygrammar	signature:()
tinygrammar::tinygrammar	syntax/grammar.cpp	/^tinygrammar::tinygrammar(const tinygrammar& other)$/;"	f	class:tinygrammar	signature:(const tinygrammar& other)
tinygrammar::tinygrammar	syntax/grammar.h	/^	tinygrammar();$/;"	p	class:tinygrammar	access:public	signature:()
tinygrammar::tinygrammar	syntax/grammar.h	/^	tinygrammar(_Iter_Sym _First_Sym, _Iter_Sym _Last_Sym, _Iter_Prod _First_Prod, _Iter_Prod _Last_Prod, int32 _Start, int32 _Eplison = -1, int32 _Ending = -1)$/;"	f	class:tinygrammar	access:public	signature:(_Iter_Sym _First_Sym, _Iter_Sym _Last_Sym, _Iter_Prod _First_Prod, _Iter_Prod _Last_Prod, int32 _Start, int32 _Eplison = -1, int32 _Ending = -1)
tinygrammar::tinygrammar	syntax/grammar.h	/^	tinygrammar(const tinygrammar& other);$/;"	p	class:tinygrammar	access:public	signature:(const tinygrammar& other)
tinygrammar::vecprods	syntax/grammar.h	/^	typedef kog::smart_vector<production> vecprods;$/;"	t	class:tinygrammar	access:public
tinygrammar::~tinygrammar	syntax/grammar.cpp	/^tinygrammar::~tinygrammar()$/;"	f	class:tinygrammar	signature:()
tinygrammar::~tinygrammar	syntax/grammar.h	/^	virtual ~tinygrammar();$/;"	p	class:tinygrammar	access:public	signature:()
tnode	include/tree.h	/^	struct tnode$/;"	s	class:_tree_node	access:protected
toValue	syntax/global_values.h	/^	_Tx& toValue()$/;"	f	class:refobject	access:public	signature:()
toValue	syntax/global_values.h	/^	const _Tx& toValue() const$/;"	f	class:refobject	access:public	signature:() const
to_lower	include/stringX.h	/^	_Myt& to_lower()$/;"	f	class:xstring_basic	access:public	signature:()
to_string	compiler/funcparams.h	/^    \/* overwrite *\/ virtual _Str to_string() const$/;"	f	struct:funcparamlist	access:public	signature:() const
to_string	compiler/object.h	/^    virtual _Str to_string() const$/;"	f	struct:object	access:public	signature:() const
to_string	compiler/operation.h	/^    \/* overwrite *\/ virtual _Str to_string() const$/;"	f	struct:operation	access:public	signature:() const
to_string	compiler/operation.h	/^    static const _Str& to_string(op i)$/;"	f	struct:op_string	access:public	signature:(op i)
to_string	compiler/type.h	/^    \/* overwrite *\/ virtual _Str to_string() const$/;"	f	struct:type	access:public	signature:() const
to_string	compiler/variable.h	/^    \/* overwrite *\/ virtual _Str to_string() const$/;"	f	class:variable	access:public	signature:() const
to_string	compiler/word.h	/^    \/* overwrite *\/ virtual _Str to_string() const$/;"	f	struct:word	access:public	signature:() const
to_string	syntax/global_values.h	/^		std::string to_string() const$/;"	f	class:refobject::object	access:public	signature:() const
to_string	syntax/global_values.h	/^		virtual std::string to_string() const = 0;$/;"	p	class:refobject::holder	access:public	signature:() const
to_upper	include/stringX.h	/^	_Myt& to_upper()$/;"	f	class:xstring_basic	access:public	signature:()
tocfg	galgorithm/regex2nfa.cpp	/^void regex2nfa::tocfg(const tstring& input, tinygrammar& otput)$/;"	f	class:regex2nfa	signature:(const tstring& input, tinygrammar& otput)
tocfg	galgorithm/regex2nfa.h	/^	void tocfg(const tstring& input, tinygrammar& otput);$/;"	p	class:regex2nfa	access:private	signature:(const tstring& input, tinygrammar& otput)
tocfg	tmp/back/regex2nfa.cpp	/^void regex2nfa::tocfg(const tstring& input, grammar& otput)$/;"	f	class:regex2nfa	signature:(const tstring& input, grammar& otput)
todfa	galgorithm/nfa2dfa.cpp	/^void nfa2dfa::todfa(const tinygrammar& tig, tinygrammar& tog)$/;"	f	class:nfa2dfa	signature:(const tinygrammar& tig, tinygrammar& tog)
todfa	galgorithm/nfa2dfa.h	/^	void todfa(const tinygrammar& tig, tinygrammar& tog);$/;"	p	class:nfa2dfa	access:private	signature:(const tinygrammar& tig, tinygrammar& tog)
todfa	test/nfa2dfatest.cpp	/^	void todfa(const tinygrammar& gin)$/;"	f	class:nfa2dfa_test	file:	access:private	signature:(const tinygrammar& gin)
toe	galgorithm/basicalgorithms.h	/^	vecint toe; \/\/ symbol A->..->e?$/;"	m	class:eliminate_eplison	access:private
tolower	include/stringXF.h	/^_Elem tolower(_Elem _ch)$/;"	f	signature:(_Elem _ch)
tolower	include/stringXF.h	/^std::basic_string<_Elem> tolower(const std::basic_string<_Elem>& _Str)$/;"	f	signature:(const std::basic_string<_Elem>& _Str)
tonfa	galgorithm/regex2nfa.cpp	/^void regex2nfa::tonfa(const tinygrammar& input, tinygrammar& otput)$/;"	f	class:regex2nfa	signature:(const tinygrammar& input, tinygrammar& otput)
tonfa	galgorithm/regex2nfa.h	/^	void tonfa(const tinygrammar& input, tinygrammar& otput);$/;"	p	class:regex2nfa	access:private	signature:(const tinygrammar& input, tinygrammar& otput)
tonfa	tmp/back/regex2nfa.cpp	/^void regex2nfa::tonfa(const grammar& input, grammar& otput)$/;"	f	class:regex2nfa	signature:(const grammar& input, grammar& otput)
tostring	include/stringX.h	/^	static _Myt tostring(const _Tz& _value)$/;"	f	class:xstring_basic	access:public	signature:(const _Tz& _value)
toupper	include/stringXF.h	/^_Elem toupper(_Elem _ch)$/;"	f	signature:(_Elem _ch)
toupper	include/stringXF.h	/^std::basic_string<_Elem> toupper(const std::basic_string<_Elem>& _Str)$/;"	f	signature:(const std::basic_string<_Elem>& _Str)
tovalue	include/stringXF.h	/^template<typename _Ty, typename _Elem> _Ty tovalue(const _Elem* ptr)$/;"	f	signature:(const _Elem* ptr)
tovalue	include/stringXF.h	/^template<typename _Ty, typename _Elem> _Ty tovalue(const std::basic_string<_Elem>& s)$/;"	f	signature:(const std::basic_string<_Elem>& s)
trace	third_party/callstack/stacktrace.h	/^		trace()$/;"	f	class:kog::callstack::trace	access:public	signature:()
trace	third_party/callstack/stacktrace.h	/^		trace(const trace&);$/;"	p	class:kog::callstack::trace	access:private	signature:(const trace&)
trace	third_party/callstack/stacktrace.h	/^	class trace$/;"	c	namespace:kog::callstack
trace_	include/scerror.h	/^	kog::shared_ptr<kog::callstack::trace> trace_;$/;"	m	class:scerror	access:private
trace_message	include/scerror.h	/^	tstring trace_message() const$/;"	f	class:scerror	access:public	signature:() const
tree	include/tree.h	/^	tree()$/;"	f	class:tree	access:public	signature:()
tree	include/tree.h	/^class tree : public _tree_node<_Tx, _Alloc>$/;"	c	inherits:_tree_node
tree::_Base	include/tree.h	/^	typedef _tree_node<_Tx, _Alloc> _Base;$/;"	t	class:tree	access:public
tree::_Const_iterator	include/tree.h	/^	struct _Const_iterator : public std::iterator<std::bidirectional_iterator_tag, _Tx>$/;"	s	class:tree	inherits:std::iterator	access:public
tree::_Const_iterator::_Base	include/tree.h	/^		typedef std::iterator<std::bidirectional_iterator_tag, _Tx> _Base;$/;"	t	struct:tree::_Const_iterator	access:public
tree::_Const_iterator::_Const_iterator	include/tree.h	/^		_Const_iterator(link p)$/;"	f	struct:tree::_Const_iterator	access:public	signature:(link p)
tree::_Const_iterator::_Myt	include/tree.h	/^		typedef _Const_iterator<_Tx> _Myt;$/;"	t	struct:tree::_Const_iterator	access:public
tree::_Const_iterator::backward	include/tree.h	/^		void backward(_Myt& iter)$/;"	f	struct:tree::_Const_iterator	access:protected	signature:(_Myt& iter)
tree::_Const_iterator::const_pointer	include/tree.h	/^		typedef const value_type* const_pointer;$/;"	t	struct:tree::_Const_iterator	access:public
tree::_Const_iterator::const_reference	include/tree.h	/^		typedef const value_type& const_reference;$/;"	t	struct:tree::_Const_iterator	access:public
tree::_Const_iterator::difference_type	include/tree.h	/^		typedef typename _Base::difference_type difference_type;$/;"	t	struct:tree::_Const_iterator	access:public
tree::_Const_iterator::distance_type	include/tree.h	/^		typedef typename _Base::difference_type distance_type;	\/\/ retained$/;"	t	struct:tree::_Const_iterator	access:public
tree::_Const_iterator::forward	include/tree.h	/^		void forward(_Myt& iter)$/;"	f	struct:tree::_Const_iterator	access:protected	signature:(_Myt& iter)
tree::_Const_iterator::iterator_category	include/tree.h	/^		typedef typename _Base::iterator_category iterator_category;$/;"	t	struct:tree::_Const_iterator	access:public
tree::_Const_iterator::link	include/tree.h	/^		typedef typename tree<_Tx, _Alloc>::link link;$/;"	t	struct:tree::_Const_iterator	access:public
tree::_Const_iterator::operator *	include/tree.h	/^		const_reference operator*() const { return self_->v; }$/;"	f	struct:tree::_Const_iterator	access:public	signature:() const
tree::_Const_iterator::operator ++	include/tree.h	/^		_Myt operator++(int) { _Myt temp(*this); forward(*this); return temp;}$/;"	f	struct:tree::_Const_iterator	access:public	signature:(int)
tree::_Const_iterator::operator ++	include/tree.h	/^		_Myt& operator++() { return forward(*this); }$/;"	f	struct:tree::_Const_iterator	access:public	signature:()
tree::_Const_iterator::operator --	include/tree.h	/^		_Myt operator--(int) { _Myt temp(*this); backward(*this); return temp; }$/;"	f	struct:tree::_Const_iterator	access:public	signature:(int)
tree::_Const_iterator::operator --	include/tree.h	/^		_Myt& operator--() { return backward(*this); }$/;"	f	struct:tree::_Const_iterator	access:public	signature:()
tree::_Const_iterator::operator ->	include/tree.h	/^		const_pointer operator ->() const { return &self_->v; }$/;"	f	struct:tree::_Const_iterator	access:public	signature:() const
tree::_Const_iterator::pointer	include/tree.h	/^		typedef typename _Base::pointer pointer;$/;"	t	struct:tree::_Const_iterator	access:public
tree::_Const_iterator::reference	include/tree.h	/^		typedef typename _Base::reference reference;$/;"	t	struct:tree::_Const_iterator	access:public
tree::_Const_iterator::self_	include/tree.h	/^		link self_;$/;"	m	struct:tree::_Const_iterator	access:protected
tree::_Const_iterator::value_type	include/tree.h	/^		typedef typename _Base::value_type value_type;$/;"	t	struct:tree::_Const_iterator	access:public
tree::_Iterator	include/tree.h	/^	struct _Iterator : public _Const_iterator<_Bidirection>$/;"	s	class:tree	inherits:_Const_iterator	access:public
tree::_Iterator::_Const_base	include/tree.h	/^		typedef _Const_iterator<_Bidirection> _Const_base;$/;"	t	struct:tree::_Iterator	access:public
tree::_Iterator::_Iterator	include/tree.h	/^		_Iterator(link p)$/;"	f	struct:tree::_Iterator	access:public	signature:(link p)
tree::_Iterator::_Myt	include/tree.h	/^		typedef _Iterator<_Tx> _Myt;$/;"	t	struct:tree::_Iterator	access:public
tree::_Iterator::difference_type	include/tree.h	/^		typedef typename _Base::difference_type difference_type;$/;"	t	struct:tree::_Iterator	access:public
tree::_Iterator::distance_type	include/tree.h	/^		typedef typename _Base::difference_type distance_type;	\/\/ retained$/;"	t	struct:tree::_Iterator	access:public
tree::_Iterator::iterator_category	include/tree.h	/^		typedef typename _Base::iterator_category iterator_category;$/;"	t	struct:tree::_Iterator	access:public
tree::_Iterator::operator *	include/tree.h	/^		reference operator*() const { return _Const_base::self_->v; }$/;"	f	struct:tree::_Iterator	access:public	signature:() const
tree::_Iterator::operator ->	include/tree.h	/^		pointer operator ->() const { return &_Const_base::self_->v; }$/;"	f	struct:tree::_Iterator	access:public	signature:() const
tree::_Iterator::pointer	include/tree.h	/^		typedef typename _Base::pointer pointer;$/;"	t	struct:tree::_Iterator	access:public
tree::_Iterator::reference	include/tree.h	/^		typedef typename _Base::reference reference;$/;"	t	struct:tree::_Iterator	access:public
tree::_Iterator::value_type	include/tree.h	/^		typedef typename _Base::value_type value_type;$/;"	t	struct:tree::_Iterator	access:public
tree::const_link	include/tree.h	/^	typedef typename _Base::const_link const_link;$/;"	t	class:tree	access:public
tree::const_type	include/tree.h	/^	typedef typename mpl::add_const<_Tx>::type const_type;$/;"	t	class:tree	access:public
tree::first_order	include/tree.h	/^	struct first_order$/;"	s	class:tree	access:public
tree::first_order::first_order	include/tree.h	/^		first_order(link p) : p_(p) {}$/;"	f	struct:tree::first_order	access:public	signature:(link p)
tree::first_order::operator ++	include/tree.h	/^		first_order& operator++() const $/;"	f	struct:tree::first_order	access:public	signature:() const
tree::first_order::p_	include/tree.h	/^		link p_;$/;"	m	struct:tree::first_order	access:public
tree::link	include/tree.h	/^	typedef typename _Base::link link;$/;"	t	class:tree	access:public
tree::reset_root	include/tree.h	/^	void reset_root(link r)$/;"	f	class:tree	access:protected	signature:(link r)
tree::root	include/tree.h	/^	const_link root() const { return root_; }$/;"	f	class:tree	access:public	signature:() const
tree::root	include/tree.h	/^	link root() { return root_; }$/;"	f	class:tree	access:public	signature:()
tree::root_	include/tree.h	/^	link root_;$/;"	m	class:tree	access:private
tree::tree	include/tree.h	/^	tree()$/;"	f	class:tree	access:public	signature:()
tree::value_type	include/tree.h	/^	typedef typename mpl::remove_const<_Tx>::type value_type;$/;"	t	class:tree	access:public
tree::~tree	include/tree.h	/^	~tree()$/;"	f	class:tree	access:public	signature:()
tree_wrap	build/debug/test/tinyg.cpp	/^class tree_wrap : public make_tree$/;"	c	file:	inherits:make_tree
tree_wrap	build/debug/test/tmp.cpp	/^class tree_wrap : public make_tree$/;"	c	file:	inherits:make_tree
tree_wrap	build/debug/test/xxx.cpp	/^class tree_wrap : public make_tree$/;"	c	file:	inherits:make_tree
tree_wrap	test/output/tinyg.cpp	/^class tree_wrap : public make_tree$/;"	c	file:	inherits:make_tree
tree_wrap	test/output/tinyg/tinyg.cpp	/^class tree_wrap : public make_tree$/;"	c	file:	inherits:make_tree
tree_wrap	test/output/tinyg/tinyg_bk.cpp	/^class tree_wrap : public kog::tree<int32>$/;"	c	file:	inherits:kog::tree
tree_wrap	test/tinyg.cpp	/^class tree_wrap : public make_tree$/;"	c	file:	inherits:make_tree
tree_wrap::make	build/debug/test/tinyg.cpp	/^	void make()$/;"	f	class:tree_wrap	access:public	signature:()
tree_wrap::make	build/debug/test/tmp.cpp	/^	void make()$/;"	f	class:tree_wrap	access:public	signature:()
tree_wrap::make	build/debug/test/xxx.cpp	/^	void make()$/;"	f	class:tree_wrap	access:public	signature:()
tree_wrap::make	test/output/tinyg.cpp	/^	void make()$/;"	f	class:tree_wrap	access:public	signature:()
tree_wrap::make	test/output/tinyg/tinyg.cpp	/^	void make()$/;"	f	class:tree_wrap	access:public	signature:()
tree_wrap::make	test/output/tinyg/tinyg_bk.cpp	/^	void make()$/;"	f	class:tree_wrap	access:public	signature:()
tree_wrap::make	test/tinyg.cpp	/^	void make()$/;"	f	class:tree_wrap	access:public	signature:()
tree_wrap::new_leaf	test/output/tinyg/tinyg_bk.cpp	/^	link new_leaf(int32 v, link parent)$/;"	f	class:tree_wrap	access:public	signature:(int32 v, link parent)
tree_wrap::new_node	test/output/tinyg/tinyg_bk.cpp	/^	link new_node(link parent = NULL)$/;"	f	class:tree_wrap	access:public	signature:(link parent = NULL)
trim	include/stringX.h	/^	_Myt& trim(int _TrimType = trim_both)$/;"	f	class:xstring_basic	access:public	signature:(int _TrimType = trim_both)
trim	include/stringX.h	/^	static _Myt trim(const _Myt& _Str, int _TrimType = 3)$/;"	f	class:xstring_basic	access:public	signature:(const _Myt& _Str, int _TrimType = 3)
trim	include/stringXF.h	/^inline std::string trim(const std::string& path, int trimType = 3)$/;"	f	signature:(const std::string& path, int trimType = 3)
trim_begin	include/stringX.h	/^	enum {trim_begin, trim_end, trim_both};$/;"	e	enum:xstring_basic::__anon4
trim_both	include/stringX.h	/^	enum {trim_begin, trim_end, trim_both};$/;"	e	enum:xstring_basic::__anon4
trim_end	include/stringX.h	/^	enum {trim_begin, trim_end, trim_both};$/;"	e	enum:xstring_basic::__anon4
triple	include/functionalX.h	/^		triple(const triple<_Other1, _Other2, _Other3>& _Right)$/;"	f	struct:triple	access:public	signature:(const triple<_Other1, _Other2, _Other3>& _Right)
triple	include/functionalX.h	/^	triple()$/;"	f	struct:triple	access:public	signature:()
triple	include/functionalX.h	/^	triple(const _Ty1& _Val1, const _Ty2& _Val2, const _Ty3& _Val3)$/;"	f	struct:triple	access:public	signature:(const _Ty1& _Val1, const _Ty2& _Val2, const _Ty3& _Val3)
triple	include/functionalX.h	/^struct triple$/;"	s
triple::_Myt	include/functionalX.h	/^	typedef triple<_Ty1, _Ty2, _Ty3> _Myt;$/;"	t	struct:triple	access:public
triple::first	include/functionalX.h	/^	_Ty1 first;	\/\/ the first stored value$/;"	m	struct:triple	access:public
triple::first_type	include/functionalX.h	/^	typedef _Ty1 first_type;$/;"	t	struct:triple	access:public
triple::second	include/functionalX.h	/^	_Ty2 second;	\/\/ the second stored value$/;"	m	struct:triple	access:public
triple::second_type	include/functionalX.h	/^	typedef _Ty2 second_type;$/;"	t	struct:triple	access:public
triple::swap	include/functionalX.h	/^	void swap(_Myt& _Right)$/;"	f	struct:triple	access:public	signature:(_Myt& _Right)
triple::third	include/functionalX.h	/^	_Ty3 third; \/\/ the third stored value$/;"	m	struct:triple	access:public
triple::third_type	include/functionalX.h	/^	typedef _Ty3 third_type;$/;"	t	struct:triple	access:public
triple::triple	include/functionalX.h	/^		triple(const triple<_Other1, _Other2, _Other3>& _Right)$/;"	f	struct:triple	access:public	signature:(const triple<_Other1, _Other2, _Other3>& _Right)
triple::triple	include/functionalX.h	/^	triple()$/;"	f	struct:triple	access:public	signature:()
triple::triple	include/functionalX.h	/^	triple(const _Ty1& _Val1, const _Ty2& _Val2, const _Ty3& _Val3)$/;"	f	struct:triple	access:public	signature:(const _Ty1& _Val1, const _Ty2& _Val2, const _Ty3& _Val3)
triple_function	include/functionalX.h	/^struct triple_function$/;"	s
triple_function::first_argument_type	include/functionalX.h	/^	typedef _Arg1 first_argument_type;$/;"	t	struct:triple_function	access:public
triple_function::result_type	include/functionalX.h	/^	typedef _Result result_type;$/;"	t	struct:triple_function	access:public
triple_function::second_argument_type	include/functionalX.h	/^	typedef _Arg2 second_argument_type;$/;"	t	struct:triple_function	access:public
triple_function::third_argument_type	include/functionalX.h	/^	typedef _Arg3 third_argument_type;$/;"	t	struct:triple_function	access:public
triple_function_adptor	include/functionalX.h	/^inline triple_function_adptor_t<_Arg1, _Arg2, _Arg3, _Result> triple_function_adptor(_Result (*_Func)(_Arg1, _Arg2, _Arg3))$/;"	f	signature:(_Result (_Func)_Arg1, _Arg2, _Arg3))
triple_function_adptor_t	include/functionalX.h	/^	triple_function_adptor_t(_FunType pfun)$/;"	f	struct:triple_function_adptor_t	access:public	signature:(_FunType pfun)
triple_function_adptor_t	include/functionalX.h	/^struct triple_function_adptor_t : public triple_function<_Arg1, _Arg2, _Arg3, _Result>$/;"	s	inherits:triple_function
triple_function_adptor_t::_FunType	include/functionalX.h	/^	typedef _Result (*_FunType)(_Arg1, _Arg2, _Arg3);$/;"	t	struct:triple_function_adptor_t	access:public
triple_function_adptor_t::_pFun	include/functionalX.h	/^	_FunType _pFun;$/;"	m	struct:triple_function_adptor_t	access:private
triple_function_adptor_t::operator ()	include/functionalX.h	/^	_Result operator()(_Arg1 arg1, _Arg2 arg2, _Arg3 arg3) const$/;"	f	struct:triple_function_adptor_t	access:public	signature:(_Arg1 arg1, _Arg2 arg2, _Arg3 arg3) const
triple_function_adptor_t::triple_function_adptor_t	include/functionalX.h	/^	triple_function_adptor_t(_FunType pfun)$/;"	f	struct:triple_function_adptor_t	access:public	signature:(_FunType pfun)
true_node	galgorithm/regex2nfa.cpp	/^	void true_node(const char* vs, const char* ve, int L)$/;"	f	struct:parsecontent	access:public	signature:(const char* vs, const char* ve, int L)
true_node	tmp/back/regex2nfa.cpp	/^	void true_node(const char* vs, const char* ve, int L)$/;"	f	struct:parsecontent	access:public	signature:(const char* vs, const char* ve, int L)
try_to_read_symbol	compiler/extract.cpp	/^	int try_to_read_symbol(word& aword, int_type _Meta)$/;"	f	class:iwordstream	file:	access:private	signature:(word& aword, int_type _Meta)
tryconvert	include/stringXF.h	/^		static bool tryconvert(const std::string& _Src, std::wstring& _Dst, std::exception& ex)$/;"	f	struct:Format::swcvt	access:private	signature:(const std::string& _Src, std::wstring& _Dst, std::exception& ex)
tryconvert	include/stringXF.h	/^		static bool tryconvert(const std::wstring& _Src, std::string& _Dst, std::exception& ex)$/;"	f	struct:Format::swcvt	access:private	signature:(const std::wstring& _Src, std::string& _Dst, std::exception& ex)
tryparse	include/stringX.h	/^	static bool tryparse(const _Myt& str, _Tz& _tz)$/;"	f	class:xstring_basic	access:public	signature:(const _Myt& str, _Tz& _tz)
tryparse	include/stringX.h	/^	static bool tryparse(const _Myt& str, _Tz& _tz, std::string& exceptionMsg)$/;"	f	class:xstring_basic	access:private	signature:(const _Myt& str, _Tz& _tz, std::string& exceptionMsg)
tsize	compiler/type.h	/^	int32 tsize; \/\/ value's default size$/;"	m	struct:type	access:public
tstring	include/basic_types.h	/^typedef std::string tstring;$/;"	t
tstring	syntax/automachine.h	/^	typedef sc::tstring tstring;$/;"	t	class:automachine	access:public
tstring	test/vhelp.h	/^	typedef compile::tstring tstring;$/;"	t	class:Aproduction	access:private
tstring	test/vhelp.h	/^	typedef compile::tstring tstring;$/;"	t	class:Asymbol	access:private
tstring	test/vhelp.h	/^	typedef compile::tstring tstring;$/;"	t	class:V	access:private
tstring	test/vhelp.h	/^	typedef compile::tstring tstring;$/;"	t	struct:symindex	access:public
tstring	third_party/regex/xregex.h	/^	typedef std::basic_string<char_type> tstring;$/;"	t	class:stringX::xregex	access:public
tuple	compiler/tuple.h	/^struct tuple : public object$/;"	s	inherits:object
tuples_	compiler/module.h	/^    std::deque<tuple*> tuples_;$/;"	m	class:codemodule	access:protected
txt	compiler/word.h	/^	_Str txt;$/;"	m	struct:word	access:public
txt	syntax/word.h	/^	_Str txt;$/;"	m	struct:word	access:public
type	compiler/type.h	/^	type(int32 id = -1, int32 s = 0)$/;"	f	struct:type	access:public	signature:(int32 id = -1, int32 s = 0)
type	compiler/type.h	/^struct type : public compile::object$/;"	s	inherits:compile::object
type	include/mplX.h	/^	typedef _FalseType type;$/;"	t	struct:choos_t	access:public
type	include/mplX.h	/^	typedef _TrueType type;$/;"	t	struct:choos_t	access:public
type	include/mplX.h	/^	typedef _Tx type;$/;"	t	struct:remove_const	access:public
type	include/mplX.h	/^	typedef const _T type;$/;"	t	struct:add_const	access:public
type	include/mplX.h	/^	typedef const _Tx& type;$/;"	t	struct:const_reference	access:public
type	syntax/automachine.h	/^		int32 type() const { return eattype_; }$/;"	f	class:automachine::sheetrow	access:public	signature:() const
type	syntax/automachine.h	/^		void type(int32 t) { eattype_ = t; }$/;"	f	class:automachine::sheetrow	access:public	signature:(int32 t)
type	syntax/global_values.cpp	/^	std::string type;$/;"	m	struct:value_t	file:	access:public
type	syntax/global_values.h	/^		const std::type_info& type() const$/;"	f	class:refobject::object	access:public	signature:() const
type	syntax/global_values.h	/^		virtual const std::type_info& type() const = 0;$/;"	p	class:refobject::holder	access:public	signature:() const
type::defvalue	compiler/type.h	/^	byte* defvalue;$/;"	m	struct:type	access:public
type::tid	compiler/type.h	/^	int32 tid; \/\/ type id$/;"	m	struct:type	access:public
type::to_string	compiler/type.h	/^    \/* overwrite *\/ virtual _Str to_string() const$/;"	f	struct:type	access:public	signature:() const
type::tsize	compiler/type.h	/^	int32 tsize; \/\/ value's default size$/;"	m	struct:type	access:public
type::type	compiler/type.h	/^	type(int32 id = -1, int32 s = 0)$/;"	f	struct:type	access:public	signature:(int32 id = -1, int32 s = 0)
type_	compiler/variable.h	/^    const compile::type* type_; \/\/ variable's type$/;"	m	class:variable	access:private
type_type	compiler/type.cpp	/^const type* typesystem::type_type() const$/;"	f	class:typesystem	signature:() const
type_type	compiler/type.h	/^    const type* type_type() const;$/;"	p	class:typesystem	access:public	signature:() const
types_	compiler/type.h	/^	std::deque<type*> types_;$/;"	m	class:typesystem	access:private
typesystem	compiler/type.cpp	/^typesystem::typesystem()$/;"	f	class:typesystem	signature:()
typesystem	compiler/type.h	/^    typesystem();$/;"	p	class:typesystem	access:public	signature:()
typesystem	compiler/type.h	/^class typesystem : public kog::singleton<typesystem>$/;"	c	inherits:kog::singleton
typesystem::double_type	compiler/type.cpp	/^const type* typesystem::double_type() const$/;"	f	class:typesystem	signature:() const
typesystem::double_type	compiler/type.h	/^    const type* double_type() const;$/;"	p	class:typesystem	access:public	signature:() const
typesystem::functiontype_type	compiler/type.cpp	/^const type* typesystem::functiontype_type() const$/;"	f	class:typesystem	signature:() const
typesystem::functiontype_type	compiler/type.h	/^    const type* functiontype_type() const;$/;"	p	class:typesystem	access:public	signature:() const
typesystem::get_func_type	compiler/type.cpp	/^const function_type* typesystem::get_func_type(int32 nparams, const type* params[]) const$/;"	f	class:typesystem	signature:(int32 nparams, const type* params[]) const
typesystem::get_func_type	compiler/type.h	/^    const function_type* get_func_type(int32 nparams, const type* params[]) const;$/;"	p	class:typesystem	access:public	signature:(int32 nparams, const type* params[]) const
typesystem::gettype	compiler/type.h	/^	const type* gettype(int32 tid) const$/;"	f	class:typesystem	access:public	signature:(int32 tid) const
typesystem::int_type	compiler/type.cpp	/^const type* typesystem::int_type() const$/;"	f	class:typesystem	signature:() const
typesystem::int_type	compiler/type.h	/^    const type* int_type() const;$/;"	p	class:typesystem	access:public	signature:() const
typesystem::new_func_type	compiler/type.cpp	/^const function_type* typesystem::new_func_type(int32 nparams, const type* params[], const type* return_type)$/;"	f	class:typesystem	signature:(int32 nparams, const type* params[], const type* return_type)
typesystem::new_func_type	compiler/type.h	/^    const function_type* new_func_type(int32 nparams, const type* params[], const type* return_type);$/;"	p	class:typesystem	access:public	signature:(int32 nparams, const type* params[], const type* return_type)
typesystem::operator_type	compiler/type.cpp	/^const type* typesystem::operator_type() const$/;"	f	class:typesystem	signature:() const
typesystem::operator_type	compiler/type.h	/^    const type* operator_type() const;$/;"	p	class:typesystem	access:public	signature:() const
typesystem::type_type	compiler/type.cpp	/^const type* typesystem::type_type() const$/;"	f	class:typesystem	signature:() const
typesystem::type_type	compiler/type.h	/^    const type* type_type() const;$/;"	p	class:typesystem	access:public	signature:() const
typesystem::types_	compiler/type.h	/^	std::deque<type*> types_;$/;"	m	class:typesystem	access:private
typesystem::typesystem	compiler/type.cpp	/^typesystem::typesystem()$/;"	f	class:typesystem	signature:()
typesystem::typesystem	compiler/type.h	/^    typesystem();$/;"	p	class:typesystem	access:public	signature:()
typesystem::word_type	compiler/type.cpp	/^const type* typesystem::word_type() const$/;"	f	class:typesystem	signature:() const
typesystem::word_type	compiler/type.h	/^    const type* word_type() const;$/;"	p	class:typesystem	access:public	signature:() const
typesystem::~typesystem	compiler/type.cpp	/^typesystem::~typesystem()$/;"	f	class:typesystem	signature:()
typesystem::~typesystem	compiler/type.h	/^    virtual ~typesystem();$/;"	p	class:typesystem	access:public	signature:()
uchar	include/basic_types.h	/^typedef unsigned char uchar;$/;"	t
uint16	include/basic_types.h	/^typedef unsigned short uint16;$/;"	t
uint32	include/basic_types.h	/^typedef unsigned int uint32;$/;"	t
uint64	include/basic_types.h	/^typedef unsigned long int uint64;$/;"	t
uint8	include/basic_types.h	/^typedef unsigned char uint8;$/;"	t
unary_function_adptor	include/functionalX.h	/^inline unary_function_adptor_t<_Arg, _Result> unary_function_adptor(_Result (*_Func)(_Arg))$/;"	f	signature:(_Result (_Func)_Arg))
unary_function_adptor_t	include/functionalX.h	/^	unary_function_adptor_t(_FunType pfun)$/;"	f	struct:unary_function_adptor_t	access:public	signature:(_FunType pfun)
unary_function_adptor_t	include/functionalX.h	/^struct unary_function_adptor_t : public std::unary_function<_Arg, _Result>$/;"	s	inherits:std::unary_function
unary_function_adptor_t::_FunType	include/functionalX.h	/^	typedef _Result (*_FunType)(_Arg);$/;"	t	struct:unary_function_adptor_t	access:public
unary_function_adptor_t::_pFun	include/functionalX.h	/^	_FunType _pFun;$/;"	m	struct:unary_function_adptor_t	access:private
unary_function_adptor_t::operator ()	include/functionalX.h	/^	_Result operator()(_Arg arg) const$/;"	f	struct:unary_function_adptor_t	access:public	signature:(_Arg arg) const
unary_function_adptor_t::unary_function_adptor_t	include/functionalX.h	/^	unary_function_adptor_t(_FunType pfun)$/;"	f	struct:unary_function_adptor_t	access:public	signature:(_FunType pfun)
unittest	test/unittest.cpp	/^unittest::unittest(int min_argc, const std::string& usage)$/;"	f	class:unittest	signature:(int min_argc, const std::string& usage)
unittest	test/unittest.cpp	/^unittest::unittest(void)$/;"	f	class:unittest	signature:(void)
unittest	test/unittest.h	/^	unittest(int min_argc, const std::string& usage);$/;"	p	class:unittest	access:public	signature:(int min_argc, const std::string& usage)
unittest	test/unittest.h	/^	unittest(void);$/;"	p	class:unittest	access:public	signature:(void)
unittest	test/unittest.h	/^class unittest$/;"	c
unittest::MEMBER_VARIABLE_GET_SET	test/unittest.h	/^	MEMBER_VARIABLE_GET_SET(std::string, out_folder, outfolder_);$/;"	p	class:unittest	access:public	signature:(std::string, out_folder, outfolder_)
unittest::init	test/unittest.h	/^	virtual void init(int argc, const char* argv[]) = 0;$/;"	p	class:unittest	access:public	signature:(int argc, const char* argv[])
unittest::minargc_	test/unittest.h	/^	int minargc_;$/;"	m	class:unittest	access:private
unittest::outfolder_	test/unittest.h	/^	std::string outfolder_;$/;"	m	class:unittest	access:private
unittest::run	test/unittest.cpp	/^void unittest::run()$/;"	f	class:unittest	signature:()
unittest::run	test/unittest.cpp	/^void unittest::run(const std::string& outfolder)$/;"	f	class:unittest	signature:(const std::string& outfolder)
unittest::run	test/unittest.h	/^	void run();$/;"	p	class:unittest	access:public	signature:()
unittest::run	test/unittest.h	/^	void run(const std::string& outfolder);$/;"	p	class:unittest	access:public	signature:(const std::string& outfolder)
unittest::run_test	test/unittest.h	/^	virtual void run_test() = 0;$/;"	p	class:unittest	access:private	signature:()
unittest::unittest	test/unittest.cpp	/^unittest::unittest(int min_argc, const std::string& usage)$/;"	f	class:unittest	signature:(int min_argc, const std::string& usage)
unittest::unittest	test/unittest.cpp	/^unittest::unittest(void)$/;"	f	class:unittest	signature:(void)
unittest::unittest	test/unittest.h	/^	unittest(int min_argc, const std::string& usage);$/;"	p	class:unittest	access:public	signature:(int min_argc, const std::string& usage)
unittest::unittest	test/unittest.h	/^	unittest(void);$/;"	p	class:unittest	access:public	signature:(void)
unittest::usage_	test/unittest.h	/^	std::string usage_;$/;"	m	class:unittest	access:private
unittest::~unittest	test/unittest.cpp	/^unittest::~unittest(void)$/;"	f	class:unittest	signature:(void)
unittest::~unittest	test/unittest.h	/^	virtual ~unittest(void);$/;"	p	class:unittest	access:public	signature:(void)
unittest_list	test/unittest.cpp	/^class unittest_list : public std::list<unittest*>, public kog::singleton<unittest_list>$/;"	c	file:	inherits:std::list,kog::singleton
unittest_list::run_all_unittest	test/unittest.cpp	/^	int run_all_unittest(int argc, const char* argv[])$/;"	f	class:unittest_list	access:public	signature:(int argc, const char* argv[])
updata_sys_symbols	syntax/symbol.h	/^	void updata_sys_symbols();$/;"	p	class:symholder	access:private	signature:()
update	include/heapX.h	/^	void update()$/;"	f	class:heap	access:protected	signature:()
update	include/sortc.h	/^	void update()$/;"	f	class:sortc	access:protected	signature:()
update_closure	galgorithm/lranalyse.cpp	/^	void update_closure(lrstate& lrs) const;$/;"	p	struct:AlgorithmArg	file:	access:public	signature:(lrstate& lrs) const
update_closure	galgorithm/lranalyse.cpp	/^void AlgorithmArg::update_closure(lrstate& li) const$/;"	f	class:AlgorithmArg	signature:(lrstate& li) const
upper_bound	include/sortc.h	/^	const_iterator upper_bound(const value_type& v) const$/;"	f	class:sortc	access:public	signature:(const value_type& v) const
upper_bound	include/sortc.h	/^	iterator upper_bound(const value_type& v)$/;"	f	class:sortc	access:public	signature:(const value_type& v)
usage_	test/unittest.h	/^	std::string usage_;$/;"	m	class:unittest	access:private
usedp	galgorithm/basicalgorithms.h	/^	vecint usedp;$/;"	m	class:removenotused	access:private
useds	galgorithm/basicalgorithms.h	/^	vecint useds;$/;"	m	class:removenotused	access:private
usingList_	compiler/scope.h	/^    std::vector<scope*> usingList_;$/;"	m	class:scope	access:private
utilsfunc	include/markuputils.h	/^class utilsfunc$/;"	c
v	include/memoryX.h	/^	_Tx* v;$/;"	m	struct:memblock	access:private
v	include/tree.h	/^		value_type v;$/;"	m	struct:_tree_node::tnode	access:public
v	syntax/automachine.h	/^		typedef kog::smart_vector<gotoitem> v;$/;"	t	class:automachine::sheetrow	access:private
v	test/vhelp.h	/^	typedef kog::smart_vector<int32> v;$/;"	t	class:V	access:private
value	compiler/value.h	/^struct value : public object$/;"	s	inherits:object
value	include/buckethash.h	/^	typedef  _V value;$/;"	t	class:buckethash	access:public
value	include/functionalX.h	/^	const static unsigned int value = 0;$/;"	m	struct:binary	access:public
value	include/functionalX.h	/^	const static unsigned int value = binary<_BinaryValue \/ 10>::value * 2 + _BinaryValue % 10;$/;"	m	struct:binary	access:public
value	include/mplX.h	/^	const static bool value = false;$/;"	m	struct:is_const_t	access:public
value	include/mplX.h	/^	const static bool value = true;$/;"	m	struct:is_const_t	access:public
value	include/mplX.h	/^	const static int value = sizeof(_T);$/;"	m	struct:fire_error	access:public
value	syntax/global_values.cpp	/^	std::string value;$/;"	m	struct:value_t	file:	access:public
value::__anon131::address	compiler/value.h	/^        uint32 address;$/;"	m	union:value::__anon131	access:public
value::__anon131::initv	compiler/value.h	/^        byte* initv;$/;"	m	union:value::__anon131	access:public
value::size	compiler/value.h	/^    uint32 size;$/;"	m	struct:value	access:public
value_	syntax/global_values.h	/^		_Tx value_;$/;"	m	class:refobject::object	access:private
value_reference	include/buckethash.h	/^	typedef  value& value_reference;$/;"	t	class:buckethash	access:public
value_t	syntax/global_values.cpp	/^struct value_t$/;"	s	file:
value_t::more	syntax/global_values.cpp	/^	std::string more;$/;"	m	struct:value_t	file:	access:public
value_t::name	syntax/global_values.cpp	/^	std::string name; \/\/ name of value$/;"	m	struct:value_t	file:	access:public
value_t::type	syntax/global_values.cpp	/^	std::string type;$/;"	m	struct:value_t	file:	access:public
value_t::value	syntax/global_values.cpp	/^	std::string value;$/;"	m	struct:value_t	file:	access:public
value_type	include/arrayX.h	/^	typedef _Tx value_type;$/;"	t	class:smart_vector	access:public
value_type	include/arrayX.h	/^	typedef typename mpl::remove_const<_Ty>::type value_type;$/;"	t	struct:SmartArray	access:public
value_type	include/arrayX.h	/^	typedef typename mpl::remove_const<_Ty>::type value_type;$/;"	t	struct:SmartMatrix	access:public
value_type	include/functionalX.h	/^	typedef _Ty value_type;$/;"	t	struct:mem_value_t	access:public
value_type	include/heapX.h	/^	typedef typename _C::value_type value_type;$/;"	t	class:heap	access:public
value_type	include/iteratorX.h	/^	typedef typename _Base::value_type value_type;$/;"	t	struct:array_iterator	access:public
value_type	include/memoryX.h	/^	typedef _Tx value_type;$/;"	t	struct:memblock	access:public
value_type	include/mplX.h	/^	typedef _Tx value_type;$/;"	t	struct:parse_class_value_type	access:public
value_type	include/mplX.h	/^	typedef _Ty value_type;$/;"	t	struct:parse_class_value_type	access:public
value_type	include/singleton.h	/^	typedef _T value_type;$/;"	t	class:singleton	access:public
value_type	include/sortc.h	/^	typedef typename _C::value_type value_type;$/;"	t	class:sortc	access:public
value_type	include/stringX.h	/^	typedef typename _Mybase::value_type value_type;$/;"	t	class:xstring_basic	access:public
value_type	include/tree.h	/^		typedef typename _Base::value_type value_type;$/;"	t	struct:tree::_Const_iterator	access:public
value_type	include/tree.h	/^		typedef typename _Base::value_type value_type;$/;"	t	struct:tree::_Iterator	access:public
value_type	include/tree.h	/^	typedef _Tx value_type;$/;"	t	class:_tree_node	access:public
value_type	include/tree.h	/^	typedef typename mpl::remove_const<_Tx>::type value_type;$/;"	t	class:tree	access:public
values	include/arrayX.h	/^		pointer values;$/;"	m	struct:smart_vector::block	access:public
values_	syntax/global_values.h	/^	std::map<std::string, refobject > values_;$/;"	m	class:global_values	access:private
valuetype	test/output/gen.cpp	/^	valuetype()$/;"	f	struct:valuetype	access:public	signature:()
valuetype	test/output/gen.cpp	/^struct valuetype : public type$/;"	s	file:	inherits:type
valuetype::sid	test/output/gen.cpp	/^	enum{ sid = 1030 };$/;"	e	enum:valuetype::__anon124	file:
valuetype::valuetype	test/output/gen.cpp	/^	valuetype()$/;"	f	struct:valuetype	access:public	signature:()
variable	compiler/variable.h	/^    variable()$/;"	f	class:variable	access:public	signature:()
variable	compiler/variable.h	/^    variable(const _Str& name, const compile::type* t, const scope* env, uint32 add = -1)$/;"	f	class:variable	access:public	signature:(const _Str& name, const compile::type* t, const scope* env, uint32 add = -1)
variable	compiler/variable.h	/^    variable(const _Str& name, const compile::type* t, const scope* env, value* initial)$/;"	f	class:variable	access:public	signature:(const _Str& name, const compile::type* t, const scope* env, value* initial)
variable	compiler/variable.h	/^class variable : public compile::object$/;"	c	inherits:compile::object
variable::Ccount	compiler/variable.h	/^	uint32 Ccount;$/;"	m	class:variable	access:public
variable::Fname	compiler/variable.h	/^	const char* Fname;$/;"	m	class:variable	access:public
variable::Lcount	compiler/variable.h	/^	uint32 Lcount;$/;"	m	class:variable	access:public
variable::MEMBER_VARIABLE_GET	compiler/variable.h	/^    MEMBER_VARIABLE_GET(_Str, name, name_);$/;"	p	class:variable	access:public	signature:(_Str, name, name_)
variable::MEMBER_VARIABLE_GET	compiler/variable.h	/^    MEMBER_VARIABLE_GET(const compile::type*, vtype, type_);$/;"	p	class:variable	access:public	signature:(const compile::type*, vtype, type_)
variable::MEMBER_VARIABLE_GET	compiler/variable.h	/^    MEMBER_VARIABLE_GET(const scope*, env, env_);$/;"	p	class:variable	access:public	signature:(const scope*, env, env_)
variable::MEMBER_VARIABLE_GET_SET	compiler/variable.h	/^    MEMBER_VARIABLE_GET_SET(uint32, address, pos_);$/;"	p	class:variable	access:public	signature:(uint32, address, pos_)
variable::MEMBER_VARIABLE_GET_SET	compiler/variable.h	/^    MEMBER_VARIABLE_GET_SET(value*, initvalue, initv_);$/;"	p	class:variable	access:public	signature:(value*, initvalue, initv_)
variable::__anon130::initv_	compiler/variable.h	/^        value* initv_; \/\/ initial value$/;"	m	union:variable::__anon130	access:public
variable::__anon130::pos_	compiler/variable.h	/^        uint32 pos_; \/\/ address in memory$/;"	m	union:variable::__anon130	access:public
variable::env_	compiler/variable.h	/^    const scope* env_;$/;"	m	class:variable	access:private
variable::name_	compiler/variable.h	/^    _Str name_; \/\/ name of variable$/;"	m	class:variable	access:private
variable::to_string	compiler/variable.h	/^    \/* overwrite *\/ virtual _Str to_string() const$/;"	f	class:variable	access:public	signature:() const
variable::type_	compiler/variable.h	/^    const compile::type* type_; \/\/ variable's type$/;"	m	class:variable	access:private
variable::variable	compiler/variable.h	/^    variable()$/;"	f	class:variable	access:public	signature:()
variable::variable	compiler/variable.h	/^    variable(const _Str& name, const compile::type* t, const scope* env, uint32 add = -1)$/;"	f	class:variable	access:public	signature:(const _Str& name, const compile::type* t, const scope* env, uint32 add = -1)
variable::variable	compiler/variable.h	/^    variable(const _Str& name, const compile::type* t, const scope* env, value* initial)$/;"	f	class:variable	access:public	signature:(const _Str& name, const compile::type* t, const scope* env, value* initial)
varlist_	compiler/module.h	/^    std::deque<variable*> varlist_;$/;"	m	class:datamodule	access:protected
varscope	compiler/scope.h	/^namespace varscope$/;"	n
varscope::global	compiler/scope.h	/^        global,$/;"	e	enum:varscope::scope_defines
varscope::heap	compiler/scope.h	/^        heap,$/;"	e	enum:varscope::scope_defines
varscope::module	compiler/scope.h	/^        module$/;"	e	enum:varscope::scope_defines
varscope::scope_defines	compiler/scope.h	/^    enum scope_defines$/;"	g	namespace:varscope
varscope::stack	compiler/scope.h	/^        stack,$/;"	e	enum:varscope::scope_defines
vec_params	compiler/funcparams.h	/^    typedef kog::smart_vector<object*> vec_params;$/;"	t	struct:funcparamlist	access:public
vecint	galgorithm/basicalgorithms.h	/^	typedef kog::smart_vector<int32> vecint;$/;"	t	class:eliminate_eplison	access:private
vecint	galgorithm/basicalgorithms.h	/^	typedef kog::smart_vector<int32> vecint;$/;"	t	class:removenotused	access:private
vecint	galgorithm/basicalgorithms.h	/^	typedef kog::smart_vector<int32> vecint;$/;"	t	class:symbol_to_eplison	access:public
vecint	galgorithm/firstfollow.h	/^	typedef kog::smart_vector<int32> vecint;$/;"	t	class:firstset	access:public
vecint	galgorithm/firstfollow.h	/^	typedef kog::smart_vector<int32> vecint;$/;"	t	class:followset	access:public
vecintset	galgorithm/firstfollow.h	/^	typedef kog::smart_vector<vecint> vecintset;$/;"	t	class:firstset	access:public
vecintset	galgorithm/firstfollow.h	/^	typedef kog::smart_vector<vecint> vecintset;$/;"	t	class:followset	access:public
veckeywords	syntax/grammar.h	/^	typedef kog::smart_vector<std::pair<tstring, int32> > veckeywords;$/;"	t	class:grammar	access:public
vecprods	syntax/grammar.h	/^	typedef kog::smart_vector<production> vecprods;$/;"	t	class:tinygrammar	access:public
vecsmacs	syntax/grammar.h	/^	typedef kog::smart_vector<std::pair<tstring, int32> > vecsmacs; \/\/ first: symbol.sid, second: regex string$/;"	t	class:grammar	access:public
weak_ptr	include/shared_ptr.h	/^		explicit weak_ptr( const shared_ptr<T>& s) : ptr(s.ptr), count(s.count) {}$/;"	f	class:weak_ptr	access:public	signature:( const shared_ptr<T>& s)
weak_ptr	include/shared_ptr.h	/^		weak_ptr() : ptr(0), count(shared_ptr<T>::nil()) {}$/;"	f	class:weak_ptr	access:public	signature:()
weak_ptr	include/shared_ptr.h	/^class weak_ptr {$/;"	c
weak_ptr::count	include/shared_ptr.h	/^		unsigned* count;$/;"	m	class:weak_ptr	access:private
weak_ptr::get	include/shared_ptr.h	/^		T* get() { return ptr; }$/;"	f	class:weak_ptr	access:public	signature:()
weak_ptr::get	include/shared_ptr.h	/^		const T* get() const { return ptr; }$/;"	f	class:weak_ptr	access:public	signature:() const
weak_ptr::lock	include/shared_ptr.h	/^		shared_ptr<T> lock() const { return shared_ptr<T>(*this); }$/;"	f	class:weak_ptr	access:public	signature:() const
weak_ptr::operator !=	include/shared_ptr.h	/^		bool operator!=(const shared_ptr<T>& o) const { return ptr != o.ptr; }$/;"	f	class:weak_ptr	access:public	signature:(const shared_ptr<T>& o) const
weak_ptr::operator *	include/shared_ptr.h	/^		T& operator*()  { return *ptr; }$/;"	f	class:weak_ptr	access:public	signature:()
weak_ptr::operator *	include/shared_ptr.h	/^		const T& operator*() const { return *ptr; }$/;"	f	class:weak_ptr	access:public	signature:() const
weak_ptr::operator ->	include/shared_ptr.h	/^		T* operator->() { return ptr; }$/;"	f	class:weak_ptr	access:public	signature:()
weak_ptr::operator ->	include/shared_ptr.h	/^		const T* operator->() const { return ptr; }$/;"	f	class:weak_ptr	access:public	signature:() const
weak_ptr::operator <	include/shared_ptr.h	/^		bool operator<(const shared_ptr<T>& o) const { return ptr < o.ptr; }	$/;"	f	class:weak_ptr	access:public	signature:(const shared_ptr<T>& o) const
weak_ptr::operator ==	include/shared_ptr.h	/^		bool operator==(const shared_ptr<T>& o) const { return ptr == o.ptr; }$/;"	f	class:weak_ptr	access:public	signature:(const shared_ptr<T>& o) const
weak_ptr::ptr	include/shared_ptr.h	/^		T* ptr;$/;"	m	class:weak_ptr	access:private
weak_ptr::refcount	include/shared_ptr.h	/^		unsigned refcount() const { return *count; }$/;"	f	class:weak_ptr	access:public	signature:() const
weak_ptr::weak_ptr	include/shared_ptr.h	/^		explicit weak_ptr( const shared_ptr<T>& s) : ptr(s.ptr), count(s.count) {}$/;"	f	class:weak_ptr	access:public	signature:( const shared_ptr<T>& s)
weak_ptr::weak_ptr	include/shared_ptr.h	/^		weak_ptr() : ptr(0), count(shared_ptr<T>::nil()) {}$/;"	f	class:weak_ptr	access:public	signature:()
whitespaces_	syntax/grammar.h	/^	tstring whitespaces_;	\/\/ whitespace: space tab or some other charactors$/;"	m	class:grammar	access:protected
word	compiler/word.h	/^	word(const _Str& str, short state = Unknown)$/;"	f	struct:word	access:public	signature:(const _Str& str, short state = Unknown)
word	compiler/word.h	/^	word(void) {}$/;"	f	struct:word	access:public	signature:(void)
word	compiler/word.h	/^struct word : public compile::object$/;"	s	inherits:compile::object
word	syntax/word.h	/^	word(const _Str& str, short state = Unknown)$/;"	f	struct:word	access:public	signature:(const _Str& str, short state = Unknown)
word	syntax/word.h	/^	word(void) {}$/;"	f	struct:word	access:public	signature:(void)
word	syntax/word.h	/^struct word$/;"	s
word::Error	compiler/word.h	/^	enum{Known = 1, Unknown = 0, Error = -1};$/;"	e	enum:word::__anon129
word::Error	syntax/word.h	/^	enum{Known = 1, Unknown = 0, Error = -1};$/;"	e	enum:word::__anon125
word::Known	compiler/word.h	/^	enum{Known = 1, Unknown = 0, Error = -1};$/;"	e	enum:word::__anon129
word::Known	syntax/word.h	/^	enum{Known = 1, Unknown = 0, Error = -1};$/;"	e	enum:word::__anon125
word::Unknown	compiler/word.h	/^	enum{Known = 1, Unknown = 0, Error = -1};$/;"	e	enum:word::__anon129
word::Unknown	syntax/word.h	/^	enum{Known = 1, Unknown = 0, Error = -1};$/;"	e	enum:word::__anon125
word::_Str	compiler/word.h	/^	typedef sc::tstring _Str;$/;"	t	struct:word	access:public
word::_Str	syntax/word.h	/^	typedef sc::tstring _Str;$/;"	t	struct:word	access:public
word::swap	compiler/word.h	/^	void swap(word& aword)$/;"	f	struct:word	access:public	signature:(word& aword)
word::swap	syntax/word.h	/^	void swap(word& aword)$/;"	f	struct:word	access:public	signature:(word& aword)
word::to_string	compiler/word.h	/^    \/* overwrite *\/ virtual _Str to_string() const$/;"	f	struct:word	access:public	signature:() const
word::txt	compiler/word.h	/^	_Str txt;$/;"	m	struct:word	access:public
word::txt	syntax/word.h	/^	_Str txt;$/;"	m	struct:word	access:public
word::word	compiler/word.h	/^	word(const _Str& str, short state = Unknown)$/;"	f	struct:word	access:public	signature:(const _Str& str, short state = Unknown)
word::word	compiler/word.h	/^	word(void) {}$/;"	f	struct:word	access:public	signature:(void)
word::word	syntax/word.h	/^	word(const _Str& str, short state = Unknown)$/;"	f	struct:word	access:public	signature:(const _Str& str, short state = Unknown)
word::word	syntax/word.h	/^	word(void) {}$/;"	f	struct:word	access:public	signature:(void)
word::wordClass	compiler/word.h	/^	short wordClass;$/;"	m	struct:word	access:public
word::wordClass	syntax/word.h	/^	short wordClass;$/;"	m	struct:word	access:public
word::wordstate	compiler/word.h	/^	short wordstate;$/;"	m	struct:word	access:public
word::wordstate	syntax/word.h	/^	short wordstate;$/;"	m	struct:word	access:public
wordClass	compiler/word.h	/^	short wordClass;$/;"	m	struct:word	access:public
wordClass	syntax/word.h	/^	short wordClass;$/;"	m	struct:word	access:public
word_type	compiler/type.cpp	/^const type* typesystem::word_type() const$/;"	f	class:typesystem	signature:() const
word_type	compiler/type.h	/^    const type* word_type() const;$/;"	p	class:typesystem	access:public	signature:() const
words_	compiler/extract.h	/^	deqwords words_;$/;"	m	class:streamsplit	access:private
wordstate	compiler/word.h	/^	short wordstate;$/;"	m	struct:word	access:public
wordstate	syntax/word.h	/^	short wordstate;$/;"	m	struct:word	access:public
wstringbuffer	include/stringX.h	/^typedef basic_stringbuffer<wchar_t> wstringbuffer;$/;"	t
x	compiler/compiler.cpp	/^	int32 x;$/;"	m	struct:split_separators	file:	access:public
x	tmp/sizetest.cpp	/^	int x;$/;"	m	struct:A	file:	access:public
x_ATTRIBQUOTE	third_party/xml/Markup.cpp	45;"	d	file:
x_AddElem	third_party/xml/Markup.cpp	/^bool CMarkup::x_AddElem( MCD_PCSZ pName, MCD_PCSZ pValue, int nFlags )$/;"	f	class:CMarkup	signature:( MCD_PCSZ pName, MCD_PCSZ pValue, int nFlags )
x_AddElem	third_party/xml/Markup.cpp	/^bool CMarkup::x_AddElem( MCD_PCSZ pName, int nValue, int nFlags )$/;"	f	class:CMarkup	signature:( MCD_PCSZ pName, int nValue, int nFlags )
x_AddElem	third_party/xml/Markup.h	/^	bool x_AddElem( MCD_PCSZ pName, MCD_PCSZ pValue, int nFlags );$/;"	p	class:CMarkup	access:protected	signature:( MCD_PCSZ pName, MCD_PCSZ pValue, int nFlags )
x_AddElem	third_party/xml/Markup.h	/^	bool x_AddElem( MCD_PCSZ pName, int nValue, int nFlags );$/;"	p	class:CMarkup	access:protected	signature:( MCD_PCSZ pName, int nValue, int nFlags )
x_AddNode	third_party/xml/Markup.cpp	/^bool CMarkup::x_AddNode( int nNodeType, MCD_PCSZ pText, int nNodeFlags )$/;"	f	class:CMarkup	signature:( int nNodeType, MCD_PCSZ pText, int nNodeFlags )
x_AddNode	third_party/xml/Markup.h	/^	bool x_AddNode( int nNodeType, MCD_PCSZ pText, int nNodeFlags );$/;"	p	class:CMarkup	access:protected	signature:( int nNodeType, MCD_PCSZ pText, int nNodeFlags )
x_AddResult	third_party/xml/Markup.cpp	/^void x_AddResult( MCD_STR& strResult, MCD_CSTR pszID, MCD_CSTR pszVal = NULL, int nResultCode = 0, int n = -1, int n2 = -1 )$/;"	f	signature:( MCD_STR& strResult, MCD_CSTR pszID, MCD_CSTR pszVal = NULL, int nResultCode = 0, int n = -1, int n2 = -1 )
x_AddSubDoc	third_party/xml/Markup.cpp	/^bool CMarkup::x_AddSubDoc( MCD_PCSZ pSubDoc, int nFlags )$/;"	f	class:CMarkup	signature:( MCD_PCSZ pSubDoc, int nFlags )
x_AddSubDoc	third_party/xml/Markup.h	/^	bool x_AddSubDoc( MCD_PCSZ pSubDoc, int nFlags );$/;"	p	class:CMarkup	access:protected	signature:( MCD_PCSZ pSubDoc, int nFlags )
x_Adjust	third_party/xml/Markup.cpp	/^void CMarkup::x_Adjust( int iPos, int nShift, bool bAfterPos \/*=false*\/ )$/;"	f	class:CMarkup	signature:( int iPos, int nShift, bool bAfterPos )
x_Adjust	third_party/xml/Markup.h	/^	void x_Adjust( int iPos, int nShift, bool bAfterPos = false );$/;"	p	class:CMarkup	access:protected	signature:( int iPos, int nShift, bool bAfterPos = false )
x_AdjustForNode	third_party/xml/Markup.cpp	/^void CMarkup::x_AdjustForNode( int iPosParent, int iPos, int nShift )$/;"	f	class:CMarkup	signature:( int iPosParent, int iPos, int nShift )
x_AdjustForNode	third_party/xml/Markup.h	/^	void x_AdjustForNode( int iPosParent, int iPos, int nShift );$/;"	p	class:CMarkup	access:protected	signature:( int iPosParent, int iPos, int nShift )
x_AllocElemPos	third_party/xml/Markup.cpp	/^bool CMarkup::x_AllocElemPos( int nNewSize \/*=0*\/ )$/;"	f	class:CMarkup	signature:( int nNewSize )
x_AllocElemPos	third_party/xml/Markup.h	/^	bool x_AllocElemPos( int nNewSize = 0 );$/;"	p	class:CMarkup	access:protected	signature:( int nNewSize = 0 )
x_CheckSavedPos	third_party/xml/Markup.cpp	/^void CMarkup::x_CheckSavedPos()$/;"	f	class:CMarkup	signature:()
x_CheckSavedPos	third_party/xml/Markup.h	/^	void x_CheckSavedPos();$/;"	p	class:CMarkup	access:protected	signature:()
x_CreateNode	third_party/xml/Markup.cpp	/^bool CMarkup::x_CreateNode( MCD_STR& strNode, int nNodeType, MCD_PCSZ pText )$/;"	f	class:CMarkup	signature:( MCD_STR& strNode, int nNodeType, MCD_PCSZ pText )
x_CreateNode	third_party/xml/Markup.h	/^	static bool x_CreateNode( MCD_STR& strNode, int nNodeType, MCD_PCSZ pText );$/;"	p	class:CMarkup	access:protected	signature:( MCD_STR& strNode, int nNodeType, MCD_PCSZ pText )
x_DocChange	third_party/xml/Markup.cpp	/^void CMarkup::x_DocChange( int nLeft, int nReplace, const MCD_STR& strInsert )$/;"	f	class:CMarkup	signature:( int nLeft, int nReplace, const MCD_STR& strInsert )
x_DocChange	third_party/xml/Markup.h	/^	void x_DocChange( int nLeft, int nReplace, const MCD_STR& strInsert );$/;"	p	class:CMarkup	access:protected	signature:( int nLeft, int nReplace, const MCD_STR& strInsert )
x_EOL	third_party/xml/Markup.cpp	43;"	d	file:
x_EOLLEN	third_party/xml/Markup.cpp	44;"	d	file:
x_EncodeCDATASection	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::x_EncodeCDATASection( MCD_PCSZ szData )$/;"	f	class:CMarkup	signature:( MCD_PCSZ szData )
x_EncodeCDATASection	third_party/xml/Markup.h	/^	static MCD_STR x_EncodeCDATASection( MCD_PCSZ szData );$/;"	p	class:CMarkup	access:protected	signature:( MCD_PCSZ szData )
x_EndianSwapRequired	third_party/xml/Markup.cpp	/^bool x_EndianSwapRequired( int nDocFlags )$/;"	f	signature:( int nDocFlags )
x_EndianSwapUTF16	third_party/xml/Markup.cpp	/^void x_EndianSwapUTF16( unsigned short* pBuffer, int nCharLen )$/;"	f	signature:( unsigned short* pBuffer, int nCharLen )
x_FindElem	third_party/xml/Markup.cpp	/^int CMarkup::x_FindElem( int iPosParent, int iPos, PathPos& path ) const$/;"	f	class:CMarkup	signature:( int iPosParent, int iPos, PathPos& path ) const
x_FindElem	third_party/xml/Markup.h	/^	int x_FindElem( int iPosParent, int iPos, PathPos& path ) const;$/;"	p	class:CMarkup	access:protected	signature:( int iPosParent, int iPos, PathPos& path ) const
x_GetAttrib	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::x_GetAttrib( int iPos, MCD_PCSZ pAttrib ) const$/;"	f	class:CMarkup	signature:( int iPos, MCD_PCSZ pAttrib ) const
x_GetAttrib	third_party/xml/Markup.h	/^	MCD_STR x_GetAttrib( int iPos, MCD_PCSZ pAttrib ) const;$/;"	p	class:CMarkup	access:protected	signature:( int iPos, MCD_PCSZ pAttrib ) const
x_GetData	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::x_GetData( int iPos )$/;"	f	class:CMarkup	signature:( int iPos )
x_GetData	third_party/xml/Markup.h	/^	MCD_STR x_GetData( int iPos );$/;"	p	class:CMarkup	access:protected	signature:( int iPos )
x_GetElemContent	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::x_GetElemContent( int iPos ) const$/;"	f	class:CMarkup	signature:( int iPos ) const
x_GetElemContent	third_party/xml/Markup.h	/^	MCD_STR x_GetElemContent( int iPos ) const;$/;"	p	class:CMarkup	access:protected	signature:( int iPos ) const
x_GetEncodingCodePage	third_party/xml/Markup.cpp	/^int x_GetEncodingCodePage( MCD_CSTR pszEncoding )$/;"	f	signature:( MCD_CSTR pszEncoding )
x_GetFreePos	third_party/xml/Markup.cpp	/^int CMarkup::x_GetFreePos()$/;"	f	class:CMarkup	signature:()
x_GetFreePos	third_party/xml/Markup.h	/^	int x_GetFreePos();$/;"	p	class:CMarkup	access:protected	signature:()
x_GetParent	third_party/xml/Markup.cpp	/^int CMarkup::x_GetParent( int i )$/;"	f	class:CMarkup	signature:( int i )
x_GetParent	third_party/xml/Markup.h	/^	int x_GetParent( int i );$/;"	p	class:CMarkup	access:protected	signature:( int i )
x_GetPath	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::x_GetPath( int iPos ) const$/;"	f	class:CMarkup	signature:( int iPos ) const
x_GetPath	third_party/xml/Markup.h	/^	MCD_STR x_GetPath( int iPos ) const;$/;"	p	class:CMarkup	access:protected	signature:( int iPos ) const
x_GetSubDoc	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::x_GetSubDoc( int iPos )$/;"	f	class:CMarkup	signature:( int iPos )
x_GetSubDoc	third_party/xml/Markup.h	/^	MCD_STR x_GetSubDoc( int iPos );$/;"	p	class:CMarkup	access:protected	signature:( int iPos )
x_GetTagName	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::x_GetTagName( int iPos ) const$/;"	f	class:CMarkup	signature:( int iPos ) const
x_GetTagName	third_party/xml/Markup.h	/^	MCD_STR x_GetTagName( int iPos ) const;$/;"	p	class:CMarkup	access:protected	signature:( int iPos ) const
x_Hash	third_party/xml/Markup.cpp	/^int x_Hash( MCD_PCSZ p, int nSize )$/;"	f	signature:( MCD_PCSZ p, int nSize )
x_InitMarkup	third_party/xml/Markup.cpp	/^void CMarkup::x_InitMarkup()$/;"	f	class:CMarkup	signature:()
x_InitMarkup	third_party/xml/Markup.h	/^	void x_InitMarkup();$/;"	p	class:CMarkup	access:protected	signature:()
x_InsertNew	third_party/xml/Markup.cpp	/^int CMarkup::x_InsertNew( int iPosParent, int& iPosRel, NodePos& node )$/;"	f	class:CMarkup	signature:( int iPosParent, int& iPosRel, NodePos& node )
x_InsertNew	third_party/xml/Markup.h	/^	int x_InsertNew( int iPosParent, int& iPosRel, NodePos& node );$/;"	p	class:CMarkup	access:protected	signature:( int iPosParent, int& iPosRel, NodePos& node )
x_IntToStr	third_party/xml/Markup.cpp	/^MCD_STR x_IntToStr( int n )$/;"	f	signature:( int n )
x_LinkElem	third_party/xml/Markup.cpp	/^void CMarkup::x_LinkElem( int iPosParent, int iPosBefore, int iPos )$/;"	f	class:CMarkup	signature:( int iPosParent, int iPosBefore, int iPos )
x_LinkElem	third_party/xml/Markup.h	/^	void x_LinkElem( int iPosParent, int iPosBefore, int iPos );$/;"	p	class:CMarkup	access:protected	signature:( int iPosParent, int iPosBefore, int iPos )
x_NoDefaultChar	third_party/xml/Markup.cpp	/^bool x_NoDefaultChar( int nCP )$/;"	f	signature:( int nCP )
x_ParseDoc	third_party/xml/Markup.cpp	/^bool CMarkup::x_ParseDoc()$/;"	f	class:CMarkup	signature:()
x_ParseDoc	third_party/xml/Markup.h	/^	bool x_ParseDoc();$/;"	p	class:CMarkup	access:protected	signature:()
x_ParseElem	third_party/xml/Markup.cpp	/^int CMarkup::x_ParseElem( int iPosParent, TokenPos& token )$/;"	f	class:CMarkup	signature:( int iPosParent, TokenPos& token )
x_ParseElem	third_party/xml/Markup.h	/^	int x_ParseElem( int iPos, TokenPos& token );$/;"	p	class:CMarkup	access:protected	signature:( int iPos, TokenPos& token )
x_ReleasePos	third_party/xml/Markup.cpp	/^int CMarkup::x_ReleasePos( int iPos )$/;"	f	class:CMarkup	signature:( int iPos )
x_ReleasePos	third_party/xml/Markup.h	/^	int x_ReleasePos( int iPos );$/;"	p	class:CMarkup	access:protected	signature:( int iPos )
x_ReleaseSubDoc	third_party/xml/Markup.cpp	/^int CMarkup::x_ReleaseSubDoc( int iPos )$/;"	f	class:CMarkup	signature:( int iPos )
x_ReleaseSubDoc	third_party/xml/Markup.h	/^	int x_ReleaseSubDoc( int iPos );$/;"	p	class:CMarkup	access:protected	signature:( int iPos )
x_RemoveElem	third_party/xml/Markup.cpp	/^int CMarkup::x_RemoveElem( int iPos )$/;"	f	class:CMarkup	signature:( int iPos )
x_RemoveElem	third_party/xml/Markup.h	/^	int x_RemoveElem( int iPos );$/;"	p	class:CMarkup	access:protected	signature:( int iPos )
x_RemoveNode	third_party/xml/Markup.cpp	/^void CMarkup::x_RemoveNode( int iPosParent, int& iPos, int& nNodeType, int& nNodeOffset, int& nNodeLength )$/;"	f	class:CMarkup	signature:( int iPosParent, int& iPos, int& nNodeType, int& nNodeOffset, int& nNodeLength )
x_RemoveNode	third_party/xml/Markup.h	/^	void x_RemoveNode( int iPosParent, int& iPos, int& nNodeType, int& nNodeOffset, int& nNodeLength );$/;"	p	class:CMarkup	access:protected	signature:( int iPosParent, int& iPos, int& nNodeType, int& nNodeOffset, int& nNodeLength )
x_SetAttrib	third_party/xml/Markup.cpp	/^bool CMarkup::x_SetAttrib( int iPos, MCD_PCSZ pAttrib, MCD_PCSZ pValue, int nFlags \/*=0*\/ )$/;"	f	class:CMarkup	signature:( int iPos, MCD_PCSZ pAttrib, MCD_PCSZ pValue, int nFlags )
x_SetAttrib	third_party/xml/Markup.cpp	/^bool CMarkup::x_SetAttrib( int iPos, MCD_PCSZ pAttrib, int nValue, int nFlags \/*=0*\/ )$/;"	f	class:CMarkup	signature:( int iPos, MCD_PCSZ pAttrib, int nValue, int nFlags )
x_SetAttrib	third_party/xml/Markup.h	/^	bool x_SetAttrib( int iPos, MCD_PCSZ pAttrib, MCD_PCSZ pValue, int nFlags=0 );$/;"	p	class:CMarkup	access:protected	signature:( int iPos, MCD_PCSZ pAttrib, MCD_PCSZ pValue, int nFlags=0 )
x_SetAttrib	third_party/xml/Markup.h	/^	bool x_SetAttrib( int iPos, MCD_PCSZ pAttrib, int nValue, int nFlags=0 );$/;"	p	class:CMarkup	access:protected	signature:( int iPos, MCD_PCSZ pAttrib, int nValue, int nFlags=0 )
x_SetData	third_party/xml/Markup.cpp	/^bool CMarkup::x_SetData( int iPos, MCD_PCSZ szData, int nFlags )$/;"	f	class:CMarkup	signature:( int iPos, MCD_PCSZ szData, int nFlags )
x_SetData	third_party/xml/Markup.cpp	/^bool CMarkup::x_SetData( int iPos, int nValue )$/;"	f	class:CMarkup	signature:( int iPos, int nValue )
x_SetData	third_party/xml/Markup.h	/^	bool x_SetData( int iPos, MCD_PCSZ szData, int nFlags );$/;"	p	class:CMarkup	access:protected	signature:( int iPos, MCD_PCSZ szData, int nFlags )
x_SetData	third_party/xml/Markup.h	/^	bool x_SetData( int iPos, int nValue );$/;"	p	class:CMarkup	access:protected	signature:( int iPos, int nValue )
x_SetDebugState	third_party/xml/Markup.cpp	/^void CMarkup::x_SetDebugState()$/;"	f	class:CMarkup	signature:()
x_SetDebugState	third_party/xml/Markup.h	/^	void x_SetDebugState();$/;"	p	class:CMarkup	access:protected	signature:()
x_SetElemContent	third_party/xml/Markup.cpp	/^bool CMarkup::x_SetElemContent( MCD_PCSZ szContent )$/;"	f	class:CMarkup	signature:( MCD_PCSZ szContent )
x_SetElemContent	third_party/xml/Markup.h	/^	bool x_SetElemContent( MCD_PCSZ szContent );$/;"	p	class:CMarkup	access:protected	signature:( MCD_PCSZ szContent )
x_SetPos	third_party/xml/Markup.cpp	/^void CMarkup::x_SetPos( int iPosParent, int iPos, int iPosChild )$/;"	f	class:CMarkup	signature:( int iPosParent, int iPos, int iPosChild )
x_SetPos	third_party/xml/Markup.h	/^	void x_SetPos( int iPosParent, int iPos, int iPosChild );$/;"	p	class:CMarkup	access:protected	signature:( int iPosParent, int iPos, int iPosChild )
x_StrInsertReplace	third_party/xml/Markup.cpp	/^void x_StrInsertReplace( MCD_STR& str, int nLeft, int nReplace, const MCD_STR& strInsert )$/;"	f	signature:( MCD_STR& str, int nLeft, int nReplace, const MCD_STR& strInsert )
x_UnlinkElem	third_party/xml/Markup.cpp	/^int CMarkup::x_UnlinkElem( int iPos )$/;"	f	class:CMarkup	signature:( int iPos )
x_UnlinkElem	third_party/xml/Markup.h	/^	int x_UnlinkElem( int iPos );$/;"	p	class:CMarkup	access:protected	signature:( int iPos )
x_UnlinkPrevElem	third_party/xml/Markup.cpp	/^int CMarkup::x_UnlinkPrevElem( int iPosParent, int iPosBefore, int iPos )$/;"	f	class:CMarkup	signature:( int iPosParent, int iPosBefore, int iPos )
x_UnlinkPrevElem	third_party/xml/Markup.h	/^	int x_UnlinkPrevElem( int iPosParent, int iPosBefore, int iPos );$/;"	p	class:CMarkup	access:protected	signature:( int iPosParent, int iPosBefore, int iPos )
xmlfile	syntax/global_values.cpp	/^typedef xml::CMarkup xmlfile;$/;"	t	file:
xregex	third_party/regex/xregex.cpp	/^xregex::xregex(void)$/;"	f	class:stringX::xregex	signature:(void)
xregex	third_party/regex/xregex.h	/^	xregex(void);$/;"	p	class:stringX::xregex	access:public	signature:(void)
xregex	third_party/regex/xregex.h	/^class xregex$/;"	c	namespace:stringX
xstring	include/stringX.h	/^typedef xstring_basic<char> xstring;$/;"	t
xstring_basic	include/stringX.h	/^	xstring_basic()$/;"	f	class:xstring_basic	access:public	signature:()
xstring_basic	include/stringX.h	/^	xstring_basic(_It _First, _It _Last)$/;"	f	class:xstring_basic	access:public	signature:(_It _First, _It _Last)
xstring_basic	include/stringX.h	/^	xstring_basic(const _Elem* _Ptr)$/;"	f	class:xstring_basic	access:public	signature:(const _Elem* _Ptr)
xstring_basic	include/stringX.h	/^	xstring_basic(const _Elem* _Ptr, size_t _Count)$/;"	f	class:xstring_basic	access:public	signature:(const _Elem* _Ptr, size_t _Count)
xstring_basic	include/stringX.h	/^	xstring_basic(const _Mybase& _Right, size_t _Roff, size_t n = _Mybase::npos)$/;"	f	class:xstring_basic	access:public	signature:(const _Mybase& _Right, size_t _Roff, size_t n = _Mybase::npos)
xstring_basic	include/stringX.h	/^	xstring_basic(const _Mybase& str)$/;"	f	class:xstring_basic	access:public	signature:(const _Mybase& str)
xstring_basic	include/stringX.h	/^	xstring_basic(size_t _Count, _Elem _Ch)$/;"	f	class:xstring_basic	access:public	signature:(size_t _Count, _Elem _Ch)
xstring_basic	include/stringX.h	/^class xstring_basic$/;"	c	inherits:std::basic_string
xstring_basic::OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(append, const _Elem*, _Ptr);$/;"	p	class:xstring_basic	access:public	signature:(append, const _Elem*, _Ptr)
xstring_basic::OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(append, const _Mybase&, _Right);$/;"	p	class:xstring_basic	access:public	signature:(append, const _Mybase&, _Right)
xstring_basic::OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(assign, const _Elem*, _Ptr);$/;"	p	class:xstring_basic	access:public	signature:(assign, const _Elem*, _Ptr)
xstring_basic::OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(assign, const _Mybase&, _Right);$/;"	p	class:xstring_basic	access:public	signature:(assign, const _Mybase&, _Right)
xstring_basic::OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(operator+=, _Elem, _Ch);$/;"	p	class:xstring_basic	access:public	signature:(operator+=, _Elem, _Ch)
xstring_basic::OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(operator+=, const _Elem*&, _Ptr);$/;"	p	class:xstring_basic	access:public	signature:(operator+=, const _Elem*&, _Ptr)
xstring_basic::OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(operator+=, const _Mybase&, _Right);$/;"	p	class:xstring_basic	access:public	signature:(operator+=, const _Mybase&, _Right)
xstring_basic::OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(operator=, _Elem, _Ch);$/;"	p	class:xstring_basic	access:public	signature:(operator=, _Elem, _Ch)
xstring_basic::OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(operator=, const _Elem*&, _Ptr);$/;"	p	class:xstring_basic	access:public	signature:(operator=, const _Elem*&, _Ptr)
xstring_basic::OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(operator=, const _Mybase&, _Right);$/;"	p	class:xstring_basic	access:public	signature:(operator=, const _Mybase&, _Right)
xstring_basic::OVERWRITE_FUNCTION_2	include/stringX.h	/^	OVERWRITE_FUNCTION_2(append, _It, _First, _It, _Last);$/;"	p	class:xstring_basic	access:public	signature:(append, _It, _First, _It, _Last)
xstring_basic::OVERWRITE_FUNCTION_2	include/stringX.h	/^	OVERWRITE_FUNCTION_2(append, const _Elem*, _Ptr, size_type, _Count);$/;"	p	class:xstring_basic	access:public	signature:(append, const _Elem*, _Ptr, size_type, _Count)
xstring_basic::OVERWRITE_FUNCTION_2	include/stringX.h	/^	OVERWRITE_FUNCTION_2(append, size_type, _Count, _Elem, _Ch);$/;"	p	class:xstring_basic	access:public	signature:(append, size_type, _Count, _Elem, _Ch)
xstring_basic::OVERWRITE_FUNCTION_2	include/stringX.h	/^	OVERWRITE_FUNCTION_2(assign, _It, _First, _It, _Last);$/;"	p	class:xstring_basic	access:public	signature:(assign, _It, _First, _It, _Last)
xstring_basic::OVERWRITE_FUNCTION_2	include/stringX.h	/^	OVERWRITE_FUNCTION_2(assign, const _Elem*, _Ptr, size_type, _Count);$/;"	p	class:xstring_basic	access:public	signature:(assign, const _Elem*, _Ptr, size_type, _Count)
xstring_basic::OVERWRITE_FUNCTION_2	include/stringX.h	/^	OVERWRITE_FUNCTION_2(assign, size_type, _Count, _Elem, _Ch);$/;"	p	class:xstring_basic	access:public	signature:(assign, size_type, _Count, _Elem, _Ch)
xstring_basic::OVERWRITE_FUNCTION_2	include/stringX.h	/^	OVERWRITE_FUNCTION_2(insert, size_type, _Off, const _Elem*, _Ptr);$/;"	p	class:xstring_basic	access:public	signature:(insert, size_type, _Off, const _Elem*, _Ptr)
xstring_basic::OVERWRITE_FUNCTION_2	include/stringX.h	/^	OVERWRITE_FUNCTION_2(insert, size_type, _Off, const _Mybase&, _Right);$/;"	p	class:xstring_basic	access:public	signature:(insert, size_type, _Off, const _Mybase&, _Right)
xstring_basic::OVERWRITE_FUNCTION_3	include/stringX.h	/^	OVERWRITE_FUNCTION_3(append, const _Mybase&, _Right, size_type, _Roff, size_type, _Count);$/;"	p	class:xstring_basic	access:public	signature:(append, const _Mybase&, _Right, size_type, _Roff, size_type, _Count)
xstring_basic::OVERWRITE_FUNCTION_3	include/stringX.h	/^	OVERWRITE_FUNCTION_3(assign, const _Mybase&, _Right, size_type, _Roff, size_type, _Count);$/;"	p	class:xstring_basic	access:public	signature:(assign, const _Mybase&, _Right, size_type, _Roff, size_type, _Count)
xstring_basic::OVERWRITE_FUNCTION_3	include/stringX.h	/^	OVERWRITE_FUNCTION_3(insert, size_type, _Off, const _Elem*, _Ptr, size_type, _Count);$/;"	p	class:xstring_basic	access:public	signature:(insert, size_type, _Off, const _Elem*, _Ptr, size_type, _Count)
xstring_basic::OVERWRITE_FUNCTION_3	include/stringX.h	/^	OVERWRITE_FUNCTION_3(insert, size_type, _Off, size_type, _Count, _Elem, _Ch);$/;"	p	class:xstring_basic	access:public	signature:(insert, size_type, _Off, size_type, _Count, _Elem, _Ch)
xstring_basic::OVERWRITE_FUNCTION_3	include/stringX.h	/^	OVERWRITE_FUNCTION_3(replace, size_type, _Off, size_type, _N0, const _Elem*, _Ptr);$/;"	p	class:xstring_basic	access:public	signature:(replace, size_type, _Off, size_type, _N0, const _Elem*, _Ptr)
xstring_basic::OVERWRITE_FUNCTION_3	include/stringX.h	/^	OVERWRITE_FUNCTION_3(replace, size_type, _Off, size_type, _N0, const _Myt&, _Right);$/;"	p	class:xstring_basic	access:public	signature:(replace, size_type, _Off, size_type, _N0, const _Myt&, _Right)
xstring_basic::OVERWRITE_FUNCTION_3	include/stringX.h	/^	OVERWRITE_FUNCTION_3(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, const _Elem*, _Ptr);$/;"	p	class:xstring_basic	access:public	signature:(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, const _Elem*, _Ptr)
xstring_basic::OVERWRITE_FUNCTION_3	include/stringX.h	/^	OVERWRITE_FUNCTION_3(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, const _Myt&, _Right);$/;"	p	class:xstring_basic	access:public	signature:(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, const _Myt&, _Right)
xstring_basic::OVERWRITE_FUNCTION_4	include/stringX.h	/^	OVERWRITE_FUNCTION_4(insert, size_type, _Off, const _Mybase&, _Right, size_type, _Roff, size_type, _Count);$/;"	p	class:xstring_basic	access:public	signature:(insert, size_type, _Off, const _Mybase&, _Right, size_type, _Roff, size_type, _Count)
xstring_basic::OVERWRITE_FUNCTION_4	include/stringX.h	/^	OVERWRITE_FUNCTION_4(replace, size_type, _Off, size_type, _N0, const _Elem*, _Ptr, size_type, _Count);$/;"	p	class:xstring_basic	access:public	signature:(replace, size_type, _Off, size_type, _N0, const _Elem*, _Ptr, size_type, _Count)
xstring_basic::OVERWRITE_FUNCTION_4	include/stringX.h	/^	OVERWRITE_FUNCTION_4(replace, size_type, _Off, size_type, _N0, size_type, _Count, _Elem, _Ch);$/;"	p	class:xstring_basic	access:public	signature:(replace, size_type, _Off, size_type, _N0, size_type, _Count, _Elem, _Ch)
xstring_basic::OVERWRITE_FUNCTION_4	include/stringX.h	/^	OVERWRITE_FUNCTION_4(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, _It, _First2, _It, _Last2);$/;"	p	class:xstring_basic	access:public	signature:(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, _It, _First2, _It, _Last2)
xstring_basic::OVERWRITE_FUNCTION_4	include/stringX.h	/^	OVERWRITE_FUNCTION_4(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, const _Elem*, _Ptr, size_type, _Count);$/;"	p	class:xstring_basic	access:public	signature:(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, const _Elem*, _Ptr, size_type, _Count)
xstring_basic::OVERWRITE_FUNCTION_4	include/stringX.h	/^	OVERWRITE_FUNCTION_4(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, size_type, _Count, _Elem, _Ch);$/;"	p	class:xstring_basic	access:public	signature:(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, size_type, _Count, _Elem, _Ch)
xstring_basic::_Ctptr	include/stringX.h	/^	typedef typename _Mybase::const_pointer _Ctptr;$/;"	t	class:xstring_basic	access:public
xstring_basic::_Dift	include/stringX.h	/^	typedef typename _Mybase::difference_type _Dift;$/;"	t	class:xstring_basic	access:public
xstring_basic::_IStream	include/stringX.h	/^	typedef std::basic_istringstream<_Elem, _Traits, _Ax> _IStream;$/;"	t	class:xstring_basic	access:public
xstring_basic::_Mybase	include/stringX.h	/^	typedef std::basic_string<_Elem, _Traits, _Ax> _Mybase;$/;"	t	class:xstring_basic	access:public
xstring_basic::_Myt	include/stringX.h	/^	typedef xstring_basic<_Elem, _Traits, _Ax> _Myt;$/;"	t	class:xstring_basic	access:public
xstring_basic::_OStream	include/stringX.h	/^	typedef std::basic_ostringstream<_Elem, _Traits, _Ax> _OStream;$/;"	t	class:xstring_basic	access:public
xstring_basic::_Reft	include/stringX.h	/^	typedef typename _Mybase::reference _Reft;$/;"	t	class:xstring_basic	access:public
xstring_basic::_Stream	include/stringX.h	/^	typedef std::basic_stringstream<_Elem, _Traits, _Ax> _Stream;$/;"	t	class:xstring_basic	access:public
xstring_basic::_Tptr	include/stringX.h	/^	typedef typename _Mybase::pointer _Tptr;$/;"	t	class:xstring_basic	access:public
xstring_basic::base	include/stringX.h	/^	_Mybase& base()$/;"	f	class:xstring_basic	access:public	signature:()
xstring_basic::base	include/stringX.h	/^	const _Mybase& base() const$/;"	f	class:xstring_basic	access:public	signature:() const
xstring_basic::const_pointer	include/stringX.h	/^	typedef _Ctptr const_pointer;$/;"	t	class:xstring_basic	access:public
xstring_basic::const_reference	include/stringX.h	/^	typedef typename _Mybase::const_reference const_reference;$/;"	t	class:xstring_basic	access:public
xstring_basic::difference_type	include/stringX.h	/^	typedef _Dift difference_type;$/;"	t	class:xstring_basic	access:public
xstring_basic::erase	include/stringX.h	/^	_Myt& erase(size_type _Off = 0, size_type _Count = _Mybase::npos)$/;"	f	class:xstring_basic	access:public	signature:(size_type _Off = 0, size_type _Count = _Mybase::npos)
xstring_basic::format	include/stringX.h	/^	static _Myt format(const _Elem* fmt, ...)$/;"	f	class:xstring_basic	access:public	signature:(const _Elem* fmt, ...)
xstring_basic::getstream	include/stringX.h	/^	bool getstream(_IStream& _istream)$/;"	f	class:xstring_basic	access:public	signature:(_IStream& _istream)
xstring_basic::getstream	include/stringX.h	/^	bool getstream(_OStream& _ostream)$/;"	f	class:xstring_basic	access:public	signature:(_OStream& _ostream)
xstring_basic::getstream	include/stringX.h	/^	bool getstream(_Stream& _stream)$/;"	f	class:xstring_basic	access:public	signature:(_Stream& _stream)
xstring_basic::isdigit	include/stringX.h	/^	static bool isdigit(_Elem _Ch)$/;"	f	class:xstring_basic	access:public	signature:(_Elem _Ch)
xstring_basic::isinteger	include/stringX.h	/^	static bool isinteger(const _Myt& _Str)$/;"	f	class:xstring_basic	access:public	signature:(const _Myt& _Str)
xstring_basic::islatter	include/stringX.h	/^	static bool islatter(_Elem _Ch)$/;"	f	class:xstring_basic	access:public	signature:(_Elem _Ch)
xstring_basic::isspace	include/stringX.h	/^	static bool isspace(_Elem _Ch)$/;"	f	class:xstring_basic	access:public	signature:(_Elem _Ch)
xstring_basic::operator +	include/stringX.h	/^	_Myt operator +(const _Elem _Right) const$/;"	f	class:xstring_basic	access:public	signature:(const _Elem _Right) const
xstring_basic::operator +	include/stringX.h	/^	_Myt operator +(const _Elem* _Right) const$/;"	f	class:xstring_basic	access:public	signature:(const _Elem* _Right) const
xstring_basic::operator +	include/stringX.h	/^	_Myt operator +(const _Mybase& _Right) const$/;"	f	class:xstring_basic	access:public	signature:(const _Mybase& _Right) const
xstring_basic::operator +	include/stringX.h	/^	_Myt operator +(const _Tz& _tz) const$/;"	f	class:xstring_basic	access:public	signature:(const _Tz& _tz) const
xstring_basic::operator +=	include/stringX.h	/^	_Myt& operator +=(const _Myt& _Right)$/;"	f	class:xstring_basic	access:public	signature:(const _Myt& _Right)
xstring_basic::operator +=	include/stringX.h	/^	_Myt& operator +=(const _Tz& _tz)$/;"	f	class:xstring_basic	access:public	signature:(const _Tz& _tz)
xstring_basic::operator _Mybase&	include/stringX.h	/^	operator _Mybase&()$/;"	f	class:xstring_basic	access:public	signature:()
xstring_basic::operator const _Mybase&	include/stringX.h	/^	operator const _Mybase&() const$/;"	f	class:xstring_basic	access:public	signature:() const
xstring_basic::parse	include/stringX.h	/^	static _Tz parse(const _Myt& str)$/;"	f	class:xstring_basic	access:public	signature:(const _Myt& str)
xstring_basic::pointer	include/stringX.h	/^	typedef _Tptr pointer;$/;"	t	class:xstring_basic	access:public
xstring_basic::reference	include/stringX.h	/^	typedef _Reft reference;$/;"	t	class:xstring_basic	access:public
xstring_basic::replace	include/stringX.h	/^	_Myt& replace(size_type _Off,$/;"	f	class:xstring_basic	access:public	signature:(size_type _Off, size_type _N0, const _Mybase& _Right, size_type _Roff, size_type _Count)
xstring_basic::size_type	include/stringX.h	/^	typedef typename _Mybase::size_type size_type;$/;"	t	class:xstring_basic	access:public
xstring_basic::substr	include/stringX.h	/^	_Myt substr(size_type _Off = 0, size_type _Count = _Mybase::npos) const$/;"	f	class:xstring_basic	access:public	signature:(size_type _Off = 0, size_type _Count = _Mybase::npos) const
xstring_basic::to_lower	include/stringX.h	/^	_Myt& to_lower()$/;"	f	class:xstring_basic	access:public	signature:()
xstring_basic::to_upper	include/stringX.h	/^	_Myt& to_upper()$/;"	f	class:xstring_basic	access:public	signature:()
xstring_basic::tostring	include/stringX.h	/^	static _Myt tostring(const _Tz& _value)$/;"	f	class:xstring_basic	access:public	signature:(const _Tz& _value)
xstring_basic::trim	include/stringX.h	/^	_Myt& trim(int _TrimType = trim_both)$/;"	f	class:xstring_basic	access:public	signature:(int _TrimType = trim_both)
xstring_basic::trim	include/stringX.h	/^	static _Myt trim(const _Myt& _Str, int _TrimType = 3)$/;"	f	class:xstring_basic	access:public	signature:(const _Myt& _Str, int _TrimType = 3)
xstring_basic::trim_begin	include/stringX.h	/^	enum {trim_begin, trim_end, trim_both};$/;"	e	enum:xstring_basic::__anon4
xstring_basic::trim_both	include/stringX.h	/^	enum {trim_begin, trim_end, trim_both};$/;"	e	enum:xstring_basic::__anon4
xstring_basic::trim_end	include/stringX.h	/^	enum {trim_begin, trim_end, trim_both};$/;"	e	enum:xstring_basic::__anon4
xstring_basic::tryparse	include/stringX.h	/^	static bool tryparse(const _Myt& str, _Tz& _tz)$/;"	f	class:xstring_basic	access:public	signature:(const _Myt& str, _Tz& _tz)
xstring_basic::tryparse	include/stringX.h	/^	static bool tryparse(const _Myt& str, _Tz& _tz, std::string& exceptionMsg)$/;"	f	class:xstring_basic	access:private	signature:(const _Myt& str, _Tz& _tz, std::string& exceptionMsg)
xstring_basic::value_type	include/stringX.h	/^	typedef typename _Mybase::value_type value_type;$/;"	t	class:xstring_basic	access:public
xstring_basic::xstring_basic	include/stringX.h	/^	xstring_basic()$/;"	f	class:xstring_basic	access:public	signature:()
xstring_basic::xstring_basic	include/stringX.h	/^	xstring_basic(_It _First, _It _Last)$/;"	f	class:xstring_basic	access:public	signature:(_It _First, _It _Last)
xstring_basic::xstring_basic	include/stringX.h	/^	xstring_basic(const _Elem* _Ptr)$/;"	f	class:xstring_basic	access:public	signature:(const _Elem* _Ptr)
xstring_basic::xstring_basic	include/stringX.h	/^	xstring_basic(const _Elem* _Ptr, size_t _Count)$/;"	f	class:xstring_basic	access:public	signature:(const _Elem* _Ptr, size_t _Count)
xstring_basic::xstring_basic	include/stringX.h	/^	xstring_basic(const _Mybase& _Right, size_t _Roff, size_t n = _Mybase::npos)$/;"	f	class:xstring_basic	access:public	signature:(const _Mybase& _Right, size_t _Roff, size_t n = _Mybase::npos)
xstring_basic::xstring_basic	include/stringX.h	/^	xstring_basic(const _Mybase& str)$/;"	f	class:xstring_basic	access:public	signature:(const _Mybase& str)
xstring_basic::xstring_basic	include/stringX.h	/^	xstring_basic(size_t _Count, _Elem _Ch)$/;"	f	class:xstring_basic	access:public	signature:(size_t _Count, _Elem _Ch)
xstringcat	include/stringX.h	/^xstring_basic<_Elem> xstringcat(const _Elem* str1, const _Elem* str2)$/;"	f	signature:(const _Elem* str1, const _Elem* str2)
xwstring	include/stringX.h	/^typedef xstring_basic<wchar_t> xwstring;$/;"	t
y	tmp/sizetest.cpp	/^	short y;$/;"	m	struct:A	file:	access:public
z	tmp/sizetest.cpp	/^	char z;$/;"	m	struct:A	file:	access:public
~CMarkup	third_party/xml/Markup.cpp	/^CMarkup::~CMarkup()$/;"	f	class:CMarkup	signature:()
~CMarkup	third_party/xml/Markup.h	/^	~CMarkup();$/;"	p	class:CMarkup	access:public	signature:()
~ElemPosTree	third_party/xml/Markup.cpp	/^	~ElemPosTree() { Release(); };$/;"	f	struct:ElemPosTree	access:public	signature:()
~ElemStack	third_party/xml/Markup.cpp	/^	~ElemStack() { if (pL) delete [] pL; };$/;"	f	struct:ElemStack	access:public	signature:()
~SavedPosMap	third_party/xml/Markup.cpp	/^	~SavedPosMap() { if (pTable) { for (int n=0;n<nMapSize;++n) if (pTable[n]) delete[] pTable[n]; delete[] pTable; } };$/;"	f	struct:SavedPosMap	access:public	signature:()
~SavedPosMapArray	third_party/xml/Markup.cpp	/^	~SavedPosMapArray() { ReleaseMaps(); };$/;"	f	struct:SavedPosMapArray	access:public	signature:()
~automachine	syntax/automachine.cpp	/^automachine::~automachine()$/;"	f	class:automachine	signature:()
~automachine	syntax/automachine.h	/^	virtual ~automachine();$/;"	p	class:automachine	access:public	signature:()
~block	include/arrayX.h	/^		~block()$/;"	f	struct:smart_vector::block	access:public	signature:()
~compiler	compiler/compiler.cpp	/^compiler::~compiler()$/;"	f	class:compiler	signature:()
~compiler	compiler/compiler.h	/^    ~compiler();$/;"	p	class:compiler	access:public	signature:()
~file	include/markuputils.h	/^	virtual ~file()$/;"	f	class:file	access:public	signature:()
~global_values	syntax/global_values.h	/^	~global_values()$/;"	f	class:global_values	access:public	signature:()
~grammar	syntax/grammar.cpp	/^grammar::~grammar()$/;"	f	class:grammar	signature:()
~grammar	syntax/grammar.h	/^	virtual ~grammar();$/;"	p	class:grammar	access:public	signature:()
~heap	include/heapX.h	/^	~heap()$/;"	f	class:heap	access:public	signature:()
~holder	syntax/global_values.h	/^		virtual ~holder() = 0 {};$/;"	p	class:refobject::holder	access:public	signature:()
~holder	syntax/global_values.h	/^		virtual ~holder() {};$/;"	f	class:refobject::holder	access:public	signature:()
~interlanguage	compiler/interlanguage.cpp	/^interlanguage::~interlanguage()$/;"	f	class:interlanguage	signature:()
~interlanguage	compiler/interlanguage.h	/^    virtual ~interlanguage();$/;"	p	class:interlanguage	access:public	signature:()
~lalr1machine	compiler/lalr1machine.cpp	/^lalr1machine::~lalr1machine()$/;"	f	class:lalr1machine	signature:()
~lalr1machine	compiler/lalr1machine.h	/^	virtual ~lalr1machine();$/;"	p	class:lalr1machine	access:public	signature:()
~loader	syntax/loader.h	/^	virtual ~loader();$/;"	p	class:loader	access:public	signature:()
~logger	include/logger.h	/^	~logger()$/;"	f	class:logger	access:public	signature:()
~loggermanager	include/logger.h	/^	~loggermanager()$/;"	f	class:loggermanager	access:public	signature:()
~object	compiler/object.h	/^    virtual ~object()$/;"	f	struct:object	access:public	signature:()
~ptr_container	include/pointholder.h	/^	~ptr_container()$/;"	f	class:ptr_container	access:public	signature:()
~refobject	syntax/global_values.h	/^	~refobject()$/;"	f	class:refobject	access:public	signature:()
~scerror	include/scerror.h	/^	~scerror() throw()$/;"	f	class:scerror	access:public	signature:()
~scope	compiler/scope.cpp	/^scope::~scope()$/;"	f	class:scope	signature:()
~scope	compiler/scope.h	/^    ~scope();$/;"	p	class:scope	access:public	signature:()
~shared_ptr	include/shared_ptr.h	/^		~shared_ptr() { decref(); }$/;"	f	class:shared_ptr	access:public	signature:()
~singleton	include/singleton.h	/^	virtual ~singleton(){} \/\/ make sure correct deconstruct$/;"	f	class:singleton	access:protected	signature:()
~state_machine	syntax/statemachine.cpp	/^state_machine::~state_machine()$/;"	f	class:state_machine	signature:()
~state_machine	syntax/statemachine.h	/^	virtual ~state_machine();$/;"	p	class:state_machine	access:public	signature:()
~streamsplit	compiler/extract.cpp	/^compile::doc::streamsplit::~streamsplit()$/;"	f	class:compile::doc::streamsplit	signature:()
~streamsplit	compiler/extract.h	/^	virtual ~streamsplit();$/;"	p	class:streamsplit	access:public	signature:()
~syntaxgenerator	makecompiler/gensyntax.cpp	/^syntaxgenerator::~syntaxgenerator()$/;"	f	class:syntaxgenerator	signature:()
~syntaxgenerator	makecompiler/gensyntax.h	/^	virtual ~syntaxgenerator();$/;"	p	class:syntaxgenerator	access:public	signature:()
~tinygrammar	syntax/grammar.cpp	/^tinygrammar::~tinygrammar()$/;"	f	class:tinygrammar	signature:()
~tinygrammar	syntax/grammar.h	/^	virtual ~tinygrammar();$/;"	p	class:tinygrammar	access:public	signature:()
~tree	include/tree.h	/^	~tree()$/;"	f	class:tree	access:public	signature:()
~typesystem	compiler/type.cpp	/^typesystem::~typesystem()$/;"	f	class:typesystem	signature:()
~typesystem	compiler/type.h	/^    virtual ~typesystem();$/;"	p	class:typesystem	access:public	signature:()
~unittest	test/unittest.cpp	/^unittest::~unittest(void)$/;"	f	class:unittest	signature:(void)
~unittest	test/unittest.h	/^	virtual ~unittest(void);$/;"	p	class:unittest	access:public	signature:(void)
~xregex	third_party/regex/xregex.cpp	/^xregex::~xregex(void)$/;"	f	class:stringX::xregex	signature:(void)
~xregex	third_party/regex/xregex.h	/^	~xregex(void);$/;"	p	class:stringX::xregex	access:public	signature:(void)
