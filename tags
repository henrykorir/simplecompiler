!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
A	tmp/protected.cpp	/^class A : protected base$/;"	c	file:	inherits:base
A	tmp/sizetest.cpp	/^struct A$/;"	s	file:
A::m	tmp/sizetest.cpp	/^	char m;$/;"	m	struct:A	file:	access:public
A::x	tmp/sizetest.cpp	/^	int x;$/;"	m	struct:A	file:	access:public
A::y	tmp/sizetest.cpp	/^	short y;$/;"	m	struct:A	file:	access:public
A::z	tmp/sizetest.cpp	/^	char z;$/;"	m	struct:A	file:	access:public
AExpression	test/output/gen.cpp	/^	AExpression()$/;"	f	struct:AExpression	access:public	signature:()
AExpression	test/output/gen.cpp	/^struct AExpression : public type$/;"	s	file:	inherits:type
AExpression	test/output/tinyg.cpp	/^	AExpression()$/;"	f	struct:AExpression	access:public	signature:()
AExpression	test/output/tinyg.cpp	/^struct AExpression : public type$/;"	s	file:	inherits:type
AExpression::AExpression	test/output/gen.cpp	/^	AExpression()$/;"	f	struct:AExpression	access:public	signature:()
AExpression::AExpression	test/output/tinyg.cpp	/^	AExpression()$/;"	f	struct:AExpression	access:public	signature:()
AExpression::sid	test/output/gen.cpp	/^	enum{ sid = 1001 };$/;"	e	enum:AExpression::__anon8	file:
AExpression::sid	test/output/tinyg.cpp	/^	enum{ sid = 7 };$/;"	e	enum:AExpression::__anon42	file:
AProgramItem	test/output/gen.cpp	/^	AProgramItem()$/;"	f	struct:AProgramItem	access:public	signature:()
AProgramItem	test/output/gen.cpp	/^struct AProgramItem : public type$/;"	s	file:	inherits:type
AProgramItem	test/output/tinyg.cpp	/^	AProgramItem()$/;"	f	struct:AProgramItem	access:public	signature:()
AProgramItem	test/output/tinyg.cpp	/^struct AProgramItem : public type$/;"	s	file:	inherits:type
AProgramItem::AProgramItem	test/output/gen.cpp	/^	AProgramItem()$/;"	f	struct:AProgramItem	access:public	signature:()
AProgramItem::AProgramItem	test/output/tinyg.cpp	/^	AProgramItem()$/;"	f	struct:AProgramItem	access:public	signature:()
AProgramItem::sid	test/output/gen.cpp	/^	enum{ sid = 1002 };$/;"	e	enum:AProgramItem::__anon9	file:
AProgramItem::sid	test/output/tinyg.cpp	/^	enum{ sid = 1 };$/;"	e	enum:AProgramItem::__anon36	file:
AToUTF8	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::AToUTF8( MCD_CSTR pszANSI )$/;"	f	class:CMarkup	signature:( MCD_CSTR pszANSI )
AToUTF8	third_party/xml/Markup.h	/^	static MCD_STR AToUTF8( MCD_CSTR pszANSI );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR pszANSI )
AValue	test/output/gen.cpp	/^	AValue()$/;"	f	struct:AValue	access:public	signature:()
AValue	test/output/gen.cpp	/^struct AValue : public type$/;"	s	file:	inherits:type
AValue	test/output/tinyg.cpp	/^	AValue()$/;"	f	struct:AValue	access:public	signature:()
AValue	test/output/tinyg.cpp	/^struct AValue : public type$/;"	s	file:	inherits:type
AValue::AValue	test/output/gen.cpp	/^	AValue()$/;"	f	struct:AValue	access:public	signature:()
AValue::AValue	test/output/tinyg.cpp	/^	AValue()$/;"	f	struct:AValue	access:public	signature:()
AValue::sid	test/output/gen.cpp	/^	enum{ sid = 1003 };$/;"	e	enum:AValue::__anon10	file:
AValue::sid	test/output/tinyg.cpp	/^	enum{ sid = 8 };$/;"	e	enum:AValue::__anon43	file:
AWConvert	include/stringXF.h	/^struct AWConvert$/;"	s
AddAttrib	third_party/xml/Markup.h	/^	bool AddAttrib( MCD_CSTR szAttrib, MCD_CSTR szValue ) { return x_SetAttrib(m_iPos,szAttrib,szValue); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib, MCD_CSTR szValue )
AddAttrib	third_party/xml/Markup.h	/^	bool AddAttrib( MCD_CSTR szAttrib, int nValue ) { return x_SetAttrib(m_iPos,szAttrib,nValue); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib, int nValue )
AddChildAttrib	third_party/xml/Markup.h	/^	bool AddChildAttrib( MCD_CSTR szAttrib, MCD_CSTR szValue ) { return x_SetAttrib(m_iPosChild,szAttrib,szValue); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib, MCD_CSTR szValue )
AddChildAttrib	third_party/xml/Markup.h	/^	bool AddChildAttrib( MCD_CSTR szAttrib, int nValue ) { return x_SetAttrib(m_iPosChild,szAttrib,nValue); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib, int nValue )
AddChildElem	third_party/xml/Markup.h	/^	bool AddChildElem( MCD_CSTR szName, MCD_CSTR szData=NULL, int nFlags=0 ) { return x_AddElem(szName,szData,nFlags|MNF_CHILD); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szName, MCD_CSTR szData=NULL, int nFlags=0 )
AddChildElem	third_party/xml/Markup.h	/^	bool AddChildElem( MCD_CSTR szName, int nValue, int nFlags=0 ) { return x_AddElem(szName,nValue,nFlags|MNF_CHILD); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szName, int nValue, int nFlags=0 )
AddChildSubDoc	third_party/xml/Markup.h	/^	bool AddChildSubDoc( MCD_CSTR szSubDoc ) { return x_AddSubDoc(szSubDoc,MNF_CHILD); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szSubDoc )
AddElem	third_party/xml/Markup.h	/^	bool AddElem( MCD_CSTR szName, MCD_CSTR szData=NULL, int nFlags=0 ) { return x_AddElem(szName,szData,nFlags); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szName, MCD_CSTR szData=NULL, int nFlags=0 )
AddElem	third_party/xml/Markup.h	/^	bool AddElem( MCD_CSTR szName, int nValue, int nFlags=0 ) { return x_AddElem(szName,nValue,nFlags); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szName, int nValue, int nFlags=0 )
AddNode	third_party/xml/Markup.h	/^	bool AddNode( int nType, MCD_CSTR szText ) { return x_AddNode(nType,szText,0); };$/;"	f	class:CMarkup	access:public	signature:( int nType, MCD_CSTR szText )
AddSubDoc	third_party/xml/Markup.h	/^	bool AddSubDoc( MCD_CSTR szSubDoc ) { return x_AddSubDoc(szSubDoc,0); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szSubDoc )
AdjustStartTagLen	third_party/xml/Markup.cpp	/^	void AdjustStartTagLen( int n ) { nStartTagLen += n; };$/;"	f	struct:ElemPos	access:public	signature:( int n )
Algorithm::update_closure	galgorithm/lranalyse.cpp	/^void Algorithm::update_closure(lrstateitem& li)$/;"	f	class:Algorithm	signature:(lrstateitem& li)
AlgorithmArg	galgorithm/lranalyse.cpp	/^	AlgorithmArg(const grammar& orggrammar);$/;"	p	struct:AlgorithmArg	file:	access:public	signature:(const grammar& orggrammar)
AlgorithmArg	galgorithm/lranalyse.cpp	/^AlgorithmArg::AlgorithmArg(const grammar& orggrammar)$/;"	f	class:AlgorithmArg	signature:(const grammar& orggrammar)
AlgorithmArg	galgorithm/lranalyse.cpp	/^struct AlgorithmArg$/;"	s	file:
AlgorithmArg::AlgorithmArg	galgorithm/lranalyse.cpp	/^	AlgorithmArg(const grammar& orggrammar);$/;"	p	struct:AlgorithmArg	file:	access:public	signature:(const grammar& orggrammar)
AlgorithmArg::AlgorithmArg	galgorithm/lranalyse.cpp	/^AlgorithmArg::AlgorithmArg(const grammar& orggrammar)$/;"	f	class:AlgorithmArg	signature:(const grammar& orggrammar)
AlgorithmArg::CheckLR1	galgorithm/lranalyse.cpp	/^bool AlgorithmArg::CheckLR1(const automachine::sheetrow& sortedActs) const$/;"	f	class:AlgorithmArg	signature:(const automachine::sheetrow& sortedActs) const
AlgorithmArg::FirstSets	galgorithm/lranalyse.cpp	/^	 FirstSets;$/;"	m	struct:AlgorithmArg	file:	access:public
AlgorithmArg::GetFirsts	galgorithm/lranalyse.cpp	/^bool AlgorithmArg::GetFirsts(right_range range, std::list<size_t>& Follows) const$/;"	f	class:AlgorithmArg	signature:(right_range range, std::list<size_t>& Follows) const
AlgorithmArg::GetNextSymbol	galgorithm/lranalyse.cpp	/^size_t AlgorithmArg::GetNextSymbol(size_t prodNo, size_t dotPos) const$/;"	f	class:AlgorithmArg	signature:(size_t prodNo, size_t dotPos) const
AlgorithmArg::GetNextSymbols	galgorithm/lranalyse.cpp	/^			AlgorithmArg::GetNextSymbols(size_t prodNo, size_t dotPos) const$/;"	f	class:AlgorithmArg	signature:(size_t prodNo, size_t dotPos) const
AlgorithmArg::IsTerminate	galgorithm/lranalyse.cpp	/^	std::vector<int> IsTerminate;$/;"	m	struct:AlgorithmArg	file:	access:public
AlgorithmArg::IsVNEmpty	galgorithm/lranalyse.cpp	/^	std::vector<int> IsVNEmpty;$/;"	m	struct:AlgorithmArg	file:	access:public
AlgorithmArg::grammar	galgorithm/lranalyse.cpp	/^	const grammar& grammar;$/;"	m	struct:AlgorithmArg	file:	access:public
AlgorithmArg::lrsts	galgorithm/lranalyse.cpp	/^	std::list<lrstate> lrsts;$/;"	m	struct:AlgorithmArg	file:	access:public
AlgorithmArg::productionMap	galgorithm/lranalyse.cpp	/^	std::vector<size_t> productionMap;$/;"	m	struct:AlgorithmArg	file:	access:public
AlgorithmArg::refProductions	galgorithm/lranalyse.cpp	/^	const kog::smart_vector<production>* refProductions;$/;"	m	struct:AlgorithmArg	file:	access:public
AlgorithmArg::right_iterator	galgorithm/lranalyse.cpp	/^	typedef std::list<size_t>::const_iterator right_iterator;$/;"	t	struct:AlgorithmArg	file:	access:public
AlgorithmArg::right_range	galgorithm/lranalyse.cpp	/^	typedef std::pair<right_iterator, right_iterator> right_range;$/;"	t	struct:AlgorithmArg	file:	access:public
AlgorithmArg::sparsesheet	galgorithm/lranalyse.cpp	/^	std::list<kog::triple<const lrstate*, int32, nextstate> > sparsesheet;$/;"	m	struct:AlgorithmArg	file:	access:public
AlgorithmArg::update_closure	galgorithm/lranalyse.cpp	/^	void update_closure(lrstate& lrs) const;$/;"	p	struct:AlgorithmArg	file:	access:public	signature:(lrstate& lrs) const
AlgorithmArg::update_firsts	galgorithm/lranalyse.cpp	/^	void update_firsts(lrstateitem& snew, const lrstateitem& sorg) const;$/;"	p	struct:AlgorithmArg	file:	access:public	signature:(lrstateitem& snew, const lrstateitem& sorg) const
Algorithm_IsLR1::AlgorithmArg::UpdateClosure	galgorithm/lranalyse.cpp	/^size_t Algorithm_IsLR1::AlgorithmArg::UpdateClosure(LR::LRState& orgState) const$/;"	f	class:Algorithm_IsLR1::AlgorithmArg	signature:(LR::LRState& orgState) const
Alloc	third_party/xml/Markup.cpp	/^	void Alloc( int nNewSize ) { TagPos* pLNew = new TagPos[nNewSize]; Copy(pLNew); nSize=nNewSize; };$/;"	f	struct:ElemStack	access:protected	signature:( int nNewSize )
Aproduction	test/vhelp.h	/^	Aproduction(int32 L, const V& v)$/;"	f	class:Aproduction	access:public	signature:(int32 L, const V& v)
Aproduction	test/vhelp.h	/^class Aproduction : public compile::production$/;"	c	inherits:compile::production
Aproduction::Aproduction	test/vhelp.h	/^	Aproduction(int32 L, const V& v)$/;"	f	class:Aproduction	access:public	signature:(int32 L, const V& v)
Aproduction::int32	test/vhelp.h	/^	typedef compile::int32 int32;$/;"	t	class:Aproduction	access:private
Aproduction::tstring	test/vhelp.h	/^	typedef compile::tstring tstring;$/;"	t	class:Aproduction	access:private
Asymbol	test/vhelp.h	/^	Asymbol(const tstring& sname, int32 ist, const tstring& regex_exp = "")$/;"	f	class:Asymbol	access:public	signature:(const tstring& sname, int32 ist, const tstring& regex_exp = Ó)
Asymbol	test/vhelp.h	/^class Asymbol : public compile::symbol$/;"	c	inherits:compile::symbol
Asymbol::Asymbol	test/vhelp.h	/^	Asymbol(const tstring& sname, int32 ist, const tstring& regex_exp = "")$/;"	f	class:Asymbol	access:public	signature:(const tstring& sname, int32 ist, const tstring& regex_exp = Ó)
Asymbol::int32	test/vhelp.h	/^	typedef compile::int32 int32;$/;"	t	class:Asymbol	access:private
Asymbol::keywords	test/tinygrammartest.cpp	/^std::deque<std::pair<tstring, int32> > Asymbol::keywords;$/;"	m	class:Asymbol	file:
Asymbol::keywords	test/vhelp.h	/^	static std::deque<std::pair<tstring, int32> > keywords;$/;"	m	class:Asymbol	access:public
Asymbol::smacs	test/tinygrammartest.cpp	/^std::deque<std::pair<tstring, int32> > Asymbol::smacs;$/;"	m	class:Asymbol	file:
Asymbol::smacs	test/vhelp.h	/^	static std::deque<std::pair<tstring, int32> > smacs;$/;"	m	class:Asymbol	access:public
Asymbol::stringBuf	test/tinygrammartest.cpp	/^std::deque<tchar> Asymbol::stringBuf;$/;"	m	class:Asymbol	file:
Asymbol::stringBuf	test/vhelp.h	/^	static std::deque<tchar> stringBuf;$/;"	m	class:Asymbol	access:public
Asymbol::tchar	test/vhelp.h	/^	typedef compile::tchar tchar;$/;"	t	class:Asymbol	access:private
Asymbol::tstring	test/vhelp.h	/^	typedef compile::tstring tstring;$/;"	t	class:Asymbol	access:private
AttribPredicateMatch	third_party/xml/Markup.cpp	/^	bool AttribPredicateMatch( TokenPos& token );$/;"	p	struct:PathPos	file:	access:public	signature:( TokenPos& token )
AttribPredicateMatch	third_party/xml/Markup.cpp	/^bool PathPos::AttribPredicateMatch( TokenPos& token )$/;"	f	class:PathPos	signature:( TokenPos& token )
BomTable	third_party/xml/Markup.cpp	/^struct BomTableStruct { const char* pszBom; int nBomLen; MCD_PCSZ pszBomEnc; int nBomFlag; } BomTable[] =$/;"	v	typeref:struct:BomTableStruct
BomTableStruct	third_party/xml/Markup.cpp	/^struct BomTableStruct { const char* pszBom; int nBomLen; MCD_PCSZ pszBomEnc; int nBomFlag; } BomTable[] =$/;"	s	file:
BomTableStruct::nBomFlag	third_party/xml/Markup.cpp	/^struct BomTableStruct { const char* pszBom; int nBomLen; MCD_PCSZ pszBomEnc; int nBomFlag; } BomTable[] =$/;"	m	struct:BomTableStruct	file:	access:public
BomTableStruct::nBomLen	third_party/xml/Markup.cpp	/^struct BomTableStruct { const char* pszBom; int nBomLen; MCD_PCSZ pszBomEnc; int nBomFlag; } BomTable[] =$/;"	m	struct:BomTableStruct	file:	access:public
BomTableStruct::pszBom	third_party/xml/Markup.cpp	/^struct BomTableStruct { const char* pszBom; int nBomLen; MCD_PCSZ pszBomEnc; int nBomFlag; } BomTable[] =$/;"	m	struct:BomTableStruct	file:	access:public
BomTableStruct::pszBomEnc	third_party/xml/Markup.cpp	/^struct BomTableStruct { const char* pszBom; int nBomLen; MCD_PCSZ pszBomEnc; int nBomFlag; } BomTable[] =$/;"	m	struct:BomTableStruct	file:	access:public
CATCH_EXCEPTIONS_COUT	include/macros.h	71;"	d
CMarkup	third_party/xml/Markup.h	/^	CMarkup( MCD_CSTR szDoc ) { x_InitMarkup(); SetDoc( szDoc ); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szDoc )
CMarkup	third_party/xml/Markup.h	/^	CMarkup( const CMarkup& markup ) { x_InitMarkup(); *this = markup; };$/;"	f	class:CMarkup	access:public	signature:( const CMarkup& markup )
CMarkup	third_party/xml/Markup.h	/^	CMarkup( int nFlags ) { x_InitMarkup(); SetDoc( NULL ); m_nDocFlags = nFlags; };$/;"	f	class:CMarkup	access:public	signature:( int nFlags )
CMarkup	third_party/xml/Markup.h	/^	CMarkup() { x_InitMarkup(); SetDoc( NULL ); };$/;"	f	class:CMarkup	access:public	signature:()
CMarkup	third_party/xml/Markup.h	/^class CMarkup$/;"	c
CMarkup::AToUTF8	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::AToUTF8( MCD_CSTR pszANSI )$/;"	f	class:CMarkup	signature:( MCD_CSTR pszANSI )
CMarkup::AToUTF8	third_party/xml/Markup.h	/^	static MCD_STR AToUTF8( MCD_CSTR pszANSI );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR pszANSI )
CMarkup::AddAttrib	third_party/xml/Markup.h	/^	bool AddAttrib( MCD_CSTR szAttrib, MCD_CSTR szValue ) { return x_SetAttrib(m_iPos,szAttrib,szValue); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib, MCD_CSTR szValue )
CMarkup::AddAttrib	third_party/xml/Markup.h	/^	bool AddAttrib( MCD_CSTR szAttrib, int nValue ) { return x_SetAttrib(m_iPos,szAttrib,nValue); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib, int nValue )
CMarkup::AddChildAttrib	third_party/xml/Markup.h	/^	bool AddChildAttrib( MCD_CSTR szAttrib, MCD_CSTR szValue ) { return x_SetAttrib(m_iPosChild,szAttrib,szValue); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib, MCD_CSTR szValue )
CMarkup::AddChildAttrib	third_party/xml/Markup.h	/^	bool AddChildAttrib( MCD_CSTR szAttrib, int nValue ) { return x_SetAttrib(m_iPosChild,szAttrib,nValue); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib, int nValue )
CMarkup::AddChildElem	third_party/xml/Markup.h	/^	bool AddChildElem( MCD_CSTR szName, MCD_CSTR szData=NULL, int nFlags=0 ) { return x_AddElem(szName,szData,nFlags|MNF_CHILD); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szName, MCD_CSTR szData=NULL, int nFlags=0 )
CMarkup::AddChildElem	third_party/xml/Markup.h	/^	bool AddChildElem( MCD_CSTR szName, int nValue, int nFlags=0 ) { return x_AddElem(szName,nValue,nFlags|MNF_CHILD); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szName, int nValue, int nFlags=0 )
CMarkup::AddChildSubDoc	third_party/xml/Markup.h	/^	bool AddChildSubDoc( MCD_CSTR szSubDoc ) { return x_AddSubDoc(szSubDoc,MNF_CHILD); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szSubDoc )
CMarkup::AddElem	third_party/xml/Markup.h	/^	bool AddElem( MCD_CSTR szName, MCD_CSTR szData=NULL, int nFlags=0 ) { return x_AddElem(szName,szData,nFlags); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szName, MCD_CSTR szData=NULL, int nFlags=0 )
CMarkup::AddElem	third_party/xml/Markup.h	/^	bool AddElem( MCD_CSTR szName, int nValue, int nFlags=0 ) { return x_AddElem(szName,nValue,nFlags); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szName, int nValue, int nFlags=0 )
CMarkup::AddNode	third_party/xml/Markup.h	/^	bool AddNode( int nType, MCD_CSTR szText ) { return x_AddNode(nType,szText,0); };$/;"	f	class:CMarkup	access:public	signature:( int nType, MCD_CSTR szText )
CMarkup::AddSubDoc	third_party/xml/Markup.h	/^	bool AddSubDoc( MCD_CSTR szSubDoc ) { return x_AddSubDoc(szSubDoc,0); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szSubDoc )
CMarkup::CMarkup	third_party/xml/Markup.h	/^	CMarkup( MCD_CSTR szDoc ) { x_InitMarkup(); SetDoc( szDoc ); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szDoc )
CMarkup::CMarkup	third_party/xml/Markup.h	/^	CMarkup( const CMarkup& markup ) { x_InitMarkup(); *this = markup; };$/;"	f	class:CMarkup	access:public	signature:( const CMarkup& markup )
CMarkup::CMarkup	third_party/xml/Markup.h	/^	CMarkup( int nFlags ) { x_InitMarkup(); SetDoc( NULL ); m_nDocFlags = nFlags; };$/;"	f	class:CMarkup	access:public	signature:( int nFlags )
CMarkup::CMarkup	third_party/xml/Markup.h	/^	CMarkup() { x_InitMarkup(); SetDoc( NULL ); };$/;"	f	class:CMarkup	access:public	signature:()
CMarkup::DecodeCharUTF16	third_party/xml/Markup.cpp	/^int CMarkup::DecodeCharUTF16( const unsigned short*& pwszUTF16, const unsigned short* pszUTF16End\/*=NULL*\/ )$/;"	f	class:CMarkup	signature:( const unsigned short*& pwszUTF16, const unsigned short* pszUTF16End )
CMarkup::DecodeCharUTF16	third_party/xml/Markup.h	/^	static int DecodeCharUTF16( const unsigned short*& pwszUTF16, const unsigned short* pszUTF16End = NULL );$/;"	p	class:CMarkup	access:public	signature:( const unsigned short*& pwszUTF16, const unsigned short* pszUTF16End = NULL )
CMarkup::DecodeCharUTF8	third_party/xml/Markup.cpp	/^int CMarkup::DecodeCharUTF8( const char*& pszUTF8, const char* pszUTF8End\/*=NULL*\/ )$/;"	f	class:CMarkup	signature:( const char*& pszUTF8, const char* pszUTF8End )
CMarkup::DecodeCharUTF8	third_party/xml/Markup.h	/^	static int DecodeCharUTF8( const char*& pszUTF8, const char* pszUTF8End = NULL );$/;"	p	class:CMarkup	access:public	signature:( const char*& pszUTF8, const char* pszUTF8End = NULL )
CMarkup::DetectUTF8	third_party/xml/Markup.cpp	/^bool CMarkup::DetectUTF8( const char* pText, int nTextLen, int* pnNonASCII\/*=NULL*\/, bool* bErrorAtEnd\/*=NULL*\/ )$/;"	f	class:CMarkup	signature:( const char* pText, int nTextLen, int* pnNonASCII , bool* bErrorAtEnd )
CMarkup::DetectUTF8	third_party/xml/Markup.h	/^	static bool DetectUTF8( const char* pText, int nTextLen, int* pnNonASCII = NULL, bool* bErrorAtEnd = NULL );$/;"	p	class:CMarkup	access:public	signature:( const char* pText, int nTextLen, int* pnNonASCII = NULL, bool* bErrorAtEnd = NULL )
CMarkup::EncodeCharUTF16	third_party/xml/Markup.cpp	/^void CMarkup::EncodeCharUTF16( int nUChar, unsigned short* pwszUTF16, int& nUTF16Len )$/;"	f	class:CMarkup	signature:( int nUChar, unsigned short* pwszUTF16, int& nUTF16Len )
CMarkup::EncodeCharUTF16	third_party/xml/Markup.h	/^	static void EncodeCharUTF16( int nUChar, unsigned short* pwszUTF16, int& nUTF16Len );$/;"	p	class:CMarkup	access:public	signature:( int nUChar, unsigned short* pwszUTF16, int& nUTF16Len )
CMarkup::EncodeCharUTF8	third_party/xml/Markup.cpp	/^void CMarkup::EncodeCharUTF8( int nUChar, char* pszUTF8, int& nUTF8Len )$/;"	f	class:CMarkup	signature:( int nUChar, char* pszUTF8, int& nUTF8Len )
CMarkup::EncodeCharUTF8	third_party/xml/Markup.h	/^	static void EncodeCharUTF8( int nUChar, char* pszUTF8, int& nUTF8Len );$/;"	p	class:CMarkup	access:public	signature:( int nUChar, char* pszUTF8, int& nUTF8Len )
CMarkup::EscapeText	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::EscapeText( MCD_CSTR szText, int nFlags )$/;"	f	class:CMarkup	signature:( MCD_CSTR szText, int nFlags )
CMarkup::EscapeText	third_party/xml/Markup.h	/^	static MCD_STR EscapeText( MCD_CSTR szText, int nFlags = 0 );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR szText, int nFlags = 0 )
CMarkup::FindChildElem	third_party/xml/Markup.cpp	/^bool CMarkup::FindChildElem( MCD_CSTR szName )$/;"	f	class:CMarkup	signature:( MCD_CSTR szName )
CMarkup::FindChildElem	third_party/xml/Markup.h	/^	bool FindChildElem( MCD_CSTR szName=NULL );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR szName=NULL )
CMarkup::FindElem	third_party/xml/Markup.cpp	/^bool CMarkup::FindElem( MCD_CSTR szName )$/;"	f	class:CMarkup	signature:( MCD_CSTR szName )
CMarkup::FindElem	third_party/xml/Markup.h	/^	bool FindElem( MCD_CSTR szName=NULL );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR szName=NULL )
CMarkup::FindNode	third_party/xml/Markup.cpp	/^int CMarkup::FindNode( int nType )$/;"	f	class:CMarkup	signature:( int nType )
CMarkup::FindNode	third_party/xml/Markup.h	/^	int FindNode( int nType=0 );$/;"	p	class:CMarkup	access:public	signature:( int nType=0 )
CMarkup::GetAttrib	third_party/xml/Markup.h	/^	MCD_STR GetAttrib( MCD_CSTR szAttrib ) const { return x_GetAttrib(m_iPos,szAttrib); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib ) const
CMarkup::GetAttribName	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::GetAttribName( int n ) const$/;"	f	class:CMarkup	signature:( int n ) const
CMarkup::GetAttribName	third_party/xml/Markup.h	/^	MCD_STR GetAttribName( int n ) const;$/;"	p	class:CMarkup	access:public	signature:( int n ) const
CMarkup::GetChildAttrib	third_party/xml/Markup.h	/^	MCD_STR GetChildAttrib( MCD_CSTR szAttrib ) const { return x_GetAttrib(m_iPosChild,szAttrib); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib ) const
CMarkup::GetChildData	third_party/xml/Markup.h	/^	MCD_STR GetChildData() { return x_GetData(m_iPosChild); };$/;"	f	class:CMarkup	access:public	signature:()
CMarkup::GetChildSubDoc	third_party/xml/Markup.h	/^	MCD_STR GetChildSubDoc() { return x_GetSubDoc(m_iPosChild); };$/;"	f	class:CMarkup	access:public	signature:()
CMarkup::GetChildTagName	third_party/xml/Markup.h	/^	MCD_STR GetChildTagName() const { return x_GetTagName(m_iPosChild); };$/;"	f	class:CMarkup	access:public	signature:() const
CMarkup::GetData	third_party/xml/Markup.h	/^	MCD_STR GetData() { return x_GetData(m_iPos); };$/;"	f	class:CMarkup	access:public	signature:()
CMarkup::GetDeclaredEncoding	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::GetDeclaredEncoding( MCD_CSTR szDoc )$/;"	f	class:CMarkup	signature:( MCD_CSTR szDoc )
CMarkup::GetDeclaredEncoding	third_party/xml/Markup.h	/^	static MCD_STR GetDeclaredEncoding( MCD_CSTR szDoc );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR szDoc )
CMarkup::GetDoc	third_party/xml/Markup.h	/^	const MCD_STR& GetDoc() const { return m_strDoc; };$/;"	f	class:CMarkup	access:public	signature:() const
CMarkup::GetDocFlags	third_party/xml/Markup.h	/^	int GetDocFlags() const { return m_nDocFlags; };$/;"	f	class:CMarkup	access:public	signature:() const
CMarkup::GetElemContent	third_party/xml/Markup.h	/^	MCD_STR GetElemContent() const { return x_GetElemContent(m_iPos); };$/;"	f	class:CMarkup	access:public	signature:() const
CMarkup::GetEncodingCodePage	third_party/xml/Markup.cpp	/^int CMarkup::GetEncodingCodePage( MCD_CSTR pszEncoding )$/;"	f	class:CMarkup	signature:( MCD_CSTR pszEncoding )
CMarkup::GetEncodingCodePage	third_party/xml/Markup.h	/^	static int GetEncodingCodePage( MCD_CSTR pszEncoding );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR pszEncoding )
CMarkup::GetError	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::GetError() const$/;"	f	class:CMarkup	signature:() const
CMarkup::GetError	third_party/xml/Markup.h	/^	MCD_STR GetError() const;$/;"	p	class:CMarkup	access:public	signature:() const
CMarkup::GetNodeType	third_party/xml/Markup.h	/^	int GetNodeType() { return m_nNodeType; };$/;"	f	class:CMarkup	access:public	signature:()
CMarkup::GetResult	third_party/xml/Markup.h	/^	const MCD_STR& GetResult() const { return m_strResult; };$/;"	f	class:CMarkup	access:public	signature:() const
CMarkup::GetSubDoc	third_party/xml/Markup.h	/^	MCD_STR GetSubDoc() { return x_GetSubDoc(m_iPos); };$/;"	f	class:CMarkup	access:public	signature:()
CMarkup::GetTagName	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::GetTagName() const$/;"	f	class:CMarkup	signature:() const
CMarkup::GetTagName	third_party/xml/Markup.h	/^	MCD_STR GetTagName() const;$/;"	p	class:CMarkup	access:public	signature:() const
CMarkup::InsertChildElem	third_party/xml/Markup.h	/^	bool InsertChildElem( MCD_CSTR szName, MCD_CSTR szData=NULL, int nFlags=0 ) { return x_AddElem(szName,szData,nFlags|MNF_INSERT|MNF_CHILD); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szName, MCD_CSTR szData=NULL, int nFlags=0 )
CMarkup::InsertChildElem	third_party/xml/Markup.h	/^	bool InsertChildElem( MCD_CSTR szName, int nValue, int nFlags=0 ) { return x_AddElem(szName,nValue,nFlags|MNF_INSERT|MNF_CHILD); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szName, int nValue, int nFlags=0 )
CMarkup::InsertChildSubDoc	third_party/xml/Markup.h	/^	bool InsertChildSubDoc( MCD_CSTR szSubDoc ) { return x_AddSubDoc(szSubDoc,MNF_CHILD|MNF_INSERT); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szSubDoc )
CMarkup::InsertElem	third_party/xml/Markup.h	/^	bool InsertElem( MCD_CSTR szName, MCD_CSTR szData=NULL, int nFlags=0 ) { return x_AddElem(szName,szData,nFlags|MNF_INSERT); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szName, MCD_CSTR szData=NULL, int nFlags=0 )
CMarkup::InsertElem	third_party/xml/Markup.h	/^	bool InsertElem( MCD_CSTR szName, int nValue, int nFlags=0 ) { return x_AddElem(szName,nValue,nFlags|MNF_INSERT); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szName, int nValue, int nFlags=0 )
CMarkup::InsertNode	third_party/xml/Markup.h	/^	bool InsertNode( int nType, MCD_CSTR szText ) { return x_AddNode(nType,szText,MNF_INSERT); };$/;"	f	class:CMarkup	access:public	signature:( int nType, MCD_CSTR szText )
CMarkup::InsertSubDoc	third_party/xml/Markup.h	/^	bool InsertSubDoc( MCD_CSTR szSubDoc ) { return x_AddSubDoc(szSubDoc,MNF_INSERT); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szSubDoc )
CMarkup::IntoElem	third_party/xml/Markup.cpp	/^bool CMarkup::IntoElem()$/;"	f	class:CMarkup	signature:()
CMarkup::IntoElem	third_party/xml/Markup.h	/^	bool IntoElem();$/;"	p	class:CMarkup	access:public	signature:()
CMarkup::IsWellFormed	third_party/xml/Markup.cpp	/^bool CMarkup::IsWellFormed()$/;"	f	class:CMarkup	signature:()
CMarkup::IsWellFormed	third_party/xml/Markup.h	/^	bool IsWellFormed();$/;"	p	class:CMarkup	access:public	signature:()
CMarkup::Load	third_party/xml/Markup.cpp	/^bool CMarkup::Load( MCD_CSTR_FILENAME szFileName )$/;"	f	class:CMarkup	signature:( MCD_CSTR_FILENAME szFileName )
CMarkup::Load	third_party/xml/Markup.h	/^	bool Load( MCD_CSTR_FILENAME szFileName );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR_FILENAME szFileName )
CMarkup::MDF_APPENDFILE	third_party/xml/Markup.h	/^		MDF_APPENDFILE = 64,$/;"	e	enum:CMarkup::MarkupDocFlags
CMarkup::MDF_IGNORECASE	third_party/xml/Markup.h	/^		MDF_IGNORECASE = 8,$/;"	e	enum:CMarkup::MarkupDocFlags
CMarkup::MDF_READFILE	third_party/xml/Markup.h	/^		MDF_READFILE = 16,$/;"	e	enum:CMarkup::MarkupDocFlags
CMarkup::MDF_UTF16BEFILE	third_party/xml/Markup.h	/^		MDF_UTF16BEFILE = 128$/;"	e	enum:CMarkup::MarkupDocFlags
CMarkup::MDF_UTF16LEFILE	third_party/xml/Markup.h	/^		MDF_UTF16LEFILE = 1,$/;"	e	enum:CMarkup::MarkupDocFlags
CMarkup::MDF_UTF8PREAMBLE	third_party/xml/Markup.h	/^		MDF_UTF8PREAMBLE = 4,$/;"	e	enum:CMarkup::MarkupDocFlags
CMarkup::MDF_WRITEFILE	third_party/xml/Markup.h	/^		MDF_WRITEFILE = 32,$/;"	e	enum:CMarkup::MarkupDocFlags
CMarkup::MNF_CHILD	third_party/xml/Markup.h	/^		MNF_CHILD      = 0x004000$/;"	e	enum:CMarkup::MarkupNodeFlagsInternal
CMarkup::MNF_ESCAPEQUOTES	third_party/xml/Markup.h	/^		MNF_ESCAPEQUOTES  = 0x100,$/;"	e	enum:CMarkup::MarkupNodeFlags
CMarkup::MNF_ILLDATA	third_party/xml/Markup.h	/^		MNF_ILLDATA    = 0x200000$/;"	e	enum:CMarkup::MarkupNodeFlags
CMarkup::MNF_INSERT	third_party/xml/Markup.h	/^		MNF_INSERT     = 0x002000,$/;"	e	enum:CMarkup::MarkupNodeFlagsInternal
CMarkup::MNF_NONENDED	third_party/xml/Markup.h	/^		MNF_NONENDED   = 0x100000,$/;"	e	enum:CMarkup::MarkupNodeFlags
CMarkup::MNF_WITHCDATA	third_party/xml/Markup.h	/^		MNF_WITHCDATA      = 0x01,$/;"	e	enum:CMarkup::MarkupNodeFlags
CMarkup::MNF_WITHNOEND	third_party/xml/Markup.h	/^		MNF_WITHNOEND      = 0x10,$/;"	e	enum:CMarkup::MarkupNodeFlags
CMarkup::MNF_WITHNOLINES	third_party/xml/Markup.h	/^		MNF_WITHNOLINES    = 0x02,$/;"	e	enum:CMarkup::MarkupNodeFlags
CMarkup::MNF_WITHREFS	third_party/xml/Markup.h	/^		MNF_WITHREFS       = 0x08,$/;"	e	enum:CMarkup::MarkupNodeFlags
CMarkup::MNF_WITHXHTMLSPACE	third_party/xml/Markup.h	/^		MNF_WITHXHTMLSPACE = 0x04,$/;"	e	enum:CMarkup::MarkupNodeFlags
CMarkup::MNT_CDATA_SECTION	third_party/xml/Markup.h	/^		MNT_CDATA_SECTION			= 8,    \/\/ 0x0008$/;"	e	enum:CMarkup::MarkupNodeType
CMarkup::MNT_COMMENT	third_party/xml/Markup.h	/^		MNT_COMMENT					= 32,   \/\/ 0x0020$/;"	e	enum:CMarkup::MarkupNodeType
CMarkup::MNT_DOCUMENT_TYPE	third_party/xml/Markup.h	/^		MNT_DOCUMENT_TYPE			= 64,   \/\/ 0x0040$/;"	e	enum:CMarkup::MarkupNodeType
CMarkup::MNT_ELEMENT	third_party/xml/Markup.h	/^		MNT_ELEMENT					= 1,    \/\/ 0x0001$/;"	e	enum:CMarkup::MarkupNodeType
CMarkup::MNT_EXCLUDE_WHITESPACE	third_party/xml/Markup.h	/^		MNT_EXCLUDE_WHITESPACE		= 123,  \/\/ 0x007b$/;"	e	enum:CMarkup::MarkupNodeType
CMarkup::MNT_LONE_END_TAG	third_party/xml/Markup.h	/^		MNT_LONE_END_TAG			= 128,  \/\/ 0x0080$/;"	e	enum:CMarkup::MarkupNodeType
CMarkup::MNT_NODE_ERROR	third_party/xml/Markup.h	/^		MNT_NODE_ERROR              = 32768 \/\/ 0x8000$/;"	e	enum:CMarkup::MarkupNodeType
CMarkup::MNT_PROCESSING_INSTRUCTION	third_party/xml/Markup.h	/^		MNT_PROCESSING_INSTRUCTION	= 16,   \/\/ 0x0010$/;"	e	enum:CMarkup::MarkupNodeType
CMarkup::MNT_TEXT	third_party/xml/Markup.h	/^		MNT_TEXT					= 2,    \/\/ 0x0002$/;"	e	enum:CMarkup::MarkupNodeType
CMarkup::MNT_TEXT_AND_WHITESPACE	third_party/xml/Markup.h	/^		MNT_TEXT_AND_WHITESPACE     = 6,    \/\/ 0x0006$/;"	e	enum:CMarkup::MarkupNodeType
CMarkup::MNT_WHITESPACE	third_party/xml/Markup.h	/^		MNT_WHITESPACE				= 4,    \/\/ 0x0004$/;"	e	enum:CMarkup::MarkupNodeType
CMarkup::MarkupDocFlags	third_party/xml/Markup.h	/^	enum MarkupDocFlags$/;"	g	class:CMarkup	access:public
CMarkup::MarkupNodeFlags	third_party/xml/Markup.h	/^	enum MarkupNodeFlags$/;"	g	class:CMarkup	access:public
CMarkup::MarkupNodeFlagsInternal	third_party/xml/Markup.h	/^	enum MarkupNodeFlagsInternal$/;"	g	class:CMarkup	access:protected
CMarkup::MarkupNodeType	third_party/xml/Markup.h	/^	enum MarkupNodeType$/;"	g	class:CMarkup	access:public
CMarkup::OutOfElem	third_party/xml/Markup.cpp	/^bool CMarkup::OutOfElem()$/;"	f	class:CMarkup	signature:()
CMarkup::OutOfElem	third_party/xml/Markup.h	/^	bool OutOfElem();$/;"	p	class:CMarkup	access:public	signature:()
CMarkup::ReadTextFile	third_party/xml/Markup.cpp	/^bool CMarkup::ReadTextFile( MCD_CSTR_FILENAME szFileName, MCD_STR& strDoc, MCD_STR* pstrResult, int* pnDocFlags, MCD_STR* pstrEncoding )$/;"	f	class:CMarkup	signature:( MCD_CSTR_FILENAME szFileName, MCD_STR& strDoc, MCD_STR* pstrResult, int* pnDocFlags, MCD_STR* pstrEncoding )
CMarkup::ReadTextFile	third_party/xml/Markup.h	/^	static bool ReadTextFile( MCD_CSTR_FILENAME szFileName, MCD_STR& strDoc, MCD_STR* pstrResult=NULL, int* pnDocFlags=NULL, MCD_STR* pstrEncoding=NULL );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR_FILENAME szFileName, MCD_STR& strDoc, MCD_STR* pstrResult=NULL, int* pnDocFlags=NULL, MCD_STR* pstrEncoding=NULL )
CMarkup::RemoveChildElem	third_party/xml/Markup.cpp	/^bool CMarkup::RemoveChildElem()$/;"	f	class:CMarkup	signature:()
CMarkup::RemoveChildElem	third_party/xml/Markup.h	/^	bool RemoveChildElem();$/;"	p	class:CMarkup	access:public	signature:()
CMarkup::RemoveElem	third_party/xml/Markup.cpp	/^bool CMarkup::RemoveElem()$/;"	f	class:CMarkup	signature:()
CMarkup::RemoveElem	third_party/xml/Markup.h	/^	bool RemoveElem();$/;"	p	class:CMarkup	access:public	signature:()
CMarkup::RemoveNode	third_party/xml/Markup.cpp	/^bool CMarkup::RemoveNode()$/;"	f	class:CMarkup	signature:()
CMarkup::RemoveNode	third_party/xml/Markup.h	/^	bool RemoveNode();$/;"	p	class:CMarkup	access:public	signature:()
CMarkup::ResetChildPos	third_party/xml/Markup.h	/^	void ResetChildPos() { x_SetPos(m_iPosParent,m_iPos,0); };$/;"	f	class:CMarkup	access:public	signature:()
CMarkup::ResetMainPos	third_party/xml/Markup.h	/^	void ResetMainPos() { x_SetPos(m_iPosParent,0,0); };$/;"	f	class:CMarkup	access:public	signature:()
CMarkup::ResetPos	third_party/xml/Markup.h	/^	void ResetPos() { x_SetPos(0,0,0); };$/;"	f	class:CMarkup	access:public	signature:()
CMarkup::RestorePos	third_party/xml/Markup.cpp	/^bool CMarkup::RestorePos( MCD_CSTR szPosName \/*=""*\/, int nMap \/*=0*\/ )$/;"	f	class:CMarkup	signature:( MCD_CSTR szPosName , int nMap )
CMarkup::RestorePos	third_party/xml/Markup.h	/^	bool RestorePos( MCD_CSTR szPosName=MCD_T(""), int nMap = 0 );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR szPosName=MCD_T(Ó), int nMap = 0 )
CMarkup::Save	third_party/xml/Markup.cpp	/^bool CMarkup::Save( MCD_CSTR_FILENAME szFileName )$/;"	f	class:CMarkup	signature:( MCD_CSTR_FILENAME szFileName )
CMarkup::Save	third_party/xml/Markup.h	/^	bool Save( MCD_CSTR_FILENAME szFileName );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR_FILENAME szFileName )
CMarkup::SavePos	third_party/xml/Markup.cpp	/^bool CMarkup::SavePos( MCD_CSTR szPosName \/*=""*\/, int nMap \/*=0*\/ )$/;"	f	class:CMarkup	signature:( MCD_CSTR szPosName , int nMap )
CMarkup::SavePos	third_party/xml/Markup.h	/^	bool SavePos( MCD_CSTR szPosName=MCD_T(""), int nMap = 0 );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR szPosName=MCD_T(Ó), int nMap = 0 )
CMarkup::SetAttrib	third_party/xml/Markup.h	/^	bool SetAttrib( MCD_CSTR szAttrib, MCD_CSTR szValue, int nFlags=0 ) { return x_SetAttrib(m_iPos,szAttrib,szValue,nFlags); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib, MCD_CSTR szValue, int nFlags=0 )
CMarkup::SetAttrib	third_party/xml/Markup.h	/^	bool SetAttrib( MCD_CSTR szAttrib, int nValue, int nFlags=0 ) { return x_SetAttrib(m_iPos,szAttrib,nValue,nFlags); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib, int nValue, int nFlags=0 )
CMarkup::SetChildAttrib	third_party/xml/Markup.h	/^	bool SetChildAttrib( MCD_CSTR szAttrib, MCD_CSTR szValue, int nFlags=0 ) { return x_SetAttrib(m_iPosChild,szAttrib,szValue,nFlags); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib, MCD_CSTR szValue, int nFlags=0 )
CMarkup::SetChildAttrib	third_party/xml/Markup.h	/^	bool SetChildAttrib( MCD_CSTR szAttrib, int nValue, int nFlags=0 ) { return x_SetAttrib(m_iPosChild,szAttrib,nValue,nFlags); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib, int nValue, int nFlags=0 )
CMarkup::SetChildData	third_party/xml/Markup.h	/^	bool SetChildData( MCD_CSTR szData, int nFlags=0 ) { return x_SetData(m_iPosChild,szData,nFlags); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szData, int nFlags=0 )
CMarkup::SetChildData	third_party/xml/Markup.h	/^	bool SetChildData( int nValue ) { return x_SetData(m_iPosChild,nValue); };$/;"	f	class:CMarkup	access:public	signature:( int nValue )
CMarkup::SetData	third_party/xml/Markup.h	/^	bool SetData( MCD_CSTR szData, int nFlags=0 ) { return x_SetData(m_iPos,szData,nFlags); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szData, int nFlags=0 )
CMarkup::SetData	third_party/xml/Markup.h	/^	bool SetData( int nValue ) { return x_SetData(m_iPos,nValue); };$/;"	f	class:CMarkup	access:public	signature:( int nValue )
CMarkup::SetDoc	third_party/xml/Markup.cpp	/^bool CMarkup::SetDoc( MCD_PCSZ pDoc )$/;"	f	class:CMarkup	signature:( MCD_PCSZ pDoc )
CMarkup::SetDoc	third_party/xml/Markup.cpp	/^bool CMarkup::SetDoc( const MCD_STR& strDoc )$/;"	f	class:CMarkup	signature:( const MCD_STR& strDoc )
CMarkup::SetDoc	third_party/xml/Markup.h	/^	bool SetDoc( MCD_PCSZ pDoc );$/;"	p	class:CMarkup	access:public	signature:( MCD_PCSZ pDoc )
CMarkup::SetDoc	third_party/xml/Markup.h	/^	bool SetDoc( const MCD_STR& strDoc );$/;"	p	class:CMarkup	access:public	signature:( const MCD_STR& strDoc )
CMarkup::SetDocFlags	third_party/xml/Markup.h	/^	void SetDocFlags( int nFlags ) { m_nDocFlags = (nFlags & ~(MDF_READFILE|MDF_WRITEFILE|MDF_APPENDFILE)); };$/;"	f	class:CMarkup	access:public	signature:( int nFlags )
CMarkup::SetElemContent	third_party/xml/Markup.h	/^	bool SetElemContent( MCD_CSTR szContent ) { return x_SetElemContent(szContent); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szContent )
CMarkup::SetMapSize	third_party/xml/Markup.cpp	/^bool CMarkup::SetMapSize( int nSize, int nMap \/*=0*\/ )$/;"	f	class:CMarkup	signature:( int nSize, int nMap )
CMarkup::SetMapSize	third_party/xml/Markup.h	/^	bool SetMapSize( int nSize, int nMap = 0 );$/;"	p	class:CMarkup	access:public	signature:( int nSize, int nMap = 0 )
CMarkup::UTF16To8	third_party/xml/Markup.cpp	/^int CMarkup::UTF16To8( char* pszUTF8, const unsigned short* pwszUTF16, int nUTF8Count )$/;"	f	class:CMarkup	signature:( char* pszUTF8, const unsigned short* pwszUTF16, int nUTF8Count )
CMarkup::UTF16To8	third_party/xml/Markup.h	/^	static int UTF16To8( char *pszUTF8, const unsigned short* pwszUTF16, int nUTF8Count );$/;"	p	class:CMarkup	access:public	signature:( char *pszUTF8, const unsigned short* pwszUTF16, int nUTF8Count )
CMarkup::UTF8To16	third_party/xml/Markup.cpp	/^int CMarkup::UTF8To16( unsigned short* pwszUTF16, const char* pszUTF8, int nUTF8Count )$/;"	f	class:CMarkup	signature:( unsigned short* pwszUTF16, const char* pszUTF8, int nUTF8Count )
CMarkup::UTF8To16	third_party/xml/Markup.h	/^	static int UTF8To16( unsigned short* pwszUTF16, const char* pszUTF8, int nUTF8Count );$/;"	p	class:CMarkup	access:public	signature:( unsigned short* pwszUTF16, const char* pszUTF8, int nUTF8Count )
CMarkup::UTF8ToA	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::UTF8ToA( MCD_CSTR pszUTF8, int* pnFailed\/*=NULL*\/ )$/;"	f	class:CMarkup	signature:( MCD_CSTR pszUTF8, int* pnFailed )
CMarkup::UTF8ToA	third_party/xml/Markup.h	/^	static MCD_STR UTF8ToA( MCD_CSTR pszUTF8, int* pnFailed = NULL );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR pszUTF8, int* pnFailed = NULL )
CMarkup::UnescapeText	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::UnescapeText( MCD_CSTR szText, int nTextLength \/*=-1*\/ )$/;"	f	class:CMarkup	signature:( MCD_CSTR szText, int nTextLength )
CMarkup::UnescapeText	third_party/xml/Markup.h	/^	static MCD_STR UnescapeText( MCD_CSTR szText, int nTextLength = -1 );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR szText, int nTextLength = -1 )
CMarkup::WriteTextFile	third_party/xml/Markup.cpp	/^bool CMarkup::WriteTextFile( MCD_CSTR_FILENAME szFileName, const MCD_STR& strDoc, MCD_STR* pstrResult, int* pnDocFlags, MCD_STR* pstrEncoding )$/;"	f	class:CMarkup	signature:( MCD_CSTR_FILENAME szFileName, const MCD_STR& strDoc, MCD_STR* pstrResult, int* pnDocFlags, MCD_STR* pstrEncoding )
CMarkup::WriteTextFile	third_party/xml/Markup.h	/^	static bool WriteTextFile( MCD_CSTR_FILENAME szFileName, const MCD_STR& strDoc, MCD_STR* pstrResult=NULL, int* pnDocFlags=NULL, MCD_STR* pstrEncoding=NULL );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR_FILENAME szFileName, const MCD_STR& strDoc, MCD_STR* pstrResult=NULL, int* pnDocFlags=NULL, MCD_STR* pstrEncoding=NULL )
CMarkup::m_iPos	third_party/xml/Markup.h	/^	int m_iPos;$/;"	m	class:CMarkup	access:protected
CMarkup::m_iPosChild	third_party/xml/Markup.h	/^	int m_iPosChild;$/;"	m	class:CMarkup	access:protected
CMarkup::m_iPosDeleted	third_party/xml/Markup.h	/^	int m_iPosDeleted;$/;"	m	class:CMarkup	access:protected
CMarkup::m_iPosFree	third_party/xml/Markup.h	/^	int m_iPosFree;$/;"	m	class:CMarkup	access:protected
CMarkup::m_iPosParent	third_party/xml/Markup.h	/^	int m_iPosParent;$/;"	m	class:CMarkup	access:protected
CMarkup::m_nDocFlags	third_party/xml/Markup.h	/^	int m_nDocFlags;$/;"	m	class:CMarkup	access:protected
CMarkup::m_nNodeLength	third_party/xml/Markup.h	/^	int m_nNodeLength;$/;"	m	class:CMarkup	access:protected
CMarkup::m_nNodeOffset	third_party/xml/Markup.h	/^	int m_nNodeOffset;$/;"	m	class:CMarkup	access:protected
CMarkup::m_nNodeType	third_party/xml/Markup.h	/^	int m_nNodeType;$/;"	m	class:CMarkup	access:protected
CMarkup::m_pDebugCur	third_party/xml/Markup.h	/^	MCD_PCSZ m_pDebugCur;$/;"	m	class:CMarkup	access:protected
CMarkup::m_pDebugPos	third_party/xml/Markup.h	/^	MCD_PCSZ m_pDebugPos;$/;"	m	class:CMarkup	access:protected
CMarkup::m_pElemPosTree	third_party/xml/Markup.h	/^	ElemPosTree* m_pElemPosTree;$/;"	m	class:CMarkup	access:protected
CMarkup::m_pFilePos	third_party/xml/Markup.h	/^	FilePos* m_pFilePos;$/;"	m	class:CMarkup	access:protected
CMarkup::m_pSavedPosMaps	third_party/xml/Markup.h	/^	SavedPosMapArray* m_pSavedPosMaps;$/;"	m	class:CMarkup	access:protected
CMarkup::m_strDoc	third_party/xml/Markup.h	/^	MCD_STR m_strDoc;$/;"	m	class:CMarkup	access:protected
CMarkup::m_strResult	third_party/xml/Markup.h	/^	MCD_STR m_strResult;$/;"	m	class:CMarkup	access:protected
CMarkup::operator =	third_party/xml/Markup.cpp	/^void CMarkup::operator=( const CMarkup& markup )$/;"	f	class:CMarkup	signature:( const CMarkup& markup )
CMarkup::operator =	third_party/xml/Markup.h	/^	void operator=( const CMarkup& markup );$/;"	p	class:CMarkup	access:public	signature:( const CMarkup& markup )
CMarkup::x_AddElem	third_party/xml/Markup.cpp	/^bool CMarkup::x_AddElem( MCD_PCSZ pName, MCD_PCSZ pValue, int nFlags )$/;"	f	class:CMarkup	signature:( MCD_PCSZ pName, MCD_PCSZ pValue, int nFlags )
CMarkup::x_AddElem	third_party/xml/Markup.cpp	/^bool CMarkup::x_AddElem( MCD_PCSZ pName, int nValue, int nFlags )$/;"	f	class:CMarkup	signature:( MCD_PCSZ pName, int nValue, int nFlags )
CMarkup::x_AddElem	third_party/xml/Markup.h	/^	bool x_AddElem( MCD_PCSZ pName, MCD_PCSZ pValue, int nFlags );$/;"	p	class:CMarkup	access:protected	signature:( MCD_PCSZ pName, MCD_PCSZ pValue, int nFlags )
CMarkup::x_AddElem	third_party/xml/Markup.h	/^	bool x_AddElem( MCD_PCSZ pName, int nValue, int nFlags );$/;"	p	class:CMarkup	access:protected	signature:( MCD_PCSZ pName, int nValue, int nFlags )
CMarkup::x_AddNode	third_party/xml/Markup.cpp	/^bool CMarkup::x_AddNode( int nNodeType, MCD_PCSZ pText, int nNodeFlags )$/;"	f	class:CMarkup	signature:( int nNodeType, MCD_PCSZ pText, int nNodeFlags )
CMarkup::x_AddNode	third_party/xml/Markup.h	/^	bool x_AddNode( int nNodeType, MCD_PCSZ pText, int nNodeFlags );$/;"	p	class:CMarkup	access:protected	signature:( int nNodeType, MCD_PCSZ pText, int nNodeFlags )
CMarkup::x_AddSubDoc	third_party/xml/Markup.cpp	/^bool CMarkup::x_AddSubDoc( MCD_PCSZ pSubDoc, int nFlags )$/;"	f	class:CMarkup	signature:( MCD_PCSZ pSubDoc, int nFlags )
CMarkup::x_AddSubDoc	third_party/xml/Markup.h	/^	bool x_AddSubDoc( MCD_PCSZ pSubDoc, int nFlags );$/;"	p	class:CMarkup	access:protected	signature:( MCD_PCSZ pSubDoc, int nFlags )
CMarkup::x_Adjust	third_party/xml/Markup.cpp	/^void CMarkup::x_Adjust( int iPos, int nShift, bool bAfterPos \/*=false*\/ )$/;"	f	class:CMarkup	signature:( int iPos, int nShift, bool bAfterPos )
CMarkup::x_Adjust	third_party/xml/Markup.h	/^	void x_Adjust( int iPos, int nShift, bool bAfterPos = false );$/;"	p	class:CMarkup	access:protected	signature:( int iPos, int nShift, bool bAfterPos = false )
CMarkup::x_AdjustForNode	third_party/xml/Markup.cpp	/^void CMarkup::x_AdjustForNode( int iPosParent, int iPos, int nShift )$/;"	f	class:CMarkup	signature:( int iPosParent, int iPos, int nShift )
CMarkup::x_AdjustForNode	third_party/xml/Markup.h	/^	void x_AdjustForNode( int iPosParent, int iPos, int nShift );$/;"	p	class:CMarkup	access:protected	signature:( int iPosParent, int iPos, int nShift )
CMarkup::x_AllocElemPos	third_party/xml/Markup.cpp	/^bool CMarkup::x_AllocElemPos( int nNewSize \/*=0*\/ )$/;"	f	class:CMarkup	signature:( int nNewSize )
CMarkup::x_AllocElemPos	third_party/xml/Markup.h	/^	bool x_AllocElemPos( int nNewSize = 0 );$/;"	p	class:CMarkup	access:protected	signature:( int nNewSize = 0 )
CMarkup::x_CheckSavedPos	third_party/xml/Markup.cpp	/^void CMarkup::x_CheckSavedPos()$/;"	f	class:CMarkup	signature:()
CMarkup::x_CheckSavedPos	third_party/xml/Markup.h	/^	void x_CheckSavedPos();$/;"	p	class:CMarkup	access:protected	signature:()
CMarkup::x_CreateNode	third_party/xml/Markup.cpp	/^bool CMarkup::x_CreateNode( MCD_STR& strNode, int nNodeType, MCD_PCSZ pText )$/;"	f	class:CMarkup	signature:( MCD_STR& strNode, int nNodeType, MCD_PCSZ pText )
CMarkup::x_CreateNode	third_party/xml/Markup.h	/^	static bool x_CreateNode( MCD_STR& strNode, int nNodeType, MCD_PCSZ pText );$/;"	p	class:CMarkup	access:protected	signature:( MCD_STR& strNode, int nNodeType, MCD_PCSZ pText )
CMarkup::x_DocChange	third_party/xml/Markup.cpp	/^void CMarkup::x_DocChange( int nLeft, int nReplace, const MCD_STR& strInsert )$/;"	f	class:CMarkup	signature:( int nLeft, int nReplace, const MCD_STR& strInsert )
CMarkup::x_DocChange	third_party/xml/Markup.h	/^	void x_DocChange( int nLeft, int nReplace, const MCD_STR& strInsert );$/;"	p	class:CMarkup	access:protected	signature:( int nLeft, int nReplace, const MCD_STR& strInsert )
CMarkup::x_EncodeCDATASection	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::x_EncodeCDATASection( MCD_PCSZ szData )$/;"	f	class:CMarkup	signature:( MCD_PCSZ szData )
CMarkup::x_EncodeCDATASection	third_party/xml/Markup.h	/^	static MCD_STR x_EncodeCDATASection( MCD_PCSZ szData );$/;"	p	class:CMarkup	access:protected	signature:( MCD_PCSZ szData )
CMarkup::x_FindElem	third_party/xml/Markup.cpp	/^int CMarkup::x_FindElem( int iPosParent, int iPos, PathPos& path ) const$/;"	f	class:CMarkup	signature:( int iPosParent, int iPos, PathPos& path ) const
CMarkup::x_FindElem	third_party/xml/Markup.h	/^	int x_FindElem( int iPosParent, int iPos, PathPos& path ) const;$/;"	p	class:CMarkup	access:protected	signature:( int iPosParent, int iPos, PathPos& path ) const
CMarkup::x_GetAttrib	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::x_GetAttrib( int iPos, MCD_PCSZ pAttrib ) const$/;"	f	class:CMarkup	signature:( int iPos, MCD_PCSZ pAttrib ) const
CMarkup::x_GetAttrib	third_party/xml/Markup.h	/^	MCD_STR x_GetAttrib( int iPos, MCD_PCSZ pAttrib ) const;$/;"	p	class:CMarkup	access:protected	signature:( int iPos, MCD_PCSZ pAttrib ) const
CMarkup::x_GetData	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::x_GetData( int iPos )$/;"	f	class:CMarkup	signature:( int iPos )
CMarkup::x_GetData	third_party/xml/Markup.h	/^	MCD_STR x_GetData( int iPos );$/;"	p	class:CMarkup	access:protected	signature:( int iPos )
CMarkup::x_GetElemContent	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::x_GetElemContent( int iPos ) const$/;"	f	class:CMarkup	signature:( int iPos ) const
CMarkup::x_GetElemContent	third_party/xml/Markup.h	/^	MCD_STR x_GetElemContent( int iPos ) const;$/;"	p	class:CMarkup	access:protected	signature:( int iPos ) const
CMarkup::x_GetFreePos	third_party/xml/Markup.cpp	/^int CMarkup::x_GetFreePos()$/;"	f	class:CMarkup	signature:()
CMarkup::x_GetFreePos	third_party/xml/Markup.h	/^	int x_GetFreePos();$/;"	p	class:CMarkup	access:protected	signature:()
CMarkup::x_GetParent	third_party/xml/Markup.cpp	/^int CMarkup::x_GetParent( int i )$/;"	f	class:CMarkup	signature:( int i )
CMarkup::x_GetParent	third_party/xml/Markup.h	/^	int x_GetParent( int i );$/;"	p	class:CMarkup	access:protected	signature:( int i )
CMarkup::x_GetPath	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::x_GetPath( int iPos ) const$/;"	f	class:CMarkup	signature:( int iPos ) const
CMarkup::x_GetPath	third_party/xml/Markup.h	/^	MCD_STR x_GetPath( int iPos ) const;$/;"	p	class:CMarkup	access:protected	signature:( int iPos ) const
CMarkup::x_GetSubDoc	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::x_GetSubDoc( int iPos )$/;"	f	class:CMarkup	signature:( int iPos )
CMarkup::x_GetSubDoc	third_party/xml/Markup.h	/^	MCD_STR x_GetSubDoc( int iPos );$/;"	p	class:CMarkup	access:protected	signature:( int iPos )
CMarkup::x_GetTagName	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::x_GetTagName( int iPos ) const$/;"	f	class:CMarkup	signature:( int iPos ) const
CMarkup::x_GetTagName	third_party/xml/Markup.h	/^	MCD_STR x_GetTagName( int iPos ) const;$/;"	p	class:CMarkup	access:protected	signature:( int iPos ) const
CMarkup::x_InitMarkup	third_party/xml/Markup.cpp	/^void CMarkup::x_InitMarkup()$/;"	f	class:CMarkup	signature:()
CMarkup::x_InitMarkup	third_party/xml/Markup.h	/^	void x_InitMarkup();$/;"	p	class:CMarkup	access:protected	signature:()
CMarkup::x_InsertNew	third_party/xml/Markup.cpp	/^int CMarkup::x_InsertNew( int iPosParent, int& iPosRel, NodePos& node )$/;"	f	class:CMarkup	signature:( int iPosParent, int& iPosRel, NodePos& node )
CMarkup::x_InsertNew	third_party/xml/Markup.h	/^	int x_InsertNew( int iPosParent, int& iPosRel, NodePos& node );$/;"	p	class:CMarkup	access:protected	signature:( int iPosParent, int& iPosRel, NodePos& node )
CMarkup::x_LinkElem	third_party/xml/Markup.cpp	/^void CMarkup::x_LinkElem( int iPosParent, int iPosBefore, int iPos )$/;"	f	class:CMarkup	signature:( int iPosParent, int iPosBefore, int iPos )
CMarkup::x_LinkElem	third_party/xml/Markup.h	/^	void x_LinkElem( int iPosParent, int iPosBefore, int iPos );$/;"	p	class:CMarkup	access:protected	signature:( int iPosParent, int iPosBefore, int iPos )
CMarkup::x_ParseDoc	third_party/xml/Markup.cpp	/^bool CMarkup::x_ParseDoc()$/;"	f	class:CMarkup	signature:()
CMarkup::x_ParseDoc	third_party/xml/Markup.h	/^	bool x_ParseDoc();$/;"	p	class:CMarkup	access:protected	signature:()
CMarkup::x_ParseElem	third_party/xml/Markup.cpp	/^int CMarkup::x_ParseElem( int iPosParent, TokenPos& token )$/;"	f	class:CMarkup	signature:( int iPosParent, TokenPos& token )
CMarkup::x_ParseElem	third_party/xml/Markup.h	/^	int x_ParseElem( int iPos, TokenPos& token );$/;"	p	class:CMarkup	access:protected	signature:( int iPos, TokenPos& token )
CMarkup::x_ReleasePos	third_party/xml/Markup.cpp	/^int CMarkup::x_ReleasePos( int iPos )$/;"	f	class:CMarkup	signature:( int iPos )
CMarkup::x_ReleasePos	third_party/xml/Markup.h	/^	int x_ReleasePos( int iPos );$/;"	p	class:CMarkup	access:protected	signature:( int iPos )
CMarkup::x_ReleaseSubDoc	third_party/xml/Markup.cpp	/^int CMarkup::x_ReleaseSubDoc( int iPos )$/;"	f	class:CMarkup	signature:( int iPos )
CMarkup::x_ReleaseSubDoc	third_party/xml/Markup.h	/^	int x_ReleaseSubDoc( int iPos );$/;"	p	class:CMarkup	access:protected	signature:( int iPos )
CMarkup::x_RemoveElem	third_party/xml/Markup.cpp	/^int CMarkup::x_RemoveElem( int iPos )$/;"	f	class:CMarkup	signature:( int iPos )
CMarkup::x_RemoveElem	third_party/xml/Markup.h	/^	int x_RemoveElem( int iPos );$/;"	p	class:CMarkup	access:protected	signature:( int iPos )
CMarkup::x_RemoveNode	third_party/xml/Markup.cpp	/^void CMarkup::x_RemoveNode( int iPosParent, int& iPos, int& nNodeType, int& nNodeOffset, int& nNodeLength )$/;"	f	class:CMarkup	signature:( int iPosParent, int& iPos, int& nNodeType, int& nNodeOffset, int& nNodeLength )
CMarkup::x_RemoveNode	third_party/xml/Markup.h	/^	void x_RemoveNode( int iPosParent, int& iPos, int& nNodeType, int& nNodeOffset, int& nNodeLength );$/;"	p	class:CMarkup	access:protected	signature:( int iPosParent, int& iPos, int& nNodeType, int& nNodeOffset, int& nNodeLength )
CMarkup::x_SetAttrib	third_party/xml/Markup.cpp	/^bool CMarkup::x_SetAttrib( int iPos, MCD_PCSZ pAttrib, MCD_PCSZ pValue, int nFlags \/*=0*\/ )$/;"	f	class:CMarkup	signature:( int iPos, MCD_PCSZ pAttrib, MCD_PCSZ pValue, int nFlags )
CMarkup::x_SetAttrib	third_party/xml/Markup.cpp	/^bool CMarkup::x_SetAttrib( int iPos, MCD_PCSZ pAttrib, int nValue, int nFlags \/*=0*\/ )$/;"	f	class:CMarkup	signature:( int iPos, MCD_PCSZ pAttrib, int nValue, int nFlags )
CMarkup::x_SetAttrib	third_party/xml/Markup.h	/^	bool x_SetAttrib( int iPos, MCD_PCSZ pAttrib, MCD_PCSZ pValue, int nFlags=0 );$/;"	p	class:CMarkup	access:protected	signature:( int iPos, MCD_PCSZ pAttrib, MCD_PCSZ pValue, int nFlags=0 )
CMarkup::x_SetAttrib	third_party/xml/Markup.h	/^	bool x_SetAttrib( int iPos, MCD_PCSZ pAttrib, int nValue, int nFlags=0 );$/;"	p	class:CMarkup	access:protected	signature:( int iPos, MCD_PCSZ pAttrib, int nValue, int nFlags=0 )
CMarkup::x_SetData	third_party/xml/Markup.cpp	/^bool CMarkup::x_SetData( int iPos, MCD_PCSZ szData, int nFlags )$/;"	f	class:CMarkup	signature:( int iPos, MCD_PCSZ szData, int nFlags )
CMarkup::x_SetData	third_party/xml/Markup.cpp	/^bool CMarkup::x_SetData( int iPos, int nValue )$/;"	f	class:CMarkup	signature:( int iPos, int nValue )
CMarkup::x_SetData	third_party/xml/Markup.h	/^	bool x_SetData( int iPos, MCD_PCSZ szData, int nFlags );$/;"	p	class:CMarkup	access:protected	signature:( int iPos, MCD_PCSZ szData, int nFlags )
CMarkup::x_SetData	third_party/xml/Markup.h	/^	bool x_SetData( int iPos, int nValue );$/;"	p	class:CMarkup	access:protected	signature:( int iPos, int nValue )
CMarkup::x_SetDebugState	third_party/xml/Markup.cpp	/^void CMarkup::x_SetDebugState()$/;"	f	class:CMarkup	signature:()
CMarkup::x_SetDebugState	third_party/xml/Markup.h	/^	void x_SetDebugState();$/;"	p	class:CMarkup	access:protected	signature:()
CMarkup::x_SetElemContent	third_party/xml/Markup.cpp	/^bool CMarkup::x_SetElemContent( MCD_PCSZ szContent )$/;"	f	class:CMarkup	signature:( MCD_PCSZ szContent )
CMarkup::x_SetElemContent	third_party/xml/Markup.h	/^	bool x_SetElemContent( MCD_PCSZ szContent );$/;"	p	class:CMarkup	access:protected	signature:( MCD_PCSZ szContent )
CMarkup::x_SetPos	third_party/xml/Markup.cpp	/^void CMarkup::x_SetPos( int iPosParent, int iPos, int iPosChild )$/;"	f	class:CMarkup	signature:( int iPosParent, int iPos, int iPosChild )
CMarkup::x_SetPos	third_party/xml/Markup.h	/^	void x_SetPos( int iPosParent, int iPos, int iPosChild );$/;"	p	class:CMarkup	access:protected	signature:( int iPosParent, int iPos, int iPosChild )
CMarkup::x_UnlinkElem	third_party/xml/Markup.cpp	/^int CMarkup::x_UnlinkElem( int iPos )$/;"	f	class:CMarkup	signature:( int iPos )
CMarkup::x_UnlinkElem	third_party/xml/Markup.h	/^	int x_UnlinkElem( int iPos );$/;"	p	class:CMarkup	access:protected	signature:( int iPos )
CMarkup::x_UnlinkPrevElem	third_party/xml/Markup.cpp	/^int CMarkup::x_UnlinkPrevElem( int iPosParent, int iPosBefore, int iPos )$/;"	f	class:CMarkup	signature:( int iPosParent, int iPosBefore, int iPos )
CMarkup::x_UnlinkPrevElem	third_party/xml/Markup.h	/^	int x_UnlinkPrevElem( int iPosParent, int iPosBefore, int iPos );$/;"	p	class:CMarkup	access:protected	signature:( int iPosParent, int iPosBefore, int iPos )
CMarkup::~CMarkup	third_party/xml/Markup.cpp	/^CMarkup::~CMarkup()$/;"	f	class:CMarkup	signature:()
CMarkup::~CMarkup	third_party/xml/Markup.h	/^	~CMarkup();$/;"	p	class:CMarkup	access:public	signature:()
CalcSlot	third_party/xml/Markup.cpp	/^	static int CalcSlot( MCD_PCSZ pName, int n, bool bIC );$/;"	p	struct:ElemStack	file:	access:public	signature:( MCD_PCSZ pName, int n, bool bIC )
CalcSlot	third_party/xml/Markup.cpp	/^int ElemStack::CalcSlot( MCD_PCSZ pName, int n, bool bIC )$/;"	f	class:ElemStack	signature:( MCD_PCSZ pName, int n, bool bIC )
CanConvert	third_party/xml/Markup.cpp	/^	static bool CanConvert( MCD_CSTR pszToEncoding, MCD_CSTR pszFromEncoding );$/;"	p	struct:TextEncoding	file:	access:public	signature:( MCD_CSTR pszToEncoding, MCD_CSTR pszFromEncoding )
CanConvert	third_party/xml/Markup.cpp	/^bool TextEncoding::CanConvert( MCD_CSTR pszToEncoding, MCD_CSTR pszFromEncoding )$/;"	f	class:TextEncoding	signature:( MCD_CSTR pszToEncoding, MCD_CSTR pszFromEncoding )
CheckLR1	galgorithm/lranalyse.cpp	/^bool AlgorithmArg::CheckLR1(const automachine::sheetrow& sortedActs) const$/;"	f	class:AlgorithmArg	signature:(const automachine::sheetrow& sortedActs) const
Clear	third_party/xml/Markup.cpp	/^	void Clear() { m_nL=0; m_nR=-1; m_nNext=0; };$/;"	f	struct:TokenPos	access:public	signature:()
Clear	third_party/xml/Markup.cpp	/^	void Clear() { m_nSegs=0; m_nSize=0; m_pSegs=NULL; };$/;"	f	struct:ElemPosTree	access:public	signature:()
ClearVirtualParent	third_party/xml/Markup.cpp	/^	void ClearVirtualParent() { memset(this,0,sizeof(ElemPos)); };$/;"	f	struct:ElemPos	access:public	signature:()
Column	include/arrayX.h	/^	const static size_t Column = _Col;$/;"	m	struct:SmartMatrix	access:public
ConstRowVector	include/arrayX.h	/^	typedef const_pointer ConstRowVector;$/;"	t	struct:SmartMatrix	access:public
ContentLen	third_party/xml/Markup.cpp	/^	int ContentLen() const { return nLength - StartTagLen() - EndTagLen(); };$/;"	f	struct:ElemPos	access:public	signature:() const
Copy	third_party/xml/Markup.cpp	/^	void Copy( TagPos* pLNew ) { for(int n=0;n<nSize;++n) pLNew[n]=pL[n]; if (pL) delete [] pL; pL=pLNew; };$/;"	f	struct:ElemStack	access:protected	signature:( TagPos* pLNew )
CopyElemPosTree	third_party/xml/Markup.cpp	/^	void CopyElemPosTree( ElemPosTree* pOtherTree, int n );$/;"	p	struct:ElemPosTree	file:	access:public	signature:( ElemPosTree* pOtherTree, int n )
CopyElemPosTree	third_party/xml/Markup.cpp	/^void ElemPosTree::CopyElemPosTree( ElemPosTree* pOtherTree, int n )$/;"	f	class:ElemPosTree	signature:( ElemPosTree* pOtherTree, int n )
CopySavedPosMaps	third_party/xml/Markup.cpp	/^	void CopySavedPosMaps( SavedPosMapArray* pOtherMaps );$/;"	p	struct:SavedPosMapArray	file:	access:public	signature:( SavedPosMapArray* pOtherMaps )
CopySavedPosMaps	third_party/xml/Markup.cpp	/^void SavedPosMapArray::CopySavedPosMaps( SavedPosMapArray* pOtherMaps )$/;"	f	class:SavedPosMapArray	signature:( SavedPosMapArray* pOtherMaps )
Current	third_party/xml/Markup.cpp	/^	TagPos& Current() { return pL[iTop]; };$/;"	f	struct:ElemStack	access:public	signature:()
DEBUG_OUTPUT	galgorithm/basicalgorithms.cpp	10;"	d	file:
DEBUG_OUTPUT	galgorithm/firstfollow.cpp	7;"	d	file:
DecodeCharUTF16	third_party/xml/Markup.cpp	/^int CMarkup::DecodeCharUTF16( const unsigned short*& pwszUTF16, const unsigned short* pszUTF16End\/*=NULL*\/ )$/;"	f	class:CMarkup	signature:( const unsigned short*& pwszUTF16, const unsigned short* pszUTF16End )
DecodeCharUTF16	third_party/xml/Markup.h	/^	static int DecodeCharUTF16( const unsigned short*& pwszUTF16, const unsigned short* pszUTF16End = NULL );$/;"	p	class:CMarkup	access:public	signature:( const unsigned short*& pwszUTF16, const unsigned short* pszUTF16End = NULL )
DecodeCharUTF8	third_party/xml/Markup.cpp	/^int CMarkup::DecodeCharUTF8( const char*& pszUTF8, const char* pszUTF8End\/*=NULL*\/ )$/;"	f	class:CMarkup	signature:( const char*& pszUTF8, const char* pszUTF8End )
DecodeCharUTF8	third_party/xml/Markup.h	/^	static int DecodeCharUTF8( const char*& pszUTF8, const char* pszUTF8End = NULL );$/;"	p	class:CMarkup	access:public	signature:( const char*& pszUTF8, const char* pszUTF8End = NULL )
DetectUTF8	third_party/xml/Markup.cpp	/^bool CMarkup::DetectUTF8( const char* pText, int nTextLen, int* pnNonASCII\/*=NULL*\/, bool* bErrorAtEnd\/*=NULL*\/ )$/;"	f	class:CMarkup	signature:( const char* pText, int nTextLen, int* pnNonASCII , bool* bErrorAtEnd )
DetectUTF8	third_party/xml/Markup.h	/^	static bool DetectUTF8( const char* pText, int nTextLen, int* pnNonASCII = NULL, bool* bErrorAtEnd = NULL );$/;"	p	class:CMarkup	access:public	signature:( const char* pText, int nTextLen, int* pnNonASCII = NULL, bool* bErrorAtEnd = NULL )
Diff_Mast_Grate_Than_Zero	include/iteratorX.h	/^template<size_t D> struct Diff_Mast_Grate_Than_Zero{};$/;"	s
ELEM	third_party/xml/Markup.cpp	1023;"	d	file:
ElemPos	third_party/xml/Markup.cpp	/^	ElemPos( const ElemPos& pos ) { *this = pos; };$/;"	f	struct:ElemPos	access:public	signature:( const ElemPos& pos )
ElemPos	third_party/xml/Markup.cpp	/^	ElemPos() {};$/;"	f	struct:ElemPos	access:public	signature:()
ElemPos	third_party/xml/Markup.cpp	/^struct ElemPos$/;"	s	file:
ElemPos::AdjustStartTagLen	third_party/xml/Markup.cpp	/^	void AdjustStartTagLen( int n ) { nStartTagLen += n; };$/;"	f	struct:ElemPos	access:public	signature:( int n )
ElemPos::ClearVirtualParent	third_party/xml/Markup.cpp	/^	void ClearVirtualParent() { memset(this,0,sizeof(ElemPos)); };$/;"	f	struct:ElemPos	access:public	signature:()
ElemPos::ContentLen	third_party/xml/Markup.cpp	/^	int ContentLen() const { return nLength - StartTagLen() - EndTagLen(); };$/;"	f	struct:ElemPos	access:public	signature:() const
ElemPos::ElemPos	third_party/xml/Markup.cpp	/^	ElemPos( const ElemPos& pos ) { *this = pos; };$/;"	f	struct:ElemPos	access:public	signature:( const ElemPos& pos )
ElemPos::ElemPos	third_party/xml/Markup.cpp	/^	ElemPos() {};$/;"	f	struct:ElemPos	access:public	signature:()
ElemPos::EndTagLen	third_party/xml/Markup.cpp	/^	int EndTagLen() const { return nEndTagLen; };$/;"	f	struct:ElemPos	access:public	signature:() const
ElemPos::IsEmptyElement	third_party/xml/Markup.cpp	/^	bool IsEmptyElement() { return (StartTagLen()==nLength)?true:false; };$/;"	f	struct:ElemPos	access:public	signature:()
ElemPos::IsUnparsed	third_party/xml/Markup.cpp	/^	bool IsUnparsed() { return EndTagLen() == 1; };$/;"	f	struct:ElemPos	access:public	signature:()
ElemPos::Level	third_party/xml/Markup.cpp	/^    int Level() const { return nFlags & 0xffff; };$/;"	f	struct:ElemPos	access:public	signature:() const
ElemPos::SetEndTagLen	third_party/xml/Markup.cpp	/^	void SetEndTagLen( int n ) { nEndTagLen = n; };$/;"	f	struct:ElemPos	access:public	signature:( int n )
ElemPos::SetEndTagLenUnparsed	third_party/xml/Markup.cpp	/^	void SetEndTagLenUnparsed() { SetEndTagLen(1); };$/;"	f	struct:ElemPos	access:public	signature:()
ElemPos::SetLevel	third_party/xml/Markup.cpp	/^    void SetLevel( int nLev ) { nFlags = (nFlags & ~0xffff) | nLev; };$/;"	f	struct:ElemPos	access:public	signature:( int nLev )
ElemPos::SetStartTagLen	third_party/xml/Markup.cpp	/^	void SetStartTagLen( int n ) { nStartTagLen = n; };$/;"	f	struct:ElemPos	access:public	signature:( int n )
ElemPos::StartAfter	third_party/xml/Markup.cpp	/^	int StartAfter() const { return nStart + nLength; };$/;"	f	struct:ElemPos	access:public	signature:() const
ElemPos::StartContent	third_party/xml/Markup.cpp	/^	int StartContent() const { return nStart + StartTagLen(); };$/;"	f	struct:ElemPos	access:public	signature:() const
ElemPos::StartTagLen	third_party/xml/Markup.cpp	/^	int StartTagLen() const { return nStartTagLen; };$/;"	f	struct:ElemPos	access:public	signature:() const
ElemPos::iElemChild	third_party/xml/Markup.cpp	/^	int iElemChild; \/\/ first child$/;"	m	struct:ElemPos	file:	access:public
ElemPos::iElemNext	third_party/xml/Markup.cpp	/^	int iElemNext; \/\/ next sibling$/;"	m	struct:ElemPos	file:	access:public
ElemPos::iElemParent	third_party/xml/Markup.cpp	/^	int iElemParent;$/;"	m	struct:ElemPos	file:	access:public
ElemPos::iElemPrev	third_party/xml/Markup.cpp	/^	int iElemPrev; \/\/ if this is first, iElemPrev points to last$/;"	m	struct:ElemPos	file:	access:public
ElemPos::nEndTagLen	third_party/xml/Markup.cpp	/^	unsigned int nEndTagLen : 10; \/\/ 1K limit for end tag$/;"	m	struct:ElemPos	file:	access:public
ElemPos::nFlags	third_party/xml/Markup.cpp	/^    int nFlags; \/\/ 16 bits flags, 16 bits level 65536 depth limit$/;"	m	struct:ElemPos	file:	access:public
ElemPos::nLength	third_party/xml/Markup.cpp	/^	int nLength;$/;"	m	struct:ElemPos	file:	access:public
ElemPos::nStart	third_party/xml/Markup.cpp	/^	int nStart;$/;"	m	struct:ElemPos	file:	access:public
ElemPos::nStartTagLen	third_party/xml/Markup.cpp	/^	unsigned int nStartTagLen : 22; \/\/ 4MB limit for start tag$/;"	m	struct:ElemPos	file:	access:public
ElemPosTree	third_party/xml/Markup.cpp	/^	ElemPosTree() { Clear(); };$/;"	f	struct:ElemPosTree	access:public	signature:()
ElemPosTree	third_party/xml/Markup.cpp	/^struct ElemPosTree$/;"	s	file:
ElemPosTree::Clear	third_party/xml/Markup.cpp	/^	void Clear() { m_nSegs=0; m_nSize=0; m_pSegs=NULL; };$/;"	f	struct:ElemPosTree	access:public	signature:()
ElemPosTree::CopyElemPosTree	third_party/xml/Markup.cpp	/^	void CopyElemPosTree( ElemPosTree* pOtherTree, int n );$/;"	p	struct:ElemPosTree	file:	access:public	signature:( ElemPosTree* pOtherTree, int n )
ElemPosTree::CopyElemPosTree	third_party/xml/Markup.cpp	/^void ElemPosTree::CopyElemPosTree( ElemPosTree* pOtherTree, int n )$/;"	f	class:ElemPosTree	signature:( ElemPosTree* pOtherTree, int n )
ElemPosTree::ElemPosTree	third_party/xml/Markup.cpp	/^	ElemPosTree() { Clear(); };$/;"	f	struct:ElemPosTree	access:public	signature:()
ElemPosTree::GetRefElemPosAt	third_party/xml/Markup.cpp	/^	ElemPos& GetRefElemPosAt(int i) const { return m_pSegs[i>>PA_SEGBITS][i&PA_SEGMASK]; };$/;"	f	struct:ElemPosTree	access:public	signature:(int i) const
ElemPosTree::GetSize	third_party/xml/Markup.cpp	/^	int GetSize() const { return m_nSize; };$/;"	f	struct:ElemPosTree	access:public	signature:() const
ElemPosTree::GrowElemPosTree	third_party/xml/Markup.cpp	/^	void GrowElemPosTree( int nNewSize );$/;"	p	struct:ElemPosTree	file:	access:public	signature:( int nNewSize )
ElemPosTree::GrowElemPosTree	third_party/xml/Markup.cpp	/^void ElemPosTree::GrowElemPosTree( int nNewSize )$/;"	f	class:ElemPosTree	signature:( int nNewSize )
ElemPosTree::PA_SEGBITS	third_party/xml/Markup.cpp	/^	enum { PA_SEGBITS = 16, PA_SEGMASK = 0xffff };$/;"	e	enum:ElemPosTree::__anon65	file:
ElemPosTree::PA_SEGMASK	third_party/xml/Markup.cpp	/^	enum { PA_SEGBITS = 16, PA_SEGMASK = 0xffff };$/;"	e	enum:ElemPosTree::__anon65	file:
ElemPosTree::Release	third_party/xml/Markup.cpp	/^	void Release() { for (int n=0;n<SegsUsed();++n) delete[] (char*)m_pSegs[n]; if (m_pSegs) delete[] (char*)m_pSegs; };$/;"	f	struct:ElemPosTree	access:public	signature:()
ElemPosTree::ReleaseElemPosTree	third_party/xml/Markup.cpp	/^	void ReleaseElemPosTree() { Release(); Clear(); };$/;"	f	struct:ElemPosTree	access:public	signature:()
ElemPosTree::SegsUsed	third_party/xml/Markup.cpp	/^	int SegsUsed() const { return ((m_nSize-1)>>PA_SEGBITS) + 1; };$/;"	f	struct:ElemPosTree	access:public	signature:() const
ElemPosTree::m_nSegs	third_party/xml/Markup.cpp	/^	int m_nSegs;$/;"	m	struct:ElemPosTree	file:	access:private
ElemPosTree::m_nSize	third_party/xml/Markup.cpp	/^	int m_nSize;$/;"	m	struct:ElemPosTree	file:	access:private
ElemPosTree::m_pSegs	third_party/xml/Markup.cpp	/^	ElemPos** m_pSegs;$/;"	m	struct:ElemPosTree	file:	access:private
ElemPosTree::~ElemPosTree	third_party/xml/Markup.cpp	/^	~ElemPosTree() { Release(); };$/;"	f	struct:ElemPosTree	access:public	signature:()
ElemStack	third_party/xml/Markup.cpp	/^	ElemStack() { iTop=0; iUsed=0; iPar=0; nLevel=0; nSize=0; pL=NULL; Alloc(7); pL[0].Init(); InitTable(); };$/;"	f	struct:ElemStack	access:public	signature:()
ElemStack	third_party/xml/Markup.cpp	/^struct ElemStack$/;"	s	file:
ElemStack::Alloc	third_party/xml/Markup.cpp	/^	void Alloc( int nNewSize ) { TagPos* pLNew = new TagPos[nNewSize]; Copy(pLNew); nSize=nNewSize; };$/;"	f	struct:ElemStack	access:protected	signature:( int nNewSize )
ElemStack::CalcSlot	third_party/xml/Markup.cpp	/^	static int CalcSlot( MCD_PCSZ pName, int n, bool bIC );$/;"	p	struct:ElemStack	file:	access:public	signature:( MCD_PCSZ pName, int n, bool bIC )
ElemStack::CalcSlot	third_party/xml/Markup.cpp	/^int ElemStack::CalcSlot( MCD_PCSZ pName, int n, bool bIC )$/;"	f	class:ElemStack	signature:( MCD_PCSZ pName, int n, bool bIC )
ElemStack::Copy	third_party/xml/Markup.cpp	/^	void Copy( TagPos* pLNew ) { for(int n=0;n<nSize;++n) pLNew[n]=pL[n]; if (pL) delete [] pL; pL=pLNew; };$/;"	f	struct:ElemStack	access:protected	signature:( TagPos* pLNew )
ElemStack::Current	third_party/xml/Markup.cpp	/^	TagPos& Current() { return pL[iTop]; };$/;"	f	struct:ElemStack	access:public	signature:()
ElemStack::ElemStack	third_party/xml/Markup.cpp	/^	ElemStack() { iTop=0; iUsed=0; iPar=0; nLevel=0; nSize=0; pL=NULL; Alloc(7); pL[0].Init(); InitTable(); };$/;"	f	struct:ElemStack	access:public	signature:()
ElemStack::GetRefTagPosAt	third_party/xml/Markup.cpp	/^	TagPos& GetRefTagPosAt( int i ) { return pL[i]; };$/;"	f	struct:ElemStack	access:public	signature:( int i )
ElemStack::InitTable	third_party/xml/Markup.cpp	/^	void InitTable() { memset(anTable,0,sizeof(int)*LS_TABLESIZE); };$/;"	f	struct:ElemStack	access:public	signature:()
ElemStack::IntoLevel	third_party/xml/Markup.cpp	/^	void IntoLevel() { iPar = iTop; ++nLevel; };$/;"	f	struct:ElemStack	access:public	signature:()
ElemStack::LS_TABLESIZE	third_party/xml/Markup.cpp	/^	enum { LS_TABLESIZE = 23 };$/;"	e	enum:ElemStack::__anon66	file:
ElemStack::NextParent	third_party/xml/Markup.cpp	/^	TagPos& NextParent( int& i ) { int iCur=i; i=pL[i].iParent; return pL[iCur]; };$/;"	f	struct:ElemStack	access:public	signature:( int& i )
ElemStack::OutOfLevel	third_party/xml/Markup.cpp	/^	void OutOfLevel() { if (iPar!=iTop) Pop(); iPar = pL[iTop].iParent; --nLevel; };$/;"	f	struct:ElemStack	access:public	signature:()
ElemStack::Pop	third_party/xml/Markup.cpp	/^	void Pop() { iTop = iPar; while (iUsed && pL[iUsed].iParent==iPar) { if (pL[iUsed].nSlot!=-1) Unslot(pL[iUsed]); --iUsed; } };$/;"	f	struct:ElemStack	access:public	signature:()
ElemStack::PopOutOfLevel	third_party/xml/Markup.cpp	/^	void PopOutOfLevel() { --iTop; };$/;"	f	struct:ElemStack	access:public	signature:()
ElemStack::Push	third_party/xml/Markup.cpp	/^	void Push( MCD_PCSZ pName, int n ) { ++iUsed; if (iUsed==nSize) Alloc(nSize*2); pL[iUsed].SetTagName(pName,n); pL[iUsed].iParent=iPar; iTop=iUsed; };$/;"	f	struct:ElemStack	access:public	signature:( MCD_PCSZ pName, int n )
ElemStack::PushIntoLevel	third_party/xml/Markup.cpp	/^	void PushIntoLevel( MCD_PCSZ pName, int n ) { ++iTop; if (iTop==nSize) Alloc(nSize*2); pL[iTop].SetTagName(pName,n); };$/;"	f	struct:ElemStack	access:public	signature:( MCD_PCSZ pName, int n )
ElemStack::PushTagAndCount	third_party/xml/Markup.cpp	/^	void PushTagAndCount( TokenPos& token );$/;"	p	struct:ElemStack	file:	access:public	signature:( TokenPos& token )
ElemStack::PushTagAndCount	third_party/xml/Markup.cpp	/^void ElemStack::PushTagAndCount( TokenPos& token )$/;"	f	class:ElemStack	signature:( TokenPos& token )
ElemStack::Slot	third_party/xml/Markup.cpp	/^	void Slot( int n ) { pL[iUsed].nSlot=n; int i=anTable[n]; anTable[n]=iUsed; pL[iUsed].iSlotNext=i; if (i) pL[i].iSlotPrev=iUsed; };$/;"	f	struct:ElemStack	access:public	signature:( int n )
ElemStack::Unslot	third_party/xml/Markup.cpp	/^	void Unslot( TagPos& lp ) { int n=lp.iSlotNext,p=lp.iSlotPrev; if (n) pL[n].iSlotPrev=p; if (p) pL[p].iSlotNext=n; else anTable[lp.nSlot]=n; };$/;"	f	struct:ElemStack	access:public	signature:( TagPos& lp )
ElemStack::anTable	third_party/xml/Markup.cpp	/^	int anTable[LS_TABLESIZE];$/;"	m	struct:ElemStack	file:	access:protected
ElemStack::iPar	third_party/xml/Markup.cpp	/^	int iPar;$/;"	m	struct:ElemStack	file:	access:public
ElemStack::iTop	third_party/xml/Markup.cpp	/^	int iTop;$/;"	m	struct:ElemStack	file:	access:public
ElemStack::iUsed	third_party/xml/Markup.cpp	/^	int iUsed;$/;"	m	struct:ElemStack	file:	access:protected
ElemStack::nLevel	third_party/xml/Markup.cpp	/^	int nLevel;$/;"	m	struct:ElemStack	file:	access:public
ElemStack::nSize	third_party/xml/Markup.cpp	/^	int nSize;$/;"	m	struct:ElemStack	file:	access:protected
ElemStack::pL	third_party/xml/Markup.cpp	/^	TagPos* pL;$/;"	m	struct:ElemStack	file:	access:protected
ElemStack::~ElemStack	third_party/xml/Markup.cpp	/^	~ElemStack() { if (pL) delete [] pL; };$/;"	f	struct:ElemStack	access:public	signature:()
EncodeCharUTF16	third_party/xml/Markup.cpp	/^void CMarkup::EncodeCharUTF16( int nUChar, unsigned short* pwszUTF16, int& nUTF16Len )$/;"	f	class:CMarkup	signature:( int nUChar, unsigned short* pwszUTF16, int& nUTF16Len )
EncodeCharUTF16	third_party/xml/Markup.h	/^	static void EncodeCharUTF16( int nUChar, unsigned short* pwszUTF16, int& nUTF16Len );$/;"	p	class:CMarkup	access:public	signature:( int nUChar, unsigned short* pwszUTF16, int& nUTF16Len )
EncodeCharUTF8	third_party/xml/Markup.cpp	/^void CMarkup::EncodeCharUTF8( int nUChar, char* pszUTF8, int& nUTF8Len )$/;"	f	class:CMarkup	signature:( int nUChar, char* pszUTF8, int& nUTF8Len )
EncodeCharUTF8	third_party/xml/Markup.h	/^	static void EncodeCharUTF8( int nUChar, char* pszUTF8, int& nUTF8Len );$/;"	p	class:CMarkup	access:public	signature:( int nUChar, char* pszUTF8, int& nUTF8Len )
EncodingNameTable	third_party/xml/Markup.cpp	/^MCD_PCSZ EncodingNameTable[155] =$/;"	v
EndTagLen	third_party/xml/Markup.cpp	/^	int EndTagLen() const { return nEndTagLen; };$/;"	f	struct:ElemPos	access:public	signature:() const
Error	syntax/word.h	/^	enum{Known = 1, Unknown = 0, Error = -1};$/;"	e	enum:word::__anon7
EscapeText	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::EscapeText( MCD_CSTR szText, int nFlags )$/;"	f	class:CMarkup	signature:( MCD_CSTR szText, int nFlags )
EscapeText	third_party/xml/Markup.h	/^	static MCD_STR EscapeText( MCD_CSTR szText, int nFlags = 0 );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR szText, int nFlags = 0 )
Expression	test/output/gen.cpp	/^	Expression()$/;"	f	struct:Expression	access:public	signature:()
Expression	test/output/gen.cpp	/^struct Expression : public type$/;"	s	file:	inherits:type
Expression	test/output/tinyg.cpp	/^	Expression()$/;"	f	struct:Expression	access:public	signature:()
Expression	test/output/tinyg.cpp	/^struct Expression : public type$/;"	s	file:	inherits:type
Expression::Expression	test/output/gen.cpp	/^	Expression()$/;"	f	struct:Expression	access:public	signature:()
Expression::Expression	test/output/tinyg.cpp	/^	Expression()$/;"	f	struct:Expression	access:public	signature:()
Expression::sid	test/output/gen.cpp	/^	enum{ sid = 1004 };$/;"	e	enum:Expression::__anon11	file:
Expression::sid	test/output/tinyg.cpp	/^	enum{ sid = 4 };$/;"	e	enum:Expression::__anon39	file:
FINDNODEBAD	third_party/xml/Markup.cpp	2306;"	d	file:
FINDNODETYPE	third_party/xml/Markup.cpp	2304;"	d	file:
FINDNODETYPENAME	third_party/xml/Markup.cpp	2305;"	d	file:
FIRST_NONTSID	galgorithm/regex2nfa.cpp	12;"	d	file:
FileAtTop	third_party/xml/Markup.cpp	/^	bool FileAtTop();$/;"	p	struct:FilePos	file:	access:public	signature:()
FileAtTop	third_party/xml/Markup.cpp	/^bool FilePos::FileAtTop()$/;"	f	class:FilePos	signature:()
FileCheckRaggedEnd	third_party/xml/Markup.cpp	/^	bool FileCheckRaggedEnd( void* pBuffer );$/;"	p	struct:FilePos	file:	access:public	signature:( void* pBuffer )
FileCheckRaggedEnd	third_party/xml/Markup.cpp	/^bool FilePos::FileCheckRaggedEnd( void* pBuffer )$/;"	f	class:FilePos	signature:( void* pBuffer )
FileClose	third_party/xml/Markup.cpp	/^	bool FileClose();$/;"	p	struct:FilePos	file:	access:public	signature:()
FileClose	third_party/xml/Markup.cpp	/^bool FilePos::FileClose()$/;"	f	class:FilePos	signature:()
FileErrorAddResult	third_party/xml/Markup.cpp	/^	bool FileErrorAddResult();$/;"	p	struct:FilePos	file:	access:public	signature:()
FileErrorAddResult	third_party/xml/Markup.cpp	/^bool FilePos::FileErrorAddResult()$/;"	f	class:FilePos	signature:()
FileFlush	third_party/xml/Markup.cpp	/^	bool FileFlush( MCD_STR& strBuffer, int nWriteStrLen = -1, bool bFflush = false );$/;"	p	struct:FilePos	file:	access:public	signature:( MCD_STR& strBuffer, int nWriteStrLen = -1, bool bFflush = false )
FileFlush	third_party/xml/Markup.cpp	/^bool FilePos::FileFlush( MCD_STR& strBuffer, int nWriteStrLen\/*=-1*\/, bool bFflush\/*=false*\/ )$/;"	f	class:FilePos	signature:( MCD_STR& strBuffer, int nWriteStrLen , bool bFflush )
FileGatherEnd	third_party/xml/Markup.cpp	/^	int FileGatherEnd( MCD_STR& strSubDoc );$/;"	p	struct:FilePos	file:	access:public	signature:( MCD_STR& strSubDoc )
FileGatherEnd	third_party/xml/Markup.cpp	/^int FilePos::FileGatherEnd( MCD_STR& strMarkup )$/;"	f	class:FilePos	signature:( MCD_STR& strMarkup )
FileGatherStart	third_party/xml/Markup.cpp	/^	void FileGatherStart( int nStart );$/;"	p	struct:FilePos	file:	access:public	signature:( int nStart )
FileGatherStart	third_party/xml/Markup.cpp	/^void FilePos::FileGatherStart( int nStart )$/;"	f	class:FilePos	signature:( int nStart )
FileOpen	third_party/xml/Markup.cpp	/^	bool FileOpen( MCD_CSTR_FILENAME szFileName );$/;"	p	struct:FilePos	file:	access:public	signature:( MCD_CSTR_FILENAME szFileName )
FileOpen	third_party/xml/Markup.cpp	/^bool FilePos::FileOpen( MCD_CSTR_FILENAME szFileName )$/;"	f	class:FilePos	signature:( MCD_CSTR_FILENAME szFileName )
FilePos	third_party/xml/Markup.cpp	/^	FilePos()$/;"	f	struct:FilePos	access:public	signature:()
FilePos	third_party/xml/Markup.cpp	/^struct FilePos$/;"	s	file:
FilePos::FileAtTop	third_party/xml/Markup.cpp	/^	bool FileAtTop();$/;"	p	struct:FilePos	file:	access:public	signature:()
FilePos::FileAtTop	third_party/xml/Markup.cpp	/^bool FilePos::FileAtTop()$/;"	f	class:FilePos	signature:()
FilePos::FileCheckRaggedEnd	third_party/xml/Markup.cpp	/^	bool FileCheckRaggedEnd( void* pBuffer );$/;"	p	struct:FilePos	file:	access:public	signature:( void* pBuffer )
FilePos::FileCheckRaggedEnd	third_party/xml/Markup.cpp	/^bool FilePos::FileCheckRaggedEnd( void* pBuffer )$/;"	f	class:FilePos	signature:( void* pBuffer )
FilePos::FileClose	third_party/xml/Markup.cpp	/^	bool FileClose();$/;"	p	struct:FilePos	file:	access:public	signature:()
FilePos::FileClose	third_party/xml/Markup.cpp	/^bool FilePos::FileClose()$/;"	f	class:FilePos	signature:()
FilePos::FileErrorAddResult	third_party/xml/Markup.cpp	/^	bool FileErrorAddResult();$/;"	p	struct:FilePos	file:	access:public	signature:()
FilePos::FileErrorAddResult	third_party/xml/Markup.cpp	/^bool FilePos::FileErrorAddResult()$/;"	f	class:FilePos	signature:()
FilePos::FileFlush	third_party/xml/Markup.cpp	/^	bool FileFlush( MCD_STR& strBuffer, int nWriteStrLen = -1, bool bFflush = false );$/;"	p	struct:FilePos	file:	access:public	signature:( MCD_STR& strBuffer, int nWriteStrLen = -1, bool bFflush = false )
FilePos::FileFlush	third_party/xml/Markup.cpp	/^bool FilePos::FileFlush( MCD_STR& strBuffer, int nWriteStrLen\/*=-1*\/, bool bFflush\/*=false*\/ )$/;"	f	class:FilePos	signature:( MCD_STR& strBuffer, int nWriteStrLen , bool bFflush )
FilePos::FileGatherEnd	third_party/xml/Markup.cpp	/^	int FileGatherEnd( MCD_STR& strSubDoc );$/;"	p	struct:FilePos	file:	access:public	signature:( MCD_STR& strSubDoc )
FilePos::FileGatherEnd	third_party/xml/Markup.cpp	/^int FilePos::FileGatherEnd( MCD_STR& strMarkup )$/;"	f	class:FilePos	signature:( MCD_STR& strMarkup )
FilePos::FileGatherStart	third_party/xml/Markup.cpp	/^	void FileGatherStart( int nStart );$/;"	p	struct:FilePos	file:	access:public	signature:( int nStart )
FilePos::FileGatherStart	third_party/xml/Markup.cpp	/^void FilePos::FileGatherStart( int nStart )$/;"	f	class:FilePos	signature:( int nStart )
FilePos::FileOpen	third_party/xml/Markup.cpp	/^	bool FileOpen( MCD_CSTR_FILENAME szFileName );$/;"	p	struct:FilePos	file:	access:public	signature:( MCD_CSTR_FILENAME szFileName )
FilePos::FileOpen	third_party/xml/Markup.cpp	/^bool FilePos::FileOpen( MCD_CSTR_FILENAME szFileName )$/;"	f	class:FilePos	signature:( MCD_CSTR_FILENAME szFileName )
FilePos::FilePos	third_party/xml/Markup.cpp	/^	FilePos()$/;"	f	struct:FilePos	access:public	signature:()
FilePos::FileRead	third_party/xml/Markup.cpp	/^	bool FileRead( void* pBuffer );$/;"	p	struct:FilePos	file:	access:public	signature:( void* pBuffer )
FilePos::FileRead	third_party/xml/Markup.cpp	/^bool FilePos::FileRead( void* pBuffer )$/;"	f	class:FilePos	signature:( void* pBuffer )
FilePos::FileReadNextBuffer	third_party/xml/Markup.cpp	/^	bool FileReadNextBuffer();$/;"	p	struct:FilePos	file:	access:public	signature:()
FilePos::FileReadNextBuffer	third_party/xml/Markup.cpp	/^bool FilePos::FileReadNextBuffer()$/;"	f	class:FilePos	signature:()
FilePos::FileReadText	third_party/xml/Markup.cpp	/^	bool FileReadText( MCD_STR& strDoc );$/;"	p	struct:FilePos	file:	access:public	signature:( MCD_STR& strDoc )
FilePos::FileReadText	third_party/xml/Markup.cpp	/^bool FilePos::FileReadText( MCD_STR& strDoc )$/;"	f	class:FilePos	signature:( MCD_STR& strDoc )
FilePos::FileSpecifyEncoding	third_party/xml/Markup.cpp	/^	void FileSpecifyEncoding( MCD_STR* pstrEncoding );$/;"	p	struct:FilePos	file:	access:public	signature:( MCD_STR* pstrEncoding )
FilePos::FileSpecifyEncoding	third_party/xml/Markup.cpp	/^void FilePos::FileSpecifyEncoding( MCD_STR* pstrEncoding )$/;"	f	class:FilePos	signature:( MCD_STR* pstrEncoding )
FilePos::FileWrite	third_party/xml/Markup.cpp	/^	bool FileWrite( void* pBuffer, const void* pConstBuffer = NULL );$/;"	p	struct:FilePos	file:	access:public	signature:( void* pBuffer, const void* pConstBuffer = NULL )
FilePos::FileWrite	third_party/xml/Markup.cpp	/^bool FilePos::FileWrite( void* pBuffer, const void* pConstBuffer \/*=NULL*\/ )$/;"	f	class:FilePos	signature:( void* pBuffer, const void* pConstBuffer )
FilePos::FileWriteText	third_party/xml/Markup.cpp	/^	bool FileWriteText( const MCD_STR& strDoc, int nWriteStrLen = -1 );$/;"	p	struct:FilePos	file:	access:public	signature:( const MCD_STR& strDoc, int nWriteStrLen = -1 )
FilePos::FileWriteText	third_party/xml/Markup.cpp	/^bool FilePos::FileWriteText( const MCD_STR& strDoc, int nWriteStrLen\/*=-1*\/ )$/;"	f	class:FilePos	signature:( const MCD_STR& strDoc, int nWriteStrLen )
FilePos::m_elemstack	third_party/xml/Markup.cpp	/^	ElemStack m_elemstack;$/;"	m	struct:FilePos	file:	access:public
FilePos::m_fp	third_party/xml/Markup.cpp	/^	FILE* m_fp;$/;"	m	struct:FilePos	file:	access:public
FilePos::m_nBlockSizeBasis	third_party/xml/Markup.cpp	/^	int m_nBlockSizeBasis;$/;"	m	struct:FilePos	file:	access:public
FilePos::m_nDocFlags	third_party/xml/Markup.cpp	/^	int m_nDocFlags;$/;"	m	struct:FilePos	file:	access:public
FilePos::m_nFileByteLen	third_party/xml/Markup.cpp	/^	MCD_INTFILEOFFSET m_nFileByteLen;$/;"	m	struct:FilePos	file:	access:public
FilePos::m_nFileByteOffset	third_party/xml/Markup.cpp	/^	MCD_INTFILEOFFSET m_nFileByteOffset;$/;"	m	struct:FilePos	file:	access:public
FilePos::m_nFileCharUnitSize	third_party/xml/Markup.cpp	/^	int m_nFileCharUnitSize;$/;"	m	struct:FilePos	file:	access:public
FilePos::m_nOpFileByteLen	third_party/xml/Markup.cpp	/^	int m_nOpFileByteLen;$/;"	m	struct:FilePos	file:	access:public
FilePos::m_nOpFileTextLen	third_party/xml/Markup.cpp	/^	int m_nOpFileTextLen;$/;"	m	struct:FilePos	file:	access:public
FilePos::m_nReadBufferRemoved	third_party/xml/Markup.cpp	/^	int m_nReadBufferRemoved;$/;"	m	struct:FilePos	file:	access:public
FilePos::m_nReadBufferStart	third_party/xml/Markup.cpp	/^	int m_nReadBufferStart;$/;"	m	struct:FilePos	file:	access:public
FilePos::m_nReadGatherStart	third_party/xml/Markup.cpp	/^	int m_nReadGatherStart;$/;"	m	struct:FilePos	file:	access:public
FilePos::m_pstrBuffer	third_party/xml/Markup.cpp	/^	MCD_STR* m_pstrBuffer;$/;"	m	struct:FilePos	file:	access:public
FilePos::m_strEncoding	third_party/xml/Markup.cpp	/^	MCD_STR m_strEncoding;$/;"	m	struct:FilePos	file:	access:public
FilePos::m_strIOResult	third_party/xml/Markup.cpp	/^	MCD_STR m_strIOResult;$/;"	m	struct:FilePos	file:	access:public
FilePos::m_strReadGatherMarkup	third_party/xml/Markup.cpp	/^	MCD_STR m_strReadGatherMarkup;$/;"	m	struct:FilePos	file:	access:public
FileRead	third_party/xml/Markup.cpp	/^	bool FileRead( void* pBuffer );$/;"	p	struct:FilePos	file:	access:public	signature:( void* pBuffer )
FileRead	third_party/xml/Markup.cpp	/^bool FilePos::FileRead( void* pBuffer )$/;"	f	class:FilePos	signature:( void* pBuffer )
FileReadNextBuffer	third_party/xml/Markup.cpp	/^	bool FileReadNextBuffer();$/;"	p	struct:FilePos	file:	access:public	signature:()
FileReadNextBuffer	third_party/xml/Markup.cpp	/^bool FilePos::FileReadNextBuffer()$/;"	f	class:FilePos	signature:()
FileReadText	third_party/xml/Markup.cpp	/^	bool FileReadText( MCD_STR& strDoc );$/;"	p	struct:FilePos	file:	access:public	signature:( MCD_STR& strDoc )
FileReadText	third_party/xml/Markup.cpp	/^bool FilePos::FileReadText( MCD_STR& strDoc )$/;"	f	class:FilePos	signature:( MCD_STR& strDoc )
FileSpecifyEncoding	third_party/xml/Markup.cpp	/^	void FileSpecifyEncoding( MCD_STR* pstrEncoding );$/;"	p	struct:FilePos	file:	access:public	signature:( MCD_STR* pstrEncoding )
FileSpecifyEncoding	third_party/xml/Markup.cpp	/^void FilePos::FileSpecifyEncoding( MCD_STR* pstrEncoding )$/;"	f	class:FilePos	signature:( MCD_STR* pstrEncoding )
FileWrite	third_party/xml/Markup.cpp	/^	bool FileWrite( void* pBuffer, const void* pConstBuffer = NULL );$/;"	p	struct:FilePos	file:	access:public	signature:( void* pBuffer, const void* pConstBuffer = NULL )
FileWrite	third_party/xml/Markup.cpp	/^bool FilePos::FileWrite( void* pBuffer, const void* pConstBuffer \/*=NULL*\/ )$/;"	f	class:FilePos	signature:( void* pBuffer, const void* pConstBuffer )
FileWriteText	third_party/xml/Markup.cpp	/^	bool FileWriteText( const MCD_STR& strDoc, int nWriteStrLen = -1 );$/;"	p	struct:FilePos	file:	access:public	signature:( const MCD_STR& strDoc, int nWriteStrLen = -1 )
FileWriteText	third_party/xml/Markup.cpp	/^bool FilePos::FileWriteText( const MCD_STR& strDoc, int nWriteStrLen\/*=-1*\/ )$/;"	f	class:FilePos	signature:( const MCD_STR& strDoc, int nWriteStrLen )
FindAny	third_party/xml/Markup.cpp	/^	bool FindAny()$/;"	f	struct:TokenPos	access:public	signature:()
FindAttrib	third_party/xml/Markup.cpp	/^	bool FindAttrib( MCD_PCSZ pAttrib, int n = 0 );$/;"	p	struct:TokenPos	file:	access:public	signature:( MCD_PCSZ pAttrib, int n = 0 )
FindAttrib	third_party/xml/Markup.cpp	/^bool TokenPos::FindAttrib( MCD_PCSZ pAttrib, int n\/*=0*\/ )$/;"	f	class:TokenPos	signature:( MCD_PCSZ pAttrib, int n )
FindChildElem	third_party/xml/Markup.cpp	/^bool CMarkup::FindChildElem( MCD_CSTR szName )$/;"	f	class:CMarkup	signature:( MCD_CSTR szName )
FindChildElem	third_party/xml/Markup.h	/^	bool FindChildElem( MCD_CSTR szName=NULL );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR szName=NULL )
FindElem	third_party/xml/Markup.cpp	/^bool CMarkup::FindElem( MCD_CSTR szName )$/;"	f	class:CMarkup	signature:( MCD_CSTR szName )
FindElem	third_party/xml/Markup.h	/^	bool FindElem( MCD_CSTR szName=NULL );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR szName=NULL )
FindName	third_party/xml/Markup.cpp	/^	bool FindName()$/;"	f	struct:TokenPos	access:public	signature:()
FindNode	third_party/xml/Markup.cpp	/^int CMarkup::FindNode( int nType )$/;"	f	class:CMarkup	signature:( int nType )
FindNode	third_party/xml/Markup.h	/^	int FindNode( int nType=0 );$/;"	p	class:CMarkup	access:public	signature:( int nType=0 )
FindRaggedEnd	third_party/xml/Markup.cpp	/^	bool FindRaggedEnd( int& nTruncBeforeBytes );$/;"	p	struct:TextEncoding	file:	access:public	signature:( int& nTruncBeforeBytes )
FindRaggedEnd	third_party/xml/Markup.cpp	/^bool TextEncoding::FindRaggedEnd( int& nTruncBeforeBytes )$/;"	f	class:TextEncoding	signature:( int& nTruncBeforeBytes )
FirstSets	galgorithm/lranalyse.cpp	/^	 FirstSets;$/;"	m	struct:AlgorithmArg	file:	access:public
Float	test/output/tinyg.cpp	/^	Float()$/;"	f	struct:Float	access:public	signature:()
Float	test/output/tinyg.cpp	/^struct Float : public type$/;"	s	file:	inherits:type
Float::Float	test/output/tinyg.cpp	/^	Float()$/;"	f	struct:Float	access:public	signature:()
Float::sid	test/output/tinyg.cpp	/^	enum{ sid = 18 };$/;"	e	enum:Float::__anon53	file:
Format	include/stringXF.h	/^namespace Format$/;"	n
Format::IsDigit	include/stringXF.h	/^	struct IsDigit$/;"	s	namespace:Format
Format::IsDigit::operator ()	include/stringXF.h	/^		bool operator()(char _Ch) const$/;"	f	struct:Format::IsDigit	access:public	signature:(char _Ch) const
Format::IsDigit::operator ()	include/stringXF.h	/^		bool operator()(wchar_t _Ch) const$/;"	f	struct:Format::IsDigit	access:public	signature:(wchar_t _Ch) const
Format::IsSpace	include/stringXF.h	/^	struct IsSpace$/;"	s	namespace:Format
Format::IsSpace::operator ()	include/stringXF.h	/^		bool operator()(char _Ch) const$/;"	f	struct:Format::IsSpace	access:public	signature:(char _Ch) const
Format::IsSpace::operator ()	include/stringXF.h	/^		bool operator()(wchar_t _Ch) const$/;"	f	struct:Format::IsSpace	access:public	signature:(wchar_t _Ch) const
Format::meta	include/stringXF.h	/^	_Elem meta(unsigned short _ch)$/;"	f	namespace:Format	signature:(unsigned short _ch)
Format::swcvt	include/stringXF.h	/^	struct swcvt$/;"	s	namespace:Format
Format::swcvt::convert	include/stringXF.h	/^		static bool convert(const std::string& _Src, std::string& _Dst)$/;"	f	struct:Format::swcvt	access:public	signature:(const std::string& _Src, std::string& _Dst)
Format::swcvt::convert	include/stringXF.h	/^		static bool convert(const std::string& _Src, std::wstring& _Dst)$/;"	f	struct:Format::swcvt	access:public	signature:(const std::string& _Src, std::wstring& _Dst)
Format::swcvt::convert	include/stringXF.h	/^		static bool convert(const std::wstring& _Src, std::string& _Dst)$/;"	f	struct:Format::swcvt	access:public	signature:(const std::wstring& _Src, std::string& _Dst)
Format::swcvt::convert	include/stringXF.h	/^		static bool convert(const std::wstring& _Src, std::wstring& _Dst)$/;"	f	struct:Format::swcvt	access:public	signature:(const std::wstring& _Src, std::wstring& _Dst)
Format::swcvt::convert	include/stringXF.h	/^		static std::basic_string<_Dst_Elem> convert(const std::basic_string<_Src_Elem>& _Src)$/;"	f	struct:Format::swcvt	access:public	signature:(const std::basic_string<_Src_Elem>& _Src)
Format::swcvt::convert	include/stringXF.h	/^		static std::string convert(const std::wstring& _Src)$/;"	f	struct:Format::swcvt	access:public	signature:(const std::wstring& _Src)
Format::swcvt::convert	include/stringXF.h	/^		static std::wstring convert(const std::string& _Src)$/;"	f	struct:Format::swcvt	access:public	signature:(const std::string& _Src)
Format::swcvt::tryconvert	include/stringXF.h	/^		static bool tryconvert(const std::string& _Src, std::wstring& _Dst, std::exception& ex)$/;"	f	struct:Format::swcvt	access:private	signature:(const std::string& _Src, std::wstring& _Dst, std::exception& ex)
Format::swcvt::tryconvert	include/stringXF.h	/^		static bool tryconvert(const std::wstring& _Src, std::string& _Dst, std::exception& ex)$/;"	f	struct:Format::swcvt	access:private	signature:(const std::wstring& _Src, std::string& _Dst, std::exception& ex)
ForwardUntil	third_party/xml/Markup.cpp	/^	void ForwardUntil( MCD_PCSZ szStopChars ) { while ( m_pDocText[m_nNext] && ! MCD_PSZCHR(szStopChars,m_pDocText[m_nNext]) ) m_nNext += MCD_CLEN(&m_pDocText[m_nNext]); }$/;"	f	struct:TokenPos	access:public	signature:( MCD_PCSZ szStopChars )
FuncCall	test/output/gen.cpp	/^	FuncCall()$/;"	f	struct:FuncCall	access:public	signature:()
FuncCall	test/output/gen.cpp	/^struct FuncCall : public type$/;"	s	file:	inherits:type
FuncCall	test/output/tinyg.cpp	/^	FuncCall()$/;"	f	struct:FuncCall	access:public	signature:()
FuncCall	test/output/tinyg.cpp	/^struct FuncCall : public type$/;"	s	file:	inherits:type
FuncCall::FuncCall	test/output/gen.cpp	/^	FuncCall()$/;"	f	struct:FuncCall	access:public	signature:()
FuncCall::FuncCall	test/output/tinyg.cpp	/^	FuncCall()$/;"	f	struct:FuncCall	access:public	signature:()
FuncCall::sid	test/output/gen.cpp	/^	enum{ sid = 1005 };$/;"	e	enum:FuncCall::__anon12	file:
FuncCall::sid	test/output/tinyg.cpp	/^	enum{ sid = 10 };$/;"	e	enum:FuncCall::__anon45	file:
Function	test/output/gen.cpp	/^	Function()$/;"	f	struct:Function	access:public	signature:()
Function	test/output/gen.cpp	/^struct Function : public type$/;"	s	file:	inherits:type
Function	test/output/tinyg.cpp	/^	Function()$/;"	f	struct:Function	access:public	signature:()
Function	test/output/tinyg.cpp	/^struct Function : public type$/;"	s	file:	inherits:type
Function::Function	test/output/gen.cpp	/^	Function()$/;"	f	struct:Function	access:public	signature:()
Function::Function	test/output/tinyg.cpp	/^	Function()$/;"	f	struct:Function	access:public	signature:()
Function::sid	test/output/gen.cpp	/^	enum{ sid = 1006 };$/;"	e	enum:Function::__anon13	file:
Function::sid	test/output/tinyg.cpp	/^	enum{ sid = 3 };$/;"	e	enum:Function::__anon38	file:
FunctionContent	test/output/gen.cpp	/^	FunctionContent()$/;"	f	struct:FunctionContent	access:public	signature:()
FunctionContent	test/output/gen.cpp	/^struct FunctionContent : public type$/;"	s	file:	inherits:type
FunctionContent	test/output/tinyg.cpp	/^	FunctionContent()$/;"	f	struct:FunctionContent	access:public	signature:()
FunctionContent	test/output/tinyg.cpp	/^struct FunctionContent : public type$/;"	s	file:	inherits:type
FunctionContent::FunctionContent	test/output/gen.cpp	/^	FunctionContent()$/;"	f	struct:FunctionContent	access:public	signature:()
FunctionContent::FunctionContent	test/output/tinyg.cpp	/^	FunctionContent()$/;"	f	struct:FunctionContent	access:public	signature:()
FunctionContent::sid	test/output/gen.cpp	/^	enum{ sid = 1007 };$/;"	e	enum:FunctionContent::__anon14	file:
FunctionContent::sid	test/output/tinyg.cpp	/^	enum{ sid = 14 };$/;"	e	enum:FunctionContent::__anon49	file:
GetAttrib	third_party/xml/Markup.h	/^	MCD_STR GetAttrib( MCD_CSTR szAttrib ) const { return x_GetAttrib(m_iPos,szAttrib); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib ) const
GetAttribName	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::GetAttribName( int n ) const$/;"	f	class:CMarkup	signature:( int n ) const
GetAttribName	third_party/xml/Markup.h	/^	MCD_STR GetAttribName( int n ) const;$/;"	p	class:CMarkup	access:public	signature:( int n ) const
GetChar	third_party/xml/Markup.cpp	/^	MCD_CHAR GetChar() { return p[i]; };$/;"	f	struct:PathPos	access:public	signature:()
GetChildAttrib	third_party/xml/Markup.h	/^	MCD_STR GetChildAttrib( MCD_CSTR szAttrib ) const { return x_GetAttrib(m_iPosChild,szAttrib); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib ) const
GetChildData	third_party/xml/Markup.h	/^	MCD_STR GetChildData() { return x_GetData(m_iPosChild); };$/;"	f	class:CMarkup	access:public	signature:()
GetChildSubDoc	third_party/xml/Markup.h	/^	MCD_STR GetChildSubDoc() { return x_GetSubDoc(m_iPosChild); };$/;"	f	class:CMarkup	access:public	signature:()
GetChildTagName	third_party/xml/Markup.h	/^	MCD_STR GetChildTagName() const { return x_GetTagName(m_iPosChild); };$/;"	f	class:CMarkup	access:public	signature:() const
GetData	third_party/xml/Markup.h	/^	MCD_STR GetData() { return x_GetData(m_iPos); };$/;"	f	class:CMarkup	access:public	signature:()
GetDeclaredEncoding	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::GetDeclaredEncoding( MCD_CSTR szDoc )$/;"	f	class:CMarkup	signature:( MCD_CSTR szDoc )
GetDeclaredEncoding	third_party/xml/Markup.h	/^	static MCD_STR GetDeclaredEncoding( MCD_CSTR szDoc );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR szDoc )
GetDoc	third_party/xml/Markup.h	/^	const MCD_STR& GetDoc() const { return m_strDoc; };$/;"	f	class:CMarkup	access:public	signature:() const
GetDocFlags	third_party/xml/Markup.h	/^	int GetDocFlags() const { return m_nDocFlags; };$/;"	f	class:CMarkup	access:public	signature:() const
GetElemContent	third_party/xml/Markup.h	/^	MCD_STR GetElemContent() const { return x_GetElemContent(m_iPos); };$/;"	f	class:CMarkup	access:public	signature:() const
GetEncodingCodePage	third_party/xml/Markup.cpp	/^int CMarkup::GetEncodingCodePage( MCD_CSTR pszEncoding )$/;"	f	class:CMarkup	signature:( MCD_CSTR pszEncoding )
GetEncodingCodePage	third_party/xml/Markup.h	/^	static int GetEncodingCodePage( MCD_CSTR pszEncoding );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR pszEncoding )
GetError	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::GetError() const$/;"	f	class:CMarkup	signature:() const
GetError	third_party/xml/Markup.h	/^	MCD_STR GetError() const;$/;"	p	class:CMarkup	access:public	signature:() const
GetFirsts	galgorithm/lranalyse.cpp	/^bool AlgorithmArg::GetFirsts(right_range range, std::list<size_t>& Follows) const$/;"	f	class:AlgorithmArg	signature:(right_range range, std::list<size_t>& Follows) const
GetMap	third_party/xml/Markup.cpp	/^	bool GetMap( SavedPosMap*& pMap, int nMap, int nMapSize = 7 );$/;"	p	struct:SavedPosMapArray	file:	access:public	signature:( SavedPosMap*& pMap, int nMap, int nMapSize = 7 )
GetMap	third_party/xml/Markup.cpp	/^bool SavedPosMapArray::GetMap( SavedPosMap*& pMap, int nMap, int nMapSize \/*=7*\/ )$/;"	f	class:SavedPosMapArray	signature:( SavedPosMap*& pMap, int nMap, int nMapSize )
GetNextSymbol	galgorithm/lranalyse.cpp	/^size_t AlgorithmArg::GetNextSymbol(size_t prodNo, size_t dotPos) const$/;"	f	class:AlgorithmArg	signature:(size_t prodNo, size_t dotPos) const
GetNextSymbols	galgorithm/lranalyse.cpp	/^			AlgorithmArg::GetNextSymbols(size_t prodNo, size_t dotPos) const$/;"	f	class:AlgorithmArg	signature:(size_t prodNo, size_t dotPos) const
GetNodeType	third_party/xml/Markup.h	/^	int GetNodeType() { return m_nNodeType; };$/;"	f	class:CMarkup	access:public	signature:()
GetNumAndInc	third_party/xml/Markup.cpp	/^	int GetNumAndInc() { int n=0; while (p[i]>='0'&&p[i]<='9') n=n*10+(int)p[i++]-(int)'0'; return n; };$/;"	f	struct:PathPos	access:public	signature:()
GetPathAttribName	third_party/xml/Markup.cpp	/^	MCD_PCSZ GetPathAttribName() { if (iPathAttribName) return &p[iPathAttribName]; return NULL; };$/;"	f	struct:PathPos	access:public	signature:()
GetPtr	third_party/xml/Markup.cpp	/^	MCD_PCSZ GetPtr() { return &p[i]; };$/;"	f	struct:PathPos	access:public	signature:()
GetRefElemPosAt	third_party/xml/Markup.cpp	/^	ElemPos& GetRefElemPosAt(int i) const { return m_pSegs[i>>PA_SEGBITS][i&PA_SEGMASK]; };$/;"	f	struct:ElemPosTree	access:public	signature:(int i) const
GetRefTagPosAt	third_party/xml/Markup.cpp	/^	TagPos& GetRefTagPosAt( int i ) { return pL[i]; };$/;"	f	struct:ElemStack	access:public	signature:( int i )
GetResult	third_party/xml/Markup.h	/^	const MCD_STR& GetResult() const { return m_strResult; };$/;"	f	class:CMarkup	access:public	signature:() const
GetSize	third_party/xml/Markup.cpp	/^	int GetSize() const { return m_nSize; };$/;"	f	struct:ElemPosTree	access:public	signature:() const
GetSubDoc	third_party/xml/Markup.h	/^	MCD_STR GetSubDoc() { return x_GetSubDoc(m_iPos); };$/;"	f	class:CMarkup	access:public	signature:()
GetTagName	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::GetTagName() const$/;"	f	class:CMarkup	signature:() const
GetTagName	third_party/xml/Markup.h	/^	MCD_STR GetTagName() const;$/;"	p	class:CMarkup	access:public	signature:() const
GetTokenPtr	third_party/xml/Markup.cpp	/^	MCD_PCSZ GetTokenPtr() const { return &m_pDocText[m_nL]; };$/;"	f	struct:TokenPos	access:public	signature:() const
GetTokenText	third_party/xml/Markup.cpp	/^	MCD_STR GetTokenText() const { return MCD_STR( GetTokenPtr(), Length() ); };$/;"	f	struct:TokenPos	access:public	signature:() const
GetTypeAndInc	third_party/xml/Markup.cpp	/^	int GetTypeAndInc() { i=-1; if (p) { if (p[0]=='\/') { if (p[1]=='\/') i=2; else i=1; } else if (p[0]) i=0; } nPathType=i+1; return nPathType; };$/;"	f	struct:PathPos	access:public	signature:()
GetValAndInc	third_party/xml/Markup.cpp	/^	MCD_PCSZ GetValAndInc() { ++i; MCD_CHAR cEnd=']'; if (p[i]=='\\''||p[i]=='\\"') cEnd=p[i++]; int iVal=i; IncWord(cEnd); nLen=i-iVal; if (cEnd!=']') ++i; return &p[iVal]; };$/;"	f	struct:PathPos	access:public	signature:()
GetValOrWordLen	third_party/xml/Markup.cpp	/^	int GetValOrWordLen() { return nLen; };$/;"	f	struct:PathPos	access:public	signature:()
GetWordAndInc	third_party/xml/Markup.cpp	/^	MCD_PCSZ GetWordAndInc() { int iWord=i; IncWord(); nLen=i-iWord; return &p[iWord]; };$/;"	f	struct:PathPos	access:public	signature:()
GrowElemPosTree	third_party/xml/Markup.cpp	/^	void GrowElemPosTree( int nNewSize );$/;"	p	struct:ElemPosTree	file:	access:public	signature:( int nNewSize )
GrowElemPosTree	third_party/xml/Markup.cpp	/^void ElemPosTree::GrowElemPosTree( int nNewSize )$/;"	f	class:ElemPosTree	signature:( int nNewSize )
IConv	third_party/xml/Markup.cpp	/^	int IConv( void* pTo, int nToCharSize, int nFromCharSize );$/;"	p	struct:TextEncoding	file:	access:public	signature:( void* pTo, int nToCharSize, int nFromCharSize )
IConv	third_party/xml/Markup.cpp	/^int TextEncoding::IConv( void* pTo, int nToCharSize, int nFromCharSize )$/;"	f	class:TextEncoding	signature:( void* pTo, int nToCharSize, int nFromCharSize )
IConvName	third_party/xml/Markup.cpp	/^	static const char* IConvName( char* szEncoding, MCD_CSTR pszEncoding );$/;"	p	struct:TextEncoding	file:	access:public	signature:( char* szEncoding, MCD_CSTR pszEncoding )
IConvName	third_party/xml/Markup.cpp	/^const char* TextEncoding::IConvName( char* szEncoding, MCD_CSTR pszEncoding )$/;"	f	class:TextEncoding	signature:( char* szEncoding, MCD_CSTR pszEncoding )
IDX	test/vhelp.h	52;"	d
Ident	tmp/coutfun.cpp	/^	Ident(int i = 0)$/;"	f	struct:Ident	access:public	signature:(int i = 0)
Ident	tmp/coutfun.cpp	/^struct Ident$/;"	s	file:
Ident::Ident	tmp/coutfun.cpp	/^	Ident(int i = 0)$/;"	f	struct:Ident	access:public	signature:(int i = 0)
Ident::inc	tmp/coutfun.cpp	/^	int inc;$/;"	m	struct:Ident	file:	access:public
Ident::newline	tmp/coutfun.cpp	/^	static std::ostream& newline(std::ostream& os)$/;"	f	struct:Ident	access:public	signature:(std::ostream& os)
Ident::operator <<	tmp/coutfun.cpp	/^	friend std::ostream& operator<<(std::ostream& os, const Ident& a)$/;"	f	struct:Ident	access:friend	signature:(std::ostream& os, const Ident& a)
Ident::tabs	tmp/coutfun.cpp	/^	static int tabs;$/;"	m	struct:Ident	file:	access:public
Ident::tabs	tmp/coutfun.cpp	/^int Ident::tabs = 0;$/;"	m	class:Ident	file:
Inc	third_party/xml/Markup.cpp	/^	void Inc( int n ) { i+=n; };$/;"	f	struct:PathPos	access:public	signature:( int n )
IncChar	third_party/xml/Markup.cpp	/^	void IncChar() { ++i; };$/;"	f	struct:PathPos	access:public	signature:()
IncCount	third_party/xml/Markup.cpp	/^	void IncCount() { if (nCount) ++nCount; };$/;"	f	struct:TagPos	access:public	signature:()
IncWord	third_party/xml/Markup.cpp	/^	void IncWord( MCD_CHAR c ) { while (p[i]&&p[i]!=c) i+=MCD_CLEN(&p[i]); };$/;"	f	struct:PathPos	access:public	signature:( MCD_CHAR c )
IncWord	third_party/xml/Markup.cpp	/^	void IncWord() { while (p[i]&&!MCD_PSZCHR(MCD_T(" =\/[]"),p[i])) i+=MCD_CLEN(&p[i]); };$/;"	f	struct:PathPos	access:public	signature:()
Init	third_party/xml/Markup.cpp	/^	void Init( int i=0, int n=1 ) { nCount=1; nTagNames=n; iNext=i; iPrev=0; nSlot=-1; iSlotPrev=0; iSlotNext=0; };$/;"	f	struct:TagPos	access:public	signature:( int i=0, int n=1 )
InitTable	third_party/xml/Markup.cpp	/^	void InitTable() { memset(anTable,0,sizeof(int)*LS_TABLESIZE); };$/;"	f	struct:ElemStack	access:public	signature:()
InsertChildElem	third_party/xml/Markup.h	/^	bool InsertChildElem( MCD_CSTR szName, MCD_CSTR szData=NULL, int nFlags=0 ) { return x_AddElem(szName,szData,nFlags|MNF_INSERT|MNF_CHILD); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szName, MCD_CSTR szData=NULL, int nFlags=0 )
InsertChildElem	third_party/xml/Markup.h	/^	bool InsertChildElem( MCD_CSTR szName, int nValue, int nFlags=0 ) { return x_AddElem(szName,nValue,nFlags|MNF_INSERT|MNF_CHILD); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szName, int nValue, int nFlags=0 )
InsertChildSubDoc	third_party/xml/Markup.h	/^	bool InsertChildSubDoc( MCD_CSTR szSubDoc ) { return x_AddSubDoc(szSubDoc,MNF_CHILD|MNF_INSERT); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szSubDoc )
InsertElem	third_party/xml/Markup.h	/^	bool InsertElem( MCD_CSTR szName, MCD_CSTR szData=NULL, int nFlags=0 ) { return x_AddElem(szName,szData,nFlags|MNF_INSERT); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szName, MCD_CSTR szData=NULL, int nFlags=0 )
InsertElem	third_party/xml/Markup.h	/^	bool InsertElem( MCD_CSTR szName, int nValue, int nFlags=0 ) { return x_AddElem(szName,nValue,nFlags|MNF_INSERT); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szName, int nValue, int nFlags=0 )
InsertNode	third_party/xml/Markup.h	/^	bool InsertNode( int nType, MCD_CSTR szText ) { return x_AddNode(nType,szText,MNF_INSERT); };$/;"	f	class:CMarkup	access:public	signature:( int nType, MCD_CSTR szText )
InsertSubDoc	third_party/xml/Markup.h	/^	bool InsertSubDoc( MCD_CSTR szSubDoc ) { return x_AddSubDoc(szSubDoc,MNF_INSERT); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szSubDoc )
Int	test/output/tinyg.cpp	/^	Int()$/;"	f	struct:Int	access:public	signature:()
Int	test/output/tinyg.cpp	/^struct Int : public type$/;"	s	file:	inherits:type
Int::Int	test/output/tinyg.cpp	/^	Int()$/;"	f	struct:Int	access:public	signature:()
Int::sid	test/output/tinyg.cpp	/^	enum{ sid = 17 };$/;"	e	enum:Int::__anon52	file:
IntoElem	third_party/xml/Markup.cpp	/^bool CMarkup::IntoElem()$/;"	f	class:CMarkup	signature:()
IntoElem	third_party/xml/Markup.h	/^	bool IntoElem();$/;"	p	class:CMarkup	access:public	signature:()
IntoLevel	third_party/xml/Markup.cpp	/^	void IntoLevel() { iPar = iTop; ++nLevel; };$/;"	f	struct:ElemStack	access:public	signature:()
IsAbsolutePath	third_party/xml/Markup.cpp	/^	bool IsAbsolutePath() { return nPathType == 2; };$/;"	f	struct:PathPos	access:public	signature:()
IsAnywherePath	third_party/xml/Markup.cpp	/^	bool IsAnywherePath() { return nPathType == 3; };$/;"	f	struct:PathPos	access:public	signature:()
IsAtPathEnd	third_party/xml/Markup.cpp	/^	bool IsAtPathEnd() { return ((!p[i])||(iPathAttribName&&i+2>=iPathAttribName))?true:false; }; $/;"	f	struct:PathPos	access:public	signature:()
IsBetween	include/functionalX.h	/^inline bool IsBetween(const Value_Type& min_value, const Value_Type& max_value, const Value_Type& value)$/;"	f	signature:(const Value_Type& min_value, const Value_Type& max_value, const Value_Type& value)
IsDigit	include/stringXF.h	/^	struct IsDigit$/;"	s	namespace:Format
IsEmptyElement	third_party/xml/Markup.cpp	/^	bool IsEmptyElement() { return (StartTagLen()==nLength)?true:false; };$/;"	f	struct:ElemPos	access:public	signature:()
IsPath	third_party/xml/Markup.cpp	/^	bool IsPath() { return nPathType > 0; };$/;"	f	struct:PathPos	access:public	signature:()
IsSpace	include/stringXF.h	/^	struct IsSpace$/;"	s	namespace:Format
IsTerminate	galgorithm/lranalyse.cpp	/^	std::vector<int> IsTerminate;$/;"	m	struct:AlgorithmArg	file:	access:public
IsUnparsed	third_party/xml/Markup.cpp	/^	bool IsUnparsed() { return EndTagLen() == 1; };$/;"	f	struct:ElemPos	access:public	signature:()
IsVNEmpty	galgorithm/lranalyse.cpp	/^	std::vector<int> IsVNEmpty;$/;"	m	struct:AlgorithmArg	file:	access:public
IsWellFormed	third_party/xml/Markup.cpp	/^bool CMarkup::IsWellFormed()$/;"	f	class:CMarkup	signature:()
IsWellFormed	third_party/xml/Markup.h	/^	bool IsWellFormed();$/;"	p	class:CMarkup	access:public	signature:()
Known	syntax/word.h	/^	enum{Known = 1, Unknown = 0, Error = -1};$/;"	e	enum:word::__anon7
L	galgorithm/regex2nfa.cpp	/^		int L; \/\/ left$/;"	m	struct:parsecontent::prod	file:	access:public
L	tmp/back/regex2nfa.cpp	/^		int L; \/\/ left$/;"	m	struct:parsecontent::prod	file:	access:public
LS_TABLESIZE	third_party/xml/Markup.cpp	/^	enum { LS_TABLESIZE = 23 };$/;"	e	enum:ElemStack::__anon66	file:
L_	syntax/production.h	/^	int32 L_;$/;"	m	class:production	access:private
Length	include/arrayX.h	/^	const static size_t Length = _Length;$/;"	m	struct:SmartArray	access:public
Length	include/arrayX.h	/^	const static size_t Length = _Row * _Col;$/;"	m	struct:SmartMatrix	access:public
Length	third_party/xml/Markup.cpp	/^	int Length() const { return m_nR - m_nL + 1; };$/;"	f	struct:TokenPos	access:public	signature:() const
Level	third_party/xml/Markup.cpp	/^    int Level() const { return nFlags & 0xffff; };$/;"	f	struct:ElemPos	access:public	signature:() const
Lfuncs	syntax/symbol.h	/^	int8 Lfuncs;$/;"	m	struct:symbol	access:public
Lname	syntax/symbol.h	/^	int16 Lname;$/;"	m	struct:symbol	access:public
Load	third_party/xml/Markup.cpp	/^bool CMarkup::Load( MCD_CSTR_FILENAME szFileName )$/;"	f	class:CMarkup	signature:( MCD_CSTR_FILENAME szFileName )
Load	third_party/xml/Markup.h	/^	bool Load( MCD_CSTR_FILENAME szFileName );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR_FILENAME szFileName )
MARKUP_FILEBLOCKSIZE	third_party/xml/Markup.h	62;"	d
MARKUP_ICONV	third_party/xml/Markup.h	42;"	d
MARKUP_MBCS	third_party/xml/Markup.h	49;"	d
MARKUP_SETDEBUGSTATE	third_party/xml/Markup.h	414;"	d
MARKUP_SETDEBUGSTATE	third_party/xml/Markup.h	416;"	d
MARKUP_SIZEOFWCHAR	third_party/xml/Markup.h	53;"	d
MARKUP_SIZEOFWCHAR	third_party/xml/Markup.h	55;"	d
MARKUP_STL	third_party/xml/Markup.h	15;"	d
MARKUP_STL	third_party/xml/Markup.h	39;"	d
MARKUP_WINCONV	third_party/xml/Markup.h	59;"	d
MCD_2PCSZ	third_party/xml/Markup.h	155;"	d
MCD_2PCSZ	third_party/xml/Markup.h	175;"	d
MCD_ACP	third_party/xml/Markup.h	67;"	d
MCD_BLDAPPEND	third_party/xml/Markup.h	170;"	d
MCD_BLDAPPEND	third_party/xml/Markup.h	189;"	d
MCD_BLDAPPEND1	third_party/xml/Markup.h	171;"	d
MCD_BLDAPPEND1	third_party/xml/Markup.h	190;"	d
MCD_BLDAPPENDN	third_party/xml/Markup.h	169;"	d
MCD_BLDAPPENDN	third_party/xml/Markup.h	188;"	d
MCD_BLDCHECK	third_party/xml/Markup.h	167;"	d
MCD_BLDCHECK	third_party/xml/Markup.h	186;"	d
MCD_BLDRELEASE	third_party/xml/Markup.h	168;"	d
MCD_BLDRELEASE	third_party/xml/Markup.h	187;"	d
MCD_BLDRESERVE	third_party/xml/Markup.h	166;"	d
MCD_BLDRESERVE	third_party/xml/Markup.h	185;"	d
MCD_CHAR	third_party/xml/Markup.h	106;"	d
MCD_CHAR	third_party/xml/Markup.h	72;"	d
MCD_CLEN	third_party/xml/Markup.h	104;"	d
MCD_CLEN	third_party/xml/Markup.h	132;"	d
MCD_CLEN	third_party/xml/Markup.h	134;"	d
MCD_CLEN	third_party/xml/Markup.h	138;"	d
MCD_CSTR	third_party/xml/Markup.h	/^	MCD_CSTR( MCD_PCSZ p ) { pcsz=p; };$/;"	f	struct:MCD_CSTR	access:public	signature:( MCD_PCSZ p )
MCD_CSTR	third_party/xml/Markup.h	/^	MCD_CSTR( const MCD_STR& s ) { pcsz = MCD_2PCSZ(s); };$/;"	f	struct:MCD_CSTR	access:public	signature:( const MCD_STR& s )
MCD_CSTR	third_party/xml/Markup.h	/^	MCD_CSTR() { pcsz=NULL; };$/;"	f	struct:MCD_CSTR	access:public	signature:()
MCD_CSTR	third_party/xml/Markup.h	/^struct MCD_CSTR$/;"	s
MCD_CSTR::MCD_CSTR	third_party/xml/Markup.h	/^	MCD_CSTR( MCD_PCSZ p ) { pcsz=p; };$/;"	f	struct:MCD_CSTR	access:public	signature:( MCD_PCSZ p )
MCD_CSTR::MCD_CSTR	third_party/xml/Markup.h	/^	MCD_CSTR( const MCD_STR& s ) { pcsz = MCD_2PCSZ(s); };$/;"	f	struct:MCD_CSTR	access:public	signature:( const MCD_STR& s )
MCD_CSTR::MCD_CSTR	third_party/xml/Markup.h	/^	MCD_CSTR() { pcsz=NULL; };$/;"	f	struct:MCD_CSTR	access:public	signature:()
MCD_CSTR::operator MCD_PCSZ	third_party/xml/Markup.h	/^	operator MCD_PCSZ() const { return pcsz; };$/;"	f	struct:MCD_CSTR	access:public	signature:() const
MCD_CSTR::pcsz	third_party/xml/Markup.h	/^	MCD_PCSZ pcsz;$/;"	m	struct:MCD_CSTR	access:public
MCD_CSTR_FILENAME	third_party/xml/Markup.h	/^	MCD_CSTR_FILENAME( MCD_PCSZ_FILENAME p ) { pcsz=p; };$/;"	f	struct:MCD_CSTR_FILENAME	access:public	signature:( MCD_PCSZ_FILENAME p )
MCD_CSTR_FILENAME	third_party/xml/Markup.h	/^	MCD_CSTR_FILENAME( const std::string& s ) { pcsz = s.c_str(); };$/;"	f	struct:MCD_CSTR_FILENAME	access:public	signature:( const std::string& s )
MCD_CSTR_FILENAME	third_party/xml/Markup.h	/^	MCD_CSTR_FILENAME() { pcsz=NULL; };$/;"	f	struct:MCD_CSTR_FILENAME	access:public	signature:()
MCD_CSTR_FILENAME	third_party/xml/Markup.h	/^struct MCD_CSTR_FILENAME$/;"	s
MCD_CSTR_FILENAME	third_party/xml/Markup.h	221;"	d
MCD_CSTR_FILENAME::MCD_CSTR_FILENAME	third_party/xml/Markup.h	/^	MCD_CSTR_FILENAME( MCD_PCSZ_FILENAME p ) { pcsz=p; };$/;"	f	struct:MCD_CSTR_FILENAME	access:public	signature:( MCD_PCSZ_FILENAME p )
MCD_CSTR_FILENAME::MCD_CSTR_FILENAME	third_party/xml/Markup.h	/^	MCD_CSTR_FILENAME( const std::string& s ) { pcsz = s.c_str(); };$/;"	f	struct:MCD_CSTR_FILENAME	access:public	signature:( const std::string& s )
MCD_CSTR_FILENAME::MCD_CSTR_FILENAME	third_party/xml/Markup.h	/^	MCD_CSTR_FILENAME() { pcsz=NULL; };$/;"	f	struct:MCD_CSTR_FILENAME	access:public	signature:()
MCD_CSTR_FILENAME::operator MCD_PCSZ_FILENAME	third_party/xml/Markup.h	/^	operator MCD_PCSZ_FILENAME() const { return pcsz; };$/;"	f	struct:MCD_CSTR_FILENAME	access:public	signature:() const
MCD_CSTR_FILENAME::pcsz	third_party/xml/Markup.h	/^	MCD_PCSZ_FILENAME pcsz;$/;"	m	struct:MCD_CSTR_FILENAME	access:public
MCD_ENC	third_party/xml/Markup.h	100;"	d
MCD_ENC	third_party/xml/Markup.h	102;"	d
MCD_ENC	third_party/xml/Markup.h	130;"	d
MCD_ENC	third_party/xml/Markup.h	137;"	d
MCD_FOPEN	third_party/xml/Markup.h	119;"	d
MCD_FOPEN	third_party/xml/Markup.h	126;"	d
MCD_FOPEN	third_party/xml/Markup.h	208;"	d
MCD_FOPEN	third_party/xml/Markup.h	209;"	d
MCD_FOPEN	third_party/xml/Markup.h	85;"	d
MCD_FOPEN	third_party/xml/Markup.h	96;"	d
MCD_FSEEK	third_party/xml/Markup.h	227;"	d
MCD_FSEEK	third_party/xml/Markup.h	235;"	d
MCD_FSEEK	third_party/xml/Markup.h	239;"	d
MCD_FTELL	third_party/xml/Markup.h	228;"	d
MCD_FTELL	third_party/xml/Markup.h	236;"	d
MCD_FTELL	third_party/xml/Markup.h	240;"	d
MCD_GETBUFFER	third_party/xml/Markup.h	164;"	d
MCD_GETBUFFER	third_party/xml/Markup.h	183;"	d
MCD_INTFILEOFFSET	third_party/xml/Markup.h	229;"	d
MCD_INTFILEOFFSET	third_party/xml/Markup.h	237;"	d
MCD_INTFILEOFFSET	third_party/xml/Markup.h	241;"	d
MCD_PCSZ	third_party/xml/Markup.h	107;"	d
MCD_PCSZ	third_party/xml/Markup.h	73;"	d
MCD_PCSZ_FILENAME	third_party/xml/Markup.h	211;"	d
MCD_PCSZ_FILENAME	third_party/xml/Markup.h	223;"	d
MCD_PSZCAT	third_party/xml/Markup.h	117;"	d
MCD_PSZCAT	third_party/xml/Markup.h	124;"	d
MCD_PSZCAT	third_party/xml/Markup.h	83;"	d
MCD_PSZCAT	third_party/xml/Markup.h	94;"	d
MCD_PSZCHR	third_party/xml/Markup.h	109;"	d
MCD_PSZCHR	third_party/xml/Markup.h	75;"	d
MCD_PSZCPY	third_party/xml/Markup.h	115;"	d
MCD_PSZCPY	third_party/xml/Markup.h	122;"	d
MCD_PSZCPY	third_party/xml/Markup.h	81;"	d
MCD_PSZCPY	third_party/xml/Markup.h	92;"	d
MCD_PSZLEN	third_party/xml/Markup.h	108;"	d
MCD_PSZLEN	third_party/xml/Markup.h	74;"	d
MCD_PSZNCMP	third_party/xml/Markup.h	112;"	d
MCD_PSZNCMP	third_party/xml/Markup.h	78;"	d
MCD_PSZNCPY	third_party/xml/Markup.h	116;"	d
MCD_PSZNCPY	third_party/xml/Markup.h	123;"	d
MCD_PSZNCPY	third_party/xml/Markup.h	82;"	d
MCD_PSZNCPY	third_party/xml/Markup.h	93;"	d
MCD_PSZSTR	third_party/xml/Markup.h	110;"	d
MCD_PSZSTR	third_party/xml/Markup.h	76;"	d
MCD_PSZTOL	third_party/xml/Markup.h	111;"	d
MCD_PSZTOL	third_party/xml/Markup.h	77;"	d
MCD_RELEASEBUFFER	third_party/xml/Markup.h	165;"	d
MCD_RELEASEBUFFER	third_party/xml/Markup.h	184;"	d
MCD_SPRINTF	third_party/xml/Markup.h	118;"	d
MCD_SPRINTF	third_party/xml/Markup.h	125;"	d
MCD_SPRINTF	third_party/xml/Markup.h	84;"	d
MCD_SPRINTF	third_party/xml/Markup.h	95;"	d
MCD_SSZ	third_party/xml/Markup.h	114;"	d
MCD_SSZ	third_party/xml/Markup.h	121;"	d
MCD_SSZ	third_party/xml/Markup.h	80;"	d
MCD_SSZ	third_party/xml/Markup.h	88;"	d
MCD_SSZ	third_party/xml/Markup.h	90;"	d
MCD_STR	third_party/xml/Markup.h	151;"	d
MCD_STR	third_party/xml/Markup.h	153;"	d
MCD_STR	third_party/xml/Markup.h	174;"	d
MCD_STRASSIGN	third_party/xml/Markup.h	161;"	d
MCD_STRASSIGN	third_party/xml/Markup.h	181;"	d
MCD_STRCAPACITY	third_party/xml/Markup.h	162;"	d
MCD_STRCAPACITY	third_party/xml/Markup.h	182;"	d
MCD_STRCLEAR	third_party/xml/Markup.h	157;"	d
MCD_STRCLEAR	third_party/xml/Markup.h	177;"	d
MCD_STRCLEARSIZE	third_party/xml/Markup.h	158;"	d
MCD_STRCLEARSIZE	third_party/xml/Markup.h	178;"	d
MCD_STRERROR	third_party/xml/Markup.h	142;"	d
MCD_STRINSERTREPLACE	third_party/xml/Markup.h	163;"	d
MCD_STRISEMPTY	third_party/xml/Markup.h	159;"	d
MCD_STRISEMPTY	third_party/xml/Markup.h	179;"	d
MCD_STRLENGTH	third_party/xml/Markup.h	156;"	d
MCD_STRLENGTH	third_party/xml/Markup.h	176;"	d
MCD_STRMID	third_party/xml/Markup.h	160;"	d
MCD_STRMID	third_party/xml/Markup.h	180;"	d
MCD_STRTOINT	third_party/xml/Markup.h	192;"	d
MCD_T	third_party/xml/Markup.h	128;"	d
MCD_T	third_party/xml/Markup.h	98;"	d
MCD_T_FILENAME	third_party/xml/Markup.h	210;"	d
MCD_T_FILENAME	third_party/xml/Markup.h	222;"	d
MCD_UTF16	third_party/xml/Markup.h	69;"	d
MCD_UTF32	third_party/xml/Markup.h	70;"	d
MCD_UTF8	third_party/xml/Markup.h	68;"	d
MDF_APPENDFILE	third_party/xml/Markup.h	/^		MDF_APPENDFILE = 64,$/;"	e	enum:CMarkup::MarkupDocFlags
MDF_IGNORECASE	third_party/xml/Markup.h	/^		MDF_IGNORECASE = 8,$/;"	e	enum:CMarkup::MarkupDocFlags
MDF_READFILE	third_party/xml/Markup.h	/^		MDF_READFILE = 16,$/;"	e	enum:CMarkup::MarkupDocFlags
MDF_UTF16BEFILE	third_party/xml/Markup.h	/^		MDF_UTF16BEFILE = 128$/;"	e	enum:CMarkup::MarkupDocFlags
MDF_UTF16LEFILE	third_party/xml/Markup.h	/^		MDF_UTF16LEFILE = 1,$/;"	e	enum:CMarkup::MarkupDocFlags
MDF_UTF8PREAMBLE	third_party/xml/Markup.h	/^		MDF_UTF8PREAMBLE = 4,$/;"	e	enum:CMarkup::MarkupDocFlags
MDF_WRITEFILE	third_party/xml/Markup.h	/^		MDF_WRITEFILE = 32,$/;"	e	enum:CMarkup::MarkupDocFlags
MEMBER_VARIABLE_GET	compiler/extract.h	/^	MEMBER_VARIABLE_GET(const deqwords&, words, words_);$/;"	p	class:streamsplit	access:public	signature:(const deqwords&, words, words_)
MEMBER_VARIABLE_GET	include/macros.h	7;"	d
MEMBER_VARIABLE_GET	syntax/production.h	/^	MEMBER_VARIABLE_GET(const right_array&, right, Rs_);$/;"	p	class:production	access:public	signature:(const right_array&, right, Rs_)
MEMBER_VARIABLE_GET	syntax/production.h	/^	MEMBER_VARIABLE_GET(int32, right_size, Rs_.size());$/;"	p	class:production	access:public	signature:(int32, right_size, Rs_.size())
MEMBER_VARIABLE_GET_INDEXER	include/macros.h	28;"	d
MEMBER_VARIABLE_GET_SET	include/macros.h	13;"	d
MEMBER_VARIABLE_GET_SET	syntax/automachine.h	/^	MEMBER_VARIABLE_GET_SET(int, sstate, sstate_);$/;"	p	class:automachine	access:public	signature:(int, sstate, sstate_)
MEMBER_VARIABLE_GET_SET	syntax/automachine.h	/^	MEMBER_VARIABLE_GET_SET(sparsesheet, sheet, *sheet_);$/;"	p	class:automachine	access:public	signature:(sparsesheet, sheet, *sheet_)
MEMBER_VARIABLE_GET_SET	syntax/grammar.h	/^	MEMBER_VARIABLE_GET_SET(int32, endings, ending_symbol_);$/;"	p	class:tinygrammar	access:public	signature:(int32, endings, ending_symbol_)
MEMBER_VARIABLE_GET_SET	syntax/grammar.h	/^	MEMBER_VARIABLE_GET_SET(int32, eplisons, eplison_symbol_);$/;"	p	class:tinygrammar	access:public	signature:(int32, eplisons, eplison_symbol_)
MEMBER_VARIABLE_GET_SET	syntax/grammar.h	/^	MEMBER_VARIABLE_GET_SET(int32, starts, start_symbol_);$/;"	p	class:tinygrammar	access:public	signature:(int32, starts, start_symbol_)
MEMBER_VARIABLE_GET_SET	syntax/grammar.h	/^	MEMBER_VARIABLE_GET_SET(symholder, symbols, symbols_);$/;"	p	class:tinygrammar	access:public	signature:(symholder, symbols, symbols_)
MEMBER_VARIABLE_GET_SET	syntax/grammar.h	/^	MEMBER_VARIABLE_GET_SET(vecprods, productions, productions_);$/;"	p	class:tinygrammar	access:public	signature:(vecprods, productions, productions_)
MEMBER_VARIABLE_GET_SET	syntax/production.h	/^	MEMBER_VARIABLE_GET_SET(int32, left, L_);$/;"	p	class:production	access:public	signature:(int32, left, L_)
MEMBER_VARIABLE_GET_SET	syntax/statemachine.h	/^	MEMBER_VARIABLE_GET_SET(tstring, str, str_);$/;"	p	class:state_machine	access:public	signature:(tstring, str, str_)
MEMBER_VARIABLE_GET_SET	test/unittest.h	/^	MEMBER_VARIABLE_GET_SET(std::string, out_folder, outfolder_);$/;"	p	class:unittest	access:public	signature:(std::string, out_folder, outfolder_)
MEMBER_VARIABLE_GET_SET_INDEXER	include/macros.h	24;"	d
MEMBER_VARIABLE_GET_SET_INDEXER	syntax/production.h	/^	MEMBER_VARIABLE_GET_SET_INDEXER(int32, std::size_t, Rs_);$/;"	p	class:production	access:public	signature:(int32, std::size_t, Rs_)
MEMBER_VARIABLE_INDEXER	include/macros.h	32;"	d
MEMBER_VARIABLE_INDEXER_GET_SET_TEMPLATE	include/macros.h	17;"	d
MEMBER_VARIABLE_INDEXER_GET_TEMPLATE	include/macros.h	21;"	d
MEMBER_VARIABLE_INDEXER_TEMPLATE	include/macros.h	31;"	d
MEMBER_VARIABLE_SET	include/macros.h	10;"	d
MICROSIFT_VISUAL_STUDIO	include/stringXF.h	23;"	d
MNF_CHILD	third_party/xml/Markup.h	/^		MNF_CHILD      = 0x004000$/;"	e	enum:CMarkup::MarkupNodeFlagsInternal
MNF_DELETED	third_party/xml/Markup.cpp	/^	MNF_DELETED    = 0x020000,$/;"	e	enum:MarkupNodeFlagsInternal2	file:
MNF_EMPTY	third_party/xml/Markup.cpp	/^	MNF_EMPTY      = 0x010000,$/;"	e	enum:MarkupNodeFlagsInternal2	file:
MNF_ESCAPEQUOTES	third_party/xml/Markup.h	/^		MNF_ESCAPEQUOTES  = 0x100,$/;"	e	enum:CMarkup::MarkupNodeFlags
MNF_FIRST	third_party/xml/Markup.cpp	/^	MNF_FIRST      = 0x080000,$/;"	e	enum:MarkupNodeFlagsInternal2	file:
MNF_ILLDATA	third_party/xml/Markup.h	/^		MNF_ILLDATA    = 0x200000$/;"	e	enum:CMarkup::MarkupNodeFlags
MNF_ILLFORMED	third_party/xml/Markup.cpp	/^	MNF_ILLFORMED  = 0x800000,$/;"	e	enum:MarkupNodeFlagsInternal2	file:
MNF_INSERT	third_party/xml/Markup.h	/^		MNF_INSERT     = 0x002000,$/;"	e	enum:CMarkup::MarkupNodeFlagsInternal
MNF_NONENDED	third_party/xml/Markup.h	/^		MNF_NONENDED   = 0x100000,$/;"	e	enum:CMarkup::MarkupNodeFlags
MNF_PUBLIC	third_party/xml/Markup.cpp	/^	MNF_PUBLIC     = 0x300000,$/;"	e	enum:MarkupNodeFlagsInternal2	file:
MNF_QUOTED	third_party/xml/Markup.cpp	/^	MNF_QUOTED     = 0x008000,$/;"	e	enum:MarkupNodeFlagsInternal2	file:
MNF_REPLACE	third_party/xml/Markup.cpp	/^	MNF_REPLACE    = 0x001000,$/;"	e	enum:MarkupNodeFlagsInternal2	file:
MNF_USER	third_party/xml/Markup.cpp	/^	MNF_USER      = 0xf000000$/;"	e	enum:MarkupNodeFlagsInternal2	file:
MNF_WITHCDATA	third_party/xml/Markup.h	/^		MNF_WITHCDATA      = 0x01,$/;"	e	enum:CMarkup::MarkupNodeFlags
MNF_WITHNOEND	third_party/xml/Markup.h	/^		MNF_WITHNOEND      = 0x10,$/;"	e	enum:CMarkup::MarkupNodeFlags
MNF_WITHNOLINES	third_party/xml/Markup.h	/^		MNF_WITHNOLINES    = 0x02,$/;"	e	enum:CMarkup::MarkupNodeFlags
MNF_WITHREFS	third_party/xml/Markup.h	/^		MNF_WITHREFS       = 0x08,$/;"	e	enum:CMarkup::MarkupNodeFlags
MNF_WITHXHTMLSPACE	third_party/xml/Markup.h	/^		MNF_WITHXHTMLSPACE = 0x04,$/;"	e	enum:CMarkup::MarkupNodeFlags
MNT_CDATA_SECTION	third_party/xml/Markup.h	/^		MNT_CDATA_SECTION			= 8,    \/\/ 0x0008$/;"	e	enum:CMarkup::MarkupNodeType
MNT_COMMENT	third_party/xml/Markup.h	/^		MNT_COMMENT					= 32,   \/\/ 0x0020$/;"	e	enum:CMarkup::MarkupNodeType
MNT_DOCUMENT_TYPE	third_party/xml/Markup.h	/^		MNT_DOCUMENT_TYPE			= 64,   \/\/ 0x0040$/;"	e	enum:CMarkup::MarkupNodeType
MNT_ELEMENT	third_party/xml/Markup.h	/^		MNT_ELEMENT					= 1,    \/\/ 0x0001$/;"	e	enum:CMarkup::MarkupNodeType
MNT_EXCLUDE_WHITESPACE	third_party/xml/Markup.h	/^		MNT_EXCLUDE_WHITESPACE		= 123,  \/\/ 0x007b$/;"	e	enum:CMarkup::MarkupNodeType
MNT_LONE_END_TAG	third_party/xml/Markup.h	/^		MNT_LONE_END_TAG			= 128,  \/\/ 0x0080$/;"	e	enum:CMarkup::MarkupNodeType
MNT_NODE_ERROR	third_party/xml/Markup.h	/^		MNT_NODE_ERROR              = 32768 \/\/ 0x8000$/;"	e	enum:CMarkup::MarkupNodeType
MNT_PROCESSING_INSTRUCTION	third_party/xml/Markup.h	/^		MNT_PROCESSING_INSTRUCTION	= 16,   \/\/ 0x0010$/;"	e	enum:CMarkup::MarkupNodeType
MNT_TEXT	third_party/xml/Markup.h	/^		MNT_TEXT					= 2,    \/\/ 0x0002$/;"	e	enum:CMarkup::MarkupNodeType
MNT_TEXT_AND_WHITESPACE	third_party/xml/Markup.h	/^		MNT_TEXT_AND_WHITESPACE     = 6,    \/\/ 0x0006$/;"	e	enum:CMarkup::MarkupNodeType
MNT_WHITESPACE	third_party/xml/Markup.h	/^		MNT_WHITESPACE				= 4,    \/\/ 0x0004$/;"	e	enum:CMarkup::MarkupNodeType
MRC_COUNT	third_party/xml/Markup.cpp	/^	MRC_COUNT    = 1,$/;"	e	enum:MarkupResultCode	file:
MRC_ENCODING	third_party/xml/Markup.cpp	/^	MRC_ENCODING = 8,$/;"	e	enum:MarkupResultCode	file:
MRC_LENGTH	third_party/xml/Markup.cpp	/^	MRC_LENGTH   = 16,$/;"	e	enum:MarkupResultCode	file:
MRC_MODIFY	third_party/xml/Markup.cpp	/^	MRC_MODIFY   = 32,$/;"	e	enum:MarkupResultCode	file:
MRC_MSG	third_party/xml/Markup.cpp	/^	MRC_MSG      = 64$/;"	e	enum:MarkupResultCode	file:
MRC_NUMBER	third_party/xml/Markup.cpp	/^	MRC_NUMBER   = 4,$/;"	e	enum:MarkupResultCode	file:
MRC_TYPE	third_party/xml/Markup.cpp	/^	MRC_TYPE     = 2,$/;"	e	enum:MarkupResultCode	file:
MarkupDocFlags	third_party/xml/Markup.h	/^	enum MarkupDocFlags$/;"	g	class:CMarkup	access:public
MarkupNodeFlags	third_party/xml/Markup.h	/^	enum MarkupNodeFlags$/;"	g	class:CMarkup	access:public
MarkupNodeFlagsInternal	third_party/xml/Markup.h	/^	enum MarkupNodeFlagsInternal$/;"	g	class:CMarkup	access:protected
MarkupNodeFlagsInternal2	third_party/xml/Markup.cpp	/^enum MarkupNodeFlagsInternal2$/;"	g	file:
MarkupNodeType	third_party/xml/Markup.h	/^	enum MarkupNodeType$/;"	g	class:CMarkup	access:public
MarkupResultCode	third_party/xml/Markup.cpp	/^enum MarkupResultCode$/;"	g	file:
Match	third_party/xml/Markup.cpp	/^	bool Match( MCD_CSTR szName )$/;"	f	struct:TokenPos	access:public	signature:( MCD_CSTR szName )
NAMESPACE_BEGIN	include/macros.h	34;"	d
NAMESPACE_END	include/macros.h	35;"	d
NEW_UNITTEST	test/unittest.h	36;"	d
NON_COPYABLE_OBJECT	include/macros.h	37;"	d
NON_COPYABLE_OBJECT	include/singleton.h	12;"	d
NextParent	third_party/xml/Markup.cpp	/^	TagPos& NextParent( int& i ) { int iCur=i; i=pL[i].iParent; return pL[iCur]; };$/;"	f	struct:ElemStack	access:public	signature:( int& i )
No	include/functionalX.h	/^	No = -1,$/;"	e	enum:TriSate
NodePos	third_party/xml/Markup.cpp	/^	NodePos( int n ) { nNodeFlags=n; nNodeType=0; nStart=0; nLength=0; };$/;"	f	struct:NodePos	access:public	signature:( int n )
NodePos	third_party/xml/Markup.cpp	/^	NodePos() {};$/;"	f	struct:NodePos	access:public	signature:()
NodePos	third_party/xml/Markup.cpp	/^struct NodePos$/;"	s	file:
NodePos::NodePos	third_party/xml/Markup.cpp	/^	NodePos( int n ) { nNodeFlags=n; nNodeType=0; nStart=0; nLength=0; };$/;"	f	struct:NodePos	access:public	signature:( int n )
NodePos::NodePos	third_party/xml/Markup.cpp	/^	NodePos() {};$/;"	f	struct:NodePos	access:public	signature:()
NodePos::nLength	third_party/xml/Markup.cpp	/^	int nLength;$/;"	m	struct:NodePos	file:	access:public
NodePos::nNodeFlags	third_party/xml/Markup.cpp	/^	int nNodeFlags;$/;"	m	struct:NodePos	file:	access:public
NodePos::nNodeType	third_party/xml/Markup.cpp	/^	int nNodeType;$/;"	m	struct:NodePos	file:	access:public
NodePos::nStart	third_party/xml/Markup.cpp	/^	int nStart;$/;"	m	struct:NodePos	file:	access:public
NodePos::strMeta	third_party/xml/Markup.cpp	/^	MCD_STR strMeta;$/;"	m	struct:NodePos	file:	access:public
NonOp	include/functionalX.h	/^struct NonOp : public std::unary_function<_Arg, _Arg>$/;"	s	inherits:std::unary_function
NonOp::operator ()	include/functionalX.h	/^	_Arg& operator()(_Arg& _arg) const$/;"	f	struct:NonOp	access:public	signature:(_Arg& _arg) const
NonOp::operator ()	include/functionalX.h	/^	const _Arg& operator()(const _Arg& _arg) const$/;"	f	struct:NonOp	access:public	signature:(const _Arg& _arg) const
OVERWRITE_FUNCTION_1	include/macros.h	43;"	d
OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(append, const _Elem*, _Ptr);$/;"	p	class:xstring_basic	access:public	signature:(append, const _Elem*, _Ptr)
OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(append, const _Mybase&, _Right);$/;"	p	class:xstring_basic	access:public	signature:(append, const _Mybase&, _Right)
OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(assign, const _Elem*, _Ptr);$/;"	p	class:xstring_basic	access:public	signature:(assign, const _Elem*, _Ptr)
OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(assign, const _Mybase&, _Right);$/;"	p	class:xstring_basic	access:public	signature:(assign, const _Mybase&, _Right)
OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(operator+=, _Elem, _Ch);$/;"	p	class:xstring_basic	access:public	signature:(operator+=, _Elem, _Ch)
OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(operator+=, const _Elem*&, _Ptr);$/;"	p	class:xstring_basic	access:public	signature:(operator+=, const _Elem*&, _Ptr)
OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(operator+=, const _Mybase&, _Right);$/;"	p	class:xstring_basic	access:public	signature:(operator+=, const _Mybase&, _Right)
OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(operator=, _Elem, _Ch);$/;"	p	class:xstring_basic	access:public	signature:(operator=, _Elem, _Ch)
OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(operator=, const _Elem*&, _Ptr);$/;"	p	class:xstring_basic	access:public	signature:(operator=, const _Elem*&, _Ptr)
OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(operator=, const _Mybase&, _Right);$/;"	p	class:xstring_basic	access:public	signature:(operator=, const _Mybase&, _Right)
OVERWRITE_FUNCTION_2	include/macros.h	50;"	d
OVERWRITE_FUNCTION_2	include/stringX.h	/^	OVERWRITE_FUNCTION_2(append, _It, _First, _It, _Last);$/;"	p	class:xstring_basic	access:public	signature:(append, _It, _First, _It, _Last)
OVERWRITE_FUNCTION_2	include/stringX.h	/^	OVERWRITE_FUNCTION_2(append, const _Elem*, _Ptr, size_type, _Count);$/;"	p	class:xstring_basic	access:public	signature:(append, const _Elem*, _Ptr, size_type, _Count)
OVERWRITE_FUNCTION_2	include/stringX.h	/^	OVERWRITE_FUNCTION_2(append, size_type, _Count, _Elem, _Ch);$/;"	p	class:xstring_basic	access:public	signature:(append, size_type, _Count, _Elem, _Ch)
OVERWRITE_FUNCTION_2	include/stringX.h	/^	OVERWRITE_FUNCTION_2(assign, _It, _First, _It, _Last);$/;"	p	class:xstring_basic	access:public	signature:(assign, _It, _First, _It, _Last)
OVERWRITE_FUNCTION_2	include/stringX.h	/^	OVERWRITE_FUNCTION_2(assign, const _Elem*, _Ptr, size_type, _Count);$/;"	p	class:xstring_basic	access:public	signature:(assign, const _Elem*, _Ptr, size_type, _Count)
OVERWRITE_FUNCTION_2	include/stringX.h	/^	OVERWRITE_FUNCTION_2(assign, size_type, _Count, _Elem, _Ch);$/;"	p	class:xstring_basic	access:public	signature:(assign, size_type, _Count, _Elem, _Ch)
OVERWRITE_FUNCTION_2	include/stringX.h	/^	OVERWRITE_FUNCTION_2(insert, size_type, _Off, const _Elem*, _Ptr);$/;"	p	class:xstring_basic	access:public	signature:(insert, size_type, _Off, const _Elem*, _Ptr)
OVERWRITE_FUNCTION_2	include/stringX.h	/^	OVERWRITE_FUNCTION_2(insert, size_type, _Off, const _Mybase&, _Right);$/;"	p	class:xstring_basic	access:public	signature:(insert, size_type, _Off, const _Mybase&, _Right)
OVERWRITE_FUNCTION_3	include/macros.h	57;"	d
OVERWRITE_FUNCTION_3	include/stringX.h	/^	OVERWRITE_FUNCTION_3(append, const _Mybase&, _Right, size_type, _Roff, size_type, _Count);$/;"	p	class:xstring_basic	access:public	signature:(append, const _Mybase&, _Right, size_type, _Roff, size_type, _Count)
OVERWRITE_FUNCTION_3	include/stringX.h	/^	OVERWRITE_FUNCTION_3(assign, const _Mybase&, _Right, size_type, _Roff, size_type, _Count);$/;"	p	class:xstring_basic	access:public	signature:(assign, const _Mybase&, _Right, size_type, _Roff, size_type, _Count)
OVERWRITE_FUNCTION_3	include/stringX.h	/^	OVERWRITE_FUNCTION_3(insert, size_type, _Off, const _Elem*, _Ptr, size_type, _Count);$/;"	p	class:xstring_basic	access:public	signature:(insert, size_type, _Off, const _Elem*, _Ptr, size_type, _Count)
OVERWRITE_FUNCTION_3	include/stringX.h	/^	OVERWRITE_FUNCTION_3(insert, size_type, _Off, size_type, _Count, _Elem, _Ch);$/;"	p	class:xstring_basic	access:public	signature:(insert, size_type, _Off, size_type, _Count, _Elem, _Ch)
OVERWRITE_FUNCTION_3	include/stringX.h	/^	OVERWRITE_FUNCTION_3(replace, size_type, _Off, size_type, _N0, const _Elem*, _Ptr);$/;"	p	class:xstring_basic	access:public	signature:(replace, size_type, _Off, size_type, _N0, const _Elem*, _Ptr)
OVERWRITE_FUNCTION_3	include/stringX.h	/^	OVERWRITE_FUNCTION_3(replace, size_type, _Off, size_type, _N0, const _Myt&, _Right);$/;"	p	class:xstring_basic	access:public	signature:(replace, size_type, _Off, size_type, _N0, const _Myt&, _Right)
OVERWRITE_FUNCTION_3	include/stringX.h	/^	OVERWRITE_FUNCTION_3(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, const _Elem*, _Ptr);$/;"	p	class:xstring_basic	access:public	signature:(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, const _Elem*, _Ptr)
OVERWRITE_FUNCTION_3	include/stringX.h	/^	OVERWRITE_FUNCTION_3(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, const _Myt&, _Right);$/;"	p	class:xstring_basic	access:public	signature:(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, const _Myt&, _Right)
OVERWRITE_FUNCTION_4	include/macros.h	64;"	d
OVERWRITE_FUNCTION_4	include/stringX.h	/^	OVERWRITE_FUNCTION_4(insert, size_type, _Off, const _Mybase&, _Right, size_type, _Roff, size_type, _Count);$/;"	p	class:xstring_basic	access:public	signature:(insert, size_type, _Off, const _Mybase&, _Right, size_type, _Roff, size_type, _Count)
OVERWRITE_FUNCTION_4	include/stringX.h	/^	OVERWRITE_FUNCTION_4(replace, size_type, _Off, size_type, _N0, const _Elem*, _Ptr, size_type, _Count);$/;"	p	class:xstring_basic	access:public	signature:(replace, size_type, _Off, size_type, _N0, const _Elem*, _Ptr, size_type, _Count)
OVERWRITE_FUNCTION_4	include/stringX.h	/^	OVERWRITE_FUNCTION_4(replace, size_type, _Off, size_type, _N0, size_type, _Count, _Elem, _Ch);$/;"	p	class:xstring_basic	access:public	signature:(replace, size_type, _Off, size_type, _N0, size_type, _Count, _Elem, _Ch)
OVERWRITE_FUNCTION_4	include/stringX.h	/^	OVERWRITE_FUNCTION_4(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, _It, _First2, _It, _Last2);$/;"	p	class:xstring_basic	access:public	signature:(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, _It, _First2, _It, _Last2)
OVERWRITE_FUNCTION_4	include/stringX.h	/^	OVERWRITE_FUNCTION_4(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, const _Elem*, _Ptr, size_type, _Count);$/;"	p	class:xstring_basic	access:public	signature:(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, const _Elem*, _Ptr, size_type, _Count)
OVERWRITE_FUNCTION_4	include/stringX.h	/^	OVERWRITE_FUNCTION_4(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, size_type, _Count, _Elem, _Ch);$/;"	p	class:xstring_basic	access:public	signature:(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, size_type, _Count, _Elem, _Ch)
OutOfElem	third_party/xml/Markup.cpp	/^bool CMarkup::OutOfElem()$/;"	f	class:CMarkup	signature:()
OutOfElem	third_party/xml/Markup.h	/^	bool OutOfElem();$/;"	p	class:CMarkup	access:public	signature:()
OutOfLevel	third_party/xml/Markup.cpp	/^	void OutOfLevel() { if (iPar!=iTop) Pop(); iPar = pL[iTop].iParent; --nLevel; };$/;"	f	struct:ElemStack	access:public	signature:()
PA_SEGBITS	third_party/xml/Markup.cpp	/^	enum { PA_SEGBITS = 16, PA_SEGMASK = 0xffff };$/;"	e	enum:ElemPosTree::__anon65	file:
PA_SEGMASK	third_party/xml/Markup.cpp	/^	enum { PA_SEGBITS = 16, PA_SEGMASK = 0xffff };$/;"	e	enum:ElemPosTree::__anon65	file:
PI	include/mathX.h	13;"	d
ParseNode	third_party/xml/Markup.cpp	/^	int ParseNode( NodePos& node );$/;"	p	struct:TokenPos	file:	access:public	signature:( NodePos& node )
ParseNode	third_party/xml/Markup.cpp	/^int TokenPos::ParseNode( NodePos& node )$/;"	f	class:TokenPos	signature:( NodePos& node )
ParsePath	third_party/xml/Markup.cpp	/^	bool ParsePath();$/;"	p	struct:PathPos	file:	access:private	signature:()
ParsePath	third_party/xml/Markup.cpp	/^bool PathPos::ParsePath()$/;"	f	class:PathPos	signature:()
PathPos	third_party/xml/Markup.cpp	/^	PathPos( MCD_PCSZ pszPath, bool b ) { p=pszPath; bReader=b; i=0; iPathAttribName=0; iSave=0; nPathType=0; if (!ParsePath()) nPathType=-1; };$/;"	f	struct:PathPos	access:public	signature:( MCD_PCSZ pszPath, bool b )
PathPos	third_party/xml/Markup.cpp	/^struct PathPos$/;"	s	file:
PathPos::AttribPredicateMatch	third_party/xml/Markup.cpp	/^	bool AttribPredicateMatch( TokenPos& token );$/;"	p	struct:PathPos	file:	access:public	signature:( TokenPos& token )
PathPos::AttribPredicateMatch	third_party/xml/Markup.cpp	/^bool PathPos::AttribPredicateMatch( TokenPos& token )$/;"	f	class:PathPos	signature:( TokenPos& token )
PathPos::GetChar	third_party/xml/Markup.cpp	/^	MCD_CHAR GetChar() { return p[i]; };$/;"	f	struct:PathPos	access:public	signature:()
PathPos::GetNumAndInc	third_party/xml/Markup.cpp	/^	int GetNumAndInc() { int n=0; while (p[i]>='0'&&p[i]<='9') n=n*10+(int)p[i++]-(int)'0'; return n; };$/;"	f	struct:PathPos	access:public	signature:()
PathPos::GetPathAttribName	third_party/xml/Markup.cpp	/^	MCD_PCSZ GetPathAttribName() { if (iPathAttribName) return &p[iPathAttribName]; return NULL; };$/;"	f	struct:PathPos	access:public	signature:()
PathPos::GetPtr	third_party/xml/Markup.cpp	/^	MCD_PCSZ GetPtr() { return &p[i]; };$/;"	f	struct:PathPos	access:public	signature:()
PathPos::GetTypeAndInc	third_party/xml/Markup.cpp	/^	int GetTypeAndInc() { i=-1; if (p) { if (p[0]=='\/') { if (p[1]=='\/') i=2; else i=1; } else if (p[0]) i=0; } nPathType=i+1; return nPathType; };$/;"	f	struct:PathPos	access:public	signature:()
PathPos::GetValAndInc	third_party/xml/Markup.cpp	/^	MCD_PCSZ GetValAndInc() { ++i; MCD_CHAR cEnd=']'; if (p[i]=='\\''||p[i]=='\\"') cEnd=p[i++]; int iVal=i; IncWord(cEnd); nLen=i-iVal; if (cEnd!=']') ++i; return &p[iVal]; };$/;"	f	struct:PathPos	access:public	signature:()
PathPos::GetValOrWordLen	third_party/xml/Markup.cpp	/^	int GetValOrWordLen() { return nLen; };$/;"	f	struct:PathPos	access:public	signature:()
PathPos::GetWordAndInc	third_party/xml/Markup.cpp	/^	MCD_PCSZ GetWordAndInc() { int iWord=i; IncWord(); nLen=i-iWord; return &p[iWord]; };$/;"	f	struct:PathPos	access:public	signature:()
PathPos::Inc	third_party/xml/Markup.cpp	/^	void Inc( int n ) { i+=n; };$/;"	f	struct:PathPos	access:public	signature:( int n )
PathPos::IncChar	third_party/xml/Markup.cpp	/^	void IncChar() { ++i; };$/;"	f	struct:PathPos	access:public	signature:()
PathPos::IncWord	third_party/xml/Markup.cpp	/^	void IncWord( MCD_CHAR c ) { while (p[i]&&p[i]!=c) i+=MCD_CLEN(&p[i]); };$/;"	f	struct:PathPos	access:public	signature:( MCD_CHAR c )
PathPos::IncWord	third_party/xml/Markup.cpp	/^	void IncWord() { while (p[i]&&!MCD_PSZCHR(MCD_T(" =\/[]"),p[i])) i+=MCD_CLEN(&p[i]); };$/;"	f	struct:PathPos	access:public	signature:()
PathPos::IsAbsolutePath	third_party/xml/Markup.cpp	/^	bool IsAbsolutePath() { return nPathType == 2; };$/;"	f	struct:PathPos	access:public	signature:()
PathPos::IsAnywherePath	third_party/xml/Markup.cpp	/^	bool IsAnywherePath() { return nPathType == 3; };$/;"	f	struct:PathPos	access:public	signature:()
PathPos::IsAtPathEnd	third_party/xml/Markup.cpp	/^	bool IsAtPathEnd() { return ((!p[i])||(iPathAttribName&&i+2>=iPathAttribName))?true:false; }; $/;"	f	struct:PathPos	access:public	signature:()
PathPos::IsPath	third_party/xml/Markup.cpp	/^	bool IsPath() { return nPathType > 0; };$/;"	f	struct:PathPos	access:public	signature:()
PathPos::ParsePath	third_party/xml/Markup.cpp	/^	bool ParsePath();$/;"	p	struct:PathPos	file:	access:private	signature:()
PathPos::ParsePath	third_party/xml/Markup.cpp	/^bool PathPos::ParsePath()$/;"	f	class:PathPos	signature:()
PathPos::PathPos	third_party/xml/Markup.cpp	/^	PathPos( MCD_PCSZ pszPath, bool b ) { p=pszPath; bReader=b; i=0; iPathAttribName=0; iSave=0; nPathType=0; if (!ParsePath()) nPathType=-1; };$/;"	f	struct:PathPos	access:public	signature:( MCD_PCSZ pszPath, bool b )
PathPos::RevertOffset	third_party/xml/Markup.cpp	/^	void RevertOffset() { i=iSave; };$/;"	f	struct:PathPos	access:public	signature:()
PathPos::RevertOffsetAsName	third_party/xml/Markup.cpp	/^	void RevertOffsetAsName() { i=iSave; nPathType=1; };$/;"	f	struct:PathPos	access:public	signature:()
PathPos::SaveOffset	third_party/xml/Markup.cpp	/^	void SaveOffset() { iSave=i; };$/;"	f	struct:PathPos	access:public	signature:()
PathPos::ValidPath	third_party/xml/Markup.cpp	/^	bool ValidPath() { return nPathType != -1; };$/;"	f	struct:PathPos	access:public	signature:()
PathPos::bReader	third_party/xml/Markup.cpp	/^	bool bReader;$/;"	m	struct:PathPos	file:	access:private
PathPos::i	third_party/xml/Markup.cpp	/^	int i;$/;"	m	struct:PathPos	file:	access:private
PathPos::iPathAttribName	third_party/xml/Markup.cpp	/^	int iPathAttribName;$/;"	m	struct:PathPos	file:	access:private
PathPos::iSave	third_party/xml/Markup.cpp	/^	int iSave;$/;"	m	struct:PathPos	file:	access:private
PathPos::nLen	third_party/xml/Markup.cpp	/^	int nLen;$/;"	m	struct:PathPos	file:	access:private
PathPos::nPathType	third_party/xml/Markup.cpp	/^	int nPathType; \/\/ -1 invalid, 0 empty, 1 name, 2 absolute path, 3 anywhere path$/;"	m	struct:PathPos	file:	access:private
PathPos::p	third_party/xml/Markup.cpp	/^	MCD_PCSZ p;$/;"	m	struct:PathPos	file:	access:private
PerformConversion	third_party/xml/Markup.cpp	/^	int PerformConversion( void* pTo, MCD_CSTR pszToEncoding = NULL );$/;"	p	struct:TextEncoding	file:	access:public	signature:( void* pTo, MCD_CSTR pszToEncoding = NULL )
PerformConversion	third_party/xml/Markup.cpp	/^int TextEncoding::PerformConversion( void* pTo, MCD_CSTR pszToEncoding\/*=NULL*\/ )$/;"	f	class:TextEncoding	signature:( void* pTo, MCD_CSTR pszToEncoding )
Pop	third_party/xml/Markup.cpp	/^	void Pop() { iTop = iPar; while (iUsed && pL[iUsed].iParent==iPar) { if (pL[iUsed].nSlot!=-1) Unslot(pL[iUsed]); --iUsed; } };$/;"	f	struct:ElemStack	access:public	signature:()
PopOutOfLevel	third_party/xml/Markup.cpp	/^	void PopOutOfLevel() { --iTop; };$/;"	f	struct:ElemStack	access:public	signature:()
PredefEntityTable	third_party/xml/Markup.cpp	/^MCD_PCSZ PredefEntityTable[130] =$/;"	v
Print	test/output/gen.cpp	/^	Print()$/;"	f	struct:Print	access:public	signature:()
Print	test/output/gen.cpp	/^struct Print : public type$/;"	s	file:	inherits:type
Print	test/output/tinyg.cpp	/^	Print()$/;"	f	struct:Print	access:public	signature:()
Print	test/output/tinyg.cpp	/^struct Print : public type$/;"	s	file:	inherits:type
Print::Print	test/output/gen.cpp	/^	Print()$/;"	f	struct:Print	access:public	signature:()
Print::Print	test/output/tinyg.cpp	/^	Print()$/;"	f	struct:Print	access:public	signature:()
Print::sid	test/output/gen.cpp	/^	enum{ sid = 1008 };$/;"	e	enum:Print::__anon15	file:
Print::sid	test/output/tinyg.cpp	/^	enum{ sid = 12 };$/;"	e	enum:Print::__anon47	file:
Program	test/output/gen.cpp	/^	Program()$/;"	f	struct:Program	access:public	signature:()
Program	test/output/gen.cpp	/^struct Program : public type$/;"	s	file:	inherits:type
Program	test/output/tinyg.cpp	/^	Program()$/;"	f	struct:Program	access:public	signature:()
Program	test/output/tinyg.cpp	/^struct Program : public type$/;"	s	file:	inherits:type
Program::Program	test/output/gen.cpp	/^	Program()$/;"	f	struct:Program	access:public	signature:()
Program::Program	test/output/tinyg.cpp	/^	Program()$/;"	f	struct:Program	access:public	signature:()
Program::sid	test/output/gen.cpp	/^	enum{ sid = 1009 };$/;"	e	enum:Program::__anon16	file:
Program::sid	test/output/tinyg.cpp	/^	enum{ sid = 0 };$/;"	e	enum:Program::__anon35	file:
Push	third_party/xml/Markup.cpp	/^	void Push( MCD_PCSZ pName, int n ) { ++iUsed; if (iUsed==nSize) Alloc(nSize*2); pL[iUsed].SetTagName(pName,n); pL[iUsed].iParent=iPar; iTop=iUsed; };$/;"	f	struct:ElemStack	access:public	signature:( MCD_PCSZ pName, int n )
PushIntoLevel	third_party/xml/Markup.cpp	/^	void PushIntoLevel( MCD_PCSZ pName, int n ) { ++iTop; if (iTop==nSize) Alloc(nSize*2); pL[iTop].SetTagName(pName,n); };$/;"	f	struct:ElemStack	access:public	signature:( MCD_PCSZ pName, int n )
PushTagAndCount	third_party/xml/Markup.cpp	/^	void PushTagAndCount( TokenPos& token );$/;"	p	struct:ElemStack	file:	access:public	signature:( TokenPos& token )
PushTagAndCount	third_party/xml/Markup.cpp	/^void ElemStack::PushTagAndCount( TokenPos& token )$/;"	f	class:ElemStack	signature:( TokenPos& token )
ReadTextFile	third_party/xml/Markup.cpp	/^bool CMarkup::ReadTextFile( MCD_CSTR_FILENAME szFileName, MCD_STR& strDoc, MCD_STR* pstrResult, int* pnDocFlags, MCD_STR* pstrEncoding )$/;"	f	class:CMarkup	signature:( MCD_CSTR_FILENAME szFileName, MCD_STR& strDoc, MCD_STR* pstrResult, int* pnDocFlags, MCD_STR* pstrEncoding )
ReadTextFile	third_party/xml/Markup.h	/^	static bool ReadTextFile( MCD_CSTR_FILENAME szFileName, MCD_STR& strDoc, MCD_STR* pstrResult=NULL, int* pnDocFlags=NULL, MCD_STR* pstrEncoding=NULL );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR_FILENAME szFileName, MCD_STR& strDoc, MCD_STR* pstrResult=NULL, int* pnDocFlags=NULL, MCD_STR* pstrEncoding=NULL )
Release	third_party/xml/Markup.cpp	/^	void Release() { for (int n=0;n<SegsUsed();++n) delete[] (char*)m_pSegs[n]; if (m_pSegs) delete[] (char*)m_pSegs; };$/;"	f	struct:ElemPosTree	access:public	signature:()
ReleaseElemPosTree	third_party/xml/Markup.cpp	/^	void ReleaseElemPosTree() { Release(); Clear(); };$/;"	f	struct:ElemPosTree	access:public	signature:()
ReleaseMaps	third_party/xml/Markup.cpp	/^	void ReleaseMaps() { SavedPosMap**p = m_pMaps; if (p) { while (*p) delete *p++; delete[] m_pMaps; m_pMaps=NULL; } };$/;"	f	struct:SavedPosMapArray	access:public	signature:()
RemoveChildElem	third_party/xml/Markup.cpp	/^bool CMarkup::RemoveChildElem()$/;"	f	class:CMarkup	signature:()
RemoveChildElem	third_party/xml/Markup.h	/^	bool RemoveChildElem();$/;"	p	class:CMarkup	access:public	signature:()
RemoveElem	third_party/xml/Markup.cpp	/^bool CMarkup::RemoveElem()$/;"	f	class:CMarkup	signature:()
RemoveElem	third_party/xml/Markup.h	/^	bool RemoveElem();$/;"	p	class:CMarkup	access:public	signature:()
RemoveNode	third_party/xml/Markup.cpp	/^bool CMarkup::RemoveNode()$/;"	f	class:CMarkup	signature:()
RemoveNode	third_party/xml/Markup.h	/^	bool RemoveNode();$/;"	p	class:CMarkup	access:public	signature:()
ResetChildPos	third_party/xml/Markup.h	/^	void ResetChildPos() { x_SetPos(m_iPosParent,m_iPos,0); };$/;"	f	class:CMarkup	access:public	signature:()
ResetMainPos	third_party/xml/Markup.h	/^	void ResetMainPos() { x_SetPos(m_iPosParent,0,0); };$/;"	f	class:CMarkup	access:public	signature:()
ResetPos	third_party/xml/Markup.h	/^	void ResetPos() { x_SetPos(0,0,0); };$/;"	f	class:CMarkup	access:public	signature:()
RestorePos	third_party/xml/Markup.cpp	/^bool CMarkup::RestorePos( MCD_CSTR szPosName \/*=""*\/, int nMap \/*=0*\/ )$/;"	f	class:CMarkup	signature:( MCD_CSTR szPosName , int nMap )
RestorePos	third_party/xml/Markup.h	/^	bool RestorePos( MCD_CSTR szPosName=MCD_T(""), int nMap = 0 );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR szPosName=MCD_T(Ó), int nMap = 0 )
Return	test/output/tinyg.cpp	/^	Return()$/;"	f	struct:Return	access:public	signature:()
Return	test/output/tinyg.cpp	/^struct Return : public type$/;"	s	file:	inherits:type
Return::Return	test/output/tinyg.cpp	/^	Return()$/;"	f	struct:Return	access:public	signature:()
Return::sid	test/output/tinyg.cpp	/^	enum{ sid = 16 };$/;"	e	enum:Return::__anon51	file:
ReturnExp	test/output/gen.cpp	/^	ReturnExp()$/;"	f	struct:ReturnExp	access:public	signature:()
ReturnExp	test/output/gen.cpp	/^struct ReturnExp : public type$/;"	s	file:	inherits:type
ReturnExp	test/output/tinyg.cpp	/^	ReturnExp()$/;"	f	struct:ReturnExp	access:public	signature:()
ReturnExp	test/output/tinyg.cpp	/^struct ReturnExp : public type$/;"	s	file:	inherits:type
ReturnExp::ReturnExp	test/output/gen.cpp	/^	ReturnExp()$/;"	f	struct:ReturnExp	access:public	signature:()
ReturnExp::ReturnExp	test/output/tinyg.cpp	/^	ReturnExp()$/;"	f	struct:ReturnExp	access:public	signature:()
ReturnExp::sid	test/output/gen.cpp	/^	enum{ sid = 1010 };$/;"	e	enum:ReturnExp::__anon17	file:
ReturnExp::sid	test/output/tinyg.cpp	/^	enum{ sid = 15 };$/;"	e	enum:ReturnExp::__anon50	file:
RevertOffset	third_party/xml/Markup.cpp	/^	void RevertOffset() { i=iSave; };$/;"	f	struct:PathPos	access:public	signature:()
RevertOffsetAsName	third_party/xml/Markup.cpp	/^	void RevertOffsetAsName() { i=iSave; nPathType=1; };$/;"	f	struct:PathPos	access:public	signature:()
Row	include/arrayX.h	/^	const static size_t Row = _Row;$/;"	m	struct:SmartMatrix	access:public
RowVector	include/arrayX.h	/^	typedef pointer RowVector;$/;"	t	struct:SmartMatrix	access:public
Rs_	syntax/production.h	/^	right_array Rs_;$/;"	m	class:production	access:private
SPM_CHILD	third_party/xml/Markup.cpp	/^	enum { SPM_MAIN = 1, SPM_CHILD = 2, SPM_USED = 4, SPM_LAST = 8 };$/;"	e	enum:SavedPos::__anon67	file:
SPM_LAST	third_party/xml/Markup.cpp	/^	enum { SPM_MAIN = 1, SPM_CHILD = 2, SPM_USED = 4, SPM_LAST = 8 };$/;"	e	enum:SavedPos::__anon67	file:
SPM_MAIN	third_party/xml/Markup.cpp	/^	enum { SPM_MAIN = 1, SPM_CHILD = 2, SPM_USED = 4, SPM_LAST = 8 };$/;"	e	enum:SavedPos::__anon67	file:
SPM_USED	third_party/xml/Markup.cpp	/^	enum { SPM_MAIN = 1, SPM_CHILD = 2, SPM_USED = 4, SPM_LAST = 8 };$/;"	e	enum:SavedPos::__anon67	file:
Save	third_party/xml/Markup.cpp	/^bool CMarkup::Save( MCD_CSTR_FILENAME szFileName )$/;"	f	class:CMarkup	signature:( MCD_CSTR_FILENAME szFileName )
Save	third_party/xml/Markup.h	/^	bool Save( MCD_CSTR_FILENAME szFileName );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR_FILENAME szFileName )
SaveOffset	third_party/xml/Markup.cpp	/^	void SaveOffset() { iSave=i; };$/;"	f	struct:PathPos	access:public	signature:()
SavePos	third_party/xml/Markup.cpp	/^bool CMarkup::SavePos( MCD_CSTR szPosName \/*=""*\/, int nMap \/*=0*\/ )$/;"	f	class:CMarkup	signature:( MCD_CSTR szPosName , int nMap )
SavePos	third_party/xml/Markup.h	/^	bool SavePos( MCD_CSTR szPosName=MCD_T(""), int nMap = 0 );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR szPosName=MCD_T(Ó), int nMap = 0 )
SavedPos	third_party/xml/Markup.cpp	/^	SavedPos() { nSavedPosFlags=0; iPos=0; };$/;"	f	struct:SavedPos	access:public	signature:()
SavedPos	third_party/xml/Markup.cpp	/^struct SavedPos$/;"	s	file:
SavedPos::SPM_CHILD	third_party/xml/Markup.cpp	/^	enum { SPM_MAIN = 1, SPM_CHILD = 2, SPM_USED = 4, SPM_LAST = 8 };$/;"	e	enum:SavedPos::__anon67	file:
SavedPos::SPM_LAST	third_party/xml/Markup.cpp	/^	enum { SPM_MAIN = 1, SPM_CHILD = 2, SPM_USED = 4, SPM_LAST = 8 };$/;"	e	enum:SavedPos::__anon67	file:
SavedPos::SPM_MAIN	third_party/xml/Markup.cpp	/^	enum { SPM_MAIN = 1, SPM_CHILD = 2, SPM_USED = 4, SPM_LAST = 8 };$/;"	e	enum:SavedPos::__anon67	file:
SavedPos::SPM_USED	third_party/xml/Markup.cpp	/^	enum { SPM_MAIN = 1, SPM_CHILD = 2, SPM_USED = 4, SPM_LAST = 8 };$/;"	e	enum:SavedPos::__anon67	file:
SavedPos::SavedPos	third_party/xml/Markup.cpp	/^	SavedPos() { nSavedPosFlags=0; iPos=0; };$/;"	f	struct:SavedPos	access:public	signature:()
SavedPos::iPos	third_party/xml/Markup.cpp	/^	int iPos;$/;"	m	struct:SavedPos	file:	access:public
SavedPos::nSavedPosFlags	third_party/xml/Markup.cpp	/^	int nSavedPosFlags;$/;"	m	struct:SavedPos	file:	access:public
SavedPos::strName	third_party/xml/Markup.cpp	/^	MCD_STR strName;$/;"	m	struct:SavedPos	file:	access:public
SavedPosMap	third_party/xml/Markup.cpp	/^	SavedPosMap( int nSize ) { nMapSize=nSize; pTable = new SavedPos*[nSize]; memset(pTable,0,nSize*sizeof(SavedPos*)); };$/;"	f	struct:SavedPosMap	access:public	signature:( int nSize )
SavedPosMap	third_party/xml/Markup.cpp	/^struct SavedPosMap$/;"	s	file:
SavedPosMap::SavedPosMap	third_party/xml/Markup.cpp	/^	SavedPosMap( int nSize ) { nMapSize=nSize; pTable = new SavedPos*[nSize]; memset(pTable,0,nSize*sizeof(SavedPos*)); };$/;"	f	struct:SavedPosMap	access:public	signature:( int nSize )
SavedPosMap::nMapSize	third_party/xml/Markup.cpp	/^	int nMapSize;$/;"	m	struct:SavedPosMap	file:	access:public
SavedPosMap::pTable	third_party/xml/Markup.cpp	/^	SavedPos** pTable;$/;"	m	struct:SavedPosMap	file:	access:public
SavedPosMap::~SavedPosMap	third_party/xml/Markup.cpp	/^	~SavedPosMap() { if (pTable) { for (int n=0;n<nMapSize;++n) if (pTable[n]) delete[] pTable[n]; delete[] pTable; } };$/;"	f	struct:SavedPosMap	access:public	signature:()
SavedPosMapArray	third_party/xml/Markup.cpp	/^	SavedPosMapArray() { m_pMaps = NULL; };$/;"	f	struct:SavedPosMapArray	access:public	signature:()
SavedPosMapArray	third_party/xml/Markup.cpp	/^struct SavedPosMapArray$/;"	s	file:
SavedPosMapArray::CopySavedPosMaps	third_party/xml/Markup.cpp	/^	void CopySavedPosMaps( SavedPosMapArray* pOtherMaps );$/;"	p	struct:SavedPosMapArray	file:	access:public	signature:( SavedPosMapArray* pOtherMaps )
SavedPosMapArray::CopySavedPosMaps	third_party/xml/Markup.cpp	/^void SavedPosMapArray::CopySavedPosMaps( SavedPosMapArray* pOtherMaps )$/;"	f	class:SavedPosMapArray	signature:( SavedPosMapArray* pOtherMaps )
SavedPosMapArray::GetMap	third_party/xml/Markup.cpp	/^	bool GetMap( SavedPosMap*& pMap, int nMap, int nMapSize = 7 );$/;"	p	struct:SavedPosMapArray	file:	access:public	signature:( SavedPosMap*& pMap, int nMap, int nMapSize = 7 )
SavedPosMapArray::GetMap	third_party/xml/Markup.cpp	/^bool SavedPosMapArray::GetMap( SavedPosMap*& pMap, int nMap, int nMapSize \/*=7*\/ )$/;"	f	class:SavedPosMapArray	signature:( SavedPosMap*& pMap, int nMap, int nMapSize )
SavedPosMapArray::ReleaseMaps	third_party/xml/Markup.cpp	/^	void ReleaseMaps() { SavedPosMap**p = m_pMaps; if (p) { while (*p) delete *p++; delete[] m_pMaps; m_pMaps=NULL; } };$/;"	f	struct:SavedPosMapArray	access:public	signature:()
SavedPosMapArray::SavedPosMapArray	third_party/xml/Markup.cpp	/^	SavedPosMapArray() { m_pMaps = NULL; };$/;"	f	struct:SavedPosMapArray	access:public	signature:()
SavedPosMapArray::m_pMaps	third_party/xml/Markup.cpp	/^	SavedPosMap** m_pMaps; \/\/ NULL terminated array$/;"	m	struct:SavedPosMapArray	file:	access:public
SavedPosMapArray::~SavedPosMapArray	third_party/xml/Markup.cpp	/^	~SavedPosMapArray() { ReleaseMaps(); };$/;"	f	struct:SavedPosMapArray	access:public	signature:()
SegsUsed	third_party/xml/Markup.cpp	/^	int SegsUsed() const { return ((m_nSize-1)>>PA_SEGBITS) + 1; };$/;"	f	struct:ElemPosTree	access:public	signature:() const
SetAttrib	third_party/xml/Markup.h	/^	bool SetAttrib( MCD_CSTR szAttrib, MCD_CSTR szValue, int nFlags=0 ) { return x_SetAttrib(m_iPos,szAttrib,szValue,nFlags); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib, MCD_CSTR szValue, int nFlags=0 )
SetAttrib	third_party/xml/Markup.h	/^	bool SetAttrib( MCD_CSTR szAttrib, int nValue, int nFlags=0 ) { return x_SetAttrib(m_iPos,szAttrib,nValue,nFlags); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib, int nValue, int nFlags=0 )
SetChildAttrib	third_party/xml/Markup.h	/^	bool SetChildAttrib( MCD_CSTR szAttrib, MCD_CSTR szValue, int nFlags=0 ) { return x_SetAttrib(m_iPosChild,szAttrib,szValue,nFlags); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib, MCD_CSTR szValue, int nFlags=0 )
SetChildAttrib	third_party/xml/Markup.h	/^	bool SetChildAttrib( MCD_CSTR szAttrib, int nValue, int nFlags=0 ) { return x_SetAttrib(m_iPosChild,szAttrib,nValue,nFlags); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szAttrib, int nValue, int nFlags=0 )
SetChildData	third_party/xml/Markup.h	/^	bool SetChildData( MCD_CSTR szData, int nFlags=0 ) { return x_SetData(m_iPosChild,szData,nFlags); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szData, int nFlags=0 )
SetChildData	third_party/xml/Markup.h	/^	bool SetChildData( int nValue ) { return x_SetData(m_iPosChild,nValue); };$/;"	f	class:CMarkup	access:public	signature:( int nValue )
SetData	third_party/xml/Markup.h	/^	bool SetData( MCD_CSTR szData, int nFlags=0 ) { return x_SetData(m_iPos,szData,nFlags); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szData, int nFlags=0 )
SetData	third_party/xml/Markup.h	/^	bool SetData( int nValue ) { return x_SetData(m_iPos,nValue); };$/;"	f	class:CMarkup	access:public	signature:( int nValue )
SetDoc	third_party/xml/Markup.cpp	/^bool CMarkup::SetDoc( MCD_PCSZ pDoc )$/;"	f	class:CMarkup	signature:( MCD_PCSZ pDoc )
SetDoc	third_party/xml/Markup.cpp	/^bool CMarkup::SetDoc( const MCD_STR& strDoc )$/;"	f	class:CMarkup	signature:( const MCD_STR& strDoc )
SetDoc	third_party/xml/Markup.h	/^	bool SetDoc( MCD_PCSZ pDoc );$/;"	p	class:CMarkup	access:public	signature:( MCD_PCSZ pDoc )
SetDoc	third_party/xml/Markup.h	/^	bool SetDoc( const MCD_STR& strDoc );$/;"	p	class:CMarkup	access:public	signature:( const MCD_STR& strDoc )
SetDocFlags	third_party/xml/Markup.h	/^	void SetDocFlags( int nFlags ) { m_nDocFlags = (nFlags & ~(MDF_READFILE|MDF_WRITEFILE|MDF_APPENDFILE)); };$/;"	f	class:CMarkup	access:public	signature:( int nFlags )
SetElemContent	third_party/xml/Markup.h	/^	bool SetElemContent( MCD_CSTR szContent ) { return x_SetElemContent(szContent); };$/;"	f	class:CMarkup	access:public	signature:( MCD_CSTR szContent )
SetEndTagLen	third_party/xml/Markup.cpp	/^	void SetEndTagLen( int n ) { nEndTagLen = n; };$/;"	f	struct:ElemPos	access:public	signature:( int n )
SetEndTagLenUnparsed	third_party/xml/Markup.cpp	/^	void SetEndTagLenUnparsed() { SetEndTagLen(1); };$/;"	f	struct:ElemPos	access:public	signature:()
SetLevel	third_party/xml/Markup.cpp	/^    void SetLevel( int nLev ) { nFlags = (nFlags & ~0xffff) | nLev; };$/;"	f	struct:ElemPos	access:public	signature:( int nLev )
SetMapSize	third_party/xml/Markup.cpp	/^bool CMarkup::SetMapSize( int nSize, int nMap \/*=0*\/ )$/;"	f	class:CMarkup	signature:( int nSize, int nMap )
SetMapSize	third_party/xml/Markup.h	/^	bool SetMapSize( int nSize, int nMap = 0 );$/;"	p	class:CMarkup	access:public	signature:( int nSize, int nMap = 0 )
SetStartTagLen	third_party/xml/Markup.cpp	/^	void SetStartTagLen( int n ) { nStartTagLen = n; };$/;"	f	struct:ElemPos	access:public	signature:( int n )
SetTagName	third_party/xml/Markup.cpp	/^	void SetTagName( MCD_PCSZ pName, int n ) { MCD_STRASSIGN(strTagName,pName,n); };$/;"	f	struct:TagPos	access:public	signature:( MCD_PCSZ pName, int n )
Slot	third_party/xml/Markup.cpp	/^	void Slot( int n ) { pL[iUsed].nSlot=n; int i=anTable[n]; anTable[n]=iUsed; pL[iUsed].iSlotNext=i; if (i) pL[i].iSlotPrev=iUsed; };$/;"	f	struct:ElemStack	access:public	signature:( int n )
SmartArray	include/arrayX.h	/^	SmartArray() {}$/;"	f	struct:SmartArray	access:public	signature:()
SmartArray	include/arrayX.h	/^	SmartArray(_Iter _First, _Iter _Last)$/;"	f	struct:SmartArray	access:public	signature:(_Iter _First, _Iter _Last)
SmartArray	include/arrayX.h	/^	explicit SmartArray(const_reference val)$/;"	f	struct:SmartArray	access:public	signature:(const_reference val)
SmartArray	include/arrayX.h	/^struct SmartArray$/;"	s
SmartArray::Length	include/arrayX.h	/^	const static size_t Length = _Length;$/;"	m	struct:SmartArray	access:public
SmartArray::SmartArray	include/arrayX.h	/^	SmartArray() {}$/;"	f	struct:SmartArray	access:public	signature:()
SmartArray::SmartArray	include/arrayX.h	/^	SmartArray(_Iter _First, _Iter _Last)$/;"	f	struct:SmartArray	access:public	signature:(_Iter _First, _Iter _Last)
SmartArray::SmartArray	include/arrayX.h	/^	explicit SmartArray(const_reference val)$/;"	f	struct:SmartArray	access:public	signature:(const_reference val)
SmartArray::_Myt	include/arrayX.h	/^	typedef SmartArray<_Ty, _Length> _Myt;$/;"	t	struct:SmartArray	access:public
SmartArray::_buf	include/arrayX.h	/^	_Ty _buf[_Length];$/;"	m	struct:SmartArray	access:private
SmartArray::at	include/arrayX.h	/^	const_reference at(size_type idx) const$/;"	f	struct:SmartArray	access:public	signature:(size_type idx) const
SmartArray::at	include/arrayX.h	/^	reference at(size_type idx)$/;"	f	struct:SmartArray	access:public	signature:(size_type idx)
SmartArray::attach	include/arrayX.h	/^	static SmartArray<const value_type, _Length>* attach(const value_type anArray[_Length])$/;"	f	struct:SmartArray	access:public	signature:(const value_type anArray[_Length])
SmartArray::attach	include/arrayX.h	/^	static _Myt* attach(value_type anArray[_Length])$/;"	f	struct:SmartArray	access:public	signature:(value_type anArray[_Length])
SmartArray::back	include/arrayX.h	/^	const_reference back() const { return _buf[_Length - 1]; }$/;"	f	struct:SmartArray	access:public	signature:() const
SmartArray::back	include/arrayX.h	/^	reference back() { return _buf[_Length - 1]; }$/;"	f	struct:SmartArray	access:public	signature:()
SmartArray::begin	include/arrayX.h	/^	const_iterator begin() const { return const_iterator(_buf, _Length); }$/;"	f	struct:SmartArray	access:public	signature:() const
SmartArray::begin	include/arrayX.h	/^	iterator begin() { return iterator(_buf, _Length); }$/;"	f	struct:SmartArray	access:public	signature:()
SmartArray::const_iterator	include/arrayX.h	/^	typedef array_iterator<const value_type> const_iterator;$/;"	t	struct:SmartArray	access:public
SmartArray::const_pointer	include/arrayX.h	/^	typedef const _Ty* const_pointer;$/;"	t	struct:SmartArray	access:public
SmartArray::const_reference	include/arrayX.h	/^	typedef const value_type& const_reference;$/;"	t	struct:SmartArray	access:public
SmartArray::const_reverse_iterator	include/arrayX.h	/^	typedef std::reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	struct:SmartArray	access:public
SmartArray::end	include/arrayX.h	/^	const_iterator end() const { return const_iterator(_buf + _Length, _Length, 0); }$/;"	f	struct:SmartArray	access:public	signature:() const
SmartArray::end	include/arrayX.h	/^	iterator end() { return iterator(_buf + _Length, _Length, 0); }$/;"	f	struct:SmartArray	access:public	signature:()
SmartArray::front	include/arrayX.h	/^	const_reference front() const { return _buf[0]; }$/;"	f	struct:SmartArray	access:public	signature:() const
SmartArray::front	include/arrayX.h	/^	reference front() { return _buf[0]; }$/;"	f	struct:SmartArray	access:public	signature:()
SmartArray::iterator	include/arrayX.h	/^	typedef array_iterator<value_type> iterator;$/;"	t	struct:SmartArray	access:public
SmartArray::operator =	include/arrayX.h	/^	_Myt& operator=(const _Ty& val)$/;"	f	struct:SmartArray	access:public	signature:(const _Ty& val)
SmartArray::operator []	include/arrayX.h	/^	const_reference operator[](size_type idx) const { return _buf[idx]; }$/;"	f	struct:SmartArray	access:public	signature:(size_type idx) const
SmartArray::operator []	include/arrayX.h	/^	reference operator[](size_type idx) { return _buf[idx]; }$/;"	f	struct:SmartArray	access:public	signature:(size_type idx)
SmartArray::pointer	include/arrayX.h	/^	typedef _Ty* pointer;$/;"	t	struct:SmartArray	access:public
SmartArray::ptr	include/arrayX.h	/^	const_pointer ptr() const { return _buf; }$/;"	f	struct:SmartArray	access:public	signature:() const
SmartArray::ptr	include/arrayX.h	/^	pointer ptr() { return _buf; }$/;"	f	struct:SmartArray	access:public	signature:()
SmartArray::rbegin	include/arrayX.h	/^	const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); }$/;"	f	struct:SmartArray	access:public	signature:() const
SmartArray::rbegin	include/arrayX.h	/^	reverse_iterator rbegin() { return reverse_iterator(end()); }$/;"	f	struct:SmartArray	access:public	signature:()
SmartArray::reference	include/arrayX.h	/^	typedef value_type& reference;$/;"	t	struct:SmartArray	access:public
SmartArray::rend	include/arrayX.h	/^	const_reverse_iterator rend() const { return const_reverse_iterator(begin()); }$/;"	f	struct:SmartArray	access:public	signature:() const
SmartArray::rend	include/arrayX.h	/^	reverse_iterator rend() { return reverse_iterator(begin()); }$/;"	f	struct:SmartArray	access:public	signature:()
SmartArray::reverse_iterator	include/arrayX.h	/^	typedef std::reverse_iterator<iterator> reverse_iterator;$/;"	t	struct:SmartArray	access:public
SmartArray::size	include/arrayX.h	/^	size_t size() const {return _Length;}$/;"	f	struct:SmartArray	access:public	signature:() const
SmartArray::size_type	include/arrayX.h	/^	typedef std::size_t size_type;$/;"	t	struct:SmartArray	access:public
SmartArray::value_type	include/arrayX.h	/^	typedef typename mpl::remove_const<_Ty>::type value_type;$/;"	t	struct:SmartArray	access:public
SmartMatrix	include/arrayX.h	/^	SmartMatrix()$/;"	f	struct:SmartMatrix	access:public	signature:()
SmartMatrix	include/arrayX.h	/^	SmartMatrix(_IterIn _First, _IterIn _Last)$/;"	f	struct:SmartMatrix	access:public	signature:(_IterIn _First, _IterIn _Last)
SmartMatrix	include/arrayX.h	/^	SmartMatrix(const _Ty& val)$/;"	f	struct:SmartMatrix	access:public	signature:(const _Ty& val)
SmartMatrix	include/arrayX.h	/^struct SmartMatrix$/;"	s
SmartMatrix::Column	include/arrayX.h	/^	const static size_t Column = _Col;$/;"	m	struct:SmartMatrix	access:public
SmartMatrix::ConstRowVector	include/arrayX.h	/^	typedef const_pointer ConstRowVector;$/;"	t	struct:SmartMatrix	access:public
SmartMatrix::Length	include/arrayX.h	/^	const static size_t Length = _Row * _Col;$/;"	m	struct:SmartMatrix	access:public
SmartMatrix::Row	include/arrayX.h	/^	const static size_t Row = _Row;$/;"	m	struct:SmartMatrix	access:public
SmartMatrix::RowVector	include/arrayX.h	/^	typedef pointer RowVector;$/;"	t	struct:SmartMatrix	access:public
SmartMatrix::SmartMatrix	include/arrayX.h	/^	SmartMatrix()$/;"	f	struct:SmartMatrix	access:public	signature:()
SmartMatrix::SmartMatrix	include/arrayX.h	/^	SmartMatrix(_IterIn _First, _IterIn _Last)$/;"	f	struct:SmartMatrix	access:public	signature:(_IterIn _First, _IterIn _Last)
SmartMatrix::SmartMatrix	include/arrayX.h	/^	SmartMatrix(const _Ty& val)$/;"	f	struct:SmartMatrix	access:public	signature:(const _Ty& val)
SmartMatrix::_Myt	include/arrayX.h	/^	typedef SmartMatrix<_Ty, _Row, _Col> _Myt;$/;"	t	struct:SmartMatrix	access:public
SmartMatrix::_values	include/arrayX.h	/^	_Ty _values[_Row][_Col];$/;"	m	struct:SmartMatrix	access:private
SmartMatrix::begin	include/arrayX.h	/^	const_iterator begin() const { return const_iterator(_values[0], Length); }$/;"	f	struct:SmartMatrix	access:public	signature:() const
SmartMatrix::begin	include/arrayX.h	/^	iterator begin() { return iterator(_values[0], Length); }$/;"	f	struct:SmartMatrix	access:public	signature:()
SmartMatrix::col	include/arrayX.h	/^	size_t col() const { return _Col; }$/;"	f	struct:SmartMatrix	access:public	signature:() const
SmartMatrix::const_iterator	include/arrayX.h	/^	typedef array_iterator<const value_type> const_iterator;$/;"	t	struct:SmartMatrix	access:public
SmartMatrix::const_pointer	include/arrayX.h	/^	typedef const _Ty* const_pointer;$/;"	t	struct:SmartMatrix	access:public
SmartMatrix::const_reference	include/arrayX.h	/^	typedef const value_type& const_reference;$/;"	t	struct:SmartMatrix	access:public
SmartMatrix::const_reverse_iterator	include/arrayX.h	/^	typedef std::reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	struct:SmartMatrix	access:public
SmartMatrix::end	include/arrayX.h	/^	const_iterator end() const { return const_iterator(_values[0] + Length, Length, 0); }$/;"	f	struct:SmartMatrix	access:public	signature:() const
SmartMatrix::end	include/arrayX.h	/^	iterator end() { return iterator(_values[0] + Length, Length, 0); }$/;"	f	struct:SmartMatrix	access:public	signature:()
SmartMatrix::iterator	include/arrayX.h	/^	typedef array_iterator<value_type> iterator;$/;"	t	struct:SmartMatrix	access:public
SmartMatrix::operator ()	include/arrayX.h	/^	const_reference operator()(size_type r, size_type c) const { return _values[r][c]; }$/;"	f	struct:SmartMatrix	access:public	signature:(size_type r, size_type c) const
SmartMatrix::operator ()	include/arrayX.h	/^	reference operator()(size_type r, size_type c) { return _values[r][c]; }$/;"	f	struct:SmartMatrix	access:public	signature:(size_type r, size_type c)
SmartMatrix::operator []	include/arrayX.h	/^	ConstRowVector operator[](size_type idx) const{return _values[idx];}$/;"	f	struct:SmartMatrix	access:public	signature:(size_type idx) const
SmartMatrix::operator []	include/arrayX.h	/^	RowVector operator[](size_type idx) {return _values[idx];}$/;"	f	struct:SmartMatrix	access:public	signature:(size_type idx)
SmartMatrix::pointer	include/arrayX.h	/^	typedef _Ty* pointer;$/;"	t	struct:SmartMatrix	access:public
SmartMatrix::ptr	include/arrayX.h	/^	_Ty* ptr() { return _values[0]; }$/;"	f	struct:SmartMatrix	access:public	signature:()
SmartMatrix::ptr	include/arrayX.h	/^	const _Ty* ptr() const { return _values[0]; }$/;"	f	struct:SmartMatrix	access:public	signature:() const
SmartMatrix::reference	include/arrayX.h	/^	typedef value_type& reference;$/;"	t	struct:SmartMatrix	access:public
SmartMatrix::reverse_iterator	include/arrayX.h	/^	typedef std::reverse_iterator<iterator> reverse_iterator;$/;"	t	struct:SmartMatrix	access:public
SmartMatrix::row	include/arrayX.h	/^	size_t row() const { return _Row; }$/;"	f	struct:SmartMatrix	access:public	signature:() const
SmartMatrix::size	include/arrayX.h	/^	size_t size() const {return Length; }$/;"	f	struct:SmartMatrix	access:public	signature:() const
SmartMatrix::size_type	include/arrayX.h	/^	typedef std::size_t size_type;$/;"	t	struct:SmartMatrix	access:public
SmartMatrix::value_type	include/arrayX.h	/^	typedef typename mpl::remove_const<_Ty>::type value_type;$/;"	t	struct:SmartMatrix	access:public
StartAfter	third_party/xml/Markup.cpp	/^	int StartAfter() const { return nStart + nLength; };$/;"	f	struct:ElemPos	access:public	signature:() const
StartContent	third_party/xml/Markup.cpp	/^	int StartContent() const { return nStart + StartTagLen(); };$/;"	f	struct:ElemPos	access:public	signature:() const
StartTagLen	third_party/xml/Markup.cpp	/^	int StartTagLen() const { return nStartTagLen; };$/;"	f	struct:ElemPos	access:public	signature:() const
StrNIACmp	third_party/xml/Markup.cpp	/^	static int StrNIACmp( MCD_PCSZ p1, MCD_PCSZ p2, int n )$/;"	f	struct:TokenPos	access:public	signature:( MCD_PCSZ p1, MCD_PCSZ p2, int n )
THIS_FILE	third_party/xml/Markup.cpp	/^static char THIS_FILE[]=__FILE__;$/;"	v	file:
THIS_FILE	third_party/xml/Markup.cpp	35;"	d	file:
TagPos	third_party/xml/Markup.cpp	/^	TagPos() { Init(); };$/;"	f	struct:TagPos	access:public	signature:()
TagPos	third_party/xml/Markup.cpp	/^struct TagPos$/;"	s	file:
TagPos::IncCount	third_party/xml/Markup.cpp	/^	void IncCount() { if (nCount) ++nCount; };$/;"	f	struct:TagPos	access:public	signature:()
TagPos::Init	third_party/xml/Markup.cpp	/^	void Init( int i=0, int n=1 ) { nCount=1; nTagNames=n; iNext=i; iPrev=0; nSlot=-1; iSlotPrev=0; iSlotNext=0; };$/;"	f	struct:TagPos	access:public	signature:( int i=0, int n=1 )
TagPos::SetTagName	third_party/xml/Markup.cpp	/^	void SetTagName( MCD_PCSZ pName, int n ) { MCD_STRASSIGN(strTagName,pName,n); };$/;"	f	struct:TagPos	access:public	signature:( MCD_PCSZ pName, int n )
TagPos::TagPos	third_party/xml/Markup.cpp	/^	TagPos() { Init(); };$/;"	f	struct:TagPos	access:public	signature:()
TagPos::iNext	third_party/xml/Markup.cpp	/^	int iNext;$/;"	m	struct:TagPos	file:	access:public
TagPos::iParent	third_party/xml/Markup.cpp	/^	int iParent;$/;"	m	struct:TagPos	file:	access:public
TagPos::iPrev	third_party/xml/Markup.cpp	/^	int iPrev;$/;"	m	struct:TagPos	file:	access:public
TagPos::iSlotNext	third_party/xml/Markup.cpp	/^	int iSlotNext;$/;"	m	struct:TagPos	file:	access:public
TagPos::iSlotPrev	third_party/xml/Markup.cpp	/^	int iSlotPrev;$/;"	m	struct:TagPos	file:	access:public
TagPos::nCount	third_party/xml/Markup.cpp	/^	int nCount;$/;"	m	struct:TagPos	file:	access:public
TagPos::nSlot	third_party/xml/Markup.cpp	/^	int nSlot;$/;"	m	struct:TagPos	file:	access:public
TagPos::nTagNames	third_party/xml/Markup.cpp	/^	int nTagNames;$/;"	m	struct:TagPos	file:	access:public
TagPos::strTagName	third_party/xml/Markup.cpp	/^	MCD_STR strTagName;$/;"	m	struct:TagPos	file:	access:public
TextEncoding	third_party/xml/Markup.cpp	/^	TextEncoding( MCD_CSTR pszFromEncoding, const void* pFromBuffer, int nFromBufferLen )$/;"	f	struct:TextEncoding	access:public	signature:( MCD_CSTR pszFromEncoding, const void* pFromBuffer, int nFromBufferLen )
TextEncoding	third_party/xml/Markup.cpp	/^struct TextEncoding$/;"	s	file:
TextEncoding::CanConvert	third_party/xml/Markup.cpp	/^	static bool CanConvert( MCD_CSTR pszToEncoding, MCD_CSTR pszFromEncoding );$/;"	p	struct:TextEncoding	file:	access:public	signature:( MCD_CSTR pszToEncoding, MCD_CSTR pszFromEncoding )
TextEncoding::CanConvert	third_party/xml/Markup.cpp	/^bool TextEncoding::CanConvert( MCD_CSTR pszToEncoding, MCD_CSTR pszFromEncoding )$/;"	f	class:TextEncoding	signature:( MCD_CSTR pszToEncoding, MCD_CSTR pszFromEncoding )
TextEncoding::FindRaggedEnd	third_party/xml/Markup.cpp	/^	bool FindRaggedEnd( int& nTruncBeforeBytes );$/;"	p	struct:TextEncoding	file:	access:public	signature:( int& nTruncBeforeBytes )
TextEncoding::FindRaggedEnd	third_party/xml/Markup.cpp	/^bool TextEncoding::FindRaggedEnd( int& nTruncBeforeBytes )$/;"	f	class:TextEncoding	signature:( int& nTruncBeforeBytes )
TextEncoding::IConv	third_party/xml/Markup.cpp	/^	int IConv( void* pTo, int nToCharSize, int nFromCharSize );$/;"	p	struct:TextEncoding	file:	access:public	signature:( void* pTo, int nToCharSize, int nFromCharSize )
TextEncoding::IConv	third_party/xml/Markup.cpp	/^int TextEncoding::IConv( void* pTo, int nToCharSize, int nFromCharSize )$/;"	f	class:TextEncoding	signature:( void* pTo, int nToCharSize, int nFromCharSize )
TextEncoding::IConvName	third_party/xml/Markup.cpp	/^	static const char* IConvName( char* szEncoding, MCD_CSTR pszEncoding );$/;"	p	struct:TextEncoding	file:	access:public	signature:( char* szEncoding, MCD_CSTR pszEncoding )
TextEncoding::IConvName	third_party/xml/Markup.cpp	/^const char* TextEncoding::IConvName( char* szEncoding, MCD_CSTR pszEncoding )$/;"	f	class:TextEncoding	signature:( char* szEncoding, MCD_CSTR pszEncoding )
TextEncoding::PerformConversion	third_party/xml/Markup.cpp	/^	int PerformConversion( void* pTo, MCD_CSTR pszToEncoding = NULL );$/;"	p	struct:TextEncoding	file:	access:public	signature:( void* pTo, MCD_CSTR pszToEncoding = NULL )
TextEncoding::PerformConversion	third_party/xml/Markup.cpp	/^int TextEncoding::PerformConversion( void* pTo, MCD_CSTR pszToEncoding\/*=NULL*\/ )$/;"	f	class:TextEncoding	signature:( void* pTo, MCD_CSTR pszToEncoding )
TextEncoding::TextEncoding	third_party/xml/Markup.cpp	/^	TextEncoding( MCD_CSTR pszFromEncoding, const void* pFromBuffer, int nFromBufferLen )$/;"	f	struct:TextEncoding	access:public	signature:( MCD_CSTR pszFromEncoding, const void* pFromBuffer, int nFromBufferLen )
TextEncoding::m_nFailedChars	third_party/xml/Markup.cpp	/^	int m_nFailedChars;$/;"	m	struct:TextEncoding	file:	access:public
TextEncoding::m_nFromLen	third_party/xml/Markup.cpp	/^	int m_nFromLen;$/;"	m	struct:TextEncoding	file:	access:public
TextEncoding::m_nToCount	third_party/xml/Markup.cpp	/^	int m_nToCount;$/;"	m	struct:TextEncoding	file:	access:public
TextEncoding::m_pFrom	third_party/xml/Markup.cpp	/^	const void* m_pFrom;$/;"	m	struct:TextEncoding	file:	access:public
TextEncoding::m_strFromEncoding	third_party/xml/Markup.cpp	/^	MCD_STR m_strFromEncoding;$/;"	m	struct:TextEncoding	file:	access:public
TextEncoding::m_strToEncoding	third_party/xml/Markup.cpp	/^	MCD_STR m_strToEncoding;$/;"	m	struct:TextEncoding	file:	access:public
TokenPos	third_party/xml/Markup.cpp	/^	TokenPos( MCD_CSTR sz, int n, FilePos* p=NULL ) { Clear(); m_pDocText=sz; m_nTokenFlags=n; m_pReaderFilePos=p; };$/;"	f	struct:TokenPos	access:public	signature:( MCD_CSTR sz, int n, FilePos* p=NULL )
TokenPos	third_party/xml/Markup.cpp	/^struct TokenPos$/;"	s	file:
TokenPos::Clear	third_party/xml/Markup.cpp	/^	void Clear() { m_nL=0; m_nR=-1; m_nNext=0; };$/;"	f	struct:TokenPos	access:public	signature:()
TokenPos::FindAny	third_party/xml/Markup.cpp	/^	bool FindAny()$/;"	f	struct:TokenPos	access:public	signature:()
TokenPos::FindAttrib	third_party/xml/Markup.cpp	/^	bool FindAttrib( MCD_PCSZ pAttrib, int n = 0 );$/;"	p	struct:TokenPos	file:	access:public	signature:( MCD_PCSZ pAttrib, int n = 0 )
TokenPos::FindAttrib	third_party/xml/Markup.cpp	/^bool TokenPos::FindAttrib( MCD_PCSZ pAttrib, int n\/*=0*\/ )$/;"	f	class:TokenPos	signature:( MCD_PCSZ pAttrib, int n )
TokenPos::FindName	third_party/xml/Markup.cpp	/^	bool FindName()$/;"	f	struct:TokenPos	access:public	signature:()
TokenPos::ForwardUntil	third_party/xml/Markup.cpp	/^	void ForwardUntil( MCD_PCSZ szStopChars ) { while ( m_pDocText[m_nNext] && ! MCD_PSZCHR(szStopChars,m_pDocText[m_nNext]) ) m_nNext += MCD_CLEN(&m_pDocText[m_nNext]); }$/;"	f	struct:TokenPos	access:public	signature:( MCD_PCSZ szStopChars )
TokenPos::GetTokenPtr	third_party/xml/Markup.cpp	/^	MCD_PCSZ GetTokenPtr() const { return &m_pDocText[m_nL]; };$/;"	f	struct:TokenPos	access:public	signature:() const
TokenPos::GetTokenText	third_party/xml/Markup.cpp	/^	MCD_STR GetTokenText() const { return MCD_STR( GetTokenPtr(), Length() ); };$/;"	f	struct:TokenPos	access:public	signature:() const
TokenPos::Length	third_party/xml/Markup.cpp	/^	int Length() const { return m_nR - m_nL + 1; };$/;"	f	struct:TokenPos	access:public	signature:() const
TokenPos::Match	third_party/xml/Markup.cpp	/^	bool Match( MCD_CSTR szName )$/;"	f	struct:TokenPos	access:public	signature:( MCD_CSTR szName )
TokenPos::ParseNode	third_party/xml/Markup.cpp	/^	int ParseNode( NodePos& node );$/;"	p	struct:TokenPos	file:	access:public	signature:( NodePos& node )
TokenPos::ParseNode	third_party/xml/Markup.cpp	/^int TokenPos::ParseNode( NodePos& node )$/;"	f	class:TokenPos	signature:( NodePos& node )
TokenPos::StrNIACmp	third_party/xml/Markup.cpp	/^	static int StrNIACmp( MCD_PCSZ p1, MCD_PCSZ p2, int n )$/;"	f	struct:TokenPos	access:public	signature:( MCD_PCSZ p1, MCD_PCSZ p2, int n )
TokenPos::TokenPos	third_party/xml/Markup.cpp	/^	TokenPos( MCD_CSTR sz, int n, FilePos* p=NULL ) { Clear(); m_pDocText=sz; m_nTokenFlags=n; m_pReaderFilePos=p; };$/;"	f	struct:TokenPos	access:public	signature:( MCD_CSTR sz, int n, FilePos* p=NULL )
TokenPos::WhitespaceToTag	third_party/xml/Markup.cpp	/^	int WhitespaceToTag( int n ) { m_nNext = n; if (FindAny()&&m_pDocText[m_nNext]!='<') { m_nNext=n; m_nR=n-1; } return m_nNext; };$/;"	f	struct:TokenPos	access:public	signature:( int n )
TokenPos::m_nL	third_party/xml/Markup.cpp	/^	int m_nL;$/;"	m	struct:TokenPos	file:	access:public
TokenPos::m_nNext	third_party/xml/Markup.cpp	/^	int m_nNext;$/;"	m	struct:TokenPos	file:	access:public
TokenPos::m_nPreSpaceLength	third_party/xml/Markup.cpp	/^	int m_nPreSpaceLength;$/;"	m	struct:TokenPos	file:	access:public
TokenPos::m_nPreSpaceStart	third_party/xml/Markup.cpp	/^	int m_nPreSpaceStart;$/;"	m	struct:TokenPos	file:	access:public
TokenPos::m_nR	third_party/xml/Markup.cpp	/^	int m_nR;$/;"	m	struct:TokenPos	file:	access:public
TokenPos::m_nTokenFlags	third_party/xml/Markup.cpp	/^	int m_nTokenFlags;$/;"	m	struct:TokenPos	file:	access:public
TokenPos::m_pDocText	third_party/xml/Markup.cpp	/^	MCD_PCSZ m_pDocText;$/;"	m	struct:TokenPos	file:	access:public
TokenPos::m_pReaderFilePos	third_party/xml/Markup.cpp	/^	FilePos* m_pReaderFilePos;$/;"	m	struct:TokenPos	file:	access:public
TriSate	include/functionalX.h	/^enum TriSate$/;"	g
UTF16To8	third_party/xml/Markup.cpp	/^int CMarkup::UTF16To8( char* pszUTF8, const unsigned short* pwszUTF16, int nUTF8Count )$/;"	f	class:CMarkup	signature:( char* pszUTF8, const unsigned short* pwszUTF16, int nUTF8Count )
UTF16To8	third_party/xml/Markup.h	/^	static int UTF16To8( char *pszUTF8, const unsigned short* pwszUTF16, int nUTF8Count );$/;"	p	class:CMarkup	access:public	signature:( char *pszUTF8, const unsigned short* pwszUTF16, int nUTF8Count )
UTF8To16	third_party/xml/Markup.cpp	/^int CMarkup::UTF8To16( unsigned short* pwszUTF16, const char* pszUTF8, int nUTF8Count )$/;"	f	class:CMarkup	signature:( unsigned short* pwszUTF16, const char* pszUTF8, int nUTF8Count )
UTF8To16	third_party/xml/Markup.h	/^	static int UTF8To16( unsigned short* pwszUTF16, const char* pszUTF8, int nUTF8Count );$/;"	p	class:CMarkup	access:public	signature:( unsigned short* pwszUTF16, const char* pszUTF8, int nUTF8Count )
UTF8ToA	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::UTF8ToA( MCD_CSTR pszUTF8, int* pnFailed\/*=NULL*\/ )$/;"	f	class:CMarkup	signature:( MCD_CSTR pszUTF8, int* pnFailed )
UTF8ToA	third_party/xml/Markup.h	/^	static MCD_STR UTF8ToA( MCD_CSTR pszUTF8, int* pnFailed = NULL );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR pszUTF8, int* pnFailed = NULL )
UnKnown	include/functionalX.h	/^	UnKnown = 0$/;"	e	enum:TriSate
UnescapeText	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::UnescapeText( MCD_CSTR szText, int nTextLength \/*=-1*\/ )$/;"	f	class:CMarkup	signature:( MCD_CSTR szText, int nTextLength )
UnescapeText	third_party/xml/Markup.h	/^	static MCD_STR UnescapeText( MCD_CSTR szText, int nTextLength = -1 );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR szText, int nTextLength = -1 )
Unknown	syntax/word.h	/^	enum{Known = 1, Unknown = 0, Error = -1};$/;"	e	enum:word::__anon7
Unslot	third_party/xml/Markup.cpp	/^	void Unslot( TagPos& lp ) { int n=lp.iSlotNext,p=lp.iSlotPrev; if (n) pL[n].iSlotPrev=p; if (p) pL[p].iSlotNext=n; else anTable[lp.nSlot]=n; };$/;"	f	struct:ElemStack	access:public	signature:( TagPos& lp )
UpdateClosure	galgorithm/lranalyse.cpp	/^size_t Algorithm_IsLR1::AlgorithmArg::UpdateClosure(LR::LRState& orgState) const$/;"	f	class:Algorithm_IsLR1::AlgorithmArg	signature:(LR::LRState& orgState) const
V	test/vhelp.h	/^	V() {}$/;"	f	class:V	access:public	signature:()
V	test/vhelp.h	/^	V(IDX _0) : v(1)$/;"	f	class:V	access:public	signature:(IDX _0)
V	test/vhelp.h	/^	V(IDX _0, IDX _1) : v(2)$/;"	f	class:V	access:public	signature:(IDX _0, IDX _1)
V	test/vhelp.h	/^	V(IDX _0, IDX _1, IDX _2) : v(3)$/;"	f	class:V	access:public	signature:(IDX _0, IDX _1, IDX _2)
V	test/vhelp.h	/^	V(IDX _0, IDX _1, IDX _2, IDX _3) : v(4)$/;"	f	class:V	access:public	signature:(IDX _0, IDX _1, IDX _2, IDX _3)
V	test/vhelp.h	/^	V(IDX _0, IDX _1, IDX _2, IDX _3, IDX _4, IDX _5) : v(6)$/;"	f	class:V	access:public	signature:(IDX _0, IDX _1, IDX _2, IDX _3, IDX _4, IDX _5)
V	test/vhelp.h	/^	V(IDX _0, IDX _1, IDX _2, IDX _3, IDX _4, IDX _5, IDX _6) : v(7)$/;"	f	class:V	access:public	signature:(IDX _0, IDX _1, IDX _2, IDX _3, IDX _4, IDX _5, IDX _6)
V	test/vhelp.h	/^	V(IDX _0, IDX _1, IDX _2, IDX _3, IDX _4, IDX _5, IDX _6,$/;"	f	class:V	access:public	signature:(IDX _0, IDX _1, IDX _2, IDX _3, IDX _4, IDX _5, IDX _6, IDX _7, IDX _8, IDX _9, IDX _10, IDX _11, IDX _12)
V	test/vhelp.h	/^class V : public kog::smart_vector<compile::int32>$/;"	c	inherits:kog::smart_vector
V::V	test/vhelp.h	/^	V() {}$/;"	f	class:V	access:public	signature:()
V::V	test/vhelp.h	/^	V(IDX _0) : v(1)$/;"	f	class:V	access:public	signature:(IDX _0)
V::V	test/vhelp.h	/^	V(IDX _0, IDX _1) : v(2)$/;"	f	class:V	access:public	signature:(IDX _0, IDX _1)
V::V	test/vhelp.h	/^	V(IDX _0, IDX _1, IDX _2) : v(3)$/;"	f	class:V	access:public	signature:(IDX _0, IDX _1, IDX _2)
V::V	test/vhelp.h	/^	V(IDX _0, IDX _1, IDX _2, IDX _3) : v(4)$/;"	f	class:V	access:public	signature:(IDX _0, IDX _1, IDX _2, IDX _3)
V::V	test/vhelp.h	/^	V(IDX _0, IDX _1, IDX _2, IDX _3, IDX _4, IDX _5) : v(6)$/;"	f	class:V	access:public	signature:(IDX _0, IDX _1, IDX _2, IDX _3, IDX _4, IDX _5)
V::V	test/vhelp.h	/^	V(IDX _0, IDX _1, IDX _2, IDX _3, IDX _4, IDX _5, IDX _6) : v(7)$/;"	f	class:V	access:public	signature:(IDX _0, IDX _1, IDX _2, IDX _3, IDX _4, IDX _5, IDX _6)
V::V	test/vhelp.h	/^	V(IDX _0, IDX _1, IDX _2, IDX _3, IDX _4, IDX _5, IDX _6,$/;"	f	class:V	access:public	signature:(IDX _0, IDX _1, IDX _2, IDX _3, IDX _4, IDX _5, IDX _6, IDX _7, IDX _8, IDX _9, IDX _10, IDX _11, IDX _12)
V::int32	test/vhelp.h	/^	typedef compile::int32 int32;$/;"	t	class:V	access:private
V::symbols	test/vhelp.h	/^	static const compile::symholder*& symbols()$/;"	f	class:V	access:public	signature:()
V::tstring	test/vhelp.h	/^	typedef compile::tstring tstring;$/;"	t	class:V	access:private
V::v	test/vhelp.h	/^	typedef kog::smart_vector<int32> v;$/;"	t	class:V	access:private
ValidPath	third_party/xml/Markup.cpp	/^	bool ValidPath() { return nPathType != -1; };$/;"	f	struct:PathPos	access:public	signature:()
ValueDeclear	test/output/gen.cpp	/^	ValueDeclear()$/;"	f	struct:ValueDeclear	access:public	signature:()
ValueDeclear	test/output/gen.cpp	/^struct ValueDeclear : public type$/;"	s	file:	inherits:type
ValueDeclear	test/output/tinyg.cpp	/^	ValueDeclear()$/;"	f	struct:ValueDeclear	access:public	signature:()
ValueDeclear	test/output/tinyg.cpp	/^struct ValueDeclear : public type$/;"	s	file:	inherits:type
ValueDeclear::ValueDeclear	test/output/gen.cpp	/^	ValueDeclear()$/;"	f	struct:ValueDeclear	access:public	signature:()
ValueDeclear::ValueDeclear	test/output/tinyg.cpp	/^	ValueDeclear()$/;"	f	struct:ValueDeclear	access:public	signature:()
ValueDeclear::sid	test/output/gen.cpp	/^	enum{ sid = 1011 };$/;"	e	enum:ValueDeclear::__anon18	file:
ValueDeclear::sid	test/output/tinyg.cpp	/^	enum{ sid = 2 };$/;"	e	enum:ValueDeclear::__anon37	file:
WhitespaceToTag	third_party/xml/Markup.cpp	/^	int WhitespaceToTag( int n ) { m_nNext = n; if (FindAny()&&m_pDocText[m_nNext]!='<') { m_nNext=n; m_nR=n-1; } return m_nNext; };$/;"	f	struct:TokenPos	access:public	signature:( int n )
WriteTextFile	third_party/xml/Markup.cpp	/^bool CMarkup::WriteTextFile( MCD_CSTR_FILENAME szFileName, const MCD_STR& strDoc, MCD_STR* pstrResult, int* pnDocFlags, MCD_STR* pstrEncoding )$/;"	f	class:CMarkup	signature:( MCD_CSTR_FILENAME szFileName, const MCD_STR& strDoc, MCD_STR* pstrResult, int* pnDocFlags, MCD_STR* pstrEncoding )
WriteTextFile	third_party/xml/Markup.h	/^	static bool WriteTextFile( MCD_CSTR_FILENAME szFileName, const MCD_STR& strDoc, MCD_STR* pstrResult=NULL, int* pnDocFlags=NULL, MCD_STR* pstrEncoding=NULL );$/;"	p	class:CMarkup	access:public	signature:( MCD_CSTR_FILENAME szFileName, const MCD_STR& strDoc, MCD_STR* pstrResult=NULL, int* pnDocFlags=NULL, MCD_STR* pstrEncoding=NULL )
XML_NAMESPACE_BEGIN	third_party/xml/Markup.h	12;"	d
XML_NAMESPACE_END	third_party/xml/Markup.h	13;"	d
Yes	include/functionalX.h	/^	Yes = 1,$/;"	e	enum:TriSate
_ARRAYX_H_HUXL_	include/arrayX.h	7;"	d
_AUTO_MACHINE_H_	syntax/automachine.h	5;"	d
_BASIC_GRAMMARS_H_SC_	galgorithm/basicalgorithms.h	5;"	d
_BASIC_GRAMMARS_H_SC_	galgorithm/firstfollow.h	6;"	d
_BASIC_TYPES_H_SC_	include/basic_types.h	5;"	d
_BUCKETHASH_H_HUXL_	include/buckethash.h	5;"	d
_Base	include/functionalX.h	/^	typedef std::pair<_Iter, _Iter> _Base;$/;"	t	struct:range_t	access:public
_Base	include/iteratorX.h	/^	typedef std::iterator<std::random_access_iterator_tag, _Tx> _Base;$/;"	t	struct:array_iterator	access:public
_BaseType	include/iteratorX.h	/^	typedef std::pair<_Iter1, _Iter2> _BaseType;$/;"	t	struct:iterator_pair	access:public
_CATCH_IO_END	compiler/extract.cpp	17;"	d	file:
_COMPILER_H_SC_	compiler/compiler.h	5;"	d
_Cmp	syntax/symbol.h	/^	_CmpFunc _Cmp;$/;"	m	struct:symbolname_Cmp	access:public
_Ctptr	include/stringX.h	/^	typedef typename _Mybase::const_pointer _Ctptr;$/;"	t	class:xstring_basic	access:public
_DFA_TO_AUTOMACHINE_H_SC_	galgorithm/dfa2machine.h	5;"	d
_Diff_GT_0	include/iteratorX.h	/^	typedef mpl::fire_error<_ext::Diff_Mast_Grate_Than_Zero<_Diff> > _Diff_GT_0;$/;"	t	struct:array_iterator	access:public
_Dift	include/stringX.h	/^	typedef typename _Mybase::difference_type _Dift;$/;"	t	class:xstring_basic	access:public
_ECLOSURE_H_SC_	galgorithm/eclosures.h	5;"	d
_EXTRACT_H_SC_	compiler/extract.h	5;"	d
_FUNCTIONAL_H_HUXL_	include/functionalX.h	5;"	d
_FunType	include/functionalX.h	/^	typedef _Result (*_FunType)(_Arg);$/;"	t	struct:unary_function_adptor_t	access:public
_FunType	include/functionalX.h	/^	typedef _Result (*_FunType)(_Arg1, _Arg2);$/;"	t	struct:binary_function_adptor_t	access:public
_FunType	include/functionalX.h	/^	typedef _Result (*_FunType)(_Arg1, _Arg2, _Arg3);$/;"	t	struct:triple_function_adptor_t	access:public
_GENSYNTAX_H_SC_	makecompiler/gensyntax.h	5;"	d
_GRAMMAR_ALGORITHM_H_SC_	galgorithm/grammaralgorithm.h	5;"	d
_GRAMMAR_H_SC_	syntax/grammar.h	5;"	d
_GRAMMAR_IO_H_TEST_	test/gio.h	5;"	d
_INSTRUCTION_H_SC_	compiler/instruction.h	5;"	d
_IStream	include/stringX.h	/^	typedef std::basic_istringstream<_Elem, _Traits, _Ax> _IStream;$/;"	t	class:xstring_basic	access:public
_ITERATORX_H_HUXL_	include/iteratorX.h	5;"	d
_L	syntax/automachine.h	/^	_CmpFunc _L;$/;"	m	struct:intpair_cmp	access:public
_LALR1_MACHINE_H_	compiler/lalr1machine.h	5;"	d
_LALR1_MACHINE_H_SC_	syntax/lrmachine.h	5;"	d
_LOADER_H_SC_	syntax/loader.h	5;"	d
_LRANALYSE_H_SC_	galgorithm/lranalyse.h	5;"	d
_MACROS_H_HUXL_	include/macros.h	5;"	d
_MARKUP_H_INCLUDED_	third_party/xml/Markup.h	10;"	d
_MARKUP_UTILS_H_SC_	include/markuputils.h	5;"	d
_MATHX_H_HUXL_	include/mathX.h	5;"	d
_MEMORYX_H_HUXL_	include/memoryX.h	5;"	d
_MPLX_H_HUXL_	include/mplX.h	5;"	d
_Mybase	include/functionalX.h	/^	typedef std::pair<_Iter, _Iter> _Mybase;$/;"	t	struct:range_t	access:public
_Mybase	include/stringX.h	/^	typedef std::basic_string<_Elem, _Traits, _Ax> _Mybase;$/;"	t	class:xstring_basic	access:public
_Myios	compiler/extract.cpp	/^	typedef std::istream _Myios;$/;"	t	class:iwordstream	file:	access:private
_Myt	include/arrayX.h	/^	typedef SmartArray<_Ty, _Length> _Myt;$/;"	t	struct:SmartArray	access:public
_Myt	include/arrayX.h	/^	typedef SmartMatrix<_Ty, _Row, _Col> _Myt;$/;"	t	struct:SmartMatrix	access:public
_Myt	include/arrayX.h	/^	typedef smart_vector<_Tx> _Myt;$/;"	t	class:smart_vector	access:public
_Myt	include/functionalX.h	/^	typedef composite_function2_t<_Fx, _Fy, _Fz> _Myt;$/;"	t	struct:composite_function2_t	access:public
_Myt	include/functionalX.h	/^	typedef composite_function_t<_Fx, _Fy> _Myt;$/;"	t	struct:composite_function_t	access:public
_Myt	include/functionalX.h	/^	typedef mem_value_t<_Tc, _Ty> _Myt;$/;"	t	struct:mem_value_t	access:public
_Myt	include/functionalX.h	/^	typedef triple<_Ty1, _Ty2, _Ty3> _Myt;$/;"	t	struct:triple	access:public
_Myt	include/iteratorX.h	/^	typedef array_iterator<_Tx> _Myt;$/;"	t	struct:array_iterator	access:public
_Myt	include/iteratorX.h	/^	typedef iterator_pair<_Iter1, _Iter2> _Myt;$/;"	t	struct:iterator_pair	access:public
_Myt	include/stringX.h	/^	typedef xstring_basic<_Elem, _Traits, _Ax> _Myt;$/;"	t	class:xstring_basic	access:public
_NFA_TO_DFA_H_SC_	galgorithm/nfa2dfa.h	5;"	d
_OStream	include/stringX.h	/^	typedef std::basic_ostringstream<_Elem, _Traits, _Ax> _OStream;$/;"	t	class:xstring_basic	access:public
_PRODUCTION_H_SC_	syntax/production.h	5;"	d
_REGEX2NFA_H_SC_	galgorithm/regex2nfa.h	5;"	d
_Reft	include/stringX.h	/^	typedef typename _Mybase::reference _Reft;$/;"	t	class:xstring_basic	access:public
_SCERROR_H_SC_	include/scerror.h	5;"	d
_SHARE_PTR_H_HUXL_	include/share_ptr.h	5;"	d
_SINGLETON_H_HUXL_	include/singleton.h	5;"	d
_STATE_MACHINE_H_SC_	syntax/statemachine.h	5;"	d
_STREAMX_H_HUXL_	include/streamX.h	5;"	d
_STRINGXF_H_HUXL_	include/stringXF.h	5;"	d
_STRINGX_H_HUXL_	include/stringX.h	5;"	d
_SYMBOL_H_SC_	syntax/symbol.h	5;"	d
_Str	include/basic_types.h	/^typedef tstring _Str;$/;"	t
_Str	syntax/word.h	/^	typedef sc::tstring _Str;$/;"	t	struct:word	access:public
_Stream	include/stringX.h	/^	typedef std::basic_stringstream<_Elem, _Traits, _Ax> _Stream;$/;"	t	class:xstring_basic	access:public
_TRY_IO_BEGIN	compiler/extract.cpp	13;"	d	file:
_TYPES_H_SC_	compiler/type.h	5;"	d
_Tptr	include/stringX.h	/^	typedef typename _Mybase::pointer _Tptr;$/;"	t	class:xstring_basic	access:public
_UNITTEST_H_HUXL_	test/unittest.h	5;"	d
_VALUES_H_SC_	compiler/value.h	5;"	d
_VHELP_H_TEST_	test/vhelp.h	5;"	d
_WORD_H_SC_	syntax/word.h	5;"	d
_XREGEX_H_HUXL_	third_party/regex/xregex.h	4;"	d
_before	include/iteratorX.h	/^	difference_type _before;$/;"	m	struct:array_iterator	access:public
_buf	include/arrayX.h	/^	_Ty _buf[_Length];$/;"	m	struct:SmartArray	access:private
_follow	include/iteratorX.h	/^	difference_type _follow;$/;"	m	struct:array_iterator	access:public
_fseeki64	third_party/xml/Markup.h	/^extern "C" int __cdecl _fseeki64(FILE *, __int64, int);$/;"	p	signature:(FILE *, __int64, int)
_fun	include/stringXF.h	/^	_CmpFunc _fun;$/;"	m	struct:stringcmp	access:public
_func1	include/functionalX.h	/^	_Func1 _func1;$/;"	m	class:apply	access:private
_func2	include/functionalX.h	/^	_Func2 _func2;$/;"	m	class:apply	access:private
_fx	include/functionalX.h	/^	_Fx _fx;$/;"	m	struct:composite_function2_t	access:protected
_fx	include/functionalX.h	/^	_Fx _fx;$/;"	m	struct:composite_function_t	access:protected
_fy	include/functionalX.h	/^	_Fy _fy;$/;"	m	struct:composite_function2_t	access:protected
_fy	include/functionalX.h	/^	_Fy _fy;$/;"	m	struct:composite_function_t	access:protected
_fz	include/functionalX.h	/^	_Fz _fz;$/;"	m	struct:composite_function2_t	access:protected
_maxValue	include/functionalX.h	/^	const _Arg& _maxValue;$/;"	m	class:is_between_t	access:private
_minValue	include/functionalX.h	/^	const _Arg& _minValue;$/;"	m	class:is_between_t	access:private
_op	include/functionalX.h	/^	_Oper _op;$/;"	m	class:apply	access:private
_pFun	include/functionalX.h	/^	_FunType _pFun;$/;"	m	struct:binary_function_adptor_t	access:private
_pFun	include/functionalX.h	/^	_FunType _pFun;$/;"	m	struct:triple_function_adptor_t	access:private
_pFun	include/functionalX.h	/^	_FunType _pFun;$/;"	m	struct:unary_function_adptor_t	access:private
_p_value	include/functionalX.h	/^	mem_value_type _p_value;$/;"	m	struct:mem_value_t	access:protected
_ptr	include/iteratorX.h	/^	_Tx* _ptr;$/;"	m	struct:array_iterator	access:public
_ref_obj	include/functionalX.h	/^	T& _ref_obj;$/;"	m	class:ref_obj	access:private
_values	include/arrayX.h	/^	_Ty _values[_Row][_Col];$/;"	m	struct:SmartMatrix	access:private
abs	include/mathX.h	/^	static T abs(const T value)$/;"	f	class:math	access:public	signature:(const T value)
accept_state	syntax/lrmachine.h	/^	enum { accept_state = 0}; \/\/ using state 0 as ending state$/;"	e	enum:lrmachine::__anon6
accumulate	include/functionalX.h	/^inline void accumulate(_InIt _First1, _InIt _Last, _InIt _First2, _Ty _Val, _Fn2 _Func)$/;"	f	signature:(_InIt _First1, _InIt _Last, _InIt _First2, _Ty _Val, _Fn2 _Func)
accumulate	include/functionalX.h	/^inline void accumulate(_InIt _First1, _InIt _Last, _InIt _First2, _Ty _Val, _Fn2 _Func, _Op _Opt)$/;"	f	signature:(_InIt _First1, _InIt _Last, _InIt _First2, _Ty _Val, _Fn2 _Func, _Op _Opt)
add	test/input/easy.c	/^int add(int a, int b)$/;"	f	signature:(int a, int b)
add_const	include/mplX.h	/^struct add_const$/;"	s
add_const	include/mplX.h	/^struct add_const<const _T>$/;"	s
add_const::nonconst_type	include/mplX.h	/^	typedef _T nonconst_type;$/;"	t	struct:add_const	access:public
add_const::type	include/mplX.h	/^	typedef const _T type;$/;"	t	struct:add_const	access:public
address	compiler/value.h	/^	uint32 address;$/;"	m	struct:value	access:public
anTable	third_party/xml/Markup.cpp	/^	int anTable[LS_TABLESIZE];$/;"	m	struct:ElemStack	file:	access:protected
analysestack	syntax/lrmachine.h	/^	typedef std::stack<stackitem> analysestack;$/;"	t	class:lrmachine	access:private
anychar	syntax/automachine.h	/^		enum { anychar, special, exclude };$/;"	e	enum:automachine::sheetrow::__anon5
apply	include/functionalX.h	/^	apply(){}$/;"	f	class:apply	access:public	signature:()
apply	include/functionalX.h	/^	apply(const _Oper& op, const _Func1& func1, const _Func2& func2)$/;"	f	class:apply	access:public	signature:(const _Oper& op, const _Func1& func1, const _Func2& func2)
apply	include/functionalX.h	/^class apply$/;"	c
apply::_func1	include/functionalX.h	/^	_Func1 _func1;$/;"	m	class:apply	access:private
apply::_func2	include/functionalX.h	/^	_Func2 _func2;$/;"	m	class:apply	access:private
apply::_op	include/functionalX.h	/^	_Oper _op;$/;"	m	class:apply	access:private
apply::apply	include/functionalX.h	/^	apply(){}$/;"	f	class:apply	access:public	signature:()
apply::apply	include/functionalX.h	/^	apply(const _Oper& op, const _Func1& func1, const _Func2& func2)$/;"	f	class:apply	access:public	signature:(const _Oper& op, const _Func1& func1, const _Func2& func2)
apply::argument_type	include/functionalX.h	/^	typedef typename _Oper::argument_type argument_type;$/;"	t	class:apply	access:public
apply::operator ()	include/functionalX.h	/^	result_type operator()(const argument_type& arg) const$/;"	f	class:apply	access:public	signature:(const argument_type& arg) const
apply::result_type	include/functionalX.h	/^	typedef typename _Oper::result_type result_type;$/;"	t	class:apply	access:public
argument_type	include/functionalX.h	/^	typedef typename _Fx::argument_type argument_type;$/;"	t	struct:composite_function_t	access:public
argument_type	include/functionalX.h	/^	typedef typename _Oper::argument_type argument_type;$/;"	t	class:apply	access:public
array_begin	include/iteratorX.h	/^array_iterator<_Tx, _Diff> array_begin(_Tx* _Begin_ptr, typename array_iterator<_Tx, _Diff>::difference_type _Length)$/;"	f	signature:(_Tx* _Begin_ptr, typename array_iterator<_Tx, _Diff>::difference_type _Length)
array_end	include/iteratorX.h	/^array_iterator<_Tx, _Diff> array_end(_Tx* _Begin_ptr, typename array_iterator<_Tx, _Diff>::difference_type _Length)$/;"	f	signature:(_Tx* _Begin_ptr, typename array_iterator<_Tx, _Diff>::difference_type _Length)
array_iterator	include/iteratorX.h	/^	array_iterator()$/;"	f	struct:array_iterator	access:public	signature:()
array_iterator	include/iteratorX.h	/^	array_iterator(_Tx* p, distance_type b, distance_type f)$/;"	f	struct:array_iterator	access:public	signature:(_Tx* p, distance_type b, distance_type f)
array_iterator	include/iteratorX.h	/^	array_iterator(_Tx*p, distance_type size)$/;"	f	struct:array_iterator	access:public	signature:(_Tx*p, distance_type size)
array_iterator	include/iteratorX.h	/^	array_iterator(const nonconst_type& aIter)$/;"	f	struct:array_iterator	access:public	signature:(const nonconst_type& aIter)
array_iterator	include/iteratorX.h	/^struct array_iterator : public std::iterator<std::random_access_iterator_tag, _Tx*>$/;"	s	inherits:std::iterator
array_iterator::_Base	include/iteratorX.h	/^	typedef std::iterator<std::random_access_iterator_tag, _Tx> _Base;$/;"	t	struct:array_iterator	access:public
array_iterator::_Diff_GT_0	include/iteratorX.h	/^	typedef mpl::fire_error<_ext::Diff_Mast_Grate_Than_Zero<_Diff> > _Diff_GT_0;$/;"	t	struct:array_iterator	access:public
array_iterator::_Myt	include/iteratorX.h	/^	typedef array_iterator<_Tx> _Myt;$/;"	t	struct:array_iterator	access:public
array_iterator::_before	include/iteratorX.h	/^	difference_type _before;$/;"	m	struct:array_iterator	access:public
array_iterator::_follow	include/iteratorX.h	/^	difference_type _follow;$/;"	m	struct:array_iterator	access:public
array_iterator::_ptr	include/iteratorX.h	/^	_Tx* _ptr;$/;"	m	struct:array_iterator	access:public
array_iterator::array_iterator	include/iteratorX.h	/^	array_iterator()$/;"	f	struct:array_iterator	access:public	signature:()
array_iterator::array_iterator	include/iteratorX.h	/^	array_iterator(_Tx* p, distance_type b, distance_type f)$/;"	f	struct:array_iterator	access:public	signature:(_Tx* p, distance_type b, distance_type f)
array_iterator::array_iterator	include/iteratorX.h	/^	array_iterator(_Tx*p, distance_type size)$/;"	f	struct:array_iterator	access:public	signature:(_Tx*p, distance_type size)
array_iterator::array_iterator	include/iteratorX.h	/^	array_iterator(const nonconst_type& aIter)$/;"	f	struct:array_iterator	access:public	signature:(const nonconst_type& aIter)
array_iterator::assert_invalidate	include/iteratorX.h	/^	array_iterator& assert_invalidate()$/;"	f	struct:array_iterator	access:protected	signature:()
array_iterator::assert_invalidate	include/iteratorX.h	/^	const array_iterator& assert_invalidate() const$/;"	f	struct:array_iterator	access:protected	signature:() const
array_iterator::backward	include/iteratorX.h	/^	static array_iterator& backward(array_iterator& aniterator, distance_type dis = 1)$/;"	f	struct:array_iterator	access:protected	signature:(array_iterator& aniterator, distance_type dis = 1)
array_iterator::const_type	include/iteratorX.h	/^	typedef array_iterator<typename mpl::add_const<_Tx>::type> const_type;$/;"	t	struct:array_iterator	access:public
array_iterator::difference_type	include/iteratorX.h	/^	typedef typename _Base::difference_type difference_type;$/;"	t	struct:array_iterator	access:public
array_iterator::distance_type	include/iteratorX.h	/^	typedef typename _Base::difference_type distance_type;	\/\/ retained$/;"	t	struct:array_iterator	access:public
array_iterator::forward	include/iteratorX.h	/^	static array_iterator& forward(array_iterator& aniterator, distance_type dis = 1)$/;"	f	struct:array_iterator	access:protected	signature:(array_iterator& aniterator, distance_type dis = 1)
array_iterator::get	include/iteratorX.h	/^	_Tx* get() const { return _ptr; }$/;"	f	struct:array_iterator	access:public	signature:() const
array_iterator::iterator_category	include/iteratorX.h	/^	typedef typename _Base::iterator_category iterator_category;$/;"	t	struct:array_iterator	access:public
array_iterator::nonconst_type	include/iteratorX.h	/^	typedef array_iterator<typename mpl::remove_const<_Tx>::type> nonconst_type;$/;"	t	struct:array_iterator	access:public
array_iterator::operator !=	include/iteratorX.h	/^	bool operator != (const _Myt& _Other) const$/;"	f	struct:array_iterator	access:public	signature:(const _Myt& _Other) const
array_iterator::operator *	include/iteratorX.h	/^	reference operator*() const { return *_ptr; }$/;"	f	struct:array_iterator	access:public	signature:() const
array_iterator::operator +	include/iteratorX.h	/^	_Myt operator +(distance_type _Dis) const$/;"	f	struct:array_iterator	access:public	signature:(distance_type _Dis) const
array_iterator::operator +	include/iteratorX.h	/^	friend _Myt operator+ (distance_type _Dis, const _Myt& _Iter)$/;"	f	struct:array_iterator	access:friend	signature:(distance_type _Dis, const _Myt& _Iter)
array_iterator::operator ++	include/iteratorX.h	/^	_Myt operator++(int) { _Myt temp(*this); forward(*this); return temp;}$/;"	f	struct:array_iterator	access:public	signature:(int)
array_iterator::operator ++	include/iteratorX.h	/^	_Myt& operator++() { return forward(*this); }$/;"	f	struct:array_iterator	access:public	signature:()
array_iterator::operator +=	include/iteratorX.h	/^	_Myt& operator +=(distance_type _Dis)$/;"	f	struct:array_iterator	access:public	signature:(distance_type _Dis)
array_iterator::operator -	include/iteratorX.h	/^	_Myt operator -(distance_type _Dis) const$/;"	f	struct:array_iterator	access:public	signature:(distance_type _Dis) const
array_iterator::operator -	include/iteratorX.h	/^	distance_type operator -(const _Myt& _PY) const$/;"	f	struct:array_iterator	access:public	signature:(const _Myt& _PY) const
array_iterator::operator --	include/iteratorX.h	/^	_Myt operator--(int) { _Myt temp(*this); backward(*this); return temp; }$/;"	f	struct:array_iterator	access:public	signature:(int)
array_iterator::operator --	include/iteratorX.h	/^	_Myt& operator--() { return backward(*this); }$/;"	f	struct:array_iterator	access:public	signature:()
array_iterator::operator -=	include/iteratorX.h	/^	_Myt& operator -=(distance_type _Dis)$/;"	f	struct:array_iterator	access:public	signature:(distance_type _Dis)
array_iterator::operator ->	include/iteratorX.h	/^	pointer operator->() const { return _ptr; }$/;"	f	struct:array_iterator	access:public	signature:() const
array_iterator::operator <	include/iteratorX.h	/^	bool operator <(const _Myt& _Other) const$/;"	f	struct:array_iterator	access:public	signature:(const _Myt& _Other) const
array_iterator::operator <=	include/iteratorX.h	/^	bool operator <=(const _Myt& _Other) const$/;"	f	struct:array_iterator	access:public	signature:(const _Myt& _Other) const
array_iterator::operator ==	include/iteratorX.h	/^	bool operator == (const _Myt& _Other) const$/;"	f	struct:array_iterator	access:public	signature:(const _Myt& _Other) const
array_iterator::operator >	include/iteratorX.h	/^	bool operator >(const _Myt& _Other) const$/;"	f	struct:array_iterator	access:public	signature:(const _Myt& _Other) const
array_iterator::operator >=	include/iteratorX.h	/^	bool operator >=(const _Myt& _Other) const$/;"	f	struct:array_iterator	access:public	signature:(const _Myt& _Other) const
array_iterator::operator []	include/iteratorX.h	/^	reference operator[](distance_type _Dis) { return _ptr[_Dis]; }$/;"	f	struct:array_iterator	access:public	signature:(distance_type _Dis)
array_iterator::pointer	include/iteratorX.h	/^	typedef typename _Base::pointer pointer;$/;"	t	struct:array_iterator	access:public
array_iterator::reference	include/iteratorX.h	/^	typedef typename _Base::reference reference;$/;"	t	struct:array_iterator	access:public
array_iterator::value_type	include/iteratorX.h	/^	typedef typename _Base::value_type value_type;$/;"	t	struct:array_iterator	access:public
assert_invalidate	include/iteratorX.h	/^	array_iterator& assert_invalidate()$/;"	f	struct:array_iterator	access:protected	signature:()
assert_invalidate	include/iteratorX.h	/^	const array_iterator& assert_invalidate() const$/;"	f	struct:array_iterator	access:protected	signature:() const
assert_validate	include/arrayX.h	/^	void assert_validate() const$/;"	f	class:smart_vector	access:protected	signature:() const
assign_t	include/functionalX.h	/^class assign_t : public std::binary_function<_Arg, _Arg, _Arg>$/;"	c	inherits:std::binary_function
assign_t::operator ()	include/functionalX.h	/^	_Arg& operator()(_Arg& _dstVal, const _Arg& _srcVal) const$/;"	f	class:assign_t	access:public	signature:(_Arg& _dstVal, const _Arg& _srcVal) const
at	include/arrayX.h	/^	const_reference at(size_type idx) const$/;"	f	class:smart_vector	access:public	signature:(size_type idx) const
at	include/arrayX.h	/^	const_reference at(size_type idx) const$/;"	f	struct:SmartArray	access:public	signature:(size_type idx) const
at	include/arrayX.h	/^	reference at(size_type idx)$/;"	f	class:smart_vector	access:public	signature:(size_type idx)
at	include/arrayX.h	/^	reference at(size_type idx)$/;"	f	struct:SmartArray	access:public	signature:(size_type idx)
atan	include/mathX.h	/^	static double atan(const T y, const T x)$/;"	f	class:math	access:public	signature:(const T y, const T x)
attach	include/arrayX.h	/^	smart_vector& attach(pointer _Ptr, size_type _N, bool _AutoDelete = true)$/;"	f	class:smart_vector	access:public	signature:(pointer _Ptr, size_type _N, bool _AutoDelete = true)
attach	include/arrayX.h	/^	static SmartArray<const value_type, _Length>* attach(const value_type anArray[_Length])$/;"	f	struct:SmartArray	access:public	signature:(const value_type anArray[_Length])
attach	include/arrayX.h	/^	static _Myt* attach(value_type anArray[_Length])$/;"	f	struct:SmartArray	access:public	signature:(value_type anArray[_Length])
automachine	syntax/automachine.cpp	/^automachine::automachine()$/;"	f	class:automachine	signature:()
automachine	syntax/automachine.cpp	/^automachine::automachine(const shared_sheet& asheet)$/;"	f	class:automachine	signature:(const shared_sheet& asheet)
automachine	syntax/automachine.h	/^	automachine();$/;"	p	class:automachine	access:public	signature:()
automachine	syntax/automachine.h	/^	automachine(const shared_sheet& asheet);$/;"	p	class:automachine	access:public	signature:(const shared_sheet& asheet)
automachine	syntax/automachine.h	/^class automachine$/;"	c
automachine::MEMBER_VARIABLE_GET_SET	syntax/automachine.h	/^	MEMBER_VARIABLE_GET_SET(int, sstate, sstate_);$/;"	p	class:automachine	access:public	signature:(int, sstate, sstate_)
automachine::MEMBER_VARIABLE_GET_SET	syntax/automachine.h	/^	MEMBER_VARIABLE_GET_SET(sparsesheet, sheet, *sheet_);$/;"	p	class:automachine	access:public	signature:(sparsesheet, sheet, *sheet_)
automachine::automachine	syntax/automachine.cpp	/^automachine::automachine()$/;"	f	class:automachine	signature:()
automachine::automachine	syntax/automachine.cpp	/^automachine::automachine(const shared_sheet& asheet)$/;"	f	class:automachine	signature:(const shared_sheet& asheet)
automachine::automachine	syntax/automachine.h	/^	automachine();$/;"	p	class:automachine	access:public	signature:()
automachine::automachine	syntax/automachine.h	/^	automachine(const shared_sheet& asheet);$/;"	p	class:automachine	access:public	signature:(const shared_sheet& asheet)
automachine::cstate_	syntax/automachine.h	/^	int cstate_; \/\/ current state$/;"	m	class:automachine	access:protected
automachine::eta	syntax/automachine.cpp	/^bool automachine::eta(int32 meta)$/;"	f	class:automachine	signature:(int32 meta)
automachine::eta	syntax/automachine.h	/^	virtual bool eta(int meta);$/;"	p	class:automachine	access:public	signature:(int meta)
automachine::gotoitem	syntax/automachine.h	/^	typedef std::pair<int, int> gotoitem;$/;"	t	class:automachine	access:public
automachine::init	syntax/automachine.cpp	/^void automachine::init()$/;"	f	class:automachine	signature:()
automachine::init	syntax/automachine.h	/^	virtual void init();$/;"	p	class:automachine	access:public	signature:()
automachine::isaccepted	syntax/automachine.h	/^	bool isaccepted() const$/;"	f	class:automachine	access:public	signature:() const
automachine::shared_sheet	syntax/automachine.h	/^	typedef boost::shared_ptr<sparsesheet> shared_sheet;$/;"	t	class:automachine	access:public
automachine::sheet_	syntax/automachine.h	/^	shared_sheet sheet_;$/;"	m	class:automachine	access:private
automachine::sheetrow	syntax/automachine.h	/^	class sheetrow : public kog::smart_vector<gotoitem>$/;"	c	class:automachine	inherits:kog::smart_vector	access:public
automachine::sheetrow::anychar	syntax/automachine.h	/^		enum { anychar, special, exclude };$/;"	e	enum:automachine::sheetrow::__anon5
automachine::sheetrow::eattype_	syntax/automachine.h	/^		int32 eattype_;$/;"	m	class:automachine::sheetrow	access:private
automachine::sheetrow::endings	syntax/automachine.h	/^		int32 endings() const {return isendings_;}$/;"	f	class:automachine::sheetrow	access:public	signature:() const
automachine::sheetrow::endings	syntax/automachine.h	/^		void endings(int32 t) { isendings_ = t; }$/;"	f	class:automachine::sheetrow	access:public	signature:(int32 t)
automachine::sheetrow::exclude	syntax/automachine.h	/^		enum { anychar, special, exclude };$/;"	e	enum:automachine::sheetrow::__anon5
automachine::sheetrow::isendings_	syntax/automachine.h	/^		int32 isendings_;$/;"	m	class:automachine::sheetrow	access:private
automachine::sheetrow::more	syntax/automachine.h	/^		void more(void* m) { more_ = m;}$/;"	f	class:automachine::sheetrow	access:public	signature:(void* m)
automachine::sheetrow::more	syntax/automachine.h	/^		void* more() const { return more_; }$/;"	f	class:automachine::sheetrow	access:public	signature:() const
automachine::sheetrow::more_	syntax/automachine.h	/^		void* more_;$/;"	m	class:automachine::sheetrow	access:private
automachine::sheetrow::sheetrow	syntax/automachine.h	/^		sheetrow()$/;"	f	class:automachine::sheetrow	access:public	signature:()
automachine::sheetrow::special	syntax/automachine.h	/^		enum { anychar, special, exclude };$/;"	e	enum:automachine::sheetrow::__anon5
automachine::sheetrow::type	syntax/automachine.h	/^		int32 type() const { return eattype_; }$/;"	f	class:automachine::sheetrow	access:public	signature:() const
automachine::sheetrow::type	syntax/automachine.h	/^		void type(int32 t) { eattype_ = t; }$/;"	f	class:automachine::sheetrow	access:public	signature:(int32 t)
automachine::sheetrow::v	syntax/automachine.h	/^		typedef kog::smart_vector<gotoitem> v;$/;"	t	class:automachine::sheetrow	access:private
automachine::sparsesheet	syntax/automachine.h	/^	typedef kog::smart_vector<sheetrow> sparsesheet;$/;"	t	class:automachine	access:public
automachine::sstate_	syntax/automachine.h	/^	int sstate_; \/\/ start state$/;"	m	class:automachine	access:protected
automachine::swap	syntax/automachine.h	/^	void swap(automachine& other)$/;"	f	class:automachine	access:public	signature:(automachine& other)
automachine::tstring	syntax/automachine.h	/^	typedef sc::tstring tstring;$/;"	t	class:automachine	access:public
automachine::~automachine	syntax/automachine.cpp	/^automachine::~automachine()$/;"	f	class:automachine	signature:()
automachine::~automachine	syntax/automachine.h	/^	virtual ~automachine();$/;"	p	class:automachine	access:public	signature:()
bReader	third_party/xml/Markup.cpp	/^	bool bReader;$/;"	m	struct:PathPos	file:	access:private
back	include/arrayX.h	/^	const_reference back() const { return _buf[_Length - 1]; }$/;"	f	struct:SmartArray	access:public	signature:() const
back	include/arrayX.h	/^	const_reference back() const$/;"	f	class:smart_vector	access:public	signature:() const
back	include/arrayX.h	/^	reference back() { return _buf[_Length - 1]; }$/;"	f	struct:SmartArray	access:public	signature:()
back	include/arrayX.h	/^	reference back()$/;"	f	class:smart_vector	access:public	signature:()
backward	include/iteratorX.h	/^	_Myt& backward()$/;"	f	struct:iterator_pair	access:protected	signature:()
backward	include/iteratorX.h	/^	static array_iterator& backward(array_iterator& aniterator, distance_type dis = 1)$/;"	f	struct:array_iterator	access:protected	signature:(array_iterator& aniterator, distance_type dis = 1)
base	include/stringX.h	/^	_Mybase& base()$/;"	f	class:xstring_basic	access:public	signature:()
base	include/stringX.h	/^	const _Mybase& base() const$/;"	f	class:xstring_basic	access:public	signature:() const
base	tmp/protected.cpp	/^class base$/;"	c	file:
base::f	tmp/protected.cpp	/^	void f()$/;"	f	class:base	access:public	signature:()
basicalg_test	test/basicalgorithmtest.cpp	/^NEW_UNITTEST(basicalg_test);$/;"	v
basicalg_test	test/basicalgorithmtest.cpp	/^class basicalg_test : public sc::unittest$/;"	c	file:	inherits:sc::unittest
basicalg_test::fin_	test/basicalgorithmtest.cpp	/^	std::string fin_;$/;"	m	class:basicalg_test	file:	access:private
basicalg_test::fout_	test/basicalgorithmtest.cpp	/^	std::string fout_;$/;"	m	class:basicalg_test	file:	access:private
basicalg_test::init	test/basicalgorithmtest.cpp	/^	\/* overwrite *\/ virtual void init(int argc, const char* argv[])$/;"	f	class:basicalg_test	file:	access:private	signature:(int argc, const char* argv[])
basicalg_test::run_test	test/basicalgorithmtest.cpp	/^	\/* overwrite *\/ virtual void run_test()$/;"	f	class:basicalg_test	file:	access:private	signature:()
basicalg_test::test_grammar	test/basicalgorithmtest.cpp	/^	void test_grammar(grammar& gin)$/;"	f	class:basicalg_test	file:	access:private	signature:(grammar& gin)
begin	include/arrayX.h	/^	const_iterator begin() const { return const_iterator(_buf, _Length); }$/;"	f	struct:SmartArray	access:public	signature:() const
begin	include/arrayX.h	/^	const_iterator begin() const { return const_iterator(_values[0], Length); }$/;"	f	struct:SmartMatrix	access:public	signature:() const
begin	include/arrayX.h	/^	const_iterator begin() const { return const_iterator(buf_.values, buf_.count); }$/;"	f	class:smart_vector	access:public	signature:() const
begin	include/arrayX.h	/^	iterator begin() { return iterator(_buf, _Length); }$/;"	f	struct:SmartArray	access:public	signature:()
begin	include/arrayX.h	/^	iterator begin() { return iterator(_values[0], Length); }$/;"	f	struct:SmartMatrix	access:public	signature:()
begin	include/arrayX.h	/^	iterator begin() { return iterator(buf_.values, buf_.count); }$/;"	f	class:smart_vector	access:public	signature:()
begin	include/functionalX.h	/^	iterator begin() const$/;"	f	struct:range_t	access:public	signature:() const
binary	include/functionalX.h	/^struct binary$/;"	s
binary	include/functionalX.h	/^struct binary<0>$/;"	s
binary::value	include/functionalX.h	/^	const static unsigned int value = 0;$/;"	m	struct:binary	access:public
binary::value	include/functionalX.h	/^	const static unsigned int value = binary<_BinaryValue \/ 10>::value * 2 + _BinaryValue % 10;$/;"	m	struct:binary	access:public
binary_function_adptor	include/functionalX.h	/^inline binary_function_adptor_t<_Arg1, _Arg2, _Result> binary_function_adptor(_Result (*_Func)(_Arg1, _Arg2))$/;"	f	signature:(_Result (_Func)_Arg1, _Arg2))
binary_function_adptor_t	include/functionalX.h	/^	binary_function_adptor_t(_FunType pfun)$/;"	f	struct:binary_function_adptor_t	access:public	signature:(_FunType pfun)
binary_function_adptor_t	include/functionalX.h	/^struct binary_function_adptor_t : public std::binary_function<_Arg1, _Arg2, _Result>$/;"	s	inherits:std::binary_function
binary_function_adptor_t::_FunType	include/functionalX.h	/^	typedef _Result (*_FunType)(_Arg1, _Arg2);$/;"	t	struct:binary_function_adptor_t	access:public
binary_function_adptor_t::_pFun	include/functionalX.h	/^	_FunType _pFun;$/;"	m	struct:binary_function_adptor_t	access:private
binary_function_adptor_t::binary_function_adptor_t	include/functionalX.h	/^	binary_function_adptor_t(_FunType pfun)$/;"	f	struct:binary_function_adptor_t	access:public	signature:(_FunType pfun)
binary_function_adptor_t::operator ()	include/functionalX.h	/^	_Result operator()(_Arg1 arg1, _Arg2 arg2) const$/;"	f	struct:binary_function_adptor_t	access:public	signature:(_Arg1 arg1, _Arg2 arg2) const
block	include/arrayX.h	/^		block(pointer ptr = NULL, size_type c = 0, bool d = true)$/;"	f	struct:smart_vector::block	access:public	signature:(pointer ptr = NULL, size_type c = 0, bool d = true)
block	include/arrayX.h	/^	struct block$/;"	s	class:smart_vector	access:protected
brace_stage	galgorithm/regex2nfa.cpp	/^	int brace_stage(int L, char rc\/*, int& end*\/)$/;"	f	struct:parsecontent	access:public	signature:(int L, char rc )
brace_stage	tmp/back/regex2nfa.cpp	/^	int brace_stage(int L, char rc\/*, int& end*\/)$/;"	f	struct:parsecontent	access:public	signature:(int L, char rc )
bucket	include/buckethash.h	/^struct bucket : public std::list<_T>$/;"	s	inherits:std::list
buckethash	include/buckethash.h	/^	buckethash(std::size_t _MaxLength)$/;"	f	class:buckethash	access:public	signature:(std::size_t _MaxLength)
buckethash	include/buckethash.h	/^class buckethash$/;"	c
buckethash::buckethash	include/buckethash.h	/^	buckethash(std::size_t _MaxLength)$/;"	f	class:buckethash	access:public	signature:(std::size_t _MaxLength)
buckethash::buckets_	include/buckethash.h	/^	kog::smart_vector<bucket<std::pair<key, value> > > buckets_;$/;"	m	class:buckethash	access:private
buckethash::key	include/buckethash.h	/^	typedef typename _K key;$/;"	t	class:buckethash	access:public
buckethash::operator []	include/buckethash.h	/^	value& operator[](const key& k)$/;"	f	class:buckethash	access:public	signature:(const key& k)
buckethash::value	include/buckethash.h	/^	typedef typename _V value;$/;"	t	class:buckethash	access:public
buckethash::value_reference	include/buckethash.h	/^	typedef typename value& value_reference;$/;"	t	class:buckethash	access:public
buckets_	include/buckethash.h	/^	kog::smart_vector<bucket<std::pair<key, value> > > buckets_;$/;"	m	class:buckethash	access:private
buf	galgorithm/regex2nfa.cpp	/^	std::deque<int> buf;$/;"	m	struct:parsecontent	file:	access:public
buf	tmp/back/regex2nfa.cpp	/^	std::deque<int> buf;$/;"	m	struct:parsecontent	file:	access:public
buf_	include/arrayX.h	/^	block buf_;$/;"	m	class:smart_vector	access:private
byte	include/basic_types.h	/^typedef uchar byte;$/;"	t
calculateValue	include/mathX.h	/^		static T calculateValue(const T* xBegin, const T* yBegin, const size_t nSize, int index, const T& val)$/;"	f	class:math::interpolate	access:public	signature:(const T* xBegin, const T* yBegin, const size_t nSize, int index, const T& val)
char_type	third_party/regex/xregex.h	/^	typedef char char_type;$/;"	t	class:stringX::xregex	access:public
choos_t	include/mplX.h	/^struct choos_t {};$/;"	s
choos_t	include/mplX.h	/^struct choos_t<false, _TrueType, _FalseType>$/;"	s
choos_t	include/mplX.h	/^struct choos_t<true, _TrueType, _FalseType>$/;"	s
choos_t::type	include/mplX.h	/^	typedef _FalseType type;$/;"	t	struct:choos_t	access:public
choos_t::type	include/mplX.h	/^	typedef _TrueType type;$/;"	t	struct:choos_t	access:public
class_type	include/functionalX.h	/^	typedef _Tc class_type;$/;"	t	struct:mem_value_t	access:public
class_type	include/mplX.h	/^	typedef _Tc class_type;$/;"	t	struct:parse_class_value_type	access:public
class_type	include/mplX.h	/^	typedef _Tx class_type;$/;"	t	struct:parse_class_value_type	access:public
closure	galgorithm/eclosures.h	/^	typedef kog::smart_vector<int32> closure;$/;"	t	class:eclosure	access:public
closure_array	galgorithm/eclosures.h	/^	typedef kog::smart_vector<closure> closure_array;$/;"	t	class:eclosure	access:public
cnode_	include/markuputils.h	/^	node cnode_;$/;"	m	class:ifile	access:private
col	include/arrayX.h	/^	size_t col() const { return _Col; }$/;"	f	struct:SmartMatrix	access:public	signature:() const
compile::doc::streamsplit::streamsplit	compiler/extract.cpp	/^compile::doc::streamsplit::streamsplit()$/;"	f	class:compile::doc::streamsplit	signature:()
compile::doc::streamsplit::~streamsplit	compiler/extract.cpp	/^compile::doc::streamsplit::~streamsplit()$/;"	f	class:compile::doc::streamsplit	signature:()
compiler	compiler/compiler.h	/^class compiler : public kog::singleton<compiler>$/;"	c	inherits:kog::singleton
compiler::get_all_machines	compiler/compiler.cpp	/^int compiler::get_all_machines(std::list<state_machine*>& mlist)$/;"	f	class:compiler	signature:(std::list<state_machine*>& mlist)
compiler::get_all_machines	compiler/compiler.h	/^	static int get_all_machines(std::list<state_machine*>& mlist);$/;"	p	class:compiler	access:public	signature:(std::list<state_machine*>& mlist)
compiler::get_number_machine	compiler/compiler.cpp	/^state_machine compiler::get_number_machine()$/;"	f	class:compiler	signature:()
compiler::get_number_machine	compiler/compiler.h	/^	static state_machine get_number_machine();$/;"	p	class:compiler	access:public	signature:()
compiler::get_string_machine	compiler/compiler.cpp	/^state_machine compiler::get_string_machine()$/;"	f	class:compiler	signature:()
compiler::get_string_machine	compiler/compiler.h	/^	static state_machine get_string_machine();$/;"	p	class:compiler	access:public	signature:()
compiler::get_symbol_machine	compiler/compiler.cpp	/^state_machine compiler::get_symbol_machine()$/;"	f	class:compiler	signature:()
compiler::get_symbol_machine	compiler/compiler.h	/^	static state_machine get_symbol_machine();$/;"	p	class:compiler	access:public	signature:()
compiler::initmachines	compiler/compiler.cpp	/^void compiler::initmachines()$/;"	f	class:compiler	signature:()
compiler::initmachines	compiler/compiler.h	/^	void initmachines();$/;"	p	class:compiler	access:public	signature:()
compiler::is_separator	compiler/compiler.cpp	/^bool compiler::is_separator(int32 elem)$/;"	f	class:compiler	signature:(int32 elem)
compiler::is_separator	compiler/compiler.h	/^	static bool is_separator(sc::int32 elem);$/;"	p	class:compiler	access:public	signature:(sc::int32 elem)
compiler::machines	compiler/compiler.h	/^	std::map<std::string, state_machine> machines;$/;"	m	class:compiler	access:private
compiler::printablechars	compiler/compiler.h	/^	kog::smart_vector<sc::int32> printablechars;$/;"	m	class:compiler	access:private
compiler::separators	compiler/compiler.h	/^	kog::smart_vector<sc::int32> separators;$/;"	m	class:compiler	access:private
compiler::state_machine	compiler/compiler.h	/^	typedef compile::state_machine state_machine;$/;"	t	class:compiler	access:public
composite_function	include/functionalX.h	/^composite_function2_t<_Fx, _Fy, _Fz> composite_function(const _Fx& fx, const _Fy& fy, const _Fz& fz)$/;"	f	signature:(const _Fx& fx, const _Fy& fy, const _Fz& fz)
composite_function	include/functionalX.h	/^composite_function_t<_Fx, _Fy> composite_function(const _Fx& fx, const _Fy& fy)$/;"	f	signature:(const _Fx& fx, const _Fy& fy)
composite_function2_t	include/functionalX.h	/^	composite_function2_t() {}$/;"	f	struct:composite_function2_t	access:public	signature:()
composite_function2_t	include/functionalX.h	/^	composite_function2_t(const _Fx& fx, const _Fy& fy, const _Fz& fz)$/;"	f	struct:composite_function2_t	access:public	signature:(const _Fx& fx, const _Fy& fy, const _Fz& fz)
composite_function2_t	include/functionalX.h	/^struct composite_function2_t :$/;"	s	inherits:std::binary_function
composite_function2_t::_Myt	include/functionalX.h	/^	typedef composite_function2_t<_Fx, _Fy, _Fz> _Myt;$/;"	t	struct:composite_function2_t	access:public
composite_function2_t::_fx	include/functionalX.h	/^	_Fx _fx;$/;"	m	struct:composite_function2_t	access:protected
composite_function2_t::_fy	include/functionalX.h	/^	_Fy _fy;$/;"	m	struct:composite_function2_t	access:protected
composite_function2_t::_fz	include/functionalX.h	/^	_Fz _fz;$/;"	m	struct:composite_function2_t	access:protected
composite_function2_t::composite_function2_t	include/functionalX.h	/^	composite_function2_t() {}$/;"	f	struct:composite_function2_t	access:public	signature:()
composite_function2_t::composite_function2_t	include/functionalX.h	/^	composite_function2_t(const _Fx& fx, const _Fy& fy, const _Fz& fz)$/;"	f	struct:composite_function2_t	access:public	signature:(const _Fx& fx, const _Fy& fy, const _Fz& fz)
composite_function2_t::first_argument_type	include/functionalX.h	/^	typedef typename _Fx::argument_type first_argument_type;$/;"	t	struct:composite_function2_t	access:public
composite_function2_t::operator ()	include/functionalX.h	/^	result_type operator()(const first_argument_type& _arg1, const second_argument_type& _arg2) const$/;"	f	struct:composite_function2_t	access:public	signature:(const first_argument_type& _arg1, const second_argument_type& _arg2) const
composite_function2_t::operator ()	include/functionalX.h	/^	result_type operator()(first_argument_type& _arg1, second_argument_type& _arg2) const$/;"	f	struct:composite_function2_t	access:public	signature:(first_argument_type& _arg1, second_argument_type& _arg2) const
composite_function2_t::result_type	include/functionalX.h	/^	typedef typename _Fz::result_type result_type;$/;"	t	struct:composite_function2_t	access:public
composite_function2_t::second_argument_type	include/functionalX.h	/^	typedef typename _Fy::argument_type second_argument_type;$/;"	t	struct:composite_function2_t	access:public
composite_function_t	include/functionalX.h	/^	composite_function_t() {}$/;"	f	struct:composite_function_t	access:public	signature:()
composite_function_t	include/functionalX.h	/^	composite_function_t(const _Fx& fx, const _Fy& fy)$/;"	f	struct:composite_function_t	access:public	signature:(const _Fx& fx, const _Fy& fy)
composite_function_t	include/functionalX.h	/^struct composite_function_t :$/;"	s	inherits:std::unary_function
composite_function_t::_Myt	include/functionalX.h	/^	typedef composite_function_t<_Fx, _Fy> _Myt;$/;"	t	struct:composite_function_t	access:public
composite_function_t::_fx	include/functionalX.h	/^	_Fx _fx;$/;"	m	struct:composite_function_t	access:protected
composite_function_t::_fy	include/functionalX.h	/^	_Fy _fy;$/;"	m	struct:composite_function_t	access:protected
composite_function_t::argument_type	include/functionalX.h	/^	typedef typename _Fx::argument_type argument_type;$/;"	t	struct:composite_function_t	access:public
composite_function_t::composite_function_t	include/functionalX.h	/^	composite_function_t() {}$/;"	f	struct:composite_function_t	access:public	signature:()
composite_function_t::composite_function_t	include/functionalX.h	/^	composite_function_t(const _Fx& fx, const _Fy& fy)$/;"	f	struct:composite_function_t	access:public	signature:(const _Fx& fx, const _Fy& fy)
composite_function_t::operator ()	include/functionalX.h	/^	result_type operator()(argument_type& _arg) const$/;"	f	struct:composite_function_t	access:public	signature:(argument_type& _arg) const
composite_function_t::operator ()	include/functionalX.h	/^	result_type operator()(const argument_type& _arg) const$/;"	f	struct:composite_function_t	access:public	signature:(const argument_type& _arg) const
composite_function_t::result_type	include/functionalX.h	/^	typedef typename _Fy::result_type result_type;$/;"	t	struct:composite_function_t	access:public
const_iterator	include/arrayX.h	/^	typedef array_iterator<const value_type> const_iterator;$/;"	t	class:smart_vector	access:public
const_iterator	include/arrayX.h	/^	typedef array_iterator<const value_type> const_iterator;$/;"	t	struct:SmartArray	access:public
const_iterator	include/arrayX.h	/^	typedef array_iterator<const value_type> const_iterator;$/;"	t	struct:SmartMatrix	access:public
const_iterator	include/functionalX.h	/^	typedef typename mpl::add_const<_Iter>::const_value_type const_iterator;$/;"	t	struct:range_t	access:public
const_iterator	include/memoryX.h	/^	typedef array_iterator<const value_type> const_iterator;$/;"	t	struct:memblock	access:public
const_pointer	include/arrayX.h	/^	typedef const _Ty* const_pointer;$/;"	t	struct:SmartArray	access:public
const_pointer	include/arrayX.h	/^	typedef const _Ty* const_pointer;$/;"	t	struct:SmartMatrix	access:public
const_pointer	include/arrayX.h	/^	typedef const value_type* const_pointer;$/;"	t	class:smart_vector	access:public
const_pointer	include/memoryX.h	/^	typedef const value_type* const_pointer;$/;"	t	struct:memblock	access:public
const_pointer	include/stringX.h	/^	typedef _Ctptr const_pointer;$/;"	t	class:xstring_basic	access:public
const_ref_type	include/functionalX.h	/^	typedef const T& const_ref_type;$/;"	t	class:ref_obj	access:public
const_reference	include/arrayX.h	/^	typedef const value_type& const_reference;$/;"	t	class:smart_vector	access:public
const_reference	include/arrayX.h	/^	typedef const value_type& const_reference;$/;"	t	struct:SmartArray	access:public
const_reference	include/arrayX.h	/^	typedef const value_type& const_reference;$/;"	t	struct:SmartMatrix	access:public
const_reference	include/memoryX.h	/^	typedef const value_type& const_reference;$/;"	t	struct:memblock	access:public
const_reference	include/mplX.h	/^struct const_reference$/;"	s
const_reference	include/mplX.h	/^struct const_reference<_Tx&>$/;"	s
const_reference	include/mplX.h	/^struct const_reference<const _Tx&>$/;"	s
const_reference	include/mplX.h	/^struct const_reference<const _Tx>$/;"	s
const_reference	include/stringX.h	/^	typedef typename _Mybase::const_reference const_reference;$/;"	t	class:xstring_basic	access:public
const_reference::type	include/mplX.h	/^	typedef const _Tx& type;$/;"	t	struct:const_reference	access:public
const_reference_type	include/functionalX.h	/^	typedef const _Ty& const_reference_type;$/;"	t	struct:mem_value_t	access:public
const_reverse_iterator	include/arrayX.h	/^	typedef std::reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:smart_vector	access:public
const_reverse_iterator	include/arrayX.h	/^	typedef std::reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	struct:SmartArray	access:public
const_reverse_iterator	include/arrayX.h	/^	typedef std::reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	struct:SmartMatrix	access:public
const_reverse_iterator	include/memoryX.h	/^	typedef std::reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	struct:memblock	access:public
const_type	include/iteratorX.h	/^	typedef array_iterator<typename mpl::add_const<_Tx>::type> const_type;$/;"	t	struct:array_iterator	access:public
const_type	include/mplX.h	/^	typedef const _Tx const_type;$/;"	t	struct:remove_const	access:public
convert	include/stringXF.h	/^		static bool convert(const std::string& _Src, std::string& _Dst)$/;"	f	struct:Format::swcvt	access:public	signature:(const std::string& _Src, std::string& _Dst)
convert	include/stringXF.h	/^		static bool convert(const std::string& _Src, std::wstring& _Dst)$/;"	f	struct:Format::swcvt	access:public	signature:(const std::string& _Src, std::wstring& _Dst)
convert	include/stringXF.h	/^		static bool convert(const std::wstring& _Src, std::string& _Dst)$/;"	f	struct:Format::swcvt	access:public	signature:(const std::wstring& _Src, std::string& _Dst)
convert	include/stringXF.h	/^		static bool convert(const std::wstring& _Src, std::wstring& _Dst)$/;"	f	struct:Format::swcvt	access:public	signature:(const std::wstring& _Src, std::wstring& _Dst)
convert	include/stringXF.h	/^		static std::basic_string<_Dst_Elem> convert(const std::basic_string<_Src_Elem>& _Src)$/;"	f	struct:Format::swcvt	access:public	signature:(const std::basic_string<_Src_Elem>& _Src)
convert	include/stringXF.h	/^		static std::string convert(const std::wstring& _Src)$/;"	f	struct:Format::swcvt	access:public	signature:(const std::wstring& _Src)
convert	include/stringXF.h	/^		static std::wstring convert(const std::string& _Src)$/;"	f	struct:Format::swcvt	access:public	signature:(const std::string& _Src)
convert_error	third_party/regex/xregex.h	/^	convert_error(const _Tx& _Src, const _Ty& _Dst)$/;"	f	class:stringX::convert_error	access:public	signature:(const _Tx& _Src, const _Ty& _Dst)
convert_error	third_party/regex/xregex.h	/^	convert_error(const std::string& error_msg)$/;"	f	class:stringX::convert_error	access:public	signature:(const std::string& error_msg)
convert_error	third_party/regex/xregex.h	/^class convert_error : public std::runtime_error$/;"	c	namespace:stringX	inherits:std::runtime_error
count	include/arrayX.h	/^		size_t count;$/;"	m	struct:smart_vector::block	access:public
cppfile	test/tinygrammartest.cpp	/^	std::string cppfile;$/;"	m	class:simplegrammar_test	file:	access:private
cppfile_	makecompiler/gensyntax.h	/^	tstring cppfile_;$/;"	m	class:syntaxgenerator	access:public
cppstream_	makecompiler/gensyntax.h	/^	std::ostream* cppstream_;$/;"	m	class:syntaxgenerator	access:public
cstate_	compiler/lalr1machine.h	/^	int32 cstate_;$/;"	m	class:lalr1machine	access:private
cstate_	syntax/automachine.h	/^	int cstate_; \/\/ current state$/;"	m	class:automachine	access:protected
dectab	makecompiler/gensyntax.cpp	/^	static tabident dectab;$/;"	m	struct:tabident	file:	access:public
defvalue	compiler/value.h	/^	byte* defvalue;$/;"	m	struct:value	access:public
depointer	include/functionalX.h	/^depointer_t<_Tx> depointer(_Tx*)$/;"	f	signature:(_Tx*)
depointer_t	include/functionalX.h	/^struct depointer_t : public std::unary_function<_Tx*, _Tx>$/;"	s	inherits:std::unary_function
depointer_t	include/functionalX.h	/^struct depointer_t<const _Tx> : public std::unary_function<const _Tx*, const _Tx>$/;"	s	inherits:std::unary_function
depointer_t::operator ()	include/functionalX.h	/^	_Tx& operator()(_Tx* p) const$/;"	f	struct:depointer_t	access:public	signature:(_Tx* p) const
depointer_t::operator ()	include/functionalX.h	/^	const _Tx& operator()(const _Tx* p) const$/;"	f	struct:depointer_t	access:public	signature:(const _Tx* p) const
deqwords	compiler/extract.h	/^	typedef std::deque<word> deqwords;$/;"	t	class:streamsplit	access:public
dereference_t	include/functionalX.h	/^struct dereference_t :$/;"	s	inherits:std::unary_function
dereference_t::operator ()	include/functionalX.h	/^	reference operator()(_InIt _Iter) const$/;"	f	struct:dereference_t	access:public	signature:(_InIt _Iter) const
dereference_t::reference	include/functionalX.h	/^	typedef typename std::iterator_traits<_InIt>::reference reference;$/;"	t	struct:dereference_t	access:public
detach	include/arrayX.h	/^	smart_vector& detach()$/;"	f	class:smart_vector	access:public	signature:()
dfa2machine	galgorithm/dfa2machine.h	/^	dfa2machine(const tinygrammar& gin, automachine& mot)$/;"	f	class:dfa2machine	access:public	signature:(const tinygrammar& gin, automachine& mot)
dfa2machine	galgorithm/dfa2machine.h	/^class dfa2machine : public grammar_algorithm$/;"	c	inherits:grammar_algorithm
dfa2machine::dfa2machine	galgorithm/dfa2machine.h	/^	dfa2machine(const tinygrammar& gin, automachine& mot)$/;"	f	class:dfa2machine	access:public	signature:(const tinygrammar& gin, automachine& mot)
dfa2machine::gin_	galgorithm/dfa2machine.h	/^	const tinygrammar* gin_;$/;"	m	class:dfa2machine	access:private
dfa2machine::invoke	galgorithm/dfa2machine.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:dfa2machine	access:public	signature:()
dfa2machine::make_sure_dfa	galgorithm/dfa2machine.cpp	/^void dfa2machine::make_sure_dfa(const tinygrammar& tig) const$/;"	f	class:dfa2machine	signature:(const tinygrammar& tig) const
dfa2machine::make_sure_dfa	galgorithm/dfa2machine.h	/^	void make_sure_dfa(const tinygrammar& input) const;$/;"	p	class:dfa2machine	access:private	signature:(const tinygrammar& input) const
dfa2machine::mot_	galgorithm/dfa2machine.h	/^	automachine* mot_;$/;"	m	class:dfa2machine	access:private
dfa2machine::operator ()	galgorithm/dfa2machine.cpp	/^void dfa2machine::operator()(const tinygrammar& tig, automachine& mot)$/;"	f	class:dfa2machine	signature:(const tinygrammar& tig, automachine& mot)
dfa2machine::operator ()	galgorithm/dfa2machine.h	/^	void operator()(const tinygrammar& input, automachine& otput);$/;"	p	class:dfa2machine	access:private	signature:(const tinygrammar& input, automachine& otput)
difference_type	include/iteratorX.h	/^	typedef typename _Base::difference_type difference_type;$/;"	t	struct:array_iterator	access:public
difference_type	include/stringX.h	/^	typedef _Dift difference_type;$/;"	t	class:xstring_basic	access:public
distance_type	include/iteratorX.h	/^	typedef typename _Base::difference_type distance_type;	\/\/ retained$/;"	t	struct:array_iterator	access:public
dot	galgorithm/lranalyse.cpp	/^	int32 dot; \/\/ dot position$/;"	m	struct:lrstateitem	file:	access:public
dthenu_	syntax/grammar.h	/^	bool dthenu_; \/\/ symbol need be defined before use?$/;"	m	class:grammar	access:protected
eattype_	syntax/automachine.h	/^		int32 eattype_;$/;"	m	class:automachine::sheetrow	access:private
eclosure	galgorithm/eclosures.h	/^	eclosure(const tinygrammar& tig, closure_array& ecls)$/;"	f	class:eclosure	access:public	signature:(const tinygrammar& tig, closure_array& ecls)
eclosure	galgorithm/eclosures.h	/^class eclosure : public grammar_algorithm$/;"	c	inherits:grammar_algorithm
eclosure::closure	galgorithm/eclosures.h	/^	typedef kog::smart_vector<int32> closure;$/;"	t	class:eclosure	access:public
eclosure::closure_array	galgorithm/eclosures.h	/^	typedef kog::smart_vector<closure> closure_array;$/;"	t	class:eclosure	access:public
eclosure::eclosure	galgorithm/eclosures.h	/^	eclosure(const tinygrammar& tig, closure_array& ecls)$/;"	f	class:eclosure	access:public	signature:(const tinygrammar& tig, closure_array& ecls)
eclosure::ecs_	galgorithm/eclosures.h	/^	closure_array* ecs_;$/;"	m	class:eclosure	access:private
eclosure::invoke	galgorithm/eclosures.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:eclosure	access:public	signature:()
eclosure::operator ()	galgorithm/eclosures.cpp	/^void eclosure::operator()(const tinygrammar& tig, closure_array& closures)$/;"	f	class:eclosure	signature:(const tinygrammar& tig, closure_array& closures)
eclosure::operator ()	galgorithm/eclosures.h	/^	void operator()(const tinygrammar& tig, closure_array& closures);$/;"	p	class:eclosure	access:private	signature:(const tinygrammar& tig, closure_array& closures)
eclosure::tig_	galgorithm/eclosures.h	/^	const tinygrammar* tig_;$/;"	m	class:eclosure	access:private
ecs_	galgorithm/eclosures.h	/^	closure_array* ecs_;$/;"	m	class:eclosure	access:private
eid	galgorithm/basicalgorithms.h	/^	int32 eid; \/\/ sid of eplison$/;"	m	class:eliminate_eplison	access:private
element_type	include/share_ptr.h	/^	typedef _Tx element_type;$/;"	t	class:share_ptr	access:public
eliminate_eplison	galgorithm/basicalgorithms.h	/^	eliminate_eplison(const grammar& gin, grammar& gout)$/;"	f	class:eliminate_eplison	access:public	signature:(const grammar& gin, grammar& gout)
eliminate_eplison	galgorithm/basicalgorithms.h	/^class eliminate_eplison : public grammar_algorithm$/;"	c	inherits:grammar_algorithm
eliminate_eplison::eid	galgorithm/basicalgorithms.h	/^	int32 eid; \/\/ sid of eplison$/;"	m	class:eliminate_eplison	access:private
eliminate_eplison::eliminate_eplison	galgorithm/basicalgorithms.h	/^	eliminate_eplison(const grammar& gin, grammar& gout)$/;"	f	class:eliminate_eplison	access:public	signature:(const grammar& gin, grammar& gout)
eliminate_eplison::findtoe	galgorithm/basicalgorithms.cpp	/^void eliminate_eplison::findtoe(const tinygrammar& tig)$/;"	f	class:eliminate_eplison	signature:(const tinygrammar& tig)
eliminate_eplison::findtoe	galgorithm/basicalgorithms.h	/^	void findtoe(const tinygrammar& tig);$/;"	p	class:eliminate_eplison	access:private	signature:(const tinygrammar& tig)
eliminate_eplison::gin_	galgorithm/basicalgorithms.h	/^	const grammar* gin_;$/;"	m	class:eliminate_eplison	access:private
eliminate_eplison::gout_	galgorithm/basicalgorithms.h	/^	grammar* gout_;$/;"	m	class:eliminate_eplison	access:private
eliminate_eplison::invoke	galgorithm/basicalgorithms.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:eliminate_eplison	access:public	signature:()
eliminate_eplison::is_start_in_right	galgorithm/basicalgorithms.cpp	/^bool eliminate_eplison::is_start_in_right(const tinygrammar& tig) const$/;"	f	class:eliminate_eplison	signature:(const tinygrammar& tig) const
eliminate_eplison::is_start_in_right	galgorithm/basicalgorithms.h	/^	bool is_start_in_right(const tinygrammar& tig) const;$/;"	p	class:eliminate_eplison	access:private	signature:(const tinygrammar& tig) const
eliminate_eplison::new_start_symbol	galgorithm/basicalgorithms.cpp	/^void eliminate_eplison::new_start_symbol(const tinygrammar& tig, tinygrammar& tog)$/;"	f	class:eliminate_eplison	signature:(const tinygrammar& tig, tinygrammar& tog)
eliminate_eplison::new_start_symbol	galgorithm/basicalgorithms.h	/^	void new_start_symbol(const tinygrammar& tig, tinygrammar& tog);$/;"	p	class:eliminate_eplison	access:private	signature:(const tinygrammar& tig, tinygrammar& tog)
eliminate_eplison::operator ()	galgorithm/basicalgorithms.cpp	/^void eliminate_eplison::operator()(const grammar& gin, grammar& gout)$/;"	f	class:eliminate_eplison	signature:(const grammar& gin, grammar& gout)
eliminate_eplison::operator ()	galgorithm/basicalgorithms.h	/^	void operator()(const grammar& gin, grammar& gout);$/;"	p	class:eliminate_eplison	access:private	signature:(const grammar& gin, grammar& gout)
eliminate_eplison::rmeplison	galgorithm/basicalgorithms.cpp	/^void eliminate_eplison::rmeplison(const tinygrammar& tig, tinygrammar& tog)$/;"	f	class:eliminate_eplison	signature:(const tinygrammar& tig, tinygrammar& tog)
eliminate_eplison::rmeplison	galgorithm/basicalgorithms.h	/^	void rmeplison(const tinygrammar& tig, tinygrammar& tog);$/;"	p	class:eliminate_eplison	access:private	signature:(const tinygrammar& tig, tinygrammar& tog)
eliminate_eplison::toe	galgorithm/basicalgorithms.h	/^	vecint toe; \/\/ symbol A->..->e?$/;"	m	class:eliminate_eplison	access:private
eliminate_eplison::vecint	galgorithm/basicalgorithms.h	/^	typedef kog::smart_vector<int32> vecint;$/;"	t	class:eliminate_eplison	access:private
end	include/arrayX.h	/^	const_iterator end() const { return const_iterator(_buf + _Length, _Length, 0); }$/;"	f	struct:SmartArray	access:public	signature:() const
end	include/arrayX.h	/^	const_iterator end() const { return const_iterator(_values[0] + Length, Length, 0); }$/;"	f	struct:SmartMatrix	access:public	signature:() const
end	include/arrayX.h	/^	const_iterator end() const { return const_iterator(buf_.values + buf_.count, buf_.count, 0); }$/;"	f	class:smart_vector	access:public	signature:() const
end	include/arrayX.h	/^	iterator end() { return iterator(_buf + _Length, _Length, 0); }$/;"	f	struct:SmartArray	access:public	signature:()
end	include/arrayX.h	/^	iterator end() { return iterator(_values[0] + Length, Length, 0); }$/;"	f	struct:SmartMatrix	access:public	signature:()
end	include/arrayX.h	/^	iterator end() { return iterator(buf_.values + buf_.count, buf_.count, 0); }$/;"	f	class:smart_vector	access:public	signature:()
end	include/functionalX.h	/^	iterator end() const$/;"	f	struct:range_t	access:public	signature:() const
ending_symbol_	syntax/grammar.h	/^	int32 ending_symbol_; \/\/ ending symbol sid: -1 no$/;"	m	class:tinygrammar	access:protected
endings	syntax/automachine.h	/^		int32 endings() const {return isendings_;}$/;"	f	class:automachine::sheetrow	access:public	signature:() const
endings	syntax/automachine.h	/^		void endings(int32 t) { isendings_ = t; }$/;"	f	class:automachine::sheetrow	access:public	signature:(int32 t)
eplison_symbol_	syntax/grammar.h	/^	int32 eplison_symbol_; \/\/ eplison symbol sid: -1 not in grammar$/;"	m	class:tinygrammar	access:protected
erase	include/stringX.h	/^	_Myt& erase(size_type _Off = 0, size_type _Count = _Mybase::npos)$/;"	f	class:xstring_basic	access:public	signature:(size_type _Off = 0, size_type _Count = _Mybase::npos)
eta	compiler/lalr1machine.h	/^	bool eta(const symbol* sym);$/;"	p	class:lalr1machine	access:public	signature:(const symbol* sym)
eta	syntax/automachine.cpp	/^bool automachine::eta(int32 meta)$/;"	f	class:automachine	signature:(int32 meta)
eta	syntax/automachine.h	/^	virtual bool eta(int meta);$/;"	p	class:automachine	access:public	signature:(int meta)
eta	syntax/lrmachine.cpp	/^bool lrmachine::eta(int32 meta)$/;"	f	class:lrmachine	signature:(int32 meta)
eta	syntax/lrmachine.h	/^	\/* overwrite *\/ virtual bool eta(int meta);$/;"	p	class:lrmachine	access:public	signature:(int meta)
eta	syntax/statemachine.cpp	/^bool state_machine::eta(int32 meta)$/;"	f	class:state_machine	signature:(int32 meta)
eta	syntax/statemachine.h	/^	\/* overwrite *\/ virtual bool eta(int meta);$/;"	p	class:state_machine	access:public	signature:(int meta)
exclude	syntax/automachine.h	/^		enum { anychar, special, exclude };$/;"	e	enum:automachine::sheetrow::__anon5
explicit_convert	include/functionalX.h	/^explicit_convert_t<_Tx, _Ty> explicit_convert(const _Tx&)$/;"	f	signature:(const _Tx&)
explicit_convert_t	include/functionalX.h	/^struct explicit_convert_t : public std::unary_function<_Tx, _Ty>$/;"	s	inherits:std::unary_function
explicit_convert_t::operator ()	include/functionalX.h	/^	_Ty operator()(const _Tx& _x) const$/;"	f	struct:explicit_convert_t	access:public	signature:(const _Tx& _x) const
f	tmp/coutfun.cpp	/^std::ostream& f(std::ostream& os)$/;"	f	signature:(std::ostream& os)
f	tmp/protected.cpp	/^	void f()$/;"	f	class:base	access:public	signature:()
f_	include/markuputils.h	/^	ifile* f_;$/;"	m	class:node	access:private
fadd	test/input/easy.c	/^float fadd(float a, float b)$/;"	f	signature:(float a, float b)
file	include/markuputils.h	/^	file(const std::string& fname, bool inORout)$/;"	f	class:file	access:public	signature:(const std::string& fname, bool inORout)
file	include/markuputils.h	/^class file$/;"	c
file::file	include/markuputils.h	/^	file(const std::string& fname, bool inORout)$/;"	f	class:file	access:public	signature:(const std::string& fname, bool inORout)
file::fname_	include/markuputils.h	/^	std::string fname_;$/;"	m	class:file	access:protected
file::fs_	include/markuputils.h	/^	std::auto_ptr<CMarkup> fs_;$/;"	m	class:file	access:protected
file::fstream	include/markuputils.h	/^	typedef std::fstream fstream;$/;"	t	class:file	access:private
file::in	include/markuputils.h	/^	enum {in = 0, out = 1};$/;"	e	enum:file::__anon3
file::inORout_	include/markuputils.h	/^	bool inORout_;$/;"	m	class:file	access:protected
file::into	include/markuputils.h	/^	void into()$/;"	f	class:file	access:public	signature:()
file::out	include/markuputils.h	/^	enum {in = 0, out = 1};$/;"	e	enum:file::__anon3
file::outof	include/markuputils.h	/^	void outof()$/;"	f	class:file	access:public	signature:()
file::swap	include/markuputils.h	/^	void swap(file& other)$/;"	f	class:file	access:public	signature:(file& other)
file::~file	include/markuputils.h	/^	virtual ~file()$/;"	f	class:file	access:public	signature:()
file_	syntax/loader.h	/^	xml::ifile file_;$/;"	m	class:loader	access:private
fin_	test/basicalgorithmtest.cpp	/^	std::string fin_;$/;"	m	class:basicalg_test	file:	access:private
finds	test/gio.h	/^	compile::int32 finds(std::list<std::string>& bufs, std::deque<compile::symbol>& slist, const std::string& s) const$/;"	f	class:greader	access:private	signature:(std::list<std::string>& bufs, std::deque<compile::symbol>& slist, const std::string& s) const
findtoe	galgorithm/basicalgorithms.cpp	/^void eliminate_eplison::findtoe(const tinygrammar& tig)$/;"	f	class:eliminate_eplison	signature:(const tinygrammar& tig)
findtoe	galgorithm/basicalgorithms.h	/^	void findtoe(const tinygrammar& tig);$/;"	p	class:eliminate_eplison	access:private	signature:(const tinygrammar& tig)
fire	include/scerror.h	28;"	d
fire	include/scerror.h	31;"	d
fire_error	include/mplX.h	/^struct fire_error$/;"	s
fire_error::value	include/mplX.h	/^	const static int value = sizeof(_T);$/;"	m	struct:fire_error	access:public
first	include/functionalX.h	/^	_Ty1 first;	\/\/ the first stored value$/;"	m	struct:triple	access:public
first_argument_type	include/functionalX.h	/^	typedef _Arg1 first_argument_type;$/;"	t	struct:triple_function	access:public
first_argument_type	include/functionalX.h	/^	typedef typename _Fx::argument_type first_argument_type;$/;"	t	struct:composite_function2_t	access:public
first_type	include/functionalX.h	/^	typedef _Ty1 first_type;$/;"	t	struct:triple	access:public
firstfollow_test	test/firstfollowtest.cpp	/^NEW_UNITTEST(firstfollow_test);$/;"	v
firstfollow_test	test/firstfollowtest.cpp	/^class firstfollow_test : public sc::unittest$/;"	c	file:	inherits:sc::unittest
firstfollow_test::ginfile_	test/firstfollowtest.cpp	/^	std::string ginfile_;$/;"	m	class:firstfollow_test	file:	access:private
firstfollow_test::init	test/firstfollowtest.cpp	/^	\/* overwrite *\/ virtual void init(int argc, const char* argv[])$/;"	f	class:firstfollow_test	file:	access:private	signature:(int argc, const char* argv[])
firstfollow_test::outputSets	test/firstfollowtest.cpp	/^	void outputSets(const firstset::vecintset& sets, const symholder& sholder, std::ostream& os, const std::string& sname)$/;"	f	class:firstfollow_test	file:	access:private	signature:(const firstset::vecintset& sets, const symholder& sholder, std::ostream& os, const std::string& sname)
firstfollow_test::output_first_follow_set	test/firstfollowtest.cpp	/^	void output_first_follow_set(const grammar& g)$/;"	f	class:firstfollow_test	file:	access:private	signature:(const grammar& g)
firstfollow_test::run_test	test/firstfollowtest.cpp	/^	\/* overwrite *\/ virtual void run_test()$/;"	f	class:firstfollow_test	file:	access:private	signature:()
firstfollow_test::sotfile_	test/firstfollowtest.cpp	/^	std::string sotfile_;$/;"	m	class:firstfollow_test	file:	access:private
firstset	galgorithm/firstfollow.h	/^	firstset(const grammar& gin, vecintset& sets)$/;"	f	class:firstset	access:public	signature:(const grammar& gin, vecintset& sets)
firstset	galgorithm/firstfollow.h	/^class firstset : public grammar_algorithm$/;"	c	inherits:grammar_algorithm
firstset::firstset	galgorithm/firstfollow.h	/^	firstset(const grammar& gin, vecintset& sets)$/;"	f	class:firstset	access:public	signature:(const grammar& gin, vecintset& sets)
firstset::gin_	galgorithm/firstfollow.h	/^	const grammar* gin_;$/;"	m	class:firstset	access:private
firstset::invoke	galgorithm/firstfollow.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:firstset	access:public	signature:()
firstset::operator ()	galgorithm/firstfollow.cpp	/^void firstset::operator()(const grammar& gin, vecintset& sets)$/;"	f	class:firstset	signature:(const grammar& gin, vecintset& sets)
firstset::operator ()	galgorithm/firstfollow.h	/^	void operator()(const grammar& gin, vecintset& sets);$/;"	p	class:firstset	access:private	signature:(const grammar& gin, vecintset& sets)
firstset::sets_	galgorithm/firstfollow.h	/^	vecintset* sets_;$/;"	m	class:firstset	access:private
firstset::vecint	galgorithm/firstfollow.h	/^	typedef kog::smart_vector<int32> vecint;$/;"	t	class:firstset	access:public
firstset::vecintset	galgorithm/firstfollow.h	/^	typedef kog::smart_vector<vecint> vecintset;$/;"	t	class:firstset	access:public
firstsets_	galgorithm/firstfollow.h	/^	const vecintset* firstsets_;$/;"	m	class:followset	access:private
fname_	include/markuputils.h	/^	std::string fname_;$/;"	m	class:file	access:protected
follow	galgorithm/lranalyse.cpp	/^	std::set<int32> follow;$/;"	m	struct:lrstateitem	file:	access:public
followset	galgorithm/firstfollow.h	/^	followset(const grammar& gin, const vecintset& firstsets, vecintset& followsets)$/;"	f	class:followset	access:public	signature:(const grammar& gin, const vecintset& firstsets, vecintset& followsets)
followset	galgorithm/firstfollow.h	/^class followset : public grammar_algorithm$/;"	c	inherits:grammar_algorithm
followset::firstsets_	galgorithm/firstfollow.h	/^	const vecintset* firstsets_;$/;"	m	class:followset	access:private
followset::followset	galgorithm/firstfollow.h	/^	followset(const grammar& gin, const vecintset& firstsets, vecintset& followsets)$/;"	f	class:followset	access:public	signature:(const grammar& gin, const vecintset& firstsets, vecintset& followsets)
followset::followsets_	galgorithm/firstfollow.h	/^	vecintset* followsets_;$/;"	m	class:followset	access:private
followset::gin_	galgorithm/firstfollow.h	/^	const grammar* gin_;$/;"	m	class:followset	access:private
followset::invoke	galgorithm/firstfollow.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:followset	access:public	signature:()
followset::operator ()	galgorithm/firstfollow.cpp	/^void followset::operator()(const grammar& gin, const vecintset& FirstSets, vecintset& FollowSets)$/;"	f	class:followset	signature:(const grammar& gin, const vecintset& FirstSets, vecintset& FollowSets)
followset::operator ()	galgorithm/firstfollow.h	/^	void operator()(const grammar& gin, const vecintset& firstsets, vecintset& followsets);$/;"	p	class:followset	access:private	signature:(const grammar& gin, const vecintset& firstsets, vecintset& followsets)
followset::vecint	galgorithm/firstfollow.h	/^	typedef kog::smart_vector<int32> vecint;$/;"	t	class:followset	access:public
followset::vecintset	galgorithm/firstfollow.h	/^	typedef kog::smart_vector<vecint> vecintset;$/;"	t	class:followset	access:public
followsets_	galgorithm/firstfollow.h	/^	vecintset* followsets_;$/;"	m	class:followset	access:private
format	include/stringX.h	/^	static _Myt format(const _Elem* fmt, ...)$/;"	f	class:xstring_basic	access:public	signature:(const _Elem* fmt, ...)
format	include/stringXF.h	/^	static std::string format(const char* fmt, ...)$/;"	f	class:strformat	access:public	signature:(const char* fmt, ...)
format	include/stringXF.h	/^	static std::string& format(const char* fmt, va_list argptr, std::string& out_buf)$/;"	f	class:strformat	access:public	signature:(const char* fmt, va_list argptr, std::string& out_buf)
format	include/stringXF.h	/^	static std::wstring format(const wchar_t* fmt, ...)$/;"	f	class:strformat	access:public	signature:(const wchar_t* fmt, ...)
format	include/stringXF.h	/^	static std::wstring& format(const wchar_t* fmt, va_list argptr, std::wstring& out_buf)$/;"	f	class:strformat	access:public	signature:(const wchar_t* fmt, va_list argptr, std::wstring& out_buf)
format	include/stringXF.h	/^std::basic_string<_Elem> format(const _Elem* _fmt, ...)$/;"	f	signature:(const _Elem* _fmt, ...)
forward	include/iteratorX.h	/^	_Myt& forward()$/;"	f	struct:iterator_pair	access:protected	signature:()
forward	include/iteratorX.h	/^	static array_iterator& forward(array_iterator& aniterator, distance_type dis = 1)$/;"	f	struct:array_iterator	access:protected	signature:(array_iterator& aniterator, distance_type dis = 1)
fout_	test/basicalgorithmtest.cpp	/^	std::string fout_;$/;"	m	class:basicalg_test	file:	access:private
free_holder	include/share_ptr.h	/^	void free_holder()$/;"	f	class:share_ptr	access:private	signature:()
front	include/arrayX.h	/^	const_reference front() const { return _buf[0]; }$/;"	f	struct:SmartArray	access:public	signature:() const
front	include/arrayX.h	/^	const_reference front() const$/;"	f	class:smart_vector	access:public	signature:() const
front	include/arrayX.h	/^	reference front() { return _buf[0]; }$/;"	f	struct:SmartArray	access:public	signature:()
front	include/arrayX.h	/^	reference front()$/;"	f	class:smart_vector	access:public	signature:()
fs_	include/markuputils.h	/^	std::auto_ptr<CMarkup> fs_;$/;"	m	class:file	access:protected
fstream	include/markuputils.h	/^	typedef std::fstream fstream;$/;"	t	class:file	access:private
func	syntax/symbol.h	/^	function func;$/;"	m	struct:symfunc	access:public
funcarray	syntax/lrmachine.h	/^	typedef kog::smart_vector<symfunc*> funcarray;$/;"	t	class:lrmachine	access:public
funcs	syntax/symbol.h	/^	symfunc* funcs;$/;"	m	struct:symbol	access:public
funcs_	syntax/lrmachine.h	/^	funcarray funcs_;$/;"	m	class:lrmachine	access:private
function	syntax/symbol.h	/^	typedef void* (*function)(void*);$/;"	t	struct:symfunc	access:public
genLinear	include/functionalX.h	/^inline _Iter genLinear(_T _From, _T _Diff, _T _To, _Iter _First)$/;"	f	signature:(_T _From, _T _Diff, _T _To, _Iter _First)
genLinearC	include/functionalX.h	/^inline _Iter genLinearC(_T _From, _T _To, size_t _Count, _Iter _First)$/;"	f	signature:(_T _From, _T _To, size_t _Count, _Iter _First)
get	include/arrayX.h	/^	const_pointer get() const { return buf_.values; }$/;"	f	class:smart_vector	access:public	signature:() const
get	include/arrayX.h	/^	pointer get() { return buf_.values; }$/;"	f	class:smart_vector	access:public	signature:()
get	include/iteratorX.h	/^	_Tx* get() const { return _ptr; }$/;"	f	struct:array_iterator	access:public	signature:() const
get	include/share_ptr.h	/^	_Tx* get() throw()$/;"	f	class:share_ptr	access:public	signature:()
getIndex	include/mathX.h	/^		static int getIndex(const T* begin, const size_t nSize, const T& val)$/;"	f	class:math::interpolate	access:public	signature:(const T* begin, const size_t nSize, const T& val)
get_all_machines	compiler/compiler.cpp	/^int compiler::get_all_machines(std::list<state_machine*>& mlist)$/;"	f	class:compiler	signature:(std::list<state_machine*>& mlist)
get_all_machines	compiler/compiler.h	/^	static int get_all_machines(std::list<state_machine*>& mlist);$/;"	p	class:compiler	access:public	signature:(std::list<state_machine*>& mlist)
get_number_machine	compiler/compiler.cpp	/^state_machine compiler::get_number_machine()$/;"	f	class:compiler	signature:()
get_number_machine	compiler/compiler.h	/^	static state_machine get_number_machine();$/;"	p	class:compiler	access:public	signature:()
get_ptr_t	include/functionalX.h	/^struct get_ptr_t : public std::unary_function<_Tx, _Tx*>$/;"	s	inherits:std::unary_function
get_ptr_t::operator ()	include/functionalX.h	/^	_Tx* operator()(_Tx& _Arg) const$/;"	f	struct:get_ptr_t	access:public	signature:(_Tx& _Arg) const
get_ptr_t::operator ()	include/functionalX.h	/^	const _Tx* operator()(const _Tx& _Arg) const$/;"	f	struct:get_ptr_t	access:public	signature:(const _Tx& _Arg) const
get_r1	galgorithm/nfa2dfa.cpp	/^inline int32 get_r1(const production* p, int32 virtual_ending)$/;"	f	signature:(const production* p, int32 virtual_ending)
get_string_machine	compiler/compiler.cpp	/^state_machine compiler::get_string_machine()$/;"	f	class:compiler	signature:()
get_string_machine	compiler/compiler.h	/^	static state_machine get_string_machine();$/;"	p	class:compiler	access:public	signature:()
get_symbol_machine	compiler/compiler.cpp	/^state_machine compiler::get_symbol_machine()$/;"	f	class:compiler	signature:()
get_symbol_machine	compiler/compiler.h	/^	static state_machine get_symbol_machine();$/;"	p	class:compiler	access:public	signature:()
getstream	include/stringX.h	/^	bool getstream(_IStream& _istream)$/;"	f	class:xstring_basic	access:public	signature:(_IStream& _istream)
getstream	include/stringX.h	/^	bool getstream(_OStream& _ostream)$/;"	f	class:xstring_basic	access:public	signature:(_OStream& _ostream)
getstream	include/stringX.h	/^	bool getstream(_Stream& _stream)$/;"	f	class:xstring_basic	access:public	signature:(_Stream& _stream)
getstringptr	syntax/symbol.h	/^	const tchar* getstringptr() const$/;"	f	class:symholder	access:public	signature:() const
getsymbol	galgorithm/regex2nfa.cpp	/^	int getsymbol(int sid)$/;"	f	struct:parsecontent	access:public	signature:(int sid)
getsymbol	tmp/back/regex2nfa.cpp	/^	int getsymbol(int sid)$/;"	f	struct:parsecontent	access:public	signature:(int sid)
gettinyg	syntax/grammar.h	/^	const tinygrammar& gettinyg() const$/;"	f	class:grammar	access:public	signature:() const
gin_	galgorithm/basicalgorithms.h	/^	const grammar* gin_;$/;"	m	class:eliminate_eplison	access:private
gin_	galgorithm/basicalgorithms.h	/^	const grammar* gin_;$/;"	m	class:removenotused	access:private
gin_	galgorithm/basicalgorithms.h	/^	const grammar* gin_;$/;"	m	class:removesingle	access:private
gin_	galgorithm/basicalgorithms.h	/^	const grammar* gin_;$/;"	m	class:simplegrammar	access:private
gin_	galgorithm/dfa2machine.h	/^	const tinygrammar* gin_;$/;"	m	class:dfa2machine	access:private
gin_	galgorithm/firstfollow.h	/^	const grammar* gin_;$/;"	m	class:firstset	access:private
gin_	galgorithm/firstfollow.h	/^	const grammar* gin_;$/;"	m	class:followset	access:private
gin_	galgorithm/lranalyse.h	/^	const grammar* gin_;$/;"	m	class:lranalyse	access:private
gin_	galgorithm/nfa2dfa.h	/^	const grammar* gin_;$/;"	m	class:nfa2dfa	access:private
ginfile_	test/firstfollowtest.cpp	/^	std::string ginfile_;$/;"	m	class:firstfollow_test	file:	access:private
ginfile_	test/nfa2dfatest.cpp	/^	std::string ginfile_;$/;"	m	class:nfa2dfa_test	file:	access:private
got_	galgorithm/nfa2dfa.h	/^	grammar* got_;$/;"	m	class:nfa2dfa	access:private
gotfile_	test/nfa2dfatest.cpp	/^	std::string gotfile_;$/;"	m	class:nfa2dfa_test	file:	access:private
gotoitem	syntax/automachine.h	/^	typedef std::pair<int, int> gotoitem;$/;"	t	class:automachine	access:public
gout_	galgorithm/basicalgorithms.h	/^	grammar* gout_;$/;"	m	class:eliminate_eplison	access:private
gout_	galgorithm/basicalgorithms.h	/^	grammar* gout_;$/;"	m	class:removenotused	access:private
gout_	galgorithm/basicalgorithms.h	/^	grammar* gout_;$/;"	m	class:removesingle	access:private
gout_	galgorithm/basicalgorithms.h	/^	grammar* gout_;$/;"	m	class:simplegrammar	access:private
gout_	galgorithm/regex2nfa.h	/^	grammar* gout_;$/;"	m	class:regex2nfa	access:private
grammar	galgorithm/lranalyse.cpp	/^	const grammar& grammar;$/;"	m	struct:AlgorithmArg	file:	access:public
grammar	syntax/grammar.cpp	/^grammar::grammar()$/;"	f	class:grammar	signature:()
grammar	syntax/grammar.cpp	/^grammar::grammar(const tinygrammar& atinyG)$/;"	f	class:grammar	signature:(const tinygrammar& atinyG)
grammar	syntax/grammar.h	/^	grammar();$/;"	p	class:grammar	access:public	signature:()
grammar	syntax/grammar.h	/^	grammar(const tinygrammar& atinyG);$/;"	p	class:grammar	access:public	signature:(const tinygrammar& atinyG)
grammar	syntax/grammar.h	/^class grammar : protected tinygrammar$/;"	c	inherits:tinygrammar
grammar::dthenu_	syntax/grammar.h	/^	bool dthenu_; \/\/ symbol need be defined before use?$/;"	m	class:grammar	access:protected
grammar::gettinyg	syntax/grammar.h	/^	const tinygrammar& gettinyg() const$/;"	f	class:grammar	access:public	signature:() const
grammar::grammar	syntax/grammar.cpp	/^grammar::grammar()$/;"	f	class:grammar	signature:()
grammar::grammar	syntax/grammar.cpp	/^grammar::grammar(const tinygrammar& atinyG)$/;"	f	class:grammar	signature:(const tinygrammar& atinyG)
grammar::grammar	syntax/grammar.h	/^	grammar();$/;"	p	class:grammar	access:public	signature:()
grammar::grammar	syntax/grammar.h	/^	grammar(const tinygrammar& atinyG);$/;"	p	class:grammar	access:public	signature:(const tinygrammar& atinyG)
grammar::keyword	syntax/grammar.h	/^		keyword = 2, \/\/ keyword$/;"	e	enum:grammar::symtype
grammar::keywords_	syntax/grammar.h	/^	veckeywords keywords_;$/;"	m	class:grammar	access:protected
grammar::nont	syntax/grammar.h	/^		nont = 0, \/\/non-terminate$/;"	e	enum:grammar::symtype
grammar::sep	syntax/grammar.h	/^		sep = 1, \/\/ seperators$/;"	e	enum:grammar::symtype
grammar::seperators_	syntax/grammar.h	/^	tstring seperators_;	\/\/ seperators: split word$/;"	m	class:grammar	access:protected
grammar::smac	syntax/grammar.h	/^		smac = 3	\/\/ symbol match state machine$/;"	e	enum:grammar::symtype
grammar::smacs_	syntax/grammar.h	/^	vecsmacs smacs_; \/\/ state machines$/;"	m	class:grammar	access:protected
grammar::swap	syntax/grammar.cpp	/^void grammar::swap(grammar& other) throw ()$/;"	f	class:grammar	signature:(grammar& other)
grammar::swap	syntax/grammar.h	/^	void swap(grammar& other) throw ();$/;"	p	class:grammar	access:public	signature:(grammar& other)
grammar::symtype	syntax/grammar.h	/^	enum symtype$/;"	g	class:grammar	access:public
grammar::veckeywords	syntax/grammar.h	/^	typedef kog::smart_vector<std::pair<tstring, int32> > veckeywords;$/;"	t	class:grammar	access:public
grammar::vecsmacs	syntax/grammar.h	/^	typedef kog::smart_vector<std::pair<tstring, int32> > vecsmacs; \/\/ first: symbol.sid, second: regex string$/;"	t	class:grammar	access:public
grammar::whitespaces_	syntax/grammar.h	/^	tstring whitespaces_;	\/\/ whitespace: space tab or some other charactors$/;"	m	class:grammar	access:protected
grammar::~grammar	syntax/grammar.cpp	/^grammar::~grammar()$/;"	f	class:grammar	signature:()
grammar::~grammar	syntax/grammar.h	/^	virtual ~grammar();$/;"	p	class:grammar	access:public	signature:()
grammar_algorithm	galgorithm/grammaralgorithm.h	/^	grammar_algorithm(const tstring& name)$/;"	f	class:grammar_algorithm	access:public	signature:(const tstring& name)
grammar_algorithm	galgorithm/grammaralgorithm.h	/^class grammar_algorithm$/;"	c
grammar_algorithm::grammar_algorithm	galgorithm/grammaralgorithm.h	/^	grammar_algorithm(const tstring& name)$/;"	f	class:grammar_algorithm	access:public	signature:(const tstring& name)
grammar_algorithm::invoke	galgorithm/grammaralgorithm.h	/^	virtual void invoke() = 0;$/;"	p	class:grammar_algorithm	access:public	signature:()
grammar_algorithm::name	galgorithm/grammaralgorithm.h	/^	const tstring& name() const$/;"	f	class:grammar_algorithm	access:public	signature:() const
grammar_algorithm::name_	galgorithm/grammaralgorithm.h	/^	tstring name_;$/;"	m	class:grammar_algorithm	access:private
grammar_wrapper	test/tinygrammartest.cpp	/^class grammar_wrapper : public grammar$/;"	c	file:	inherits:grammar
grammar_wrapper::simple_grammar	test/tinygrammartest.cpp	/^	void simple_grammar();$/;"	p	class:grammar_wrapper	file:	access:public	signature:()
grammar_wrapper::simple_grammar	test/tinygrammartest.cpp	/^void grammar_wrapper::simple_grammar()$/;"	f	class:grammar_wrapper	signature:()
greader	test/gio.h	/^	greader(std::istream& is)$/;"	f	class:greader	access:public	signature:(std::istream& is)
greader	test/gio.h	/^class greader$/;"	c
greader::finds	test/gio.h	/^	compile::int32 finds(std::list<std::string>& bufs, std::deque<compile::symbol>& slist, const std::string& s) const$/;"	f	class:greader	access:private	signature:(std::list<std::string>& bufs, std::deque<compile::symbol>& slist, const std::string& s) const
greader::greader	test/gio.h	/^	greader(std::istream& is)$/;"	f	class:greader	access:public	signature:(std::istream& is)
greader::is_	test/gio.h	/^	std::istream& is_;$/;"	m	class:greader	access:private
greader::operator >>	test/gio.h	/^	greader& operator>>(compile::grammar& g)$/;"	f	class:greader	access:public	signature:(compile::grammar& g)
greader::read_grammar	test/gio.h	/^	void read_grammar(std::istream& is, compile::grammar& g, const std::string& start, const std::string& eplison, const std::string& ending) const$/;"	f	class:greader	access:private	signature:(std::istream& is, compile::grammar& g, const std::string& start, const std::string& eplison, const std::string& ending) const
gwriter	test/gio.h	/^	gwriter(std::ostream& os)$/;"	f	class:gwriter	access:public	signature:(std::ostream& os)
gwriter	test/gio.h	/^class gwriter$/;"	c
gwriter::gwriter	test/gio.h	/^	gwriter(std::ostream& os)$/;"	f	class:gwriter	access:public	signature:(std::ostream& os)
gwriter::operator <<	test/gio.h	/^	gwriter& operator<<(const compile::grammar& g)$/;"	f	class:gwriter	access:public	signature:(const compile::grammar& g)
gwriter::os_	test/gio.h	/^	std::ostream& os_;$/;"	m	class:gwriter	access:private
holder_	syntax/production.h	/^	const symholder* holder_;$/;"	m	class:production	access:private
i	third_party/xml/Markup.cpp	/^	int i;$/;"	m	struct:PathPos	file:	access:private
iElemChild	third_party/xml/Markup.cpp	/^	int iElemChild; \/\/ first child$/;"	m	struct:ElemPos	file:	access:public
iElemNext	third_party/xml/Markup.cpp	/^	int iElemNext; \/\/ next sibling$/;"	m	struct:ElemPos	file:	access:public
iElemParent	third_party/xml/Markup.cpp	/^	int iElemParent;$/;"	m	struct:ElemPos	file:	access:public
iElemPrev	third_party/xml/Markup.cpp	/^	int iElemPrev; \/\/ if this is first, iElemPrev points to last$/;"	m	struct:ElemPos	file:	access:public
iNext	third_party/xml/Markup.cpp	/^	int iNext;$/;"	m	struct:TagPos	file:	access:public
iPar	third_party/xml/Markup.cpp	/^	int iPar;$/;"	m	struct:ElemStack	file:	access:public
iParent	third_party/xml/Markup.cpp	/^	int iParent;$/;"	m	struct:TagPos	file:	access:public
iPathAttribName	third_party/xml/Markup.cpp	/^	int iPathAttribName;$/;"	m	struct:PathPos	file:	access:private
iPos	third_party/xml/Markup.cpp	/^	int iPos;$/;"	m	struct:SavedPos	file:	access:public
iPrev	third_party/xml/Markup.cpp	/^	int iPrev;$/;"	m	struct:TagPos	file:	access:public
iR	galgorithm/regex2nfa.cpp	/^		int iR; \/\/ first right index$/;"	m	struct:parsecontent::prod	file:	access:public
iR	tmp/back/regex2nfa.cpp	/^		int iR; \/\/ first right index$/;"	m	struct:parsecontent::prod	file:	access:public
iS	galgorithm/regex2nfa.cpp	/^	int iS;$/;"	m	struct:parsecontent	file:	access:public
iS	tmp/back/regex2nfa.cpp	/^	int iS;$/;"	m	struct:parsecontent	file:	access:public
iSave	third_party/xml/Markup.cpp	/^	int iSave;$/;"	m	struct:PathPos	file:	access:private
iSlotNext	third_party/xml/Markup.cpp	/^	int iSlotNext;$/;"	m	struct:TagPos	file:	access:public
iSlotPrev	third_party/xml/Markup.cpp	/^	int iSlotPrev;$/;"	m	struct:TagPos	file:	access:public
iTop	third_party/xml/Markup.cpp	/^	int iTop;$/;"	m	struct:ElemStack	file:	access:public
iUsed	third_party/xml/Markup.cpp	/^	int iUsed;$/;"	m	struct:ElemStack	file:	access:protected
idx	test/vhelp.h	/^	int32 idx;$/;"	m	struct:symindex	access:public
ifile	include/markuputils.h	/^	ifile(const std::string& fname)$/;"	f	class:ifile	access:public	signature:(const std::string& fname)
ifile	include/markuputils.h	/^class ifile : public virtual utils::file$/;"	c	inherits:utils::file
ifile::cnode_	include/markuputils.h	/^	node cnode_;$/;"	m	class:ifile	access:private
ifile::ifile	include/markuputils.h	/^	ifile(const std::string& fname)$/;"	f	class:ifile	access:public	signature:(const std::string& fname)
ifile::swap	include/markuputils.h	/^	void swap(ifile& other)$/;"	f	class:ifile	access:public	signature:(ifile& other)
in	include/markuputils.h	/^	enum {in = 0, out = 1};$/;"	e	enum:file::__anon3
inORout_	include/markuputils.h	/^	bool inORout_;$/;"	m	class:file	access:protected
inc	makecompiler/gensyntax.cpp	/^	int inc;$/;"	m	struct:tabident	file:	access:private
inc	tmp/coutfun.cpp	/^	int inc;$/;"	m	struct:Ident	file:	access:public
inc_holder	include/share_ptr.h	/^	void inc_holder()$/;"	f	class:share_ptr	access:private	signature:()
inctab	makecompiler/gensyntax.cpp	/^	static tabident inctab;$/;"	m	struct:tabident	file:	access:public
index	syntax/symbol.cpp	/^int32 symholder::index(const tstring& name) const$/;"	f	class:symholder	signature:(const tstring& name) const
index	syntax/symbol.h	/^	int index(const tstring& name) const;$/;"	p	class:symholder	access:public	signature:(const tstring& name) const
index_sort	include/functionalX.h	/^std::vector<size_t> index_sort(_InIt _First, _InIt _Last)$/;"	f	signature:(_InIt _First, _InIt _Last)
index_sort	include/functionalX.h	/^std::vector<size_t> index_sort(_InIt _First, _InIt _Last, _Pr _pr)$/;"	f	signature:(_InIt _First, _InIt _Last, _Pr _pr)
init	syntax/automachine.cpp	/^void automachine::init()$/;"	f	class:automachine	signature:()
init	syntax/automachine.h	/^	virtual void init();$/;"	p	class:automachine	access:public	signature:()
init	syntax/lrmachine.cpp	/^void lrmachine::init()$/;"	f	class:lrmachine	signature:()
init	syntax/lrmachine.h	/^	\/* overwrite *\/ virtual void init();$/;"	p	class:lrmachine	access:public	signature:()
init	syntax/statemachine.cpp	/^void state_machine::init()$/;"	f	class:state_machine	signature:()
init	syntax/statemachine.h	/^	\/* overwrite *\/ virtual void init();$/;"	p	class:state_machine	access:public	signature:()
init	test/basicalgorithmtest.cpp	/^	\/* overwrite *\/ virtual void init(int argc, const char* argv[])$/;"	f	class:basicalg_test	file:	access:private	signature:(int argc, const char* argv[])
init	test/firstfollowtest.cpp	/^	\/* overwrite *\/ virtual void init(int argc, const char* argv[])$/;"	f	class:firstfollow_test	file:	access:private	signature:(int argc, const char* argv[])
init	test/nfa2dfatest.cpp	/^	\/* overwrite *\/ virtual void init(int argc, const char* argv[])$/;"	f	class:nfa2dfa_test	file:	access:private	signature:(int argc, const char* argv[])
init	test/regexnfatest.cpp	/^	\/* overwrite *\/ virtual void init(int argc, const char* argv[])$/;"	f	class:regex2nfa_test	file:	access:private	signature:(int argc, const char* argv[])
init	test/splitwords.cpp	/^	\/* overwrite *\/ virtual void init(int argc, const char* argv[])$/;"	f	class:splitwords_test	access:public	signature:(int argc, const char* argv[])
init	test/tinygrammartest.cpp	/^	\/* overwrite *\/ virtual void init(int argc, const char* argv[])$/;"	f	class:simplegrammar_test	access:public	signature:(int argc, const char* argv[])
init	test/unittest.h	/^	virtual void init(int argc, const char* argv[]) = 0;$/;"	p	class:unittest	access:public	signature:(int argc, const char* argv[])
init_grammar	test/tinygrammartest.cpp	/^	void init_grammar(grammar& g);$/;"	p	class:simplegrammar_test	file:	access:private	signature:(grammar& g)
init_grammar	test/tinygrammartest.cpp	/^void simplegrammar_test::init_grammar(grammar& g)$/;"	f	class:simplegrammar_test	signature:(grammar& g)
initmachines	compiler/compiler.cpp	/^void compiler::initmachines()$/;"	f	class:compiler	signature:()
initmachines	compiler/compiler.h	/^	void initmachines();$/;"	p	class:compiler	access:public	signature:()
initmachines	test/output/tinyg.cpp	/^void initmachines(compiler& c)$/;"	f	signature:(compiler& c)
input	test/splitwords.cpp	/^	std::string input;$/;"	m	class:splitwords_test	file:	access:private
insert	galgorithm/regex2nfa.cpp	/^	void insert(list* ph, int v)$/;"	f	struct:parsecontent	access:public	signature:(list* ph, int v)
insert	tmp/back/regex2nfa.cpp	/^	void insert(list* ph, int v)$/;"	f	struct:parsecontent	access:public	signature:(list* ph, int v)
insert_new_prod	galgorithm/regex2nfa.cpp	/^	void insert_new_prod(int L, const int* R, int c, int prod_type)$/;"	f	struct:parsecontent	access:public	signature:(int L, const int* R, int c, int prod_type)
insert_new_prod	tmp/back/regex2nfa.cpp	/^	void insert_new_prod(int L, const int* R, int c, int prod_type)$/;"	f	struct:parsecontent	access:public	signature:(int L, const int* R, int c, int prod_type)
instance	include/singleton.h	/^	static value_type& instance()$/;"	f	class:singleton	access:public	signature:()
instructions	compiler/instruction.h	/^class instructions$/;"	c
int16	include/basic_types.h	/^typedef short int16;$/;"	t
int32	include/basic_types.h	/^typedef int int32;$/;"	t
int32	test/vhelp.h	/^	typedef compile::int32 int32;$/;"	t	class:Aproduction	access:private
int32	test/vhelp.h	/^	typedef compile::int32 int32;$/;"	t	class:Asymbol	access:private
int32	test/vhelp.h	/^	typedef compile::int32 int32;$/;"	t	class:V	access:private
int32	test/vhelp.h	/^	typedef compile::int32 int32;$/;"	t	struct:symindex	access:public
int32array	syntax/lrmachine.h	/^	typedef kog::smart_vector<int32> int32array;$/;"	t	class:lrmachine	access:private
int64	include/basic_types.h	/^typedef long int int64;$/;"	t
int8	include/basic_types.h	/^typedef char int8;$/;"	t
interp	include/mathX.h	/^		static T interp(const T* xBegin, const T* yBegin, const size_t nSize, const T& val)$/;"	f	class:math::interpolate	access:public	signature:(const T* xBegin, const T* yBegin, const size_t nSize, const T& val)
interpolate	include/mathX.h	/^	class interpolate$/;"	c	class:math	access:public
into	include/markuputils.h	/^	void into()$/;"	f	class:file	access:public	signature:()
intpair_cmp	syntax/automachine.h	/^struct intpair_cmp : public std::binary_function<std::pair<int, int>, std::pair<int, int>, bool>$/;"	s	inherits:std::binary_function
intpair_cmp::_L	syntax/automachine.h	/^	_CmpFunc _L;$/;"	m	struct:intpair_cmp	access:public
intpair_cmp::operator ()	syntax/automachine.h	/^	bool operator()(const std::pair<int, int>& p1, const std::pair<int, int>& p2) const$/;"	f	struct:intpair_cmp	access:public	signature:(const std::pair<int, int>& p1, const std::pair<int, int>& p2) const
intpair_equal	syntax/automachine.h	/^typedef intpair_cmp<std::equal_to<int> > intpair_equal;$/;"	t
intpair_less	syntax/automachine.h	/^typedef intpair_cmp<std::less<int> > intpair_less;$/;"	t
invoke	galgorithm/basicalgorithms.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:eliminate_eplison	access:public	signature:()
invoke	galgorithm/basicalgorithms.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:removenotused	access:public	signature:()
invoke	galgorithm/basicalgorithms.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:removesingle	access:public	signature:()
invoke	galgorithm/basicalgorithms.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:simplegrammar	access:public	signature:()
invoke	galgorithm/dfa2machine.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:dfa2machine	access:public	signature:()
invoke	galgorithm/eclosures.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:eclosure	access:public	signature:()
invoke	galgorithm/firstfollow.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:firstset	access:public	signature:()
invoke	galgorithm/firstfollow.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:followset	access:public	signature:()
invoke	galgorithm/grammaralgorithm.h	/^	virtual void invoke() = 0;$/;"	p	class:grammar_algorithm	access:public	signature:()
invoke	galgorithm/lranalyse.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:lranalyse	access:public	signature:()
invoke	galgorithm/nfa2dfa.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:nfa2dfa	access:public	signature:()
invoke	galgorithm/regex2nfa.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:regex2nfa	access:public	signature:()
is_	test/gio.h	/^	std::istream& is_;$/;"	m	class:greader	access:private
is_auto_delete	include/arrayX.h	/^		bool is_auto_delete;$/;"	m	struct:smart_vector::block	access:public
is_between_t	include/functionalX.h	/^	is_between_t(const _Arg& _min, const _Arg& _max)$/;"	f	class:is_between_t	access:public	signature:(const _Arg& _min, const _Arg& _max)
is_between_t	include/functionalX.h	/^class is_between_t : public std::unary_function<bool, _Arg>$/;"	c	inherits:std::unary_function
is_between_t::_maxValue	include/functionalX.h	/^	const _Arg& _maxValue;$/;"	m	class:is_between_t	access:private
is_between_t::_minValue	include/functionalX.h	/^	const _Arg& _minValue;$/;"	m	class:is_between_t	access:private
is_between_t::is_between_t	include/functionalX.h	/^	is_between_t(const _Arg& _min, const _Arg& _max)$/;"	f	class:is_between_t	access:public	signature:(const _Arg& _min, const _Arg& _max)
is_between_t::operator ()	include/functionalX.h	/^	bool operator()(const _Arg& val) const$/;"	f	class:is_between_t	access:public	signature:(const _Arg& val) const
is_const_t	include/mplX.h	/^struct is_const_t $/;"	s
is_const_t	include/mplX.h	/^struct is_const_t<const _T>$/;"	s
is_const_t::value	include/mplX.h	/^	const static bool value = false;$/;"	m	struct:is_const_t	access:public
is_const_t::value	include/mplX.h	/^	const static bool value = true;$/;"	m	struct:is_const_t	access:public
is_id	third_party/regex/xregex.cpp	/^bool xregex::is_id(const tstring& str)$/;"	f	class:stringX::xregex	signature:(const tstring& str)
is_id	third_party/regex/xregex.h	/^	static bool is_id(const tstring& str);$/;"	p	class:stringX::xregex	access:public	signature:(const tstring& str)
is_interge	third_party/regex/xregex.cpp	/^bool xregex::is_interge(const tstring& str)$/;"	f	class:stringX::xregex	signature:(const tstring& str)
is_interge	third_party/regex/xregex.h	/^	static bool is_interge(const tstring& str);$/;"	p	class:stringX::xregex	access:public	signature:(const tstring& str)
is_match	third_party/regex/xregex.cpp	/^bool is_match(const boost::regex& regex, const xregex::tstring& content)$/;"	f	namespace:stringX	signature:(const boost::regex& regex, const xregex::tstring& content)
is_match	third_party/regex/xregex.cpp	/^bool xregex::is_match(const tstring& regex_str, const tstring& content)$/;"	f	class:stringX::xregex	signature:(const tstring& regex_str, const tstring& content)
is_match	third_party/regex/xregex.h	/^	static bool is_match(const tstring& regex_str, const tstring& content);$/;"	p	class:stringX::xregex	access:public	signature:(const tstring& regex_str, const tstring& content)
is_separator	compiler/compiler.cpp	/^bool compiler::is_separator(int32 elem)$/;"	f	class:compiler	signature:(int32 elem)
is_separator	compiler/compiler.h	/^	static bool is_separator(sc::int32 elem);$/;"	p	class:compiler	access:public	signature:(sc::int32 elem)
is_start_in_right	galgorithm/basicalgorithms.cpp	/^bool eliminate_eplison::is_start_in_right(const tinygrammar& tig) const$/;"	f	class:eliminate_eplison	signature:(const tinygrammar& tig) const
is_start_in_right	galgorithm/basicalgorithms.h	/^	bool is_start_in_right(const tinygrammar& tig) const;$/;"	p	class:eliminate_eplison	access:private	signature:(const tinygrammar& tig) const
isaccepted	syntax/automachine.h	/^	bool isaccepted() const$/;"	f	class:automachine	access:public	signature:() const
isdigit	include/stringX.h	/^	static bool isdigit(_Elem _Ch)$/;"	f	class:xstring_basic	access:public	signature:(_Elem _Ch)
isendings_	syntax/automachine.h	/^		int32 isendings_;$/;"	m	class:automachine::sheetrow	access:private
isinteger	include/stringX.h	/^	static bool isinteger(const _Myt& _Str)$/;"	f	class:xstring_basic	access:public	signature:(const _Myt& _Str)
islatter	include/stringX.h	/^	static bool islatter(_Elem _Ch)$/;"	f	class:xstring_basic	access:public	signature:(_Elem _Ch)
isrealsep	galgorithm/regex2nfa.cpp	/^	bool isrealsep(const char* p, const char* s)$/;"	f	struct:parsecontent	access:public	signature:(const char* p, const char* s)
isrealsep	tmp/back/regex2nfa.cpp	/^	bool isrealsep(const char* p, const char* s)$/;"	f	struct:parsecontent	access:public	signature:(const char* p, const char* s)
isrepat	galgorithm/regex2nfa.cpp	/^	int isrepat(const char*& s)$/;"	f	struct:parsecontent	access:public	signature:(const char*& s)
isrepat	tmp/back/regex2nfa.cpp	/^	int isrepat(const char*& s)$/;"	f	struct:parsecontent	access:public	signature:(const char*& s)
isspace	include/stringX.h	/^	static bool isspace(_Elem _Ch)$/;"	f	class:xstring_basic	access:public	signature:(_Elem _Ch)
ist	syntax/symbol.h	/^	int8 ist;$/;"	m	struct:symbol	access:public
iterator	include/arrayX.h	/^	typedef array_iterator<value_type> iterator;$/;"	t	class:smart_vector	access:public
iterator	include/arrayX.h	/^	typedef array_iterator<value_type> iterator;$/;"	t	struct:SmartArray	access:public
iterator	include/arrayX.h	/^	typedef array_iterator<value_type> iterator;$/;"	t	struct:SmartMatrix	access:public
iterator	include/functionalX.h	/^	typedef typename mpl::add_const<_Iter>::value_type iterator;$/;"	t	struct:range_t	access:public
iterator	include/memoryX.h	/^	typedef array_iterator<value_type> iterator;$/;"	t	struct:memblock	access:public
iterator_category	include/iteratorX.h	/^	typedef typename _Base::iterator_category iterator_category;$/;"	t	struct:array_iterator	access:public
iterator_next	include/iteratorX.h	/^_Iter iterator_next(_Iter iter)$/;"	f	signature:(_Iter iter)
iterator_pair	include/iteratorX.h	/^	iterator_pair()$/;"	f	struct:iterator_pair	access:public	signature:()
iterator_pair	include/iteratorX.h	/^	iterator_pair(_Iter1 _It1, _Iter2 _It2)$/;"	f	struct:iterator_pair	access:public	signature:(_Iter1 _It1, _Iter2 _It2)
iterator_pair	include/iteratorX.h	/^	iterator_pair(const std::pair<_Other1, _Other2>& _Right)$/;"	f	struct:iterator_pair	access:public	signature:(const std::pair<_Other1, _Other2>& _Right)
iterator_pair	include/iteratorX.h	/^struct iterator_pair : public std::pair<_Iter1, _Iter2>$/;"	s	inherits:std::pair
iterator_pair::_BaseType	include/iteratorX.h	/^	typedef std::pair<_Iter1, _Iter2> _BaseType;$/;"	t	struct:iterator_pair	access:public
iterator_pair::_Myt	include/iteratorX.h	/^	typedef iterator_pair<_Iter1, _Iter2> _Myt;$/;"	t	struct:iterator_pair	access:public
iterator_pair::backward	include/iteratorX.h	/^	_Myt& backward()$/;"	f	struct:iterator_pair	access:protected	signature:()
iterator_pair::forward	include/iteratorX.h	/^	_Myt& forward()$/;"	f	struct:iterator_pair	access:protected	signature:()
iterator_pair::iterator_pair	include/iteratorX.h	/^	iterator_pair()$/;"	f	struct:iterator_pair	access:public	signature:()
iterator_pair::iterator_pair	include/iteratorX.h	/^	iterator_pair(_Iter1 _It1, _Iter2 _It2)$/;"	f	struct:iterator_pair	access:public	signature:(_Iter1 _It1, _Iter2 _It2)
iterator_pair::iterator_pair	include/iteratorX.h	/^	iterator_pair(const std::pair<_Other1, _Other2>& _Right)$/;"	f	struct:iterator_pair	access:public	signature:(const std::pair<_Other1, _Other2>& _Right)
iterator_pair::operator !=	include/iteratorX.h	/^	bool operator != (const _Myt& _Other) const$/;"	f	struct:iterator_pair	access:public	signature:(const _Myt& _Other) const
iterator_pair::operator ++	include/iteratorX.h	/^	_Myt operator++(int) { _Myt temp(*this); forward(); return temp;}$/;"	f	struct:iterator_pair	access:public	signature:(int)
iterator_pair::operator ++	include/iteratorX.h	/^	_Myt& operator++() { return forward(); }$/;"	f	struct:iterator_pair	access:public	signature:()
iterator_pair::operator --	include/iteratorX.h	/^	_Myt operator--(int) { _Myt temp(*this); backward(); return temp; }$/;"	f	struct:iterator_pair	access:public	signature:(int)
iterator_pair::operator --	include/iteratorX.h	/^	_Myt& operator--() { return backward(); }$/;"	f	struct:iterator_pair	access:public	signature:()
iterator_pair::operator ==	include/iteratorX.h	/^	bool operator == (const _Myt& _Other) const$/;"	f	struct:iterator_pair	access:public	signature:(const _Myt& _Other) const
iterator_prior	include/iteratorX.h	/^_Iter iterator_prior(_Iter iter)$/;"	f	signature:(_Iter iter)
iwordstream	compiler/extract.cpp	/^class iwordstream : public std::istream$/;"	c	file:	inherits:std::istream
iwordstream::_Myios	compiler/extract.cpp	/^	typedef std::istream _Myios;$/;"	t	class:iwordstream	file:	access:private
iwordstream::match_machines	compiler/extract.cpp	/^	int32 match_machines(word& aword, int_type _Meta)$/;"	f	class:iwordstream	file:	access:private	signature:(word& aword, int_type _Meta)
iwordstream::operator >>	compiler/extract.cpp	/^	iwordstream& operator>>(word& aword)$/;"	f	class:iwordstream	access:public	signature:(word& aword)
iwordstream::read_content	compiler/extract.cpp	/^	bool read_content(_Str& txt, state_machine& nm)$/;"	f	class:iwordstream	file:	access:private	signature:(_Str& txt, state_machine& nm)
iwordstream::try_to_read_symbol	compiler/extract.cpp	/^	int try_to_read_symbol(word& aword, int_type _Meta)$/;"	f	class:iwordstream	file:	access:private	signature:(word& aword, int_type _Meta)
key	include/buckethash.h	/^	typedef typename _K key;$/;"	t	class:buckethash	access:public
keyword	syntax/grammar.h	/^		keyword = 2, \/\/ keyword$/;"	e	enum:grammar::symtype
keywords	test/tinygrammartest.cpp	/^std::deque<std::pair<tstring, int32> > Asymbol::keywords;$/;"	m	class:Asymbol	file:
keywords	test/vhelp.h	/^	static std::deque<std::pair<tstring, int32> > keywords;$/;"	m	class:Asymbol	access:public
keywords_	syntax/grammar.h	/^	veckeywords keywords_;$/;"	m	class:grammar	access:protected
lalr1machine	compiler/lalr1machine.h	/^	lalr1machine();$/;"	p	class:lalr1machine	access:public	signature:()
lalr1machine	compiler/lalr1machine.h	/^class lalr1machine$/;"	c
lalr1machine::cstate_	compiler/lalr1machine.h	/^	int32 cstate_;$/;"	m	class:lalr1machine	access:private
lalr1machine::eta	compiler/lalr1machine.h	/^	bool eta(const symbol* sym);$/;"	p	class:lalr1machine	access:public	signature:(const symbol* sym)
lalr1machine::lalr1machine	compiler/lalr1machine.h	/^	lalr1machine();$/;"	p	class:lalr1machine	access:public	signature:()
lalr1machine::~lalr1machine	compiler/lalr1machine.h	/^	virtual ~lalr1machine();$/;"	p	class:lalr1machine	access:public	signature:()
list	galgorithm/regex2nfa.cpp	/^	struct list$/;"	s	struct:parsecontent	file:	access:public
list	tmp/back/regex2nfa.cpp	/^	struct list$/;"	s	struct:parsecontent	file:	access:public
ln	include/mathX.h	/^	static T ln(const T value)$/;"	f	class:math	access:public	signature:(const T value)
loader	syntax/loader.h	/^	loader();$/;"	p	class:loader	access:public	signature:()
loader	syntax/loader.h	/^	loader(const std::string& fname);$/;"	p	class:loader	access:public	signature:(const std::string& fname)
loader	syntax/loader.h	/^class loader$/;"	c
loader::file_	syntax/loader.h	/^	xml::ifile file_;$/;"	m	class:loader	access:private
loader::loader	syntax/loader.h	/^	loader();$/;"	p	class:loader	access:public	signature:()
loader::loader	syntax/loader.h	/^	loader(const std::string& fname);$/;"	p	class:loader	access:public	signature:(const std::string& fname)
loader::open	syntax/loader.h	/^	void open(const std::string& fname);$/;"	p	class:loader	access:public	signature:(const std::string& fname)
loader::operator >>	syntax/loader.h	/^	friend loader& operator>>(loader& Input, grammar& aGrammar);$/;"	p	class:loader	access:friend	signature:(loader& Input, grammar& aGrammar)
loader::readgrammar	syntax/loader.h	/^	void readgrammar(grammar& aGrammar);$/;"	p	class:loader	access:public	signature:(grammar& aGrammar)
loader::swap	syntax/loader.h	/^	void swap(loader& other);$/;"	p	class:loader	access:public	signature:(loader& other)
loader::~loader	syntax/loader.h	/^	virtual ~loader();$/;"	p	class:loader	access:public	signature:()
log	include/mathX.h	/^	static T log(const T value)$/;"	f	class:math	access:public	signature:(const T value)
log10	include/mathX.h	/^	static  T log10(const T value)$/;"	f	class:math	access:public	signature:(const T value)
log2	include/mathX.h	/^	static T log2(const T value)$/;"	f	class:math	access:public	signature:(const T value)
lranalyse	galgorithm/lranalyse.h	/^	lranalyse(const grammar& ing, lrmachine& lrm)$/;"	f	class:lranalyse	access:public	signature:(const grammar& ing, lrmachine& lrm)
lranalyse	galgorithm/lranalyse.h	/^class lranalyse : public grammar_algorithm$/;"	c	inherits:grammar_algorithm
lranalyse::gin_	galgorithm/lranalyse.h	/^	const grammar* gin_;$/;"	m	class:lranalyse	access:private
lranalyse::invoke	galgorithm/lranalyse.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:lranalyse	access:public	signature:()
lranalyse::lranalyse	galgorithm/lranalyse.h	/^	lranalyse(const grammar& ing, lrmachine& lrm)$/;"	f	class:lranalyse	access:public	signature:(const grammar& ing, lrmachine& lrm)
lranalyse::make_true_lr1	galgorithm/lranalyse.h	/^	void make_true_lr1(const tinygrammar& tig) const;$/;"	p	class:lranalyse	access:private	signature:(const tinygrammar& tig) const
lranalyse::mot_	galgorithm/lranalyse.h	/^	lrmachine* mot_;$/;"	m	class:lranalyse	access:private
lranalyse::operator ()	galgorithm/lranalyse.cpp	/^void lranalyse::operator()(const grammar& gin, lrmachine& mot) const$/;"	f	class:lranalyse	signature:(const grammar& gin, lrmachine& mot) const
lranalyse::operator ()	galgorithm/lranalyse.h	/^	void operator()(const grammar& gin, lrmachine& mot);$/;"	p	class:lranalyse	access:private	signature:(const grammar& gin, lrmachine& mot)
lrmachine	syntax/lrmachine.h	/^	lrmachine(const tinygrammar& g)$/;"	f	class:lrmachine	access:public	signature:(const tinygrammar& g)
lrmachine	syntax/lrmachine.h	/^class lrmachine : public automachine$/;"	c	inherits:automachine
lrmachine::accept_state	syntax/lrmachine.h	/^	enum { accept_state = 0}; \/\/ using state 0 as ending state$/;"	e	enum:lrmachine::__anon6
lrmachine::analysestack	syntax/lrmachine.h	/^	typedef std::stack<stackitem> analysestack;$/;"	t	class:lrmachine	access:private
lrmachine::eta	syntax/lrmachine.cpp	/^bool lrmachine::eta(int32 meta)$/;"	f	class:lrmachine	signature:(int32 meta)
lrmachine::eta	syntax/lrmachine.h	/^	\/* overwrite *\/ virtual bool eta(int meta);$/;"	p	class:lrmachine	access:public	signature:(int meta)
lrmachine::funcarray	syntax/lrmachine.h	/^	typedef kog::smart_vector<symfunc*> funcarray;$/;"	t	class:lrmachine	access:public
lrmachine::funcs_	syntax/lrmachine.h	/^	funcarray funcs_;$/;"	m	class:lrmachine	access:private
lrmachine::init	syntax/lrmachine.cpp	/^void lrmachine::init()$/;"	f	class:lrmachine	signature:()
lrmachine::init	syntax/lrmachine.h	/^	\/* overwrite *\/ virtual void init();$/;"	p	class:lrmachine	access:public	signature:()
lrmachine::int32array	syntax/lrmachine.h	/^	typedef kog::smart_vector<int32> int32array;$/;"	t	class:lrmachine	access:private
lrmachine::lrmachine	syntax/lrmachine.h	/^	lrmachine(const tinygrammar& g)$/;"	f	class:lrmachine	access:public	signature:(const tinygrammar& g)
lrmachine::pg_	syntax/lrmachine.h	/^	const tinygrammar* pg_;$/;"	m	class:lrmachine	access:private
lrmachine::pstack_	syntax/lrmachine.h	/^	analysestack pstack_;$/;"	m	class:lrmachine	access:private
lrmachine::reduce	syntax/lrmachine.cpp	/^int32 lrmachine::reduce(int32 pid)$/;"	f	class:lrmachine	signature:(int32 pid)
lrmachine::reduce	syntax/lrmachine.h	/^	int32 reduce(int32 pid);$/;"	p	class:lrmachine	access:protected	signature:(int32 pid)
lrmachine::stackitem	syntax/lrmachine.h	/^	struct stackitem$/;"	s	class:lrmachine	access:private
lrmachine::stackitem::meta	syntax/lrmachine.h	/^		int32 meta;$/;"	m	struct:lrmachine::stackitem	access:public
lrmachine::stackitem::stackitem	syntax/lrmachine.h	/^		stackitem(int32 s = -1, int32 m = -1)$/;"	f	struct:lrmachine::stackitem	access:public	signature:(int32 s = -1, int32 m = -1)
lrmachine::stackitem::state	syntax/lrmachine.h	/^		int32 state;$/;"	m	struct:lrmachine::stackitem	access:public
lrstate	galgorithm/lranalyse.cpp	/^class lrstate : public std::vector<lrstateitem>$/;"	c	file:	inherits:std::vector
lrstateitem	galgorithm/lranalyse.cpp	/^struct lrstateitem$/;"	s	file:
lrstateitem::dot	galgorithm/lranalyse.cpp	/^	int32 dot; \/\/ dot position$/;"	m	struct:lrstateitem	file:	access:public
lrstateitem::follow	galgorithm/lranalyse.cpp	/^	std::set<int32> follow;$/;"	m	struct:lrstateitem	file:	access:public
lrsts	galgorithm/lranalyse.cpp	/^	std::list<lrstate> lrsts;$/;"	m	struct:AlgorithmArg	file:	access:public
m	tmp/sizetest.cpp	/^	char m;$/;"	m	struct:A	file:	access:public
m_elemstack	third_party/xml/Markup.cpp	/^	ElemStack m_elemstack;$/;"	m	struct:FilePos	file:	access:public
m_fp	third_party/xml/Markup.cpp	/^	FILE* m_fp;$/;"	m	struct:FilePos	file:	access:public
m_iPos	third_party/xml/Markup.h	/^	int m_iPos;$/;"	m	class:CMarkup	access:protected
m_iPosChild	third_party/xml/Markup.h	/^	int m_iPosChild;$/;"	m	class:CMarkup	access:protected
m_iPosDeleted	third_party/xml/Markup.h	/^	int m_iPosDeleted;$/;"	m	class:CMarkup	access:protected
m_iPosFree	third_party/xml/Markup.h	/^	int m_iPosFree;$/;"	m	class:CMarkup	access:protected
m_iPosParent	third_party/xml/Markup.h	/^	int m_iPosParent;$/;"	m	class:CMarkup	access:protected
m_nBlockSizeBasis	third_party/xml/Markup.cpp	/^	int m_nBlockSizeBasis;$/;"	m	struct:FilePos	file:	access:public
m_nDocFlags	third_party/xml/Markup.cpp	/^	int m_nDocFlags;$/;"	m	struct:FilePos	file:	access:public
m_nDocFlags	third_party/xml/Markup.h	/^	int m_nDocFlags;$/;"	m	class:CMarkup	access:protected
m_nFailedChars	third_party/xml/Markup.cpp	/^	int m_nFailedChars;$/;"	m	struct:TextEncoding	file:	access:public
m_nFileByteLen	third_party/xml/Markup.cpp	/^	MCD_INTFILEOFFSET m_nFileByteLen;$/;"	m	struct:FilePos	file:	access:public
m_nFileByteOffset	third_party/xml/Markup.cpp	/^	MCD_INTFILEOFFSET m_nFileByteOffset;$/;"	m	struct:FilePos	file:	access:public
m_nFileCharUnitSize	third_party/xml/Markup.cpp	/^	int m_nFileCharUnitSize;$/;"	m	struct:FilePos	file:	access:public
m_nFromLen	third_party/xml/Markup.cpp	/^	int m_nFromLen;$/;"	m	struct:TextEncoding	file:	access:public
m_nL	third_party/xml/Markup.cpp	/^	int m_nL;$/;"	m	struct:TokenPos	file:	access:public
m_nNext	third_party/xml/Markup.cpp	/^	int m_nNext;$/;"	m	struct:TokenPos	file:	access:public
m_nNodeLength	third_party/xml/Markup.h	/^	int m_nNodeLength;$/;"	m	class:CMarkup	access:protected
m_nNodeOffset	third_party/xml/Markup.h	/^	int m_nNodeOffset;$/;"	m	class:CMarkup	access:protected
m_nNodeType	third_party/xml/Markup.h	/^	int m_nNodeType;$/;"	m	class:CMarkup	access:protected
m_nOpFileByteLen	third_party/xml/Markup.cpp	/^	int m_nOpFileByteLen;$/;"	m	struct:FilePos	file:	access:public
m_nOpFileTextLen	third_party/xml/Markup.cpp	/^	int m_nOpFileTextLen;$/;"	m	struct:FilePos	file:	access:public
m_nPreSpaceLength	third_party/xml/Markup.cpp	/^	int m_nPreSpaceLength;$/;"	m	struct:TokenPos	file:	access:public
m_nPreSpaceStart	third_party/xml/Markup.cpp	/^	int m_nPreSpaceStart;$/;"	m	struct:TokenPos	file:	access:public
m_nR	third_party/xml/Markup.cpp	/^	int m_nR;$/;"	m	struct:TokenPos	file:	access:public
m_nReadBufferRemoved	third_party/xml/Markup.cpp	/^	int m_nReadBufferRemoved;$/;"	m	struct:FilePos	file:	access:public
m_nReadBufferStart	third_party/xml/Markup.cpp	/^	int m_nReadBufferStart;$/;"	m	struct:FilePos	file:	access:public
m_nReadGatherStart	third_party/xml/Markup.cpp	/^	int m_nReadGatherStart;$/;"	m	struct:FilePos	file:	access:public
m_nSegs	third_party/xml/Markup.cpp	/^	int m_nSegs;$/;"	m	struct:ElemPosTree	file:	access:private
m_nSize	third_party/xml/Markup.cpp	/^	int m_nSize;$/;"	m	struct:ElemPosTree	file:	access:private
m_nToCount	third_party/xml/Markup.cpp	/^	int m_nToCount;$/;"	m	struct:TextEncoding	file:	access:public
m_nTokenFlags	third_party/xml/Markup.cpp	/^	int m_nTokenFlags;$/;"	m	struct:TokenPos	file:	access:public
m_pDebugCur	third_party/xml/Markup.h	/^	MCD_PCSZ m_pDebugCur;$/;"	m	class:CMarkup	access:protected
m_pDebugPos	third_party/xml/Markup.h	/^	MCD_PCSZ m_pDebugPos;$/;"	m	class:CMarkup	access:protected
m_pDocText	third_party/xml/Markup.cpp	/^	MCD_PCSZ m_pDocText;$/;"	m	struct:TokenPos	file:	access:public
m_pElemPosTree	third_party/xml/Markup.h	/^	ElemPosTree* m_pElemPosTree;$/;"	m	class:CMarkup	access:protected
m_pFilePos	third_party/xml/Markup.h	/^	FilePos* m_pFilePos;$/;"	m	class:CMarkup	access:protected
m_pFrom	third_party/xml/Markup.cpp	/^	const void* m_pFrom;$/;"	m	struct:TextEncoding	file:	access:public
m_pMaps	third_party/xml/Markup.cpp	/^	SavedPosMap** m_pMaps; \/\/ NULL terminated array$/;"	m	struct:SavedPosMapArray	file:	access:public
m_pReaderFilePos	third_party/xml/Markup.cpp	/^	FilePos* m_pReaderFilePos;$/;"	m	struct:TokenPos	file:	access:public
m_pSavedPosMaps	third_party/xml/Markup.h	/^	SavedPosMapArray* m_pSavedPosMaps;$/;"	m	class:CMarkup	access:protected
m_pSegs	third_party/xml/Markup.cpp	/^	ElemPos** m_pSegs;$/;"	m	struct:ElemPosTree	file:	access:private
m_pstrBuffer	third_party/xml/Markup.cpp	/^	MCD_STR* m_pstrBuffer;$/;"	m	struct:FilePos	file:	access:public
m_strDoc	third_party/xml/Markup.h	/^	MCD_STR m_strDoc;$/;"	m	class:CMarkup	access:protected
m_strEncoding	third_party/xml/Markup.cpp	/^	MCD_STR m_strEncoding;$/;"	m	struct:FilePos	file:	access:public
m_strFromEncoding	third_party/xml/Markup.cpp	/^	MCD_STR m_strFromEncoding;$/;"	m	struct:TextEncoding	file:	access:public
m_strIOResult	third_party/xml/Markup.cpp	/^	MCD_STR m_strIOResult;$/;"	m	struct:FilePos	file:	access:public
m_strReadGatherMarkup	third_party/xml/Markup.cpp	/^	MCD_STR m_strReadGatherMarkup;$/;"	m	struct:FilePos	file:	access:public
m_strResult	third_party/xml/Markup.h	/^	MCD_STR m_strResult;$/;"	m	class:CMarkup	access:protected
m_strToEncoding	third_party/xml/Markup.cpp	/^	MCD_STR m_strToEncoding;$/;"	m	struct:TextEncoding	file:	access:public
machines	compiler/compiler.h	/^	std::map<std::string, state_machine> machines;$/;"	m	class:compiler	access:private
main	test/input/easy.c	/^int main(int argc, const char* argv[])$/;"	f	signature:(int argc, const char* argv[])
main	test/unittest.cpp	/^int main(int argc, const char* argv[])$/;"	f	signature:(int argc, const char* argv[])
main	tmp/allchars.cpp	/^int main(int argc, const char* argv[])$/;"	f	signature:(int argc, const char* argv[])
main	tmp/boostregextest.cpp	/^int main(int argc, const char* argv[])$/;"	f	signature:(int argc, const char* argv[])
main	tmp/coutfun.cpp	/^int main(int argc, const char* argv[])$/;"	f	signature:(int argc, const char* argv[])
main	tmp/iterXtest.cpp	/^int main(int argc, const char* argv[])$/;"	f	signature:(int argc, const char* argv[])
main	tmp/protected.cpp	/^int main(int argc, const char* argv[])$/;"	f	signature:(int argc, const char* argv[])
main	tmp/sizetest.cpp	/^int main(int argc, const char* argv[])$/;"	f	signature:(int argc, const char* argv[])
make_index	syntax/symbol.cpp	/^void symholder::make_index()$/;"	f	class:symholder	signature:()
make_index	syntax/symbol.h	/^	void make_index();$/;"	p	class:symholder	access:public	signature:()
make_node	galgorithm/regex2nfa.cpp	/^	void make_node(const char* vs, const char* ve, int L)$/;"	f	struct:parsecontent	access:public	signature:(const char* vs, const char* ve, int L)
make_node	tmp/back/regex2nfa.cpp	/^	void make_node(const char* vs, const char* ve, int L)$/;"	f	struct:parsecontent	access:public	signature:(const char* vs, const char* ve, int L)
make_sure_dfa	galgorithm/dfa2machine.cpp	/^void dfa2machine::make_sure_dfa(const tinygrammar& tig) const$/;"	f	class:dfa2machine	signature:(const tinygrammar& tig) const
make_sure_dfa	galgorithm/dfa2machine.h	/^	void make_sure_dfa(const tinygrammar& input) const;$/;"	p	class:dfa2machine	access:private	signature:(const tinygrammar& input) const
make_sure_rg	galgorithm/nfa2dfa.cpp	/^void nfa2dfa::make_sure_rg(const grammar& gin)$/;"	f	class:nfa2dfa	signature:(const grammar& gin)
make_sure_rg	galgorithm/nfa2dfa.h	/^	void make_sure_rg(const grammar& input);$/;"	p	class:nfa2dfa	access:private	signature:(const grammar& input)
make_symbol	galgorithm/regex2nfa.cpp	/^	void make_symbol(const std::string& x, int L)$/;"	f	struct:parsecontent	access:public	signature:(const std::string& x, int L)
make_symbol	tmp/back/regex2nfa.cpp	/^	void make_symbol(const std::string& x, int L)$/;"	f	struct:parsecontent	access:public	signature:(const std::string& x, int L)
make_triple	include/functionalX.h	/^inline triple<_Ty1, _Ty2, _Ty3> make_triple(_Ty1 _Val1, _Ty2 _Val2, _Ty3 _Val3)$/;"	f	signature:(_Ty1 _Val1, _Ty2 _Val2, _Ty3 _Val3)
make_true_lr1	galgorithm/lranalyse.h	/^	void make_true_lr1(const tinygrammar& tig) const;$/;"	p	class:lranalyse	access:private	signature:(const tinygrammar& tig) const
match_machines	compiler/extract.cpp	/^	int32 match_machines(word& aword, int_type _Meta)$/;"	f	class:iwordstream	file:	access:private	signature:(word& aword, int_type _Meta)
math	include/mathX.h	/^class math$/;"	c
math::abs	include/mathX.h	/^	static T abs(const T value)$/;"	f	class:math	access:public	signature:(const T value)
math::atan	include/mathX.h	/^	static double atan(const T y, const T x)$/;"	f	class:math	access:public	signature:(const T y, const T x)
math::interpolate	include/mathX.h	/^	class interpolate$/;"	c	class:math	access:public
math::interpolate::calculateValue	include/mathX.h	/^		static T calculateValue(const T* xBegin, const T* yBegin, const size_t nSize, int index, const T& val)$/;"	f	class:math::interpolate	access:public	signature:(const T* xBegin, const T* yBegin, const size_t nSize, int index, const T& val)
math::interpolate::getIndex	include/mathX.h	/^		static int getIndex(const T* begin, const size_t nSize, const T& val)$/;"	f	class:math::interpolate	access:public	signature:(const T* begin, const size_t nSize, const T& val)
math::interpolate::interp	include/mathX.h	/^		static T interp(const T* xBegin, const T* yBegin, const size_t nSize, const T& val)$/;"	f	class:math::interpolate	access:public	signature:(const T* xBegin, const T* yBegin, const size_t nSize, const T& val)
math::interpolate::operator ()	include/mathX.h	/^		T operator()(const T* xBegin, const T* yBegin, const size_t nSize, const T& val) const$/;"	f	class:math::interpolate	access:public	signature:(const T* xBegin, const T* yBegin, const size_t nSize, const T& val) const
math::ln	include/mathX.h	/^	static T ln(const T value)$/;"	f	class:math	access:public	signature:(const T value)
math::log	include/mathX.h	/^	static T log(const T value)$/;"	f	class:math	access:public	signature:(const T value)
math::log10	include/mathX.h	/^	static  T log10(const T value)$/;"	f	class:math	access:public	signature:(const T value)
math::log2	include/mathX.h	/^	static T log2(const T value)$/;"	f	class:math	access:public	signature:(const T value)
math::round	include/mathX.h	/^	static _Result round(const _Arg value)$/;"	f	class:math	access:public	signature:(const _Arg value)
math::sqrt	include/mathX.h	/^	static T sqrt(const T value)$/;"	f	class:math	access:public	signature:(const T value)
math::square	include/mathX.h	/^	static T square(const T value)$/;"	f	class:math	access:public	signature:(const T value)
mem_value	include/functionalX.h	/^	typename mpl::parse_class_value_type<_Tx>::value_type> mem_value(_Tx _mp)$/;"	f	signature:(_Tx _mp)
mem_value_t	include/functionalX.h	/^	mem_value_t(mem_value_type _p)$/;"	f	struct:mem_value_t	access:public	signature:(mem_value_type _p)
mem_value_t	include/functionalX.h	/^struct mem_value_t : public std::unary_function<_Tc, _Ty>$/;"	s	inherits:std::unary_function
mem_value_t::_Myt	include/functionalX.h	/^	typedef mem_value_t<_Tc, _Ty> _Myt;$/;"	t	struct:mem_value_t	access:public
mem_value_t::_p_value	include/functionalX.h	/^	mem_value_type _p_value;$/;"	m	struct:mem_value_t	access:protected
mem_value_t::class_type	include/functionalX.h	/^	typedef _Tc class_type;$/;"	t	struct:mem_value_t	access:public
mem_value_t::class_type::mem_value_type	include/functionalX.h	/^	typedef value_type class_type::* mem_value_type;$/;"	t	class:mem_value_t::class_type	access:public
mem_value_t::const_reference_type	include/functionalX.h	/^	typedef const _Ty& const_reference_type;$/;"	t	struct:mem_value_t	access:public
mem_value_t::mem_value_t	include/functionalX.h	/^	mem_value_t(mem_value_type _p)$/;"	f	struct:mem_value_t	access:public	signature:(mem_value_type _p)
mem_value_t::operator ()	include/functionalX.h	/^	const_reference_type operator()(const class_type& _class) const$/;"	f	struct:mem_value_t	access:public	signature:(const class_type& _class) const
mem_value_t::operator ()	include/functionalX.h	/^	reference_type operator()(class_type& _class) const$/;"	f	struct:mem_value_t	access:public	signature:(class_type& _class) const
mem_value_t::reference_type	include/functionalX.h	/^	typedef _Ty& reference_type;$/;"	t	struct:mem_value_t	access:public
mem_value_t::value_type	include/functionalX.h	/^	typedef _Ty value_type;$/;"	t	struct:mem_value_t	access:public
mem_value_type	include/functionalX.h	/^	typedef value_type class_type::* mem_value_type;$/;"	t	class:mem_value_t::class_type	access:public
memblock	include/memoryX.h	/^struct memblock$/;"	s
memblock::const_iterator	include/memoryX.h	/^	typedef array_iterator<const value_type> const_iterator;$/;"	t	struct:memblock	access:public
memblock::const_pointer	include/memoryX.h	/^	typedef const value_type* const_pointer;$/;"	t	struct:memblock	access:public
memblock::const_reference	include/memoryX.h	/^	typedef const value_type& const_reference;$/;"	t	struct:memblock	access:public
memblock::const_reverse_iterator	include/memoryX.h	/^	typedef std::reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	struct:memblock	access:public
memblock::iterator	include/memoryX.h	/^	typedef array_iterator<value_type> iterator;$/;"	t	struct:memblock	access:public
memblock::pointer	include/memoryX.h	/^	typedef value_type* pointer;$/;"	t	struct:memblock	access:public
memblock::reference	include/memoryX.h	/^	typedef value_type& reference;$/;"	t	struct:memblock	access:public
memblock::reverse_iterator	include/memoryX.h	/^	typedef std::reverse_iterator<iterator> reverse_iterator;$/;"	t	struct:memblock	access:public
memblock::size_type	include/memoryX.h	/^	typedef std::size_t size_type;$/;"	t	struct:memblock	access:public
memblock::v	include/memoryX.h	/^	_Tx* v;$/;"	m	struct:memblock	access:private
memblock::value_type	include/memoryX.h	/^	typedef _Tx value_type;$/;"	t	struct:memblock	access:public
meta	include/stringXF.h	/^	_Elem meta(unsigned short _ch)$/;"	f	namespace:Format	signature:(unsigned short _ch)
meta	syntax/lrmachine.h	/^		int32 meta;$/;"	m	struct:lrmachine::stackitem	access:public
minargc_	test/unittest.h	/^	int minargc_;$/;"	m	class:unittest	access:private
mini_status	galgorithm/nfa2dfa.cpp	/^void nfa2dfa::mini_status(const tinygrammar& tig, tinygrammar& tog)$/;"	f	class:nfa2dfa	signature:(const tinygrammar& tig, tinygrammar& tog)
mini_status	galgorithm/nfa2dfa.h	/^	void mini_status(const tinygrammar& tig, tinygrammar& tog);$/;"	p	class:nfa2dfa	access:private	signature:(const tinygrammar& tig, tinygrammar& tog)
more	syntax/automachine.h	/^		void more(void* m) { more_ = m;}$/;"	f	class:automachine::sheetrow	access:public	signature:(void* m)
more	syntax/automachine.h	/^		void* more() const { return more_; }$/;"	f	class:automachine::sheetrow	access:public	signature:() const
more_	syntax/automachine.h	/^		void* more_;$/;"	m	class:automachine::sheetrow	access:private
mot_	galgorithm/dfa2machine.h	/^	automachine* mot_;$/;"	m	class:dfa2machine	access:private
mot_	galgorithm/lranalyse.h	/^	lrmachine* mot_;$/;"	m	class:lranalyse	access:private
n	galgorithm/regex2nfa.cpp	/^		int n;$/;"	m	struct:parsecontent::list	file:	access:public
n	tmp/back/regex2nfa.cpp	/^		int n;$/;"	m	struct:parsecontent::list	file:	access:public
nBomFlag	third_party/xml/Markup.cpp	/^struct BomTableStruct { const char* pszBom; int nBomLen; MCD_PCSZ pszBomEnc; int nBomFlag; } BomTable[] =$/;"	m	struct:BomTableStruct	file:	access:public
nBomLen	third_party/xml/Markup.cpp	/^struct BomTableStruct { const char* pszBom; int nBomLen; MCD_PCSZ pszBomEnc; int nBomFlag; } BomTable[] =$/;"	m	struct:BomTableStruct	file:	access:public
nCount	third_party/xml/Markup.cpp	/^	int nCount;$/;"	m	struct:TagPos	file:	access:public
nEndTagLen	third_party/xml/Markup.cpp	/^	unsigned int nEndTagLen : 10; \/\/ 1K limit for end tag$/;"	m	struct:ElemPos	file:	access:public
nFlags	third_party/xml/Markup.cpp	/^    int nFlags; \/\/ 16 bits flags, 16 bits level 65536 depth limit$/;"	m	struct:ElemPos	file:	access:public
nLen	third_party/xml/Markup.cpp	/^	int nLen;$/;"	m	struct:PathPos	file:	access:private
nLength	third_party/xml/Markup.cpp	/^	int nLength;$/;"	m	struct:ElemPos	file:	access:public
nLength	third_party/xml/Markup.cpp	/^	int nLength;$/;"	m	struct:NodePos	file:	access:public
nLevel	third_party/xml/Markup.cpp	/^	int nLevel;$/;"	m	struct:ElemStack	file:	access:public
nMapSize	third_party/xml/Markup.cpp	/^	int nMapSize;$/;"	m	struct:SavedPosMap	file:	access:public
nNodeFlags	third_party/xml/Markup.cpp	/^	int nNodeFlags;$/;"	m	struct:NodePos	file:	access:public
nNodeType	third_party/xml/Markup.cpp	/^	int nNodeType;$/;"	m	struct:NodePos	file:	access:public
nPathType	third_party/xml/Markup.cpp	/^	int nPathType; \/\/ -1 invalid, 0 empty, 1 name, 2 absolute path, 3 anywhere path$/;"	m	struct:PathPos	file:	access:private
nR	galgorithm/regex2nfa.cpp	/^		int nR; \/\/ right count$/;"	m	struct:parsecontent::prod	file:	access:public
nR	tmp/back/regex2nfa.cpp	/^		int nR; \/\/ right count$/;"	m	struct:parsecontent::prod	file:	access:public
nSavedPosFlags	third_party/xml/Markup.cpp	/^	int nSavedPosFlags;$/;"	m	struct:SavedPos	file:	access:public
nSize	third_party/xml/Markup.cpp	/^	int nSize;$/;"	m	struct:ElemStack	file:	access:protected
nSlot	third_party/xml/Markup.cpp	/^	int nSlot;$/;"	m	struct:TagPos	file:	access:public
nStart	third_party/xml/Markup.cpp	/^	int nStart;$/;"	m	struct:ElemPos	file:	access:public
nStart	third_party/xml/Markup.cpp	/^	int nStart;$/;"	m	struct:NodePos	file:	access:public
nStartTagLen	third_party/xml/Markup.cpp	/^	unsigned int nStartTagLen : 22; \/\/ 4MB limit for start tag$/;"	m	struct:ElemPos	file:	access:public
nTagNames	third_party/xml/Markup.cpp	/^	int nTagNames;$/;"	m	struct:TagPos	file:	access:public
name	galgorithm/grammaralgorithm.h	/^	const tstring& name() const$/;"	f	class:grammar_algorithm	access:public	signature:() const
name	syntax/symbol.h	/^	const tchar* name;$/;"	m	struct:symbol	access:public
name	syntax/symbol.h	/^	tstring name;$/;"	m	struct:symfunc	access:public
nameIndexer_	syntax/symbol.h	/^	std::map<const tchar*, const symbol*, stringless> nameIndexer_;$/;"	m	class:symholder	access:private
name_	galgorithm/grammaralgorithm.h	/^	tstring name_;$/;"	m	class:grammar_algorithm	access:private
new	third_party/xml/Markup.cpp	38;"	d	file:
new_error_msg	third_party/regex/xregex.h	/^	static std::string new_error_msg(const _Tx& _Src, const _Ty& _Dst)$/;"	f	class:stringX::convert_error	access:private	signature:(const _Tx& _Src, const _Ty& _Dst)
new_grammar	galgorithm/basicalgorithms.cpp	/^void removenotused::new_grammar(const grammar& gin, grammar& gout)$/;"	f	class:removenotused	signature:(const grammar& gin, grammar& gout)
new_grammar	galgorithm/basicalgorithms.h	/^	void new_grammar(const grammar& gin, grammar& gout); \/\/ create new grammmar$/;"	p	class:removenotused	access:private	signature:(const grammar& gin, grammar& gout)
new_list	galgorithm/regex2nfa.cpp	/^	list* new_list(list* pnext = NULL, int n = 0)$/;"	f	struct:parsecontent	access:public	signature:(list* pnext = NULL, int n = 0)
new_list	tmp/back/regex2nfa.cpp	/^	list* new_list(list* pnext = NULL, int n = 0)$/;"	f	struct:parsecontent	access:public	signature:(list* pnext = NULL, int n = 0)
new_start_symbol	galgorithm/basicalgorithms.cpp	/^void eliminate_eplison::new_start_symbol(const tinygrammar& tig, tinygrammar& tog)$/;"	f	class:eliminate_eplison	signature:(const tinygrammar& tig, tinygrammar& tog)
new_start_symbol	galgorithm/basicalgorithms.h	/^	void new_start_symbol(const tinygrammar& tig, tinygrammar& tog);$/;"	p	class:eliminate_eplison	access:private	signature:(const tinygrammar& tig, tinygrammar& tog)
newline	makecompiler/gensyntax.cpp	/^	static std::ostream& newline(std::ostream& os)$/;"	f	struct:tabident	access:public	signature:(std::ostream& os)
newline	tmp/coutfun.cpp	/^	static std::ostream& newline(std::ostream& os)$/;"	f	struct:Ident	access:public	signature:(std::ostream& os)
next	galgorithm/regex2nfa.cpp	/^		list* next;$/;"	m	struct:parsecontent::list	file:	access:public
next	tmp/back/regex2nfa.cpp	/^		list* next;$/;"	m	struct:parsecontent::list	file:	access:public
nextstate	galgorithm/lranalyse.cpp	/^	nextstate(const lrstate* p)$/;"	f	struct:nextstate	access:public	signature:(const lrstate* p)
nextstate	galgorithm/lranalyse.cpp	/^	nextstate(const production* p)$/;"	f	struct:nextstate	access:public	signature:(const production* p)
nextstate	galgorithm/lranalyse.cpp	/^struct nextstate$/;"	s	file:
nextstate::__anon1::pp	galgorithm/lranalyse.cpp	/^		const production* pp;$/;"	m	union:nextstate::__anon1	file:	access:public
nextstate::__anon1::ps	galgorithm/lranalyse.cpp	/^		const lrstate* ps;$/;"	m	union:nextstate::__anon1	file:	access:public
nextstate::nextstate	galgorithm/lranalyse.cpp	/^	nextstate(const lrstate* p)$/;"	f	struct:nextstate	access:public	signature:(const lrstate* p)
nextstate::nextstate	galgorithm/lranalyse.cpp	/^	nextstate(const production* p)$/;"	f	struct:nextstate	access:public	signature:(const production* p)
nextstate::sorp	galgorithm/lranalyse.cpp	/^	int32 sorp; \/\/ 0: s, 1: p$/;"	m	struct:nextstate	file:	access:public
nfa2dfa	galgorithm/nfa2dfa.h	/^	nfa2dfa(const grammar& gin, grammar& gout)$/;"	f	class:nfa2dfa	access:public	signature:(const grammar& gin, grammar& gout)
nfa2dfa	galgorithm/nfa2dfa.h	/^class nfa2dfa : public grammar_algorithm$/;"	c	inherits:grammar_algorithm
nfa2dfa::gin_	galgorithm/nfa2dfa.h	/^	const grammar* gin_;$/;"	m	class:nfa2dfa	access:private
nfa2dfa::got_	galgorithm/nfa2dfa.h	/^	grammar* got_;$/;"	m	class:nfa2dfa	access:private
nfa2dfa::invoke	galgorithm/nfa2dfa.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:nfa2dfa	access:public	signature:()
nfa2dfa::make_sure_rg	galgorithm/nfa2dfa.cpp	/^void nfa2dfa::make_sure_rg(const grammar& gin)$/;"	f	class:nfa2dfa	signature:(const grammar& gin)
nfa2dfa::make_sure_rg	galgorithm/nfa2dfa.h	/^	void make_sure_rg(const grammar& input);$/;"	p	class:nfa2dfa	access:private	signature:(const grammar& input)
nfa2dfa::mini_status	galgorithm/nfa2dfa.cpp	/^void nfa2dfa::mini_status(const tinygrammar& tig, tinygrammar& tog)$/;"	f	class:nfa2dfa	signature:(const tinygrammar& tig, tinygrammar& tog)
nfa2dfa::mini_status	galgorithm/nfa2dfa.h	/^	void mini_status(const tinygrammar& tig, tinygrammar& tog);$/;"	p	class:nfa2dfa	access:private	signature:(const tinygrammar& tig, tinygrammar& tog)
nfa2dfa::nfa2dfa	galgorithm/nfa2dfa.h	/^	nfa2dfa(const grammar& gin, grammar& gout)$/;"	f	class:nfa2dfa	access:public	signature:(const grammar& gin, grammar& gout)
nfa2dfa::operator ()	galgorithm/nfa2dfa.cpp	/^void nfa2dfa::operator()(const grammar& minput, grammar& motput)$/;"	f	class:nfa2dfa	signature:(const grammar& minput, grammar& motput)
nfa2dfa::operator ()	galgorithm/nfa2dfa.h	/^	void operator()(const grammar& input, grammar& otput);$/;"	p	class:nfa2dfa	access:private	signature:(const grammar& input, grammar& otput)
nfa2dfa::split	galgorithm/nfa2dfa.cpp	/^void nfa2dfa::split(const std::vector<const production*>& t, kog::smart_vector<int32>& smap, std::deque<std::set<int32> >& s) const$/;"	f	class:nfa2dfa	signature:(const std::vector<const production*>& t, kog::smart_vector<int32>& smap, std::deque<std::set<int32> >& s) const
nfa2dfa::split	galgorithm/nfa2dfa.h	/^	void split(const std::vector<const production*>& t, kog::smart_vector<int32>& smap, std::deque<std::set<int32> >& s) const;$/;"	p	class:nfa2dfa	access:private	signature:(const std::vector<const production*>& t, kog::smart_vector<int32>& smap, std::deque<std::set<int32> >& s) const
nfa2dfa::todfa	galgorithm/nfa2dfa.cpp	/^void nfa2dfa::todfa(const tinygrammar& tig, tinygrammar& tog)$/;"	f	class:nfa2dfa	signature:(const tinygrammar& tig, tinygrammar& tog)
nfa2dfa::todfa	galgorithm/nfa2dfa.h	/^	void todfa(const tinygrammar& tig, tinygrammar& tog);$/;"	p	class:nfa2dfa	access:private	signature:(const tinygrammar& tig, tinygrammar& tog)
nfa2dfa_test	test/nfa2dfatest.cpp	/^NEW_UNITTEST(nfa2dfa_test);$/;"	v
nfa2dfa_test	test/nfa2dfatest.cpp	/^class nfa2dfa_test : public sc::unittest$/;"	c	file:	inherits:sc::unittest
nfa2dfa_test::ginfile_	test/nfa2dfatest.cpp	/^	std::string ginfile_;$/;"	m	class:nfa2dfa_test	file:	access:private
nfa2dfa_test::gotfile_	test/nfa2dfatest.cpp	/^	std::string gotfile_;$/;"	m	class:nfa2dfa_test	file:	access:private
nfa2dfa_test::init	test/nfa2dfatest.cpp	/^	\/* overwrite *\/ virtual void init(int argc, const char* argv[])$/;"	f	class:nfa2dfa_test	file:	access:private	signature:(int argc, const char* argv[])
nfa2dfa_test::run_test	test/nfa2dfatest.cpp	/^	\/* overwrite *\/ virtual void run_test()$/;"	f	class:nfa2dfa_test	file:	access:private	signature:()
nfa2dfa_test::todfa	test/nfa2dfatest.cpp	/^	void todfa(const grammar& gin)$/;"	f	class:nfa2dfa_test	file:	access:private	signature:(const grammar& gin)
node	include/markuputils.h	/^	node(utils::ifile* f = NULL)$/;"	f	class:node	access:private	signature:(utils::ifile* f = NULL)
node	include/markuputils.h	/^class node$/;"	c
node::f_	include/markuputils.h	/^	ifile* f_;$/;"	m	class:node	access:private
node::node	include/markuputils.h	/^	node(utils::ifile* f = NULL)$/;"	f	class:node	access:private	signature:(utils::ifile* f = NULL)
node::operator []	include/markuputils.h	/^	tstring operator[](const tstring& tagname)$/;"	f	class:node	access:public	signature:(const tstring& tagname)
nonconst_type	include/iteratorX.h	/^	typedef array_iterator<typename mpl::remove_const<_Tx>::type> nonconst_type;$/;"	t	struct:array_iterator	access:public
nonconst_type	include/mplX.h	/^	typedef _T nonconst_type;$/;"	t	struct:add_const	access:public
nont	syntax/grammar.h	/^		nont = 0, \/\/non-terminate$/;"	e	enum:grammar::symtype
number	test/output/gen.cpp	/^	number()$/;"	f	struct:number	access:public	signature:()
number	test/output/gen.cpp	/^struct number : public type$/;"	s	file:	inherits:type
number	test/output/tinyg.cpp	/^	number()$/;"	f	struct:number	access:public	signature:()
number	test/output/tinyg.cpp	/^struct number : public type$/;"	s	file:	inherits:type
number::number	test/output/gen.cpp	/^	number()$/;"	f	struct:number	access:public	signature:()
number::number	test/output/tinyg.cpp	/^	number()$/;"	f	struct:number	access:public	signature:()
number::sid	test/output/gen.cpp	/^	enum{ sid = 1014 };$/;"	e	enum:number::__anon19	file:
number::sid	test/output/tinyg.cpp	/^	enum{ sid = 9 };$/;"	e	enum:number::__anon44	file:
op	test/output/gen.cpp	/^	op()$/;"	f	struct:op	access:public	signature:()
op	test/output/gen.cpp	/^struct op : public type$/;"	s	file:	inherits:type
op	test/output/tinyg.cpp	/^	op()$/;"	f	struct:op	access:public	signature:()
op	test/output/tinyg.cpp	/^struct op : public type$/;"	s	file:	inherits:type
op::op	test/output/gen.cpp	/^	op()$/;"	f	struct:op	access:public	signature:()
op::op	test/output/tinyg.cpp	/^	op()$/;"	f	struct:op	access:public	signature:()
op::sid	test/output/gen.cpp	/^	enum{ sid = 1015 };$/;"	e	enum:op::__anon20	file:
op::sid	test/output/tinyg.cpp	/^	enum{ sid = 11 };$/;"	e	enum:op::__anon46	file:
open	syntax/loader.h	/^	void open(const std::string& fname);$/;"	p	class:loader	access:public	signature:(const std::string& fname)
operator !=	include/iteratorX.h	/^	bool operator != (const _Myt& _Other) const$/;"	f	struct:array_iterator	access:public	signature:(const _Myt& _Other) const
operator !=	include/iteratorX.h	/^	bool operator != (const _Myt& _Other) const$/;"	f	struct:iterator_pair	access:public	signature:(const _Myt& _Other) const
operator ()	compiler/extract.cpp	/^streamsplit::deqwords& streamsplit::operator()(std::istream& is)$/;"	f	class:streamsplit	signature:(std::istream& is)
operator ()	compiler/extract.h	/^	deqwords& operator()(std::istream& is);$/;"	p	class:streamsplit	access:public	signature:(std::istream& is)
operator ()	galgorithm/basicalgorithms.cpp	/^void eliminate_eplison::operator()(const grammar& gin, grammar& gout)$/;"	f	class:eliminate_eplison	signature:(const grammar& gin, grammar& gout)
operator ()	galgorithm/basicalgorithms.cpp	/^void removenotused::operator()(const grammar& gin, grammar& gout)$/;"	f	class:removenotused	signature:(const grammar& gin, grammar& gout)
operator ()	galgorithm/basicalgorithms.cpp	/^void removesingle::operator()(const grammar& gin, grammar& gout)$/;"	f	class:removesingle	signature:(const grammar& gin, grammar& gout)
operator ()	galgorithm/basicalgorithms.cpp	/^void simplegrammar::operator()(const grammar& gin, grammar& gout)$/;"	f	class:simplegrammar	signature:(const grammar& gin, grammar& gout)
operator ()	galgorithm/basicalgorithms.h	/^	void operator()(const grammar& gin, grammar& gout);$/;"	p	class:eliminate_eplison	access:private	signature:(const grammar& gin, grammar& gout)
operator ()	galgorithm/basicalgorithms.h	/^	void operator()(const grammar& gin, grammar& gout);$/;"	p	class:removenotused	access:private	signature:(const grammar& gin, grammar& gout)
operator ()	galgorithm/basicalgorithms.h	/^	void operator()(const grammar& gin, grammar& gout);$/;"	p	class:removesingle	access:private	signature:(const grammar& gin, grammar& gout)
operator ()	galgorithm/basicalgorithms.h	/^	void operator()(const grammar& gin, grammar& gout);$/;"	p	class:simplegrammar	access:private	signature:(const grammar& gin, grammar& gout)
operator ()	galgorithm/dfa2machine.cpp	/^void dfa2machine::operator()(const tinygrammar& tig, automachine& mot)$/;"	f	class:dfa2machine	signature:(const tinygrammar& tig, automachine& mot)
operator ()	galgorithm/dfa2machine.h	/^	void operator()(const tinygrammar& input, automachine& otput);$/;"	p	class:dfa2machine	access:private	signature:(const tinygrammar& input, automachine& otput)
operator ()	galgorithm/eclosures.cpp	/^void eclosure::operator()(const tinygrammar& tig, closure_array& closures)$/;"	f	class:eclosure	signature:(const tinygrammar& tig, closure_array& closures)
operator ()	galgorithm/eclosures.h	/^	void operator()(const tinygrammar& tig, closure_array& closures);$/;"	p	class:eclosure	access:private	signature:(const tinygrammar& tig, closure_array& closures)
operator ()	galgorithm/firstfollow.cpp	/^void firstset::operator()(const grammar& gin, vecintset& sets)$/;"	f	class:firstset	signature:(const grammar& gin, vecintset& sets)
operator ()	galgorithm/firstfollow.cpp	/^void followset::operator()(const grammar& gin, const vecintset& FirstSets, vecintset& FollowSets)$/;"	f	class:followset	signature:(const grammar& gin, const vecintset& FirstSets, vecintset& FollowSets)
operator ()	galgorithm/firstfollow.h	/^	void operator()(const grammar& gin, const vecintset& firstsets, vecintset& followsets);$/;"	p	class:followset	access:private	signature:(const grammar& gin, const vecintset& firstsets, vecintset& followsets)
operator ()	galgorithm/firstfollow.h	/^	void operator()(const grammar& gin, vecintset& sets);$/;"	p	class:firstset	access:private	signature:(const grammar& gin, vecintset& sets)
operator ()	galgorithm/lranalyse.cpp	/^void lranalyse::operator()(const grammar& gin, lrmachine& mot) const$/;"	f	class:lranalyse	signature:(const grammar& gin, lrmachine& mot) const
operator ()	galgorithm/lranalyse.h	/^	void operator()(const grammar& gin, lrmachine& mot);$/;"	p	class:lranalyse	access:private	signature:(const grammar& gin, lrmachine& mot)
operator ()	galgorithm/nfa2dfa.cpp	/^void nfa2dfa::operator()(const grammar& minput, grammar& motput)$/;"	f	class:nfa2dfa	signature:(const grammar& minput, grammar& motput)
operator ()	galgorithm/nfa2dfa.h	/^	void operator()(const grammar& input, grammar& otput);$/;"	p	class:nfa2dfa	access:private	signature:(const grammar& input, grammar& otput)
operator ()	galgorithm/regex2nfa.cpp	/^void regex2nfa::operator()(const tstring& input, grammar& otput)$/;"	f	class:regex2nfa	signature:(const tstring& input, grammar& otput)
operator ()	galgorithm/regex2nfa.h	/^	void operator()(const tstring& input, grammar& otput);$/;"	p	class:regex2nfa	access:private	signature:(const tstring& input, grammar& otput)
operator ()	include/arrayX.h	/^	const_reference operator()(size_type r, size_type c) const { return _values[r][c]; }$/;"	f	struct:SmartMatrix	access:public	signature:(size_type r, size_type c) const
operator ()	include/arrayX.h	/^	reference operator()(size_type r, size_type c) { return _values[r][c]; }$/;"	f	struct:SmartMatrix	access:public	signature:(size_type r, size_type c)
operator ()	include/functionalX.h	/^	_Arg& operator()(_Arg& _arg) const$/;"	f	struct:NonOp	access:public	signature:(_Arg& _arg) const
operator ()	include/functionalX.h	/^	_Arg& operator()(_Arg& _dstVal, const _Arg& _srcVal) const$/;"	f	class:assign_t	access:public	signature:(_Arg& _dstVal, const _Arg& _srcVal) const
operator ()	include/functionalX.h	/^	_Result operator()(_Arg arg) const$/;"	f	struct:unary_function_adptor_t	access:public	signature:(_Arg arg) const
operator ()	include/functionalX.h	/^	_Result operator()(_Arg1 arg1, _Arg2 arg2) const$/;"	f	struct:binary_function_adptor_t	access:public	signature:(_Arg1 arg1, _Arg2 arg2) const
operator ()	include/functionalX.h	/^	_Result operator()(_Arg1 arg1, _Arg2 arg2, _Arg3 arg3) const$/;"	f	struct:triple_function_adptor_t	access:public	signature:(_Arg1 arg1, _Arg2 arg2, _Arg3 arg3) const
operator ()	include/functionalX.h	/^	_Tx& operator()(_Tx* p) const$/;"	f	struct:depointer_t	access:public	signature:(_Tx* p) const
operator ()	include/functionalX.h	/^	_Tx* operator()(_Tx& _Arg) const$/;"	f	struct:get_ptr_t	access:public	signature:(_Tx& _Arg) const
operator ()	include/functionalX.h	/^	_Ty operator()(const _Tx& _x) const$/;"	f	struct:explicit_convert_t	access:public	signature:(const _Tx& _x) const
operator ()	include/functionalX.h	/^	bool operator()(const _Arg& val) const$/;"	f	class:is_between_t	access:public	signature:(const _Arg& val) const
operator ()	include/functionalX.h	/^	const _Arg& operator()(const _Arg& _arg) const$/;"	f	struct:NonOp	access:public	signature:(const _Arg& _arg) const
operator ()	include/functionalX.h	/^	const _Tx& operator()(const _Tx* p) const$/;"	f	struct:depointer_t	access:public	signature:(const _Tx* p) const
operator ()	include/functionalX.h	/^	const _Tx* operator()(const _Tx& _Arg) const$/;"	f	struct:get_ptr_t	access:public	signature:(const _Tx& _Arg) const
operator ()	include/functionalX.h	/^	const_reference_type operator()(const class_type& _class) const$/;"	f	struct:mem_value_t	access:public	signature:(const class_type& _class) const
operator ()	include/functionalX.h	/^	reference operator()(_InIt _Iter) const$/;"	f	struct:dereference_t	access:public	signature:(_InIt _Iter) const
operator ()	include/functionalX.h	/^	reference_type operator()(class_type& _class) const$/;"	f	struct:mem_value_t	access:public	signature:(class_type& _class) const
operator ()	include/functionalX.h	/^	result_type operator()(argument_type& _arg) const$/;"	f	struct:composite_function_t	access:public	signature:(argument_type& _arg) const
operator ()	include/functionalX.h	/^	result_type operator()(const argument_type& _arg) const$/;"	f	struct:composite_function_t	access:public	signature:(const argument_type& _arg) const
operator ()	include/functionalX.h	/^	result_type operator()(const argument_type& arg) const$/;"	f	class:apply	access:public	signature:(const argument_type& arg) const
operator ()	include/functionalX.h	/^	result_type operator()(const first_argument_type& _arg1, const second_argument_type& _arg2) const$/;"	f	struct:composite_function2_t	access:public	signature:(const first_argument_type& _arg1, const second_argument_type& _arg2) const
operator ()	include/functionalX.h	/^	result_type operator()(first_argument_type& _arg1, second_argument_type& _arg2) const$/;"	f	struct:composite_function2_t	access:public	signature:(first_argument_type& _arg1, second_argument_type& _arg2) const
operator ()	include/functionalX.h	/^	typename _Fun::result_type operator()(_Tx* _Arg1, _Tx* _Arg2) const$/;"	f	struct:pointer_binary_function	access:public	signature:(_Tx* _Arg1, _Tx* _Arg2) const
operator ()	include/mathX.h	/^		T operator()(const T* xBegin, const T* yBegin, const size_t nSize, const T& val) const$/;"	f	class:math::interpolate	access:public	signature:(const T* xBegin, const T* yBegin, const size_t nSize, const T& val) const
operator ()	include/stringXF.h	/^		bool operator()(char _Ch) const$/;"	f	struct:Format::IsDigit	access:public	signature:(char _Ch) const
operator ()	include/stringXF.h	/^		bool operator()(char _Ch) const$/;"	f	struct:Format::IsSpace	access:public	signature:(char _Ch) const
operator ()	include/stringXF.h	/^		bool operator()(wchar_t _Ch) const$/;"	f	struct:Format::IsDigit	access:public	signature:(wchar_t _Ch) const
operator ()	include/stringXF.h	/^		bool operator()(wchar_t _Ch) const$/;"	f	struct:Format::IsSpace	access:public	signature:(wchar_t _Ch) const
operator ()	include/stringXF.h	/^	bool operator()(const std::basic_string<_Elem>& str1, const std::basic_string<_Elem>& str2) const$/;"	f	struct:stringcmp	access:public	signature:(const std::basic_string<_Elem>& str1, const std::basic_string<_Elem>& str2) const
operator ()	makecompiler/gensyntax.cpp	/^void syntaxgenerator::operator()(const grammar* aGrammar, const tstring& outfile)$/;"	f	class:syntaxgenerator	signature:(const grammar* aGrammar, const tstring& outfile)
operator ()	makecompiler/gensyntax.h	/^	void operator()(const grammar* aGrammar, const tstring& outfile);$/;"	p	class:syntaxgenerator	access:public	signature:(const grammar* aGrammar, const tstring& outfile)
operator ()	syntax/automachine.h	/^	bool operator()(const std::pair<int, int>& p1, const std::pair<int, int>& p2) const$/;"	f	struct:intpair_cmp	access:public	signature:(const std::pair<int, int>& p1, const std::pair<int, int>& p2) const
operator ()	syntax/production.h	/^	bool operator()(const production& p1, const production& p2) const$/;"	f	struct:p_cmp	access:public	signature:(const production& p1, const production& p2) const
operator ()	syntax/production.h	/^	bool operator()(const production& p1, const production& p2) const$/;"	f	struct:pfirstright_cmp	access:public	signature:(const production& p1, const production& p2) const
operator ()	syntax/production.h	/^	bool operator()(const production& p1, const production& p2) const$/;"	f	struct:pleft_cmp	access:public	signature:(const production& p1, const production& p2) const
operator ()	syntax/production.h	/^	bool operator()(const production& p1, const production& p2) const$/;"	f	struct:pright_cmp	access:public	signature:(const production& p1, const production& p2) const
operator ()	syntax/production.h	/^	bool operator()(const production& p1, const production& p2) const$/;"	f	struct:prod_less	access:public	signature:(const production& p1, const production& p2) const
operator ()	syntax/symbol.h	/^	bool operator()(const symbol& s1, const symbol& s2) const$/;"	f	struct:symbolname_Cmp	access:public	signature:(const symbol& s1, const symbol& s2) const
operator ()	syntax/symbol.h	/^	bool operator()(const tchar* str1, const tchar* str2) const$/;"	f	struct:stringless	access:public	signature:(const tchar* str1, const tchar* str2) const
operator ()	tmp/back/regex2nfa.cpp	/^void regex2nfa::operator()(const tstring& input, grammar& otput)$/;"	f	class:regex2nfa	signature:(const tstring& input, grammar& otput)
operator *	include/iteratorX.h	/^	reference operator*() const { return *_ptr; }$/;"	f	struct:array_iterator	access:public	signature:() const
operator *	include/share_ptr.h	/^	_Tx& operator*() const$/;"	f	class:share_ptr	access:public	signature:() const
operator +	include/iteratorX.h	/^	_Myt operator +(distance_type _Dis) const$/;"	f	struct:array_iterator	access:public	signature:(distance_type _Dis) const
operator +	include/iteratorX.h	/^	friend _Myt operator+ (distance_type _Dis, const _Myt& _Iter)$/;"	f	struct:array_iterator	access:friend	signature:(distance_type _Dis, const _Myt& _Iter)
operator +	include/stringX.h	/^	_Myt operator +(const _Elem _Right) const$/;"	f	class:xstring_basic	access:public	signature:(const _Elem _Right) const
operator +	include/stringX.h	/^	_Myt operator +(const _Elem* _Right) const$/;"	f	class:xstring_basic	access:public	signature:(const _Elem* _Right) const
operator +	include/stringX.h	/^	_Myt operator +(const _Mybase& _Right) const$/;"	f	class:xstring_basic	access:public	signature:(const _Mybase& _Right) const
operator +	include/stringX.h	/^	_Myt operator +(const _Tz& _tz) const$/;"	f	class:xstring_basic	access:public	signature:(const _Tz& _tz) const
operator ++	include/iteratorX.h	/^	_Myt operator++(int) { _Myt temp(*this); forward(); return temp;}$/;"	f	struct:iterator_pair	access:public	signature:(int)
operator ++	include/iteratorX.h	/^	_Myt operator++(int) { _Myt temp(*this); forward(*this); return temp;}$/;"	f	struct:array_iterator	access:public	signature:(int)
operator ++	include/iteratorX.h	/^	_Myt& operator++() { return forward(); }$/;"	f	struct:iterator_pair	access:public	signature:()
operator ++	include/iteratorX.h	/^	_Myt& operator++() { return forward(*this); }$/;"	f	struct:array_iterator	access:public	signature:()
operator +=	include/iteratorX.h	/^	_Myt& operator +=(distance_type _Dis)$/;"	f	struct:array_iterator	access:public	signature:(distance_type _Dis)
operator +=	include/stringX.h	/^	_Myt& operator +=(const _Myt& _Right)$/;"	f	class:xstring_basic	access:public	signature:(const _Myt& _Right)
operator +=	include/stringX.h	/^	_Myt& operator +=(const _Tz& _tz)$/;"	f	class:xstring_basic	access:public	signature:(const _Tz& _tz)
operator -	include/iteratorX.h	/^	_Myt operator -(distance_type _Dis) const$/;"	f	struct:array_iterator	access:public	signature:(distance_type _Dis) const
operator -	include/iteratorX.h	/^	distance_type operator -(const _Myt& _PY) const$/;"	f	struct:array_iterator	access:public	signature:(const _Myt& _PY) const
operator --	include/iteratorX.h	/^	_Myt operator--(int) { _Myt temp(*this); backward(); return temp; }$/;"	f	struct:iterator_pair	access:public	signature:(int)
operator --	include/iteratorX.h	/^	_Myt operator--(int) { _Myt temp(*this); backward(*this); return temp; }$/;"	f	struct:array_iterator	access:public	signature:(int)
operator --	include/iteratorX.h	/^	_Myt& operator--() { return backward(); }$/;"	f	struct:iterator_pair	access:public	signature:()
operator --	include/iteratorX.h	/^	_Myt& operator--() { return backward(*this); }$/;"	f	struct:array_iterator	access:public	signature:()
operator -=	include/iteratorX.h	/^	_Myt& operator -=(distance_type _Dis)$/;"	f	struct:array_iterator	access:public	signature:(distance_type _Dis)
operator ->	include/functionalX.h	/^	T* operator->()$/;"	f	class:ref_obj	access:public	signature:()
operator ->	include/iteratorX.h	/^	pointer operator->() const { return _ptr; }$/;"	f	struct:array_iterator	access:public	signature:() const
operator ->	include/share_ptr.h	/^	_Tx* operator->() const$/;"	f	class:share_ptr	access:public	signature:() const
operator <	include/iteratorX.h	/^	bool operator <(const _Myt& _Other) const$/;"	f	struct:array_iterator	access:public	signature:(const _Myt& _Other) const
operator <<	makecompiler/gensyntax.cpp	/^	friend std::ostream& operator<<(std::ostream& os, const tabident& a)$/;"	f	struct:tabident	access:friend	signature:(std::ostream& os, const tabident& a)
operator <<	test/gio.h	/^	gwriter& operator<<(const compile::grammar& g)$/;"	f	class:gwriter	access:public	signature:(const compile::grammar& g)
operator <<	tmp/coutfun.cpp	/^	friend std::ostream& operator<<(std::ostream& os, const Ident& a)$/;"	f	struct:Ident	access:friend	signature:(std::ostream& os, const Ident& a)
operator <=	include/iteratorX.h	/^	bool operator <=(const _Myt& _Other) const$/;"	f	struct:array_iterator	access:public	signature:(const _Myt& _Other) const
operator =	include/arrayX.h	/^	_Myt& operator=(const _Myt& _Other)$/;"	f	class:smart_vector	access:public	signature:(const _Myt& _Other)
operator =	include/arrayX.h	/^	_Myt& operator=(const _Tx& _val)$/;"	f	class:smart_vector	access:public	signature:(const _Tx& _val)
operator =	include/arrayX.h	/^	_Myt& operator=(const _Ty& val)$/;"	f	struct:SmartArray	access:public	signature:(const _Ty& val)
operator =	include/share_ptr.h	/^	share_ptr<_Tx>& operator=(const share_ptr<_Ty>& other) throw ()$/;"	f	class:share_ptr	access:public	signature:(const share_ptr<_Ty>& other)
operator =	include/singleton.h	/^	singleton_type& operator=(const singleton_type& other);$/;"	p	class:singleton	access:private	signature:(const singleton_type& other)
operator =	third_party/xml/Markup.cpp	/^void CMarkup::operator=( const CMarkup& markup )$/;"	f	class:CMarkup	signature:( const CMarkup& markup )
operator =	third_party/xml/Markup.h	/^	void operator=( const CMarkup& markup );$/;"	p	class:CMarkup	access:public	signature:( const CMarkup& markup )
operator ==	include/iteratorX.h	/^	bool operator == (const _Myt& _Other) const$/;"	f	struct:array_iterator	access:public	signature:(const _Myt& _Other) const
operator ==	include/iteratorX.h	/^	bool operator == (const _Myt& _Other) const$/;"	f	struct:iterator_pair	access:public	signature:(const _Myt& _Other) const
operator >	include/iteratorX.h	/^	bool operator >(const _Myt& _Other) const$/;"	f	struct:array_iterator	access:public	signature:(const _Myt& _Other) const
operator >=	include/iteratorX.h	/^	bool operator >=(const _Myt& _Other) const$/;"	f	struct:array_iterator	access:public	signature:(const _Myt& _Other) const
operator >>	compiler/extract.cpp	/^	iwordstream& operator>>(word& aword)$/;"	f	class:iwordstream	access:public	signature:(word& aword)
operator >>	syntax/loader.h	/^	friend loader& operator>>(loader& Input, grammar& aGrammar);$/;"	p	class:loader	access:friend	signature:(loader& Input, grammar& aGrammar)
operator >>	test/gio.h	/^	greader& operator>>(compile::grammar& g)$/;"	f	class:greader	access:public	signature:(compile::grammar& g)
operator MCD_PCSZ	third_party/xml/Markup.h	/^	operator MCD_PCSZ() const { return pcsz; };$/;"	f	struct:MCD_CSTR	access:public	signature:() const
operator MCD_PCSZ_FILENAME	third_party/xml/Markup.h	/^	operator MCD_PCSZ_FILENAME() const { return pcsz; };$/;"	f	struct:MCD_CSTR_FILENAME	access:public	signature:() const
operator []	include/arrayX.h	/^	ConstRowVector operator[](size_type idx) const{return _values[idx];}$/;"	f	struct:SmartMatrix	access:public	signature:(size_type idx) const
operator []	include/arrayX.h	/^	RowVector operator[](size_type idx) {return _values[idx];}$/;"	f	struct:SmartMatrix	access:public	signature:(size_type idx)
operator []	include/arrayX.h	/^	const_reference operator[](size_type idx) const { return _buf[idx]; }$/;"	f	struct:SmartArray	access:public	signature:(size_type idx) const
operator []	include/arrayX.h	/^	const_reference operator[](size_type idx) const { return buf_.values[idx]; }$/;"	f	class:smart_vector	access:public	signature:(size_type idx) const
operator []	include/arrayX.h	/^	reference operator[](size_type idx) { return _buf[idx]; }$/;"	f	struct:SmartArray	access:public	signature:(size_type idx)
operator []	include/arrayX.h	/^	reference operator[](size_type idx) { return buf_.values[idx]; }$/;"	f	class:smart_vector	access:public	signature:(size_type idx)
operator []	include/buckethash.h	/^	value& operator[](const key& k)$/;"	f	class:buckethash	access:public	signature:(const key& k)
operator []	include/iteratorX.h	/^	reference operator[](distance_type _Dis) { return _ptr[_Dis]; }$/;"	f	struct:array_iterator	access:public	signature:(distance_type _Dis)
operator []	include/markuputils.h	/^	tstring operator[](const tstring& tagname)$/;"	f	class:node	access:public	signature:(const tstring& tagname)
operator _Mybase&	include/stringX.h	/^	operator _Mybase&()$/;"	f	class:xstring_basic	access:public	signature:()
operator const _Mybase&	include/stringX.h	/^	operator const _Mybase&() const$/;"	f	class:xstring_basic	access:public	signature:() const
operator const_ref_type	include/functionalX.h	/^	operator const_ref_type() const$/;"	f	class:ref_obj	access:public	signature:() const
operator int32	test/vhelp.h	/^	operator int32() const$/;"	f	struct:symindex	access:public	signature:() const
operator ref_type	include/functionalX.h	/^	operator ref_type()$/;"	f	class:ref_obj	access:public	signature:()
os_	test/gio.h	/^	std::ostream& os_;$/;"	m	class:gwriter	access:private
otput	test/splitwords.cpp	/^	std::string otput;$/;"	m	class:splitwords_test	file:	access:private
out	include/markuputils.h	/^	enum {in = 0, out = 1};$/;"	e	enum:file::__anon3
outfile	test/regexnfatest.cpp	/^	std::string outfile;$/;"	m	class:regex2nfa_test	file:	access:private
outfolder_	test/unittest.h	/^	std::string outfolder_;$/;"	m	class:unittest	access:private
outof	include/markuputils.h	/^	void outof()$/;"	f	class:file	access:public	signature:()
outputSets	test/firstfollowtest.cpp	/^	void outputSets(const firstset::vecintset& sets, const symholder& sholder, std::ostream& os, const std::string& sname)$/;"	f	class:firstfollow_test	file:	access:private	signature:(const firstset::vecintset& sets, const symholder& sholder, std::ostream& os, const std::string& sname)
output_first_follow_set	test/firstfollowtest.cpp	/^	void output_first_follow_set(const grammar& g)$/;"	f	class:firstfollow_test	file:	access:private	signature:(const grammar& g)
p	third_party/xml/Markup.cpp	/^	MCD_PCSZ p;$/;"	m	struct:PathPos	file:	access:private
pL	third_party/xml/Markup.cpp	/^	TagPos* pL;$/;"	m	struct:ElemStack	file:	access:protected
pTable	third_party/xml/Markup.cpp	/^	SavedPos** pTable;$/;"	m	struct:SavedPosMap	file:	access:public
p_brace	galgorithm/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon2	file:
p_brace	tmp/back/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon68	file:
p_cmp	syntax/production.h	/^struct p_cmp<_Less, std::logical_and<bool> > : public std::binary_function<production, production, bool>$/;"	s	inherits:std::binary_function
p_cmp	syntax/production.h	/^struct p_cmp<_Less, std::logical_or<bool> > : public std::binary_function<production, production, bool>$/;"	s	inherits:std::binary_function
p_cmp::operator ()	syntax/production.h	/^	bool operator()(const production& p1, const production& p2) const$/;"	f	struct:p_cmp	access:public	signature:(const production& p1, const production& p2) const
p_equal	syntax/production.h	/^typedef p_cmp<std::equal_to<int32>, std::logical_and<bool> > p_equal;$/;"	t
p_less	syntax/production.h	/^typedef p_cmp<std::less<int32>, std::logical_or<bool> > p_less;$/;"	t
p_or	galgorithm/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon2	file:
p_or	tmp/back/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon68	file:
p_rep	galgorithm/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon2	file:
p_rep	tmp/back/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon68	file:
p_seq	galgorithm/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon2	file:
p_seq	tmp/back/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon68	file:
p_switch	galgorithm/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon2	file:
p_switch	tmp/back/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon68	file:
parse	include/stringX.h	/^	static _Tz parse(const _Myt& str)$/;"	f	class:xstring_basic	access:public	signature:(const _Myt& str)
parse_class_value_type	include/mplX.h	/^struct parse_class_value_type$/;"	s
parse_class_value_type	include/mplX.h	/^struct parse_class_value_type<_Ty _Tc::*>$/;"	s
parse_class_value_type::class_type	include/mplX.h	/^	typedef _Tc class_type;$/;"	t	struct:parse_class_value_type	access:public
parse_class_value_type::class_type	include/mplX.h	/^	typedef _Tx class_type;$/;"	t	struct:parse_class_value_type	access:public
parse_class_value_type::value_type	include/mplX.h	/^	typedef _Tx value_type;$/;"	t	struct:parse_class_value_type	access:public
parse_class_value_type::value_type	include/mplX.h	/^	typedef _Ty value_type;$/;"	t	struct:parse_class_value_type	access:public
parsecontent	galgorithm/regex2nfa.cpp	/^	parsecontent(const char* p)$/;"	f	struct:parsecontent	access:public	signature:(const char* p)
parsecontent	galgorithm/regex2nfa.cpp	/^struct parsecontent$/;"	s	file:
parsecontent	tmp/back/regex2nfa.cpp	/^	parsecontent(const char* p)$/;"	f	struct:parsecontent	access:public	signature:(const char* p)
parsecontent	tmp/back/regex2nfa.cpp	/^struct parsecontent$/;"	s	file:
parsecontent::brace_stage	galgorithm/regex2nfa.cpp	/^	int brace_stage(int L, char rc\/*, int& end*\/)$/;"	f	struct:parsecontent	access:public	signature:(int L, char rc )
parsecontent::brace_stage	tmp/back/regex2nfa.cpp	/^	int brace_stage(int L, char rc\/*, int& end*\/)$/;"	f	struct:parsecontent	access:public	signature:(int L, char rc )
parsecontent::buf	galgorithm/regex2nfa.cpp	/^	std::deque<int> buf;$/;"	m	struct:parsecontent	file:	access:public
parsecontent::buf	tmp/back/regex2nfa.cpp	/^	std::deque<int> buf;$/;"	m	struct:parsecontent	file:	access:public
parsecontent::getsymbol	galgorithm/regex2nfa.cpp	/^	int getsymbol(int sid)$/;"	f	struct:parsecontent	access:public	signature:(int sid)
parsecontent::getsymbol	tmp/back/regex2nfa.cpp	/^	int getsymbol(int sid)$/;"	f	struct:parsecontent	access:public	signature:(int sid)
parsecontent::iS	galgorithm/regex2nfa.cpp	/^	int iS;$/;"	m	struct:parsecontent	file:	access:public
parsecontent::iS	tmp/back/regex2nfa.cpp	/^	int iS;$/;"	m	struct:parsecontent	file:	access:public
parsecontent::insert	galgorithm/regex2nfa.cpp	/^	void insert(list* ph, int v)$/;"	f	struct:parsecontent	access:public	signature:(list* ph, int v)
parsecontent::insert	tmp/back/regex2nfa.cpp	/^	void insert(list* ph, int v)$/;"	f	struct:parsecontent	access:public	signature:(list* ph, int v)
parsecontent::insert_new_prod	galgorithm/regex2nfa.cpp	/^	void insert_new_prod(int L, const int* R, int c, int prod_type)$/;"	f	struct:parsecontent	access:public	signature:(int L, const int* R, int c, int prod_type)
parsecontent::insert_new_prod	tmp/back/regex2nfa.cpp	/^	void insert_new_prod(int L, const int* R, int c, int prod_type)$/;"	f	struct:parsecontent	access:public	signature:(int L, const int* R, int c, int prod_type)
parsecontent::isrealsep	galgorithm/regex2nfa.cpp	/^	bool isrealsep(const char* p, const char* s)$/;"	f	struct:parsecontent	access:public	signature:(const char* p, const char* s)
parsecontent::isrealsep	tmp/back/regex2nfa.cpp	/^	bool isrealsep(const char* p, const char* s)$/;"	f	struct:parsecontent	access:public	signature:(const char* p, const char* s)
parsecontent::isrepat	galgorithm/regex2nfa.cpp	/^	int isrepat(const char*& s)$/;"	f	struct:parsecontent	access:public	signature:(const char*& s)
parsecontent::isrepat	tmp/back/regex2nfa.cpp	/^	int isrepat(const char*& s)$/;"	f	struct:parsecontent	access:public	signature:(const char*& s)
parsecontent::list	galgorithm/regex2nfa.cpp	/^	struct list$/;"	s	struct:parsecontent	file:	access:public
parsecontent::list	tmp/back/regex2nfa.cpp	/^	struct list$/;"	s	struct:parsecontent	file:	access:public
parsecontent::list::n	galgorithm/regex2nfa.cpp	/^		int n;$/;"	m	struct:parsecontent::list	file:	access:public
parsecontent::list::n	tmp/back/regex2nfa.cpp	/^		int n;$/;"	m	struct:parsecontent::list	file:	access:public
parsecontent::list::next	galgorithm/regex2nfa.cpp	/^		list* next;$/;"	m	struct:parsecontent::list	file:	access:public
parsecontent::list::next	tmp/back/regex2nfa.cpp	/^		list* next;$/;"	m	struct:parsecontent::list	file:	access:public
parsecontent::make_node	galgorithm/regex2nfa.cpp	/^	void make_node(const char* vs, const char* ve, int L)$/;"	f	struct:parsecontent	access:public	signature:(const char* vs, const char* ve, int L)
parsecontent::make_node	tmp/back/regex2nfa.cpp	/^	void make_node(const char* vs, const char* ve, int L)$/;"	f	struct:parsecontent	access:public	signature:(const char* vs, const char* ve, int L)
parsecontent::make_symbol	galgorithm/regex2nfa.cpp	/^	void make_symbol(const std::string& x, int L)$/;"	f	struct:parsecontent	access:public	signature:(const std::string& x, int L)
parsecontent::make_symbol	tmp/back/regex2nfa.cpp	/^	void make_symbol(const std::string& x, int L)$/;"	f	struct:parsecontent	access:public	signature:(const std::string& x, int L)
parsecontent::new_list	galgorithm/regex2nfa.cpp	/^	list* new_list(list* pnext = NULL, int n = 0)$/;"	f	struct:parsecontent	access:public	signature:(list* pnext = NULL, int n = 0)
parsecontent::new_list	tmp/back/regex2nfa.cpp	/^	list* new_list(list* pnext = NULL, int n = 0)$/;"	f	struct:parsecontent	access:public	signature:(list* pnext = NULL, int n = 0)
parsecontent::p_brace	galgorithm/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon2	file:
parsecontent::p_brace	tmp/back/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon68	file:
parsecontent::p_or	galgorithm/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon2	file:
parsecontent::p_or	tmp/back/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon68	file:
parsecontent::p_rep	galgorithm/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon2	file:
parsecontent::p_rep	tmp/back/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon68	file:
parsecontent::p_seq	galgorithm/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon2	file:
parsecontent::p_seq	tmp/back/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon68	file:
parsecontent::p_switch	galgorithm/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon2	file:
parsecontent::p_switch	tmp/back/regex2nfa.cpp	/^	enum {p_or, p_switch, p_seq, p_rep, p_brace};$/;"	e	enum:parsecontent::__anon68	file:
parsecontent::parsecontent	galgorithm/regex2nfa.cpp	/^	parsecontent(const char* p)$/;"	f	struct:parsecontent	access:public	signature:(const char* p)
parsecontent::parsecontent	tmp/back/regex2nfa.cpp	/^	parsecontent(const char* p)$/;"	f	struct:parsecontent	access:public	signature:(const char* p)
parsecontent::prod	galgorithm/regex2nfa.cpp	/^	struct prod$/;"	s	struct:parsecontent	file:	access:public
parsecontent::prod	tmp/back/regex2nfa.cpp	/^	struct prod$/;"	s	struct:parsecontent	file:	access:public
parsecontent::prod::L	galgorithm/regex2nfa.cpp	/^		int L; \/\/ left$/;"	m	struct:parsecontent::prod	file:	access:public
parsecontent::prod::L	tmp/back/regex2nfa.cpp	/^		int L; \/\/ left$/;"	m	struct:parsecontent::prod	file:	access:public
parsecontent::prod::iR	galgorithm/regex2nfa.cpp	/^		int iR; \/\/ first right index$/;"	m	struct:parsecontent::prod	file:	access:public
parsecontent::prod::iR	tmp/back/regex2nfa.cpp	/^		int iR; \/\/ first right index$/;"	m	struct:parsecontent::prod	file:	access:public
parsecontent::prod::nR	galgorithm/regex2nfa.cpp	/^		int nR; \/\/ right count$/;"	m	struct:parsecontent::prod	file:	access:public
parsecontent::prod::nR	tmp/back/regex2nfa.cpp	/^		int nR; \/\/ right count$/;"	m	struct:parsecontent::prod	file:	access:public
parsecontent::prod::pt	galgorithm/regex2nfa.cpp	/^		int pt; \/\/ production type: p_or, p_switch, p_seq$/;"	m	struct:parsecontent::prod	file:	access:public
parsecontent::prod::pt	tmp/back/regex2nfa.cpp	/^		int pt; \/\/ production type: p_or, p_switch, p_seq$/;"	m	struct:parsecontent::prod	file:	access:public
parsecontent::prods	galgorithm/regex2nfa.cpp	/^	std::deque<prod> prods;$/;"	m	struct:parsecontent	file:	access:public
parsecontent::prods	tmp/back/regex2nfa.cpp	/^	std::deque<prod> prods;$/;"	m	struct:parsecontent	file:	access:public
parsecontent::s	galgorithm/regex2nfa.cpp	/^	const char* s;$/;"	m	struct:parsecontent	file:	access:public
parsecontent::s	tmp/back/regex2nfa.cpp	/^	const char* s;$/;"	m	struct:parsecontent	file:	access:public
parsecontent::switch_brace_or	galgorithm/regex2nfa.cpp	/^	int switch_brace_or(std::vector<int>& R, const char* p, int L, char rc)$/;"	f	struct:parsecontent	access:public	signature:(std::vector<int>& R, const char* p, int L, char rc)
parsecontent::switch_brace_or	tmp/back/regex2nfa.cpp	/^	int switch_brace_or(std::vector<int>& R, const char* p, int L, char rc)$/;"	f	struct:parsecontent	access:public	signature:(std::vector<int>& R, const char* p, int L, char rc)
parsecontent::sym	galgorithm/regex2nfa.cpp	/^	struct sym$/;"	s	struct:parsecontent	file:	access:public
parsecontent::sym	tmp/back/regex2nfa.cpp	/^	struct sym$/;"	s	struct:parsecontent	file:	access:public
parsecontent::sym::s	galgorithm/regex2nfa.cpp	/^		std::string s;$/;"	m	struct:parsecontent::sym	file:	access:public
parsecontent::sym::s	tmp/back/regex2nfa.cpp	/^		std::string s;$/;"	m	struct:parsecontent::sym	file:	access:public
parsecontent::sym::sid	galgorithm/regex2nfa.cpp	/^		int sid;$/;"	m	struct:parsecontent::sym	file:	access:public
parsecontent::sym::sid	tmp/back/regex2nfa.cpp	/^		int sid;$/;"	m	struct:parsecontent::sym	file:	access:public
parsecontent::syms	galgorithm/regex2nfa.cpp	/^	std::deque<sym> syms;$/;"	m	struct:parsecontent	file:	access:public
parsecontent::syms	tmp/back/regex2nfa.cpp	/^	std::deque<sym> syms;$/;"	m	struct:parsecontent	file:	access:public
parsecontent::true_node	galgorithm/regex2nfa.cpp	/^	void true_node(const char* vs, const char* ve, int L)$/;"	f	struct:parsecontent	access:public	signature:(const char* vs, const char* ve, int L)
parsecontent::true_node	tmp/back/regex2nfa.cpp	/^	void true_node(const char* vs, const char* ve, int L)$/;"	f	struct:parsecontent	access:public	signature:(const char* vs, const char* ve, int L)
pcsz	third_party/xml/Markup.h	/^	MCD_PCSZ pcsz;$/;"	m	struct:MCD_CSTR	access:public
pcsz	third_party/xml/Markup.h	/^	MCD_PCSZ_FILENAME pcsz;$/;"	m	struct:MCD_CSTR_FILENAME	access:public
pfirstright_cmp	syntax/production.h	/^struct pfirstright_cmp : public std::binary_function<production, production, bool>$/;"	s	inherits:std::binary_function
pfirstright_cmp::operator ()	syntax/production.h	/^	bool operator()(const production& p1, const production& p2) const$/;"	f	struct:pfirstright_cmp	access:public	signature:(const production& p1, const production& p2) const
pfirstright_less	syntax/production.h	/^typedef pfirstright_cmp<std::less<int32> > pfirstright_less;$/;"	t
pg_	syntax/lrmachine.h	/^	const tinygrammar* pg_;$/;"	m	class:lrmachine	access:private
pleft_cmp	syntax/production.h	/^struct pleft_cmp : public std::binary_function<production, production, bool>$/;"	s	inherits:std::binary_function
pleft_cmp::operator ()	syntax/production.h	/^	bool operator()(const production& p1, const production& p2) const$/;"	f	struct:pleft_cmp	access:public	signature:(const production& p1, const production& p2) const
pleft_less	syntax/production.h	/^typedef pleft_cmp<std::less<int32> > pleft_less;$/;"	t
pointer	include/arrayX.h	/^	typedef _Ty* pointer;$/;"	t	struct:SmartArray	access:public
pointer	include/arrayX.h	/^	typedef _Ty* pointer;$/;"	t	struct:SmartMatrix	access:public
pointer	include/arrayX.h	/^	typedef value_type* pointer;$/;"	t	class:smart_vector	access:public
pointer	include/iteratorX.h	/^	typedef typename _Base::pointer pointer;$/;"	t	struct:array_iterator	access:public
pointer	include/memoryX.h	/^	typedef value_type* pointer;$/;"	t	struct:memblock	access:public
pointer	include/stringX.h	/^	typedef _Tptr pointer;$/;"	t	class:xstring_basic	access:public
pointer_binary_function	include/functionalX.h	/^struct pointer_binary_function : public std::binary_function<_Tx*, _Tx*, typename _Fun::result_type>$/;"	s	inherits:std::binary_function
pointer_binary_function::operator ()	include/functionalX.h	/^	typename _Fun::result_type operator()(_Tx* _Arg1, _Tx* _Arg2) const$/;"	f	struct:pointer_binary_function	access:public	signature:(_Tx* _Arg1, _Tx* _Arg2) const
pp	galgorithm/lranalyse.cpp	/^		const production* pp;$/;"	m	union:nextstate::__anon1	file:	access:public
pright_cmp	syntax/production.h	/^struct pright_cmp<_Less, std::logical_and<bool> > : public std::binary_function<production, production, bool>$/;"	s	inherits:std::binary_function
pright_cmp	syntax/production.h	/^struct pright_cmp<_Less, std::logical_or<bool> > : public std::binary_function<production, production, bool>$/;"	s	inherits:std::binary_function
pright_cmp::operator ()	syntax/production.h	/^	bool operator()(const production& p1, const production& p2) const$/;"	f	struct:pright_cmp	access:public	signature:(const production& p1, const production& p2) const
print	test/output/gen.cpp	/^	print()$/;"	f	struct:print	access:public	signature:()
print	test/output/gen.cpp	/^struct print : public type$/;"	s	file:	inherits:type
print::print	test/output/gen.cpp	/^	print()$/;"	f	struct:print	access:public	signature:()
print::sid	test/output/gen.cpp	/^	enum{ sid = 1016 };$/;"	e	enum:print::__anon21	file:
printF	test/output/tinyg.cpp	/^	printF()$/;"	f	struct:printF	access:public	signature:()
printF	test/output/tinyg.cpp	/^struct printF : public type$/;"	s	file:	inherits:type
printF::printF	test/output/tinyg.cpp	/^	printF()$/;"	f	struct:printF	access:public	signature:()
printF::sid	test/output/tinyg.cpp	/^	enum{ sid = 13 };$/;"	e	enum:printF::__anon48	file:
print_grammar_to_file	test/regexnfatest.cpp	/^	void print_grammar_to_file(const grammar& g)$/;"	f	class:regex2nfa_test	file:	access:private	signature:(const grammar& g)
print_statemachines	makecompiler/gensyntax.cpp	/^void syntaxgenerator::print_statemachines()$/;"	f	class:syntaxgenerator	signature:()
print_statemachines	makecompiler/gensyntax.h	/^	void print_statemachines();$/;"	p	class:syntaxgenerator	access:private	signature:()
print_symbols	makecompiler/gensyntax.cpp	/^void syntaxgenerator::print_symbols()$/;"	f	class:syntaxgenerator	signature:()
print_symbols	makecompiler/gensyntax.h	/^	void print_symbols();$/;"	p	class:syntaxgenerator	access:private	signature:()
printablechars	compiler/compiler.h	/^	kog::smart_vector<sc::int32> printablechars;$/;"	m	class:compiler	access:private
prod	galgorithm/regex2nfa.cpp	/^	struct prod$/;"	s	struct:parsecontent	file:	access:public
prod	tmp/back/regex2nfa.cpp	/^	struct prod$/;"	s	struct:parsecontent	file:	access:public
prod_less	syntax/production.h	/^struct prod_less : public std::binary_function<production, production, bool>$/;"	s	inherits:std::binary_function
prod_less::operator ()	syntax/production.h	/^	bool operator()(const production& p1, const production& p2) const$/;"	f	struct:prod_less	access:public	signature:(const production& p1, const production& p2) const
prods	galgorithm/regex2nfa.cpp	/^	std::deque<prod> prods;$/;"	m	struct:parsecontent	file:	access:public
prods	tmp/back/regex2nfa.cpp	/^	std::deque<prod> prods;$/;"	m	struct:parsecontent	file:	access:public
production	syntax/production.cpp	/^production::production()$/;"	f	class:production	signature:()
production	syntax/production.cpp	/^production::production(const symholder& holder)$/;"	f	class:production	signature:(const symholder& holder)
production	syntax/production.cpp	/^production::production(const symholder& holder, int32 L, const int32* Rs, int N)$/;"	f	class:production	signature:(const symholder& holder, int32 L, const int32* Rs, int N)
production	syntax/production.cpp	/^production::production(int32 L, const int32* Rs, int32 N)$/;"	f	class:production	signature:(int32 L, const int32* Rs, int32 N)
production	syntax/production.h	/^	production();$/;"	p	class:production	access:public	signature:()
production	syntax/production.h	/^	production(const symholder& syms);$/;"	p	class:production	access:public	signature:(const symholder& syms)
production	syntax/production.h	/^	production(const symholder& syms, int32 L, const int32* Rs, int32 N);$/;"	p	class:production	access:public	signature:(const symholder& syms, int32 L, const int32* Rs, int32 N)
production	syntax/production.h	/^	production(int32 L, const int32* Rs, int32 N);$/;"	p	class:production	access:public	signature:(int32 L, const int32* Rs, int32 N)
production	syntax/production.h	/^class production$/;"	c
production::L_	syntax/production.h	/^	int32 L_;$/;"	m	class:production	access:private
production::MEMBER_VARIABLE_GET	syntax/production.h	/^	MEMBER_VARIABLE_GET(const right_array&, right, Rs_);$/;"	p	class:production	access:public	signature:(const right_array&, right, Rs_)
production::MEMBER_VARIABLE_GET	syntax/production.h	/^	MEMBER_VARIABLE_GET(int32, right_size, Rs_.size());$/;"	p	class:production	access:public	signature:(int32, right_size, Rs_.size())
production::MEMBER_VARIABLE_GET_SET	syntax/production.h	/^	MEMBER_VARIABLE_GET_SET(int32, left, L_);$/;"	p	class:production	access:public	signature:(int32, left, L_)
production::MEMBER_VARIABLE_GET_SET_INDEXER	syntax/production.h	/^	MEMBER_VARIABLE_GET_SET_INDEXER(int32, std::size_t, Rs_);$/;"	p	class:production	access:public	signature:(int32, std::size_t, Rs_)
production::Rs_	syntax/production.h	/^	right_array Rs_;$/;"	m	class:production	access:private
production::holder_	syntax/production.h	/^	const symholder* holder_;$/;"	m	class:production	access:private
production::production	syntax/production.cpp	/^production::production()$/;"	f	class:production	signature:()
production::production	syntax/production.cpp	/^production::production(const symholder& holder)$/;"	f	class:production	signature:(const symholder& holder)
production::production	syntax/production.cpp	/^production::production(const symholder& holder, int32 L, const int32* Rs, int N)$/;"	f	class:production	signature:(const symholder& holder, int32 L, const int32* Rs, int N)
production::production	syntax/production.cpp	/^production::production(int32 L, const int32* Rs, int32 N)$/;"	f	class:production	signature:(int32 L, const int32* Rs, int32 N)
production::production	syntax/production.h	/^	production();$/;"	p	class:production	access:public	signature:()
production::production	syntax/production.h	/^	production(const symholder& syms);$/;"	p	class:production	access:public	signature:(const symholder& syms)
production::production	syntax/production.h	/^	production(const symholder& syms, int32 L, const int32* Rs, int32 N);$/;"	p	class:production	access:public	signature:(const symholder& syms, int32 L, const int32* Rs, int32 N)
production::production	syntax/production.h	/^	production(int32 L, const int32* Rs, int32 N);$/;"	p	class:production	access:public	signature:(int32 L, const int32* Rs, int32 N)
production::reset_right	syntax/production.cpp	/^void production::reset_right(const int32* Rs, int N)$/;"	f	class:production	signature:(const int32* Rs, int N)
production::reset_right	syntax/production.h	/^	void reset_right(const int32* Rs, int N);$/;"	p	class:production	access:public	signature:(const int32* Rs, int N)
production::right_array	syntax/production.h	/^	typedef kog::smart_vector<int32> right_array;$/;"	t	class:production	access:public
production::swap	syntax/production.cpp	/^void production::swap(production& other)$/;"	f	class:production	signature:(production& other)
production::swap	syntax/production.h	/^	void swap(production& other);$/;"	p	class:production	access:public	signature:(production& other)
productionMap	galgorithm/lranalyse.cpp	/^	std::vector<size_t> productionMap;$/;"	m	struct:AlgorithmArg	file:	access:public
productions_	syntax/grammar.h	/^	vecprods productions_; \/\/ productions$/;"	m	class:tinygrammar	access:protected
ps	galgorithm/lranalyse.cpp	/^		const lrstate* ps;$/;"	m	union:nextstate::__anon1	file:	access:public
pstack_	syntax/lrmachine.h	/^	analysestack pstack_;$/;"	m	class:lrmachine	access:private
pszBom	third_party/xml/Markup.cpp	/^struct BomTableStruct { const char* pszBom; int nBomLen; MCD_PCSZ pszBomEnc; int nBomFlag; } BomTable[] =$/;"	m	struct:BomTableStruct	file:	access:public
pszBomEnc	third_party/xml/Markup.cpp	/^struct BomTableStruct { const char* pszBom; int nBomLen; MCD_PCSZ pszBomEnc; int nBomFlag; } BomTable[] =$/;"	m	struct:BomTableStruct	file:	access:public
pt	galgorithm/regex2nfa.cpp	/^		int pt; \/\/ production type: p_or, p_switch, p_seq$/;"	m	struct:parsecontent::prod	file:	access:public
pt	tmp/back/regex2nfa.cpp	/^		int pt; \/\/ production type: p_or, p_switch, p_seq$/;"	m	struct:parsecontent::prod	file:	access:public
ptr	include/arrayX.h	/^	_Ty* ptr() { return _values[0]; }$/;"	f	struct:SmartMatrix	access:public	signature:()
ptr	include/arrayX.h	/^	const _Ty* ptr() const { return _values[0]; }$/;"	f	struct:SmartMatrix	access:public	signature:() const
ptr	include/arrayX.h	/^	const_pointer ptr() const { return _buf; }$/;"	f	struct:SmartArray	access:public	signature:() const
ptr	include/arrayX.h	/^	pointer ptr() { return _buf; }$/;"	f	struct:SmartArray	access:public	signature:()
ptr	include/share_ptr.h	/^	const _Tx* ptr;$/;"	m	class:share_ptr	access:private
range	include/functionalX.h	/^range_t<_It> range(_It _First, _It _Last)$/;"	f	signature:(_It _First, _It _Last)
range_t	include/functionalX.h	/^	range_t(iterator first, iterator last)$/;"	f	struct:range_t	access:public	signature:(iterator first, iterator last)
range_t	include/functionalX.h	/^struct range_t : protected std::pair<_Iter, _Iter>$/;"	s	inherits:std::pair
range_t::_Base	include/functionalX.h	/^	typedef std::pair<_Iter, _Iter> _Base;$/;"	t	struct:range_t	access:public
range_t::_Mybase	include/functionalX.h	/^	typedef std::pair<_Iter, _Iter> _Mybase;$/;"	t	struct:range_t	access:public
range_t::begin	include/functionalX.h	/^	iterator begin() const$/;"	f	struct:range_t	access:public	signature:() const
range_t::const_iterator	include/functionalX.h	/^	typedef typename mpl::add_const<_Iter>::const_value_type const_iterator;$/;"	t	struct:range_t	access:public
range_t::end	include/functionalX.h	/^	iterator end() const$/;"	f	struct:range_t	access:public	signature:() const
range_t::iterator	include/functionalX.h	/^	typedef typename mpl::add_const<_Iter>::value_type iterator;$/;"	t	struct:range_t	access:public
range_t::range_t	include/functionalX.h	/^	range_t(iterator first, iterator last)$/;"	f	struct:range_t	access:public	signature:(iterator first, iterator last)
rbegin	include/arrayX.h	/^	const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); }$/;"	f	class:smart_vector	access:public	signature:() const
rbegin	include/arrayX.h	/^	const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); }$/;"	f	struct:SmartArray	access:public	signature:() const
rbegin	include/arrayX.h	/^	reverse_iterator rbegin() { return reverse_iterator(end()); }$/;"	f	class:smart_vector	access:public	signature:()
rbegin	include/arrayX.h	/^	reverse_iterator rbegin() { return reverse_iterator(end()); }$/;"	f	struct:SmartArray	access:public	signature:()
read_content	compiler/extract.cpp	/^	bool read_content(_Str& txt, state_machine& nm)$/;"	f	class:iwordstream	file:	access:private	signature:(_Str& txt, state_machine& nm)
read_grammar	test/gio.h	/^	void read_grammar(std::istream& is, compile::grammar& g, const std::string& start, const std::string& eplison, const std::string& ending) const$/;"	f	class:greader	access:private	signature:(std::istream& is, compile::grammar& g, const std::string& start, const std::string& eplison, const std::string& ending) const
readgrammar	syntax/loader.h	/^	void readgrammar(grammar& aGrammar);$/;"	p	class:loader	access:public	signature:(grammar& aGrammar)
reduce	syntax/lrmachine.cpp	/^int32 lrmachine::reduce(int32 pid)$/;"	f	class:lrmachine	signature:(int32 pid)
reduce	syntax/lrmachine.h	/^	int32 reduce(int32 pid);$/;"	p	class:lrmachine	access:protected	signature:(int32 pid)
ref	include/functionalX.h	/^inline ref_obj<T> ref(T& obj)$/;"	f	signature:(T& obj)
refCount	include/share_ptr.h	/^	int* refCount;$/;"	m	class:share_ptr	access:private
refProductions	galgorithm/lranalyse.cpp	/^	const kog::smart_vector<production>* refProductions;$/;"	m	struct:AlgorithmArg	file:	access:public
ref_obj	include/functionalX.h	/^	ref_obj(T& obj)$/;"	f	class:ref_obj	access:public	signature:(T& obj)
ref_obj	include/functionalX.h	/^class ref_obj$/;"	c
ref_obj::_ref_obj	include/functionalX.h	/^	T& _ref_obj;$/;"	m	class:ref_obj	access:private
ref_obj::const_ref_type	include/functionalX.h	/^	typedef const T& const_ref_type;$/;"	t	class:ref_obj	access:public
ref_obj::operator ->	include/functionalX.h	/^	T* operator->()$/;"	f	class:ref_obj	access:public	signature:()
ref_obj::operator const_ref_type	include/functionalX.h	/^	operator const_ref_type() const$/;"	f	class:ref_obj	access:public	signature:() const
ref_obj::operator ref_type	include/functionalX.h	/^	operator ref_type()$/;"	f	class:ref_obj	access:public	signature:()
ref_obj::ref_obj	include/functionalX.h	/^	ref_obj(T& obj)$/;"	f	class:ref_obj	access:public	signature:(T& obj)
ref_obj::ref_type	include/functionalX.h	/^	typedef T& ref_type;$/;"	t	class:ref_obj	access:public
ref_type	include/functionalX.h	/^	typedef T& ref_type;$/;"	t	class:ref_obj	access:public
reference	include/arrayX.h	/^	typedef value_type& reference;$/;"	t	class:smart_vector	access:public
reference	include/arrayX.h	/^	typedef value_type& reference;$/;"	t	struct:SmartArray	access:public
reference	include/arrayX.h	/^	typedef value_type& reference;$/;"	t	struct:SmartMatrix	access:public
reference	include/functionalX.h	/^	typedef typename std::iterator_traits<_InIt>::reference reference;$/;"	t	struct:dereference_t	access:public
reference	include/iteratorX.h	/^	typedef typename _Base::reference reference;$/;"	t	struct:array_iterator	access:public
reference	include/memoryX.h	/^	typedef value_type& reference;$/;"	t	struct:memblock	access:public
reference	include/stringX.h	/^	typedef _Reft reference;$/;"	t	class:xstring_basic	access:public
reference_type	include/functionalX.h	/^	typedef _Ty& reference_type;$/;"	t	struct:mem_value_t	access:public
regex2nfa	galgorithm/regex2nfa.h	/^	regex2nfa(const tstring& regexstr, grammar& otput)$/;"	f	class:regex2nfa	access:public	signature:(const tstring& regexstr, grammar& otput)
regex2nfa	galgorithm/regex2nfa.h	/^class regex2nfa : public grammar_algorithm$/;"	c	inherits:grammar_algorithm
regex2nfa::gout_	galgorithm/regex2nfa.h	/^	grammar* gout_;$/;"	m	class:regex2nfa	access:private
regex2nfa::invoke	galgorithm/regex2nfa.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:regex2nfa	access:public	signature:()
regex2nfa::operator ()	galgorithm/regex2nfa.cpp	/^void regex2nfa::operator()(const tstring& input, grammar& otput)$/;"	f	class:regex2nfa	signature:(const tstring& input, grammar& otput)
regex2nfa::operator ()	galgorithm/regex2nfa.h	/^	void operator()(const tstring& input, grammar& otput);$/;"	p	class:regex2nfa	access:private	signature:(const tstring& input, grammar& otput)
regex2nfa::operator ()	tmp/back/regex2nfa.cpp	/^void regex2nfa::operator()(const tstring& input, grammar& otput)$/;"	f	class:regex2nfa	signature:(const tstring& input, grammar& otput)
regex2nfa::regex2nfa	galgorithm/regex2nfa.h	/^	regex2nfa(const tstring& regexstr, grammar& otput)$/;"	f	class:regex2nfa	access:public	signature:(const tstring& regexstr, grammar& otput)
regex2nfa::regexstr_	galgorithm/regex2nfa.h	/^	tstring regexstr_;$/;"	m	class:regex2nfa	access:private
regex2nfa::tocfg	galgorithm/regex2nfa.cpp	/^void regex2nfa::tocfg(const tstring& input, grammar& otput)$/;"	f	class:regex2nfa	signature:(const tstring& input, grammar& otput)
regex2nfa::tocfg	galgorithm/regex2nfa.h	/^	void tocfg(const tstring& input, grammar& otput);$/;"	p	class:regex2nfa	access:private	signature:(const tstring& input, grammar& otput)
regex2nfa::tocfg	tmp/back/regex2nfa.cpp	/^void regex2nfa::tocfg(const tstring& input, grammar& otput)$/;"	f	class:regex2nfa	signature:(const tstring& input, grammar& otput)
regex2nfa::tonfa	galgorithm/regex2nfa.cpp	/^void regex2nfa::tonfa(const grammar& input, grammar& otput)$/;"	f	class:regex2nfa	signature:(const grammar& input, grammar& otput)
regex2nfa::tonfa	galgorithm/regex2nfa.h	/^	void tonfa(const grammar& input, grammar& otput);$/;"	p	class:regex2nfa	access:private	signature:(const grammar& input, grammar& otput)
regex2nfa::tonfa	tmp/back/regex2nfa.cpp	/^void regex2nfa::tonfa(const grammar& input, grammar& otput)$/;"	f	class:regex2nfa	signature:(const grammar& input, grammar& otput)
regex2nfa_test	test/regexnfatest.cpp	/^NEW_UNITTEST(regex2nfa_test);$/;"	v
regex2nfa_test	test/regexnfatest.cpp	/^class regex2nfa_test : public sc::unittest$/;"	c	file:	inherits:sc::unittest
regex2nfa_test::init	test/regexnfatest.cpp	/^	\/* overwrite *\/ virtual void init(int argc, const char* argv[])$/;"	f	class:regex2nfa_test	file:	access:private	signature:(int argc, const char* argv[])
regex2nfa_test::outfile	test/regexnfatest.cpp	/^	std::string outfile;$/;"	m	class:regex2nfa_test	file:	access:private
regex2nfa_test::print_grammar_to_file	test/regexnfatest.cpp	/^	void print_grammar_to_file(const grammar& g)$/;"	f	class:regex2nfa_test	file:	access:private	signature:(const grammar& g)
regex2nfa_test::run_test	test/regexnfatest.cpp	/^	\/* overwrite *\/ virtual void run_test()$/;"	f	class:regex2nfa_test	file:	access:private	signature:()
regex_str_to_machine	makecompiler/gensyntax.cpp	/^void syntaxgenerator::regex_str_to_machine(const std::string& regexstr, automachine& m)$/;"	f	class:syntaxgenerator	signature:(const std::string& regexstr, automachine& m)
regex_str_to_machine	makecompiler/gensyntax.h	/^	void regex_str_to_machine(const std::string& regexstr, automachine& m);$/;"	p	class:syntaxgenerator	access:private	signature:(const std::string& regexstr, automachine& m)
regexstr_	galgorithm/regex2nfa.h	/^	tstring regexstr_;$/;"	m	class:regex2nfa	access:private
release	include/arrayX.h	/^	pointer release()$/;"	f	class:smart_vector	access:public	signature:()
remove_const	include/mplX.h	/^struct remove_const$/;"	s
remove_const	include/mplX.h	/^struct remove_const<const _Tx>$/;"	s
remove_const::const_type	include/mplX.h	/^	typedef const _Tx const_type;$/;"	t	struct:remove_const	access:public
remove_const::type	include/mplX.h	/^	typedef _Tx type;$/;"	t	struct:remove_const	access:public
remove_duplicate	galgorithm/basicalgorithms.cpp	/^void removesingle::remove_duplicate(std::list<production>& plist)$/;"	f	class:removesingle	signature:(std::list<production>& plist)
remove_duplicate	galgorithm/basicalgorithms.h	/^	void remove_duplicate(std::list<production>& plist);$/;"	p	class:removesingle	access:private	signature:(std::list<production>& plist)
removenotused	galgorithm/basicalgorithms.h	/^	removenotused(const grammar& gin, grammar& gout)$/;"	f	class:removenotused	access:public	signature:(const grammar& gin, grammar& gout)
removenotused	galgorithm/basicalgorithms.h	/^class removenotused : public grammar_algorithm$/;"	c	inherits:grammar_algorithm
removenotused::gin_	galgorithm/basicalgorithms.h	/^	const grammar* gin_;$/;"	m	class:removenotused	access:private
removenotused::gout_	galgorithm/basicalgorithms.h	/^	grammar* gout_;$/;"	m	class:removenotused	access:private
removenotused::invoke	galgorithm/basicalgorithms.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:removenotused	access:public	signature:()
removenotused::new_grammar	galgorithm/basicalgorithms.cpp	/^void removenotused::new_grammar(const grammar& gin, grammar& gout)$/;"	f	class:removenotused	signature:(const grammar& gin, grammar& gout)
removenotused::new_grammar	galgorithm/basicalgorithms.h	/^	void new_grammar(const grammar& gin, grammar& gout); \/\/ create new grammmar$/;"	p	class:removenotused	access:private	signature:(const grammar& gin, grammar& gout)
removenotused::operator ()	galgorithm/basicalgorithms.cpp	/^void removenotused::operator()(const grammar& gin, grammar& gout)$/;"	f	class:removenotused	signature:(const grammar& gin, grammar& gout)
removenotused::operator ()	galgorithm/basicalgorithms.h	/^	void operator()(const grammar& gin, grammar& gout);$/;"	p	class:removenotused	access:private	signature:(const grammar& gin, grammar& gout)
removenotused::removenotused	galgorithm/basicalgorithms.h	/^	removenotused(const grammar& gin, grammar& gout)$/;"	f	class:removenotused	access:public	signature:(const grammar& gin, grammar& gout)
removenotused::rm_Snofm	galgorithm/basicalgorithms.cpp	/^void removenotused::rm_Snofm(const tinygrammar& tig)$/;"	f	class:removenotused	signature:(const tinygrammar& tig)
removenotused::rm_Snofm	galgorithm/basicalgorithms.h	/^	void rm_Snofm(const tinygrammar& tig);\/\/ remove symbols and productions can't start from StartSymbol$/;"	p	class:removenotused	access:private	signature:(const tinygrammar& tig)
removenotused::rm_notoT	galgorithm/basicalgorithms.cpp	/^void removenotused::rm_notoT(const tinygrammar& tig)$/;"	f	class:removenotused	signature:(const tinygrammar& tig)
removenotused::rm_notoT	galgorithm/basicalgorithms.h	/^	void rm_notoT(const tinygrammar& tig);\/\/ remove symbols and productions can't to be a terminate symbol$/;"	p	class:removenotused	access:private	signature:(const tinygrammar& tig)
removenotused::usedp	galgorithm/basicalgorithms.h	/^	vecint usedp;$/;"	m	class:removenotused	access:private
removenotused::useds	galgorithm/basicalgorithms.h	/^	vecint useds;$/;"	m	class:removenotused	access:private
removenotused::vecint	galgorithm/basicalgorithms.h	/^	typedef kog::smart_vector<int32> vecint;$/;"	t	class:removenotused	access:private
removesingle	galgorithm/basicalgorithms.h	/^	removesingle(const grammar& gin, grammar& gout)$/;"	f	class:removesingle	access:public	signature:(const grammar& gin, grammar& gout)
removesingle	galgorithm/basicalgorithms.h	/^class removesingle : public grammar_algorithm$/;"	c	inherits:grammar_algorithm
removesingle::gin_	galgorithm/basicalgorithms.h	/^	const grammar* gin_;$/;"	m	class:removesingle	access:private
removesingle::gout_	galgorithm/basicalgorithms.h	/^	grammar* gout_;$/;"	m	class:removesingle	access:private
removesingle::invoke	galgorithm/basicalgorithms.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:removesingle	access:public	signature:()
removesingle::operator ()	galgorithm/basicalgorithms.cpp	/^void removesingle::operator()(const grammar& gin, grammar& gout)$/;"	f	class:removesingle	signature:(const grammar& gin, grammar& gout)
removesingle::operator ()	galgorithm/basicalgorithms.h	/^	void operator()(const grammar& gin, grammar& gout);$/;"	p	class:removesingle	access:private	signature:(const grammar& gin, grammar& gout)
removesingle::remove_duplicate	galgorithm/basicalgorithms.cpp	/^void removesingle::remove_duplicate(std::list<production>& plist)$/;"	f	class:removesingle	signature:(std::list<production>& plist)
removesingle::remove_duplicate	galgorithm/basicalgorithms.h	/^	void remove_duplicate(std::list<production>& plist);$/;"	p	class:removesingle	access:private	signature:(std::list<production>& plist)
removesingle::removesingle	galgorithm/basicalgorithms.h	/^	removesingle(const grammar& gin, grammar& gout)$/;"	f	class:removesingle	access:public	signature:(const grammar& gin, grammar& gout)
rend	include/arrayX.h	/^	const_reverse_iterator rend() const { return const_reverse_iterator(begin()); }$/;"	f	class:smart_vector	access:public	signature:() const
rend	include/arrayX.h	/^	const_reverse_iterator rend() const { return const_reverse_iterator(begin()); }$/;"	f	struct:SmartArray	access:public	signature:() const
rend	include/arrayX.h	/^	reverse_iterator rend() { return reverse_iterator(begin()); }$/;"	f	class:smart_vector	access:public	signature:()
rend	include/arrayX.h	/^	reverse_iterator rend() { return reverse_iterator(begin()); }$/;"	f	struct:SmartArray	access:public	signature:()
replace	include/stringX.h	/^	_Myt& replace(size_type _Off,$/;"	f	class:xstring_basic	access:public	signature:(size_type _Off, size_type _N0, const _Mybase& _Right, size_type _Roff, size_type _Count)
replace_all	third_party/regex/xregex.cpp	/^xregex::tstring xregex::replace_all(const tstring& regex_str, $/;"	f	class:stringX::xregex	signature:(const tstring& regex_str, const tstring& replace_str, const tstring& org_str)
replace_all	third_party/regex/xregex.h	/^	static tstring replace_all(const tstring& regex_str, $/;"	p	class:stringX::xregex	access:public	signature:(const tstring& regex_str, const tstring& replace_str, const tstring& org_str)
replaceall	include/stringXF.h	/^std::basic_string<_Elem> replaceall(const std::basic_string<_Elem>& str, const std::basic_string<_Elem>& oldString, const std::basic_string<_Elem>& newString)$/;"	f	signature:(const std::basic_string<_Elem>& str, const std::basic_string<_Elem>& oldString, const std::basic_string<_Elem>& newString)
replacefirst	include/stringXF.h	/^std::basic_string<_Elem> replacefirst(const std::basic_string<_Elem>& str, const std::basic_string<_Elem>& oldString, const std::basic_string<_Elem>& newString, size_t pos = 0)$/;"	f	signature:(const std::basic_string<_Elem>& str, const std::basic_string<_Elem>& oldString, const std::basic_string<_Elem>& newString, size_t pos = 0)
reset	include/arrayX.h	/^	smart_vector& reset(size_type _N)$/;"	f	class:smart_vector	access:public	signature:(size_type _N)
reset	include/share_ptr.h	/^	void reset(_Tx* p) throw()$/;"	f	class:share_ptr	access:public	signature:(_Tx* p)
reset_right	syntax/production.cpp	/^void production::reset_right(const int32* Rs, int N)$/;"	f	class:production	signature:(const int32* Rs, int N)
reset_right	syntax/production.h	/^	void reset_right(const int32* Rs, int N);$/;"	p	class:production	access:public	signature:(const int32* Rs, int N)
result_type	include/functionalX.h	/^	typedef _Result result_type;$/;"	t	struct:triple_function	access:public
result_type	include/functionalX.h	/^	typedef typename _Fy::result_type result_type;$/;"	t	struct:composite_function_t	access:public
result_type	include/functionalX.h	/^	typedef typename _Fz::result_type result_type;$/;"	t	struct:composite_function2_t	access:public
result_type	include/functionalX.h	/^	typedef typename _Oper::result_type result_type;$/;"	t	class:apply	access:public
reverse_iterator	include/arrayX.h	/^	typedef std::reverse_iterator<iterator> reverse_iterator;$/;"	t	class:smart_vector	access:public
reverse_iterator	include/arrayX.h	/^	typedef std::reverse_iterator<iterator> reverse_iterator;$/;"	t	struct:SmartArray	access:public
reverse_iterator	include/arrayX.h	/^	typedef std::reverse_iterator<iterator> reverse_iterator;$/;"	t	struct:SmartMatrix	access:public
reverse_iterator	include/memoryX.h	/^	typedef std::reverse_iterator<iterator> reverse_iterator;$/;"	t	struct:memblock	access:public
right_array	syntax/production.h	/^	typedef kog::smart_vector<int32> right_array;$/;"	t	class:production	access:public
right_iterator	galgorithm/lranalyse.cpp	/^	typedef std::list<size_t>::const_iterator right_iterator;$/;"	t	struct:AlgorithmArg	file:	access:public
right_range	galgorithm/lranalyse.cpp	/^	typedef std::pair<right_iterator, right_iterator> right_range;$/;"	t	struct:AlgorithmArg	file:	access:public
rm_Snofm	galgorithm/basicalgorithms.cpp	/^void removenotused::rm_Snofm(const tinygrammar& tig)$/;"	f	class:removenotused	signature:(const tinygrammar& tig)
rm_Snofm	galgorithm/basicalgorithms.h	/^	void rm_Snofm(const tinygrammar& tig);\/\/ remove symbols and productions can't start from StartSymbol$/;"	p	class:removenotused	access:private	signature:(const tinygrammar& tig)
rm_notoT	galgorithm/basicalgorithms.cpp	/^void removenotused::rm_notoT(const tinygrammar& tig)$/;"	f	class:removenotused	signature:(const tinygrammar& tig)
rm_notoT	galgorithm/basicalgorithms.h	/^	void rm_notoT(const tinygrammar& tig);\/\/ remove symbols and productions can't to be a terminate symbol$/;"	p	class:removenotused	access:private	signature:(const tinygrammar& tig)
rmeplison	galgorithm/basicalgorithms.cpp	/^void eliminate_eplison::rmeplison(const tinygrammar& tig, tinygrammar& tog)$/;"	f	class:eliminate_eplison	signature:(const tinygrammar& tig, tinygrammar& tog)
rmeplison	galgorithm/basicalgorithms.h	/^	void rmeplison(const tinygrammar& tig, tinygrammar& tog);$/;"	p	class:eliminate_eplison	access:private	signature:(const tinygrammar& tig, tinygrammar& tog)
round	include/mathX.h	/^	static _Result round(const _Arg value)$/;"	f	class:math	access:public	signature:(const _Arg value)
row	include/arrayX.h	/^	size_t row() const { return _Row; }$/;"	f	struct:SmartMatrix	access:public	signature:() const
run	test/unittest.cpp	/^void unittest::run()$/;"	f	class:unittest	signature:()
run	test/unittest.cpp	/^void unittest::run(const std::string& outfolder)$/;"	f	class:unittest	signature:(const std::string& outfolder)
run	test/unittest.h	/^	void run();$/;"	p	class:unittest	access:public	signature:()
run	test/unittest.h	/^	void run(const std::string& outfolder);$/;"	p	class:unittest	access:public	signature:(const std::string& outfolder)
run_all_unittest	test/unittest.cpp	/^	int run_all_unittest(int argc, const char* argv[])$/;"	f	class:unittest_list	access:public	signature:(int argc, const char* argv[])
run_test	test/basicalgorithmtest.cpp	/^	\/* overwrite *\/ virtual void run_test()$/;"	f	class:basicalg_test	file:	access:private	signature:()
run_test	test/firstfollowtest.cpp	/^	\/* overwrite *\/ virtual void run_test()$/;"	f	class:firstfollow_test	file:	access:private	signature:()
run_test	test/nfa2dfatest.cpp	/^	\/* overwrite *\/ virtual void run_test()$/;"	f	class:nfa2dfa_test	file:	access:private	signature:()
run_test	test/regexnfatest.cpp	/^	\/* overwrite *\/ virtual void run_test()$/;"	f	class:regex2nfa_test	file:	access:private	signature:()
run_test	test/splitwords.cpp	/^	\/* overwrite *\/ virtual void run_test()$/;"	f	class:splitwords_test	access:public	signature:()
run_test	test/tinygrammartest.cpp	/^	\/* overwrite *\/ virtual void run_test()$/;"	f	class:simplegrammar_test	access:public	signature:()
run_test	test/unittest.h	/^	virtual void run_test() = 0;$/;"	p	class:unittest	access:private	signature:()
s	galgorithm/regex2nfa.cpp	/^		std::string s;$/;"	m	struct:parsecontent::sym	file:	access:public
s	galgorithm/regex2nfa.cpp	/^	const char* s;$/;"	m	struct:parsecontent	file:	access:public
s	tmp/back/regex2nfa.cpp	/^		std::string s;$/;"	m	struct:parsecontent::sym	file:	access:public
s	tmp/back/regex2nfa.cpp	/^	const char* s;$/;"	m	struct:parsecontent	file:	access:public
safe_delete	include/functionalX.h	/^inline void safe_delete(Ptr_Type& ptr)$/;"	f	signature:(Ptr_Type& ptr)
safe_delete_vec	include/functionalX.h	/^inline void safe_delete_vec(Ptr_Type& ptr)$/;"	f	signature:(Ptr_Type& ptr)
scerror	include/scerror.h	/^	scerror()$/;"	f	class:scerror	access:public	signature:()
scerror	include/scerror.h	/^	scerror(const tstring& err)$/;"	f	class:scerror	access:public	signature:(const tstring& err)
scerror	include/scerror.h	/^class scerror : public std::runtime_error$/;"	c	inherits:std::runtime_error
scerror::scerror	include/scerror.h	/^	scerror()$/;"	f	class:scerror	access:public	signature:()
scerror::scerror	include/scerror.h	/^	scerror(const tstring& err)$/;"	f	class:scerror	access:public	signature:(const tstring& err)
second	include/functionalX.h	/^	_Ty2 second;	\/\/ the second stored value$/;"	m	struct:triple	access:public
second_argument_type	include/functionalX.h	/^	typedef _Arg2 second_argument_type;$/;"	t	struct:triple_function	access:public
second_argument_type	include/functionalX.h	/^	typedef typename _Fy::argument_type second_argument_type;$/;"	t	struct:composite_function2_t	access:public
second_type	include/functionalX.h	/^	typedef _Ty2 second_type;$/;"	t	struct:triple	access:public
sep	syntax/grammar.h	/^		sep = 1, \/\/ seperators$/;"	e	enum:grammar::symtype
separators	compiler/compiler.h	/^	kog::smart_vector<sc::int32> separators;$/;"	m	class:compiler	access:private
seperator0	test/output/gen.cpp	/^	seperator0()$/;"	f	struct:seperator0	access:public	signature:()
seperator0	test/output/gen.cpp	/^struct seperator0 : public type$/;"	s	file:	inherits:type
seperator0	test/output/tinyg.cpp	/^	seperator0()$/;"	f	struct:seperator0	access:public	signature:()
seperator0	test/output/tinyg.cpp	/^struct seperator0 : public type$/;"	s	file:	inherits:type
seperator0::seperator0	test/output/gen.cpp	/^	seperator0()$/;"	f	struct:seperator0	access:public	signature:()
seperator0::seperator0	test/output/tinyg.cpp	/^	seperator0()$/;"	f	struct:seperator0	access:public	signature:()
seperator0::sid	test/output/gen.cpp	/^	enum{ sid = 1018 };$/;"	e	enum:seperator0::__anon22	file:
seperator0::sid	test/output/tinyg.cpp	/^	enum{ sid = 19 };$/;"	e	enum:seperator0::__anon54	file:
seperator1	test/output/gen.cpp	/^	seperator1()$/;"	f	struct:seperator1	access:public	signature:()
seperator1	test/output/gen.cpp	/^struct seperator1 : public type$/;"	s	file:	inherits:type
seperator1	test/output/tinyg.cpp	/^	seperator1()$/;"	f	struct:seperator1	access:public	signature:()
seperator1	test/output/tinyg.cpp	/^struct seperator1 : public type$/;"	s	file:	inherits:type
seperator10	test/output/gen.cpp	/^	seperator10()$/;"	f	struct:seperator10	access:public	signature:()
seperator10	test/output/gen.cpp	/^struct seperator10 : public type$/;"	s	file:	inherits:type
seperator10	test/output/tinyg.cpp	/^	seperator10()$/;"	f	struct:seperator10	access:public	signature:()
seperator10	test/output/tinyg.cpp	/^struct seperator10 : public type$/;"	s	file:	inherits:type
seperator10::seperator10	test/output/gen.cpp	/^	seperator10()$/;"	f	struct:seperator10	access:public	signature:()
seperator10::seperator10	test/output/tinyg.cpp	/^	seperator10()$/;"	f	struct:seperator10	access:public	signature:()
seperator10::sid	test/output/gen.cpp	/^	enum{ sid = 1020 };$/;"	e	enum:seperator10::__anon24	file:
seperator10::sid	test/output/tinyg.cpp	/^	enum{ sid = 29 };$/;"	e	enum:seperator10::__anon64	file:
seperator1::seperator1	test/output/gen.cpp	/^	seperator1()$/;"	f	struct:seperator1	access:public	signature:()
seperator1::seperator1	test/output/tinyg.cpp	/^	seperator1()$/;"	f	struct:seperator1	access:public	signature:()
seperator1::sid	test/output/gen.cpp	/^	enum{ sid = 1019 };$/;"	e	enum:seperator1::__anon23	file:
seperator1::sid	test/output/tinyg.cpp	/^	enum{ sid = 20 };$/;"	e	enum:seperator1::__anon55	file:
seperator2	test/output/gen.cpp	/^	seperator2()$/;"	f	struct:seperator2	access:public	signature:()
seperator2	test/output/gen.cpp	/^struct seperator2 : public type$/;"	s	file:	inherits:type
seperator2	test/output/tinyg.cpp	/^	seperator2()$/;"	f	struct:seperator2	access:public	signature:()
seperator2	test/output/tinyg.cpp	/^struct seperator2 : public type$/;"	s	file:	inherits:type
seperator2::seperator2	test/output/gen.cpp	/^	seperator2()$/;"	f	struct:seperator2	access:public	signature:()
seperator2::seperator2	test/output/tinyg.cpp	/^	seperator2()$/;"	f	struct:seperator2	access:public	signature:()
seperator2::sid	test/output/gen.cpp	/^	enum{ sid = 1021 };$/;"	e	enum:seperator2::__anon25	file:
seperator2::sid	test/output/tinyg.cpp	/^	enum{ sid = 21 };$/;"	e	enum:seperator2::__anon56	file:
seperator3	test/output/gen.cpp	/^	seperator3()$/;"	f	struct:seperator3	access:public	signature:()
seperator3	test/output/gen.cpp	/^struct seperator3 : public type$/;"	s	file:	inherits:type
seperator3	test/output/tinyg.cpp	/^	seperator3()$/;"	f	struct:seperator3	access:public	signature:()
seperator3	test/output/tinyg.cpp	/^struct seperator3 : public type$/;"	s	file:	inherits:type
seperator3::seperator3	test/output/gen.cpp	/^	seperator3()$/;"	f	struct:seperator3	access:public	signature:()
seperator3::seperator3	test/output/tinyg.cpp	/^	seperator3()$/;"	f	struct:seperator3	access:public	signature:()
seperator3::sid	test/output/gen.cpp	/^	enum{ sid = 1022 };$/;"	e	enum:seperator3::__anon26	file:
seperator3::sid	test/output/tinyg.cpp	/^	enum{ sid = 22 };$/;"	e	enum:seperator3::__anon57	file:
seperator4	test/output/gen.cpp	/^	seperator4()$/;"	f	struct:seperator4	access:public	signature:()
seperator4	test/output/gen.cpp	/^struct seperator4 : public type$/;"	s	file:	inherits:type
seperator4	test/output/tinyg.cpp	/^	seperator4()$/;"	f	struct:seperator4	access:public	signature:()
seperator4	test/output/tinyg.cpp	/^struct seperator4 : public type$/;"	s	file:	inherits:type
seperator4::seperator4	test/output/gen.cpp	/^	seperator4()$/;"	f	struct:seperator4	access:public	signature:()
seperator4::seperator4	test/output/tinyg.cpp	/^	seperator4()$/;"	f	struct:seperator4	access:public	signature:()
seperator4::sid	test/output/gen.cpp	/^	enum{ sid = 1023 };$/;"	e	enum:seperator4::__anon27	file:
seperator4::sid	test/output/tinyg.cpp	/^	enum{ sid = 23 };$/;"	e	enum:seperator4::__anon58	file:
seperator5	test/output/gen.cpp	/^	seperator5()$/;"	f	struct:seperator5	access:public	signature:()
seperator5	test/output/gen.cpp	/^struct seperator5 : public type$/;"	s	file:	inherits:type
seperator5	test/output/tinyg.cpp	/^	seperator5()$/;"	f	struct:seperator5	access:public	signature:()
seperator5	test/output/tinyg.cpp	/^struct seperator5 : public type$/;"	s	file:	inherits:type
seperator5::seperator5	test/output/gen.cpp	/^	seperator5()$/;"	f	struct:seperator5	access:public	signature:()
seperator5::seperator5	test/output/tinyg.cpp	/^	seperator5()$/;"	f	struct:seperator5	access:public	signature:()
seperator5::sid	test/output/gen.cpp	/^	enum{ sid = 1024 };$/;"	e	enum:seperator5::__anon28	file:
seperator5::sid	test/output/tinyg.cpp	/^	enum{ sid = 24 };$/;"	e	enum:seperator5::__anon59	file:
seperator6	test/output/gen.cpp	/^	seperator6()$/;"	f	struct:seperator6	access:public	signature:()
seperator6	test/output/gen.cpp	/^struct seperator6 : public type$/;"	s	file:	inherits:type
seperator6	test/output/tinyg.cpp	/^	seperator6()$/;"	f	struct:seperator6	access:public	signature:()
seperator6	test/output/tinyg.cpp	/^struct seperator6 : public type$/;"	s	file:	inherits:type
seperator6::seperator6	test/output/gen.cpp	/^	seperator6()$/;"	f	struct:seperator6	access:public	signature:()
seperator6::seperator6	test/output/tinyg.cpp	/^	seperator6()$/;"	f	struct:seperator6	access:public	signature:()
seperator6::sid	test/output/gen.cpp	/^	enum{ sid = 1025 };$/;"	e	enum:seperator6::__anon29	file:
seperator6::sid	test/output/tinyg.cpp	/^	enum{ sid = 25 };$/;"	e	enum:seperator6::__anon60	file:
seperator7	test/output/gen.cpp	/^	seperator7()$/;"	f	struct:seperator7	access:public	signature:()
seperator7	test/output/gen.cpp	/^struct seperator7 : public type$/;"	s	file:	inherits:type
seperator7	test/output/tinyg.cpp	/^	seperator7()$/;"	f	struct:seperator7	access:public	signature:()
seperator7	test/output/tinyg.cpp	/^struct seperator7 : public type$/;"	s	file:	inherits:type
seperator7::seperator7	test/output/gen.cpp	/^	seperator7()$/;"	f	struct:seperator7	access:public	signature:()
seperator7::seperator7	test/output/tinyg.cpp	/^	seperator7()$/;"	f	struct:seperator7	access:public	signature:()
seperator7::sid	test/output/gen.cpp	/^	enum{ sid = 1026 };$/;"	e	enum:seperator7::__anon30	file:
seperator7::sid	test/output/tinyg.cpp	/^	enum{ sid = 26 };$/;"	e	enum:seperator7::__anon61	file:
seperator8	test/output/gen.cpp	/^	seperator8()$/;"	f	struct:seperator8	access:public	signature:()
seperator8	test/output/gen.cpp	/^struct seperator8 : public type$/;"	s	file:	inherits:type
seperator8	test/output/tinyg.cpp	/^	seperator8()$/;"	f	struct:seperator8	access:public	signature:()
seperator8	test/output/tinyg.cpp	/^struct seperator8 : public type$/;"	s	file:	inherits:type
seperator8::seperator8	test/output/gen.cpp	/^	seperator8()$/;"	f	struct:seperator8	access:public	signature:()
seperator8::seperator8	test/output/tinyg.cpp	/^	seperator8()$/;"	f	struct:seperator8	access:public	signature:()
seperator8::sid	test/output/gen.cpp	/^	enum{ sid = 1027 };$/;"	e	enum:seperator8::__anon31	file:
seperator8::sid	test/output/tinyg.cpp	/^	enum{ sid = 27 };$/;"	e	enum:seperator8::__anon62	file:
seperator9	test/output/gen.cpp	/^	seperator9()$/;"	f	struct:seperator9	access:public	signature:()
seperator9	test/output/gen.cpp	/^struct seperator9 : public type$/;"	s	file:	inherits:type
seperator9	test/output/tinyg.cpp	/^	seperator9()$/;"	f	struct:seperator9	access:public	signature:()
seperator9	test/output/tinyg.cpp	/^struct seperator9 : public type$/;"	s	file:	inherits:type
seperator9::seperator9	test/output/gen.cpp	/^	seperator9()$/;"	f	struct:seperator9	access:public	signature:()
seperator9::seperator9	test/output/tinyg.cpp	/^	seperator9()$/;"	f	struct:seperator9	access:public	signature:()
seperator9::sid	test/output/gen.cpp	/^	enum{ sid = 1028 };$/;"	e	enum:seperator9::__anon32	file:
seperator9::sid	test/output/tinyg.cpp	/^	enum{ sid = 28 };$/;"	e	enum:seperator9::__anon63	file:
seperators_	syntax/grammar.h	/^	tstring seperators_;	\/\/ seperators: split word$/;"	m	class:grammar	access:protected
set_grammar_production	galgorithm/regex2nfa.cpp	/^void set_grammar_production(tinygrammar::vecprods& productions, parsecontent& pc, int gending)$/;"	f	signature:(tinygrammar::vecprods& productions, parsecontent& pc, int gending)
set_grammar_production	tmp/back/regex2nfa.cpp	/^void set_grammar_production(tinygrammar::vecprods& productions, parsecontent& pc)$/;"	f	signature:(tinygrammar::vecprods& productions, parsecontent& pc)
set_grammar_symbol	galgorithm/regex2nfa.cpp	/^void set_grammar_symbol(symholder& sholder, parsecontent& pc)$/;"	f	signature:(symholder& sholder, parsecontent& pc)
set_grammar_symbol	tmp/back/regex2nfa.cpp	/^void set_grammar_symbol(symholder& sholder, parsecontent& pc)$/;"	f	signature:(symholder& sholder, parsecontent& pc)
sets_	galgorithm/firstfollow.h	/^	vecintset* sets_;$/;"	m	class:firstset	access:private
share_ptr	include/share_ptr.h	/^	explicit share_ptr(_Tx* p = NULL) throw()$/;"	f	class:share_ptr	access:public	signature:(_Tx* p = NULL)
share_ptr	include/share_ptr.h	/^	share_ptr(const share_ptr<_Ty>& other) throw()$/;"	f	class:share_ptr	access:public	signature:(const share_ptr<_Ty>& other)
share_ptr	include/share_ptr.h	/^class share_ptr$/;"	c
share_ptr::element_type	include/share_ptr.h	/^	typedef _Tx element_type;$/;"	t	class:share_ptr	access:public
share_ptr::free_holder	include/share_ptr.h	/^	void free_holder()$/;"	f	class:share_ptr	access:private	signature:()
share_ptr::get	include/share_ptr.h	/^	_Tx* get() throw()$/;"	f	class:share_ptr	access:public	signature:()
share_ptr::inc_holder	include/share_ptr.h	/^	void inc_holder()$/;"	f	class:share_ptr	access:private	signature:()
share_ptr::operator *	include/share_ptr.h	/^	_Tx& operator*() const$/;"	f	class:share_ptr	access:public	signature:() const
share_ptr::operator ->	include/share_ptr.h	/^	_Tx* operator->() const$/;"	f	class:share_ptr	access:public	signature:() const
share_ptr::operator =	include/share_ptr.h	/^	share_ptr<_Tx>& operator=(const share_ptr<_Ty>& other) throw ()$/;"	f	class:share_ptr	access:public	signature:(const share_ptr<_Ty>& other)
share_ptr::ptr	include/share_ptr.h	/^	const _Tx* ptr;$/;"	m	class:share_ptr	access:private
share_ptr::refCount	include/share_ptr.h	/^	int* refCount;$/;"	m	class:share_ptr	access:private
share_ptr::reset	include/share_ptr.h	/^	void reset(_Tx* p) throw()$/;"	f	class:share_ptr	access:public	signature:(_Tx* p)
share_ptr::share_ptr	include/share_ptr.h	/^	explicit share_ptr(_Tx* p = NULL) throw()$/;"	f	class:share_ptr	access:public	signature:(_Tx* p = NULL)
share_ptr::share_ptr	include/share_ptr.h	/^	share_ptr(const share_ptr<_Ty>& other) throw()$/;"	f	class:share_ptr	access:public	signature:(const share_ptr<_Ty>& other)
share_ptr::swap	include/share_ptr.h	/^	void swap(share_ptr<_Tx>& other)$/;"	f	class:share_ptr	access:public	signature:(share_ptr<_Tx>& other)
share_ptr::~share_ptr	include/share_ptr.h	/^	~share_ptr()$/;"	f	class:share_ptr	access:public	signature:()
shared_sheet	syntax/automachine.h	/^	typedef boost::shared_ptr<sparsesheet> shared_sheet;$/;"	t	class:automachine	access:public
sheet_	syntax/automachine.h	/^	shared_sheet sheet_;$/;"	m	class:automachine	access:private
sheetrow	syntax/automachine.h	/^		sheetrow()$/;"	f	class:automachine::sheetrow	access:public	signature:()
sheetrow	syntax/automachine.h	/^	class sheetrow : public kog::smart_vector<gotoitem>$/;"	c	class:automachine	inherits:kog::smart_vector	access:public
sid	galgorithm/regex2nfa.cpp	/^		int sid;$/;"	m	struct:parsecontent::sym	file:	access:public
sid	syntax/symbol.h	/^	int32 sid; \/\/ symbol id: used to index symbol$/;"	m	struct:symbol	access:public
sid	test/output/gen.cpp	/^	enum{ sid = 1001 };$/;"	e	enum:AExpression::__anon8	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1002 };$/;"	e	enum:AProgramItem::__anon9	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1003 };$/;"	e	enum:AValue::__anon10	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1004 };$/;"	e	enum:Expression::__anon11	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1005 };$/;"	e	enum:FuncCall::__anon12	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1006 };$/;"	e	enum:Function::__anon13	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1007 };$/;"	e	enum:FunctionContent::__anon14	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1008 };$/;"	e	enum:Print::__anon15	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1009 };$/;"	e	enum:Program::__anon16	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1010 };$/;"	e	enum:ReturnExp::__anon17	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1011 };$/;"	e	enum:ValueDeclear::__anon18	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1014 };$/;"	e	enum:number::__anon19	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1015 };$/;"	e	enum:op::__anon20	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1016 };$/;"	e	enum:print::__anon21	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1018 };$/;"	e	enum:seperator0::__anon22	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1019 };$/;"	e	enum:seperator1::__anon23	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1020 };$/;"	e	enum:seperator10::__anon24	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1021 };$/;"	e	enum:seperator2::__anon25	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1022 };$/;"	e	enum:seperator3::__anon26	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1023 };$/;"	e	enum:seperator4::__anon27	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1024 };$/;"	e	enum:seperator5::__anon28	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1025 };$/;"	e	enum:seperator6::__anon29	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1026 };$/;"	e	enum:seperator7::__anon30	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1027 };$/;"	e	enum:seperator8::__anon31	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1028 };$/;"	e	enum:seperator9::__anon32	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1029 };$/;"	e	enum:symbol::__anon33	file:
sid	test/output/gen.cpp	/^	enum{ sid = 1030 };$/;"	e	enum:valuetype::__anon34	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 0 };$/;"	e	enum:Program::__anon35	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 1 };$/;"	e	enum:AProgramItem::__anon36	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 10 };$/;"	e	enum:FuncCall::__anon45	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 11 };$/;"	e	enum:op::__anon46	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 12 };$/;"	e	enum:Print::__anon47	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 13 };$/;"	e	enum:printF::__anon48	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 14 };$/;"	e	enum:FunctionContent::__anon49	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 15 };$/;"	e	enum:ReturnExp::__anon50	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 16 };$/;"	e	enum:Return::__anon51	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 17 };$/;"	e	enum:Int::__anon52	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 18 };$/;"	e	enum:Float::__anon53	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 19 };$/;"	e	enum:seperator0::__anon54	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 2 };$/;"	e	enum:ValueDeclear::__anon37	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 20 };$/;"	e	enum:seperator1::__anon55	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 21 };$/;"	e	enum:seperator2::__anon56	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 22 };$/;"	e	enum:seperator3::__anon57	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 23 };$/;"	e	enum:seperator4::__anon58	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 24 };$/;"	e	enum:seperator5::__anon59	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 25 };$/;"	e	enum:seperator6::__anon60	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 26 };$/;"	e	enum:seperator7::__anon61	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 27 };$/;"	e	enum:seperator8::__anon62	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 28 };$/;"	e	enum:seperator9::__anon63	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 29 };$/;"	e	enum:seperator10::__anon64	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 3 };$/;"	e	enum:Function::__anon38	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 4 };$/;"	e	enum:Expression::__anon39	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 5 };$/;"	e	enum:valuetype::__anon40	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 6 };$/;"	e	enum:symbol::__anon41	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 7 };$/;"	e	enum:AExpression::__anon42	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 8 };$/;"	e	enum:AValue::__anon43	file:
sid	test/output/tinyg.cpp	/^	enum{ sid = 9 };$/;"	e	enum:number::__anon44	file:
sid	tmp/back/regex2nfa.cpp	/^		int sid;$/;"	m	struct:parsecontent::sym	file:	access:public
simple_grammar	test/tinygrammartest.cpp	/^	void simple_grammar();$/;"	p	class:grammar_wrapper	file:	access:public	signature:()
simple_grammar	test/tinygrammartest.cpp	/^void grammar_wrapper::simple_grammar()$/;"	f	class:grammar_wrapper	signature:()
simplegrammar	galgorithm/basicalgorithms.h	/^	simplegrammar(const grammar& gin, grammar& gout)$/;"	f	class:simplegrammar	access:public	signature:(const grammar& gin, grammar& gout)
simplegrammar	galgorithm/basicalgorithms.h	/^class simplegrammar : public grammar_algorithm$/;"	c	inherits:grammar_algorithm
simplegrammar::gin_	galgorithm/basicalgorithms.h	/^	const grammar* gin_;$/;"	m	class:simplegrammar	access:private
simplegrammar::gout_	galgorithm/basicalgorithms.h	/^	grammar* gout_;$/;"	m	class:simplegrammar	access:private
simplegrammar::invoke	galgorithm/basicalgorithms.h	/^	\/* overwrite *\/ virtual void invoke()$/;"	f	class:simplegrammar	access:public	signature:()
simplegrammar::operator ()	galgorithm/basicalgorithms.cpp	/^void simplegrammar::operator()(const grammar& gin, grammar& gout)$/;"	f	class:simplegrammar	signature:(const grammar& gin, grammar& gout)
simplegrammar::operator ()	galgorithm/basicalgorithms.h	/^	void operator()(const grammar& gin, grammar& gout);$/;"	p	class:simplegrammar	access:private	signature:(const grammar& gin, grammar& gout)
simplegrammar::simplegrammar	galgorithm/basicalgorithms.h	/^	simplegrammar(const grammar& gin, grammar& gout)$/;"	f	class:simplegrammar	access:public	signature:(const grammar& gin, grammar& gout)
simplegrammar_test	test/tinygrammartest.cpp	/^NEW_UNITTEST(simplegrammar_test);$/;"	v
simplegrammar_test	test/tinygrammartest.cpp	/^class simplegrammar_test : public unittest$/;"	c	file:	inherits:unittest
simplegrammar_test::cppfile	test/tinygrammartest.cpp	/^	std::string cppfile;$/;"	m	class:simplegrammar_test	file:	access:private
simplegrammar_test::init	test/tinygrammartest.cpp	/^	\/* overwrite *\/ virtual void init(int argc, const char* argv[])$/;"	f	class:simplegrammar_test	access:public	signature:(int argc, const char* argv[])
simplegrammar_test::init_grammar	test/tinygrammartest.cpp	/^	void init_grammar(grammar& g);$/;"	p	class:simplegrammar_test	file:	access:private	signature:(grammar& g)
simplegrammar_test::init_grammar	test/tinygrammartest.cpp	/^void simplegrammar_test::init_grammar(grammar& g)$/;"	f	class:simplegrammar_test	signature:(grammar& g)
simplegrammar_test::run_test	test/tinygrammartest.cpp	/^	\/* overwrite *\/ virtual void run_test()$/;"	f	class:simplegrammar_test	access:public	signature:()
singleton	include/singleton.h	/^	singleton(){}$/;"	f	class:singleton	access:protected	signature:()
singleton	include/singleton.h	/^	singleton(const singleton_type& other);$/;"	p	class:singleton	access:private	signature:(const singleton_type& other)
singleton	include/singleton.h	/^class singleton$/;"	c
singleton::instance	include/singleton.h	/^	static value_type& instance()$/;"	f	class:singleton	access:public	signature:()
singleton::operator =	include/singleton.h	/^	singleton_type& operator=(const singleton_type& other);$/;"	p	class:singleton	access:private	signature:(const singleton_type& other)
singleton::singleton	include/singleton.h	/^	singleton(){}$/;"	f	class:singleton	access:protected	signature:()
singleton::singleton	include/singleton.h	/^	singleton(const singleton_type& other);$/;"	p	class:singleton	access:private	signature:(const singleton_type& other)
singleton::singleton_type	include/singleton.h	/^	typedef singleton<_T> singleton_type;$/;"	t	class:singleton	access:public
singleton::value_type	include/singleton.h	/^	typedef _T value_type;$/;"	t	class:singleton	access:public
singleton::~singleton	include/singleton.h	/^	~singleton(){}$/;"	f	class:singleton	access:protected	signature:()
singleton_type	include/singleton.h	/^	typedef singleton<_T> singleton_type;$/;"	t	class:singleton	access:public
size	compiler/value.h	/^	uint32 size;$/;"	m	struct:value	access:public
size	include/arrayX.h	/^	size_t size() const {return Length; }$/;"	f	struct:SmartMatrix	access:public	signature:() const
size	include/arrayX.h	/^	size_t size() const {return _Length;}$/;"	f	struct:SmartArray	access:public	signature:() const
size	include/arrayX.h	/^	size_t size() const {return buf_.count;}$/;"	f	class:smart_vector	access:public	signature:() const
size_in_bytes	include/arrayX.h	/^	size_t size_in_bytes() const {return size() * sizeof(_Tx); }$/;"	f	class:smart_vector	access:public	signature:() const
size_type	include/arrayX.h	/^	typedef std::size_t size_type;$/;"	t	class:smart_vector	access:public
size_type	include/arrayX.h	/^	typedef std::size_t size_type;$/;"	t	struct:SmartArray	access:public
size_type	include/arrayX.h	/^	typedef std::size_t size_type;$/;"	t	struct:SmartMatrix	access:public
size_type	include/memoryX.h	/^	typedef std::size_t size_type;$/;"	t	struct:memblock	access:public
size_type	include/stringX.h	/^	typedef typename _Mybase::size_type size_type;$/;"	t	class:xstring_basic	access:public
smac	syntax/grammar.h	/^		smac = 3	\/\/ symbol match state machine$/;"	e	enum:grammar::symtype
smacs	test/tinygrammartest.cpp	/^std::deque<std::pair<tstring, int32> > Asymbol::smacs;$/;"	m	class:Asymbol	file:
smacs	test/vhelp.h	/^	static std::deque<std::pair<tstring, int32> > smacs;$/;"	m	class:Asymbol	access:public
smacs_	syntax/grammar.h	/^	vecsmacs smacs_; \/\/ state machines$/;"	m	class:grammar	access:protected
smart_matrix	include/arrayX.h	/^class smart_matrix$/;"	c
smart_vector	include/arrayX.h	/^	smart_vector()$/;"	f	class:smart_vector	access:public	signature:()
smart_vector	include/arrayX.h	/^	smart_vector(_InIt _First, _InIt _Last)$/;"	f	class:smart_vector	access:public	signature:(_InIt _First, _InIt _Last)
smart_vector	include/arrayX.h	/^	smart_vector(const smart_vector& _Other)$/;"	f	class:smart_vector	access:public	signature:(const smart_vector& _Other)
smart_vector	include/arrayX.h	/^	smart_vector(const_pointer _Buf, std::size_t _N)$/;"	f	class:smart_vector	access:public	signature:(const_pointer _Buf, std::size_t _N)
smart_vector	include/arrayX.h	/^	smart_vector(pointer _Buf, std::size_t _N)$/;"	f	class:smart_vector	access:public	signature:(pointer _Buf, std::size_t _N)
smart_vector	include/arrayX.h	/^	smart_vector(size_type _N)$/;"	f	class:smart_vector	access:public	signature:(size_type _N)
smart_vector	include/arrayX.h	/^	smart_vector(size_type _N, const_reference _Val)$/;"	f	class:smart_vector	access:public	signature:(size_type _N, const_reference _Val)
smart_vector	include/arrayX.h	/^class smart_vector$/;"	c
smart_vector::_Myt	include/arrayX.h	/^	typedef smart_vector<_Tx> _Myt;$/;"	t	class:smart_vector	access:public
smart_vector::assert_validate	include/arrayX.h	/^	void assert_validate() const$/;"	f	class:smart_vector	access:protected	signature:() const
smart_vector::at	include/arrayX.h	/^	const_reference at(size_type idx) const$/;"	f	class:smart_vector	access:public	signature:(size_type idx) const
smart_vector::at	include/arrayX.h	/^	reference at(size_type idx)$/;"	f	class:smart_vector	access:public	signature:(size_type idx)
smart_vector::attach	include/arrayX.h	/^	smart_vector& attach(pointer _Ptr, size_type _N, bool _AutoDelete = true)$/;"	f	class:smart_vector	access:public	signature:(pointer _Ptr, size_type _N, bool _AutoDelete = true)
smart_vector::back	include/arrayX.h	/^	const_reference back() const$/;"	f	class:smart_vector	access:public	signature:() const
smart_vector::back	include/arrayX.h	/^	reference back()$/;"	f	class:smart_vector	access:public	signature:()
smart_vector::begin	include/arrayX.h	/^	const_iterator begin() const { return const_iterator(buf_.values, buf_.count); }$/;"	f	class:smart_vector	access:public	signature:() const
smart_vector::begin	include/arrayX.h	/^	iterator begin() { return iterator(buf_.values, buf_.count); }$/;"	f	class:smart_vector	access:public	signature:()
smart_vector::block	include/arrayX.h	/^	struct block$/;"	s	class:smart_vector	access:protected
smart_vector::block::block	include/arrayX.h	/^		block(pointer ptr = NULL, size_type c = 0, bool d = true)$/;"	f	struct:smart_vector::block	access:public	signature:(pointer ptr = NULL, size_type c = 0, bool d = true)
smart_vector::block::count	include/arrayX.h	/^		size_t count;$/;"	m	struct:smart_vector::block	access:public
smart_vector::block::is_auto_delete	include/arrayX.h	/^		bool is_auto_delete;$/;"	m	struct:smart_vector::block	access:public
smart_vector::block::swap	include/arrayX.h	/^		void swap(block& _Other) throw()$/;"	f	struct:smart_vector::block	access:public	signature:(block& _Other)
smart_vector::block::values	include/arrayX.h	/^		pointer values;$/;"	m	struct:smart_vector::block	access:public
smart_vector::block::~block	include/arrayX.h	/^		~block()$/;"	f	struct:smart_vector::block	access:public	signature:()
smart_vector::buf_	include/arrayX.h	/^	block buf_;$/;"	m	class:smart_vector	access:private
smart_vector::const_iterator	include/arrayX.h	/^	typedef array_iterator<const value_type> const_iterator;$/;"	t	class:smart_vector	access:public
smart_vector::const_pointer	include/arrayX.h	/^	typedef const value_type* const_pointer;$/;"	t	class:smart_vector	access:public
smart_vector::const_reference	include/arrayX.h	/^	typedef const value_type& const_reference;$/;"	t	class:smart_vector	access:public
smart_vector::const_reverse_iterator	include/arrayX.h	/^	typedef std::reverse_iterator<const_iterator> const_reverse_iterator;$/;"	t	class:smart_vector	access:public
smart_vector::detach	include/arrayX.h	/^	smart_vector& detach()$/;"	f	class:smart_vector	access:public	signature:()
smart_vector::end	include/arrayX.h	/^	const_iterator end() const { return const_iterator(buf_.values + buf_.count, buf_.count, 0); }$/;"	f	class:smart_vector	access:public	signature:() const
smart_vector::end	include/arrayX.h	/^	iterator end() { return iterator(buf_.values + buf_.count, buf_.count, 0); }$/;"	f	class:smart_vector	access:public	signature:()
smart_vector::front	include/arrayX.h	/^	const_reference front() const$/;"	f	class:smart_vector	access:public	signature:() const
smart_vector::front	include/arrayX.h	/^	reference front()$/;"	f	class:smart_vector	access:public	signature:()
smart_vector::get	include/arrayX.h	/^	const_pointer get() const { return buf_.values; }$/;"	f	class:smart_vector	access:public	signature:() const
smart_vector::get	include/arrayX.h	/^	pointer get() { return buf_.values; }$/;"	f	class:smart_vector	access:public	signature:()
smart_vector::iterator	include/arrayX.h	/^	typedef array_iterator<value_type> iterator;$/;"	t	class:smart_vector	access:public
smart_vector::operator =	include/arrayX.h	/^	_Myt& operator=(const _Myt& _Other)$/;"	f	class:smart_vector	access:public	signature:(const _Myt& _Other)
smart_vector::operator =	include/arrayX.h	/^	_Myt& operator=(const _Tx& _val)$/;"	f	class:smart_vector	access:public	signature:(const _Tx& _val)
smart_vector::operator []	include/arrayX.h	/^	const_reference operator[](size_type idx) const { return buf_.values[idx]; }$/;"	f	class:smart_vector	access:public	signature:(size_type idx) const
smart_vector::operator []	include/arrayX.h	/^	reference operator[](size_type idx) { return buf_.values[idx]; }$/;"	f	class:smart_vector	access:public	signature:(size_type idx)
smart_vector::pointer	include/arrayX.h	/^	typedef value_type* pointer;$/;"	t	class:smart_vector	access:public
smart_vector::rbegin	include/arrayX.h	/^	const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); }$/;"	f	class:smart_vector	access:public	signature:() const
smart_vector::rbegin	include/arrayX.h	/^	reverse_iterator rbegin() { return reverse_iterator(end()); }$/;"	f	class:smart_vector	access:public	signature:()
smart_vector::reference	include/arrayX.h	/^	typedef value_type& reference;$/;"	t	class:smart_vector	access:public
smart_vector::release	include/arrayX.h	/^	pointer release()$/;"	f	class:smart_vector	access:public	signature:()
smart_vector::rend	include/arrayX.h	/^	const_reverse_iterator rend() const { return const_reverse_iterator(begin()); }$/;"	f	class:smart_vector	access:public	signature:() const
smart_vector::rend	include/arrayX.h	/^	reverse_iterator rend() { return reverse_iterator(begin()); }$/;"	f	class:smart_vector	access:public	signature:()
smart_vector::reset	include/arrayX.h	/^	smart_vector& reset(size_type _N)$/;"	f	class:smart_vector	access:public	signature:(size_type _N)
smart_vector::reverse_iterator	include/arrayX.h	/^	typedef std::reverse_iterator<iterator> reverse_iterator;$/;"	t	class:smart_vector	access:public
smart_vector::size	include/arrayX.h	/^	size_t size() const {return buf_.count;}$/;"	f	class:smart_vector	access:public	signature:() const
smart_vector::size_in_bytes	include/arrayX.h	/^	size_t size_in_bytes() const {return size() * sizeof(_Tx); }$/;"	f	class:smart_vector	access:public	signature:() const
smart_vector::size_type	include/arrayX.h	/^	typedef std::size_t size_type;$/;"	t	class:smart_vector	access:public
smart_vector::smart_vector	include/arrayX.h	/^	smart_vector()$/;"	f	class:smart_vector	access:public	signature:()
smart_vector::smart_vector	include/arrayX.h	/^	smart_vector(_InIt _First, _InIt _Last)$/;"	f	class:smart_vector	access:public	signature:(_InIt _First, _InIt _Last)
smart_vector::smart_vector	include/arrayX.h	/^	smart_vector(const smart_vector& _Other)$/;"	f	class:smart_vector	access:public	signature:(const smart_vector& _Other)
smart_vector::smart_vector	include/arrayX.h	/^	smart_vector(const_pointer _Buf, std::size_t _N)$/;"	f	class:smart_vector	access:public	signature:(const_pointer _Buf, std::size_t _N)
smart_vector::smart_vector	include/arrayX.h	/^	smart_vector(pointer _Buf, std::size_t _N)$/;"	f	class:smart_vector	access:public	signature:(pointer _Buf, std::size_t _N)
smart_vector::smart_vector	include/arrayX.h	/^	smart_vector(size_type _N)$/;"	f	class:smart_vector	access:public	signature:(size_type _N)
smart_vector::smart_vector	include/arrayX.h	/^	smart_vector(size_type _N, const_reference _Val)$/;"	f	class:smart_vector	access:public	signature:(size_type _N, const_reference _Val)
smart_vector::swap	include/arrayX.h	/^	void swap(_Myt& _Other)$/;"	f	class:smart_vector	access:public	signature:(_Myt& _Other)
smart_vector::value_type	include/arrayX.h	/^	typedef _Tx value_type;$/;"	t	class:smart_vector	access:public
sorp	galgorithm/lranalyse.cpp	/^	int32 sorp; \/\/ 0: s, 1: p$/;"	m	struct:nextstate	file:	access:public
sotfile_	test/firstfollowtest.cpp	/^	std::string sotfile_;$/;"	m	class:firstfollow_test	file:	access:private
sparsesheet	galgorithm/lranalyse.cpp	/^	std::list<kog::triple<const lrstate*, int32, nextstate> > sparsesheet;$/;"	m	struct:AlgorithmArg	file:	access:public
sparsesheet	syntax/automachine.h	/^	typedef kog::smart_vector<sheetrow> sparsesheet;$/;"	t	class:automachine	access:public
special	syntax/automachine.h	/^		enum { anychar, special, exclude };$/;"	e	enum:automachine::sheetrow::__anon5
split	galgorithm/nfa2dfa.cpp	/^void nfa2dfa::split(const std::vector<const production*>& t, kog::smart_vector<int32>& smap, std::deque<std::set<int32> >& s) const$/;"	f	class:nfa2dfa	signature:(const std::vector<const production*>& t, kog::smart_vector<int32>& smap, std::deque<std::set<int32> >& s) const
split	galgorithm/nfa2dfa.h	/^	void split(const std::vector<const production*>& t, kog::smart_vector<int32>& smap, std::deque<std::set<int32> >& s) const;$/;"	p	class:nfa2dfa	access:private	signature:(const std::vector<const production*>& t, kog::smart_vector<int32>& smap, std::deque<std::set<int32> >& s) const
split	include/stringXF.h	/^std::vector<std::basic_string<_Elem> > split(const std::basic_string<_Elem>& str, const std::basic_string<_Elem>& space, bool is_remove_empty = false)$/;"	f	signature:(const std::basic_string<_Elem>& str, const std::basic_string<_Elem>& space, bool is_remove_empty = false)
splitwords_test	test/splitwords.cpp	/^NEW_UNITTEST(splitwords_test);$/;"	v
splitwords_test	test/splitwords.cpp	/^class splitwords_test : public sc::unittest$/;"	c	file:	inherits:sc::unittest
splitwords_test::init	test/splitwords.cpp	/^	\/* overwrite *\/ virtual void init(int argc, const char* argv[])$/;"	f	class:splitwords_test	access:public	signature:(int argc, const char* argv[])
splitwords_test::input	test/splitwords.cpp	/^	std::string input;$/;"	m	class:splitwords_test	file:	access:private
splitwords_test::otput	test/splitwords.cpp	/^	std::string otput;$/;"	m	class:splitwords_test	file:	access:private
splitwords_test::run_test	test/splitwords.cpp	/^	\/* overwrite *\/ virtual void run_test()$/;"	f	class:splitwords_test	access:public	signature:()
sqrt	include/mathX.h	/^	static T sqrt(const T value)$/;"	f	class:math	access:public	signature:(const T value)
square	include/mathX.h	/^	static T square(const T value)$/;"	f	class:math	access:public	signature:(const T value)
sstate_	syntax/automachine.h	/^	int sstate_; \/\/ start state$/;"	m	class:automachine	access:protected
stackitem	syntax/lrmachine.h	/^		stackitem(int32 s = -1, int32 m = -1)$/;"	f	struct:lrmachine::stackitem	access:public	signature:(int32 s = -1, int32 m = -1)
stackitem	syntax/lrmachine.h	/^	struct stackitem$/;"	s	class:lrmachine	access:private
start_symbol_	syntax/grammar.h	/^	int32 start_symbol_; \/\/ start symbol sid$/;"	m	class:tinygrammar	access:protected
state	syntax/lrmachine.h	/^		int32 state;$/;"	m	struct:lrmachine::stackitem	access:public
state_machine	compiler/compiler.h	/^	typedef compile::state_machine state_machine;$/;"	t	class:compiler	access:public
state_machine	syntax/statemachine.cpp	/^state_machine::state_machine()$/;"	f	class:state_machine	signature:()
state_machine	syntax/statemachine.cpp	/^state_machine::state_machine(const shared_sheet& asheet)$/;"	f	class:state_machine	signature:(const shared_sheet& asheet)
state_machine	syntax/statemachine.h	/^	state_machine();$/;"	p	class:state_machine	access:public	signature:()
state_machine	syntax/statemachine.h	/^	state_machine(const shared_sheet& asheet);$/;"	p	class:state_machine	access:public	signature:(const shared_sheet& asheet)
state_machine	syntax/statemachine.h	/^class state_machine : public automachine$/;"	c	inherits:automachine
state_machine::MEMBER_VARIABLE_GET_SET	syntax/statemachine.h	/^	MEMBER_VARIABLE_GET_SET(tstring, str, str_);$/;"	p	class:state_machine	access:public	signature:(tstring, str, str_)
state_machine::eta	syntax/statemachine.cpp	/^bool state_machine::eta(int32 meta)$/;"	f	class:state_machine	signature:(int32 meta)
state_machine::eta	syntax/statemachine.h	/^	\/* overwrite *\/ virtual bool eta(int meta);$/;"	p	class:state_machine	access:public	signature:(int meta)
state_machine::init	syntax/statemachine.cpp	/^void state_machine::init()$/;"	f	class:state_machine	signature:()
state_machine::init	syntax/statemachine.h	/^	\/* overwrite *\/ virtual void init();$/;"	p	class:state_machine	access:public	signature:()
state_machine::state_machine	syntax/statemachine.cpp	/^state_machine::state_machine()$/;"	f	class:state_machine	signature:()
state_machine::state_machine	syntax/statemachine.cpp	/^state_machine::state_machine(const shared_sheet& asheet)$/;"	f	class:state_machine	signature:(const shared_sheet& asheet)
state_machine::state_machine	syntax/statemachine.h	/^	state_machine();$/;"	p	class:state_machine	access:public	signature:()
state_machine::state_machine	syntax/statemachine.h	/^	state_machine(const shared_sheet& asheet);$/;"	p	class:state_machine	access:public	signature:(const shared_sheet& asheet)
state_machine::str_	syntax/statemachine.h	/^	tstring str_;$/;"	m	class:state_machine	access:private
state_machine::swap	syntax/statemachine.h	/^	void swap(state_machine& other)$/;"	f	class:state_machine	access:public	signature:(state_machine& other)
state_machine::~state_machine	syntax/statemachine.cpp	/^state_machine::~state_machine()$/;"	f	class:state_machine	signature:()
state_machine::~state_machine	syntax/statemachine.h	/^	virtual ~state_machine();$/;"	p	class:state_machine	access:public	signature:()
strMeta	third_party/xml/Markup.cpp	/^	MCD_STR strMeta;$/;"	m	struct:NodePos	file:	access:public
strName	third_party/xml/Markup.cpp	/^	MCD_STR strName;$/;"	m	struct:SavedPos	file:	access:public
strTagName	third_party/xml/Markup.cpp	/^	MCD_STR strTagName;$/;"	m	struct:TagPos	file:	access:public
str_	syntax/statemachine.h	/^	tstring str_;$/;"	m	class:state_machine	access:private
streamsplit	compiler/extract.cpp	/^compile::doc::streamsplit::streamsplit()$/;"	f	class:compile::doc::streamsplit	signature:()
streamsplit	compiler/extract.h	/^	streamsplit();$/;"	p	class:streamsplit	access:public	signature:()
streamsplit	compiler/extract.h	/^class streamsplit$/;"	c
streamsplit::MEMBER_VARIABLE_GET	compiler/extract.h	/^	MEMBER_VARIABLE_GET(const deqwords&, words, words_);$/;"	p	class:streamsplit	access:public	signature:(const deqwords&, words, words_)
streamsplit::deqwords	compiler/extract.h	/^	typedef std::deque<word> deqwords;$/;"	t	class:streamsplit	access:public
streamsplit::operator ()	compiler/extract.cpp	/^streamsplit::deqwords& streamsplit::operator()(std::istream& is)$/;"	f	class:streamsplit	signature:(std::istream& is)
streamsplit::operator ()	compiler/extract.h	/^	deqwords& operator()(std::istream& is);$/;"	p	class:streamsplit	access:public	signature:(std::istream& is)
streamsplit::streamsplit	compiler/extract.h	/^	streamsplit();$/;"	p	class:streamsplit	access:public	signature:()
streamsplit::words_	compiler/extract.h	/^	deqwords words_;$/;"	m	class:streamsplit	access:private
streamsplit::~streamsplit	compiler/extract.h	/^	virtual ~streamsplit();$/;"	p	class:streamsplit	access:public	signature:()
strformat	include/stringXF.h	/^class strformat$/;"	c
strformat::format	include/stringXF.h	/^	static std::string format(const char* fmt, ...)$/;"	f	class:strformat	access:public	signature:(const char* fmt, ...)
strformat::format	include/stringXF.h	/^	static std::string& format(const char* fmt, va_list argptr, std::string& out_buf)$/;"	f	class:strformat	access:public	signature:(const char* fmt, va_list argptr, std::string& out_buf)
strformat::format	include/stringXF.h	/^	static std::wstring format(const wchar_t* fmt, ...)$/;"	f	class:strformat	access:public	signature:(const wchar_t* fmt, ...)
strformat::format	include/stringXF.h	/^	static std::wstring& format(const wchar_t* fmt, va_list argptr, std::wstring& out_buf)$/;"	f	class:strformat	access:public	signature:(const wchar_t* fmt, va_list argptr, std::wstring& out_buf)
stringBuf	test/tinygrammartest.cpp	/^std::deque<tchar> Asymbol::stringBuf;$/;"	m	class:Asymbol	file:
stringBuf	test/vhelp.h	/^	static std::deque<tchar> stringBuf;$/;"	m	class:Asymbol	access:public
stringX	third_party/regex/xregex.cpp	/^namespace stringX{$/;"	n	file:
stringX	third_party/regex/xregex.h	/^namespace stringX{$/;"	n
stringX::convert_error	third_party/regex/xregex.h	/^class convert_error : public std::runtime_error$/;"	c	namespace:stringX	inherits:std::runtime_error
stringX::convert_error::convert_error	third_party/regex/xregex.h	/^	convert_error(const _Tx& _Src, const _Ty& _Dst)$/;"	f	class:stringX::convert_error	access:public	signature:(const _Tx& _Src, const _Ty& _Dst)
stringX::convert_error::convert_error	third_party/regex/xregex.h	/^	convert_error(const std::string& error_msg)$/;"	f	class:stringX::convert_error	access:public	signature:(const std::string& error_msg)
stringX::convert_error::new_error_msg	third_party/regex/xregex.h	/^	static std::string new_error_msg(const _Tx& _Src, const _Ty& _Dst)$/;"	f	class:stringX::convert_error	access:private	signature:(const _Tx& _Src, const _Ty& _Dst)
stringX::is_match	third_party/regex/xregex.cpp	/^bool is_match(const boost::regex& regex, const xregex::tstring& content)$/;"	f	namespace:stringX	signature:(const boost::regex& regex, const xregex::tstring& content)
stringX::xregex	third_party/regex/xregex.h	/^class xregex$/;"	c	namespace:stringX
stringX::xregex::char_type	third_party/regex/xregex.h	/^	typedef char char_type;$/;"	t	class:stringX::xregex	access:public
stringX::xregex::is_id	third_party/regex/xregex.cpp	/^bool xregex::is_id(const tstring& str)$/;"	f	class:stringX::xregex	signature:(const tstring& str)
stringX::xregex::is_id	third_party/regex/xregex.h	/^	static bool is_id(const tstring& str);$/;"	p	class:stringX::xregex	access:public	signature:(const tstring& str)
stringX::xregex::is_interge	third_party/regex/xregex.cpp	/^bool xregex::is_interge(const tstring& str)$/;"	f	class:stringX::xregex	signature:(const tstring& str)
stringX::xregex::is_interge	third_party/regex/xregex.h	/^	static bool is_interge(const tstring& str);$/;"	p	class:stringX::xregex	access:public	signature:(const tstring& str)
stringX::xregex::is_match	third_party/regex/xregex.cpp	/^bool xregex::is_match(const tstring& regex_str, const tstring& content)$/;"	f	class:stringX::xregex	signature:(const tstring& regex_str, const tstring& content)
stringX::xregex::is_match	third_party/regex/xregex.h	/^	static bool is_match(const tstring& regex_str, const tstring& content);$/;"	p	class:stringX::xregex	access:public	signature:(const tstring& regex_str, const tstring& content)
stringX::xregex::replace_all	third_party/regex/xregex.cpp	/^xregex::tstring xregex::replace_all(const tstring& regex_str, $/;"	f	class:stringX::xregex	signature:(const tstring& regex_str, const tstring& replace_str, const tstring& org_str)
stringX::xregex::replace_all	third_party/regex/xregex.h	/^	static tstring replace_all(const tstring& regex_str, $/;"	p	class:stringX::xregex	access:public	signature:(const tstring& regex_str, const tstring& replace_str, const tstring& org_str)
stringX::xregex::tstring	third_party/regex/xregex.h	/^	typedef std::basic_string<char_type> tstring;$/;"	t	class:stringX::xregex	access:public
stringX::xregex::xregex	third_party/regex/xregex.cpp	/^xregex::xregex(void)$/;"	f	class:stringX::xregex	signature:(void)
stringX::xregex::xregex	third_party/regex/xregex.h	/^	xregex(void);$/;"	p	class:stringX::xregex	access:public	signature:(void)
stringX::xregex::~xregex	third_party/regex/xregex.cpp	/^xregex::~xregex(void)$/;"	f	class:stringX::xregex	signature:(void)
stringX::xregex::~xregex	third_party/regex/xregex.h	/^	~xregex(void);$/;"	p	class:stringX::xregex	access:public	signature:(void)
stringcmp	include/stringXF.h	/^struct stringcmp : public std::binary_function<std::basic_string<_Elem>, std::basic_string<_Elem>, bool>$/;"	s	inherits:std::binary_function
stringcmp::_fun	include/stringXF.h	/^	_CmpFunc _fun;$/;"	m	struct:stringcmp	access:public
stringcmp::operator ()	include/stringXF.h	/^	bool operator()(const std::basic_string<_Elem>& str1, const std::basic_string<_Elem>& str2) const$/;"	f	struct:stringcmp	access:public	signature:(const std::basic_string<_Elem>& str1, const std::basic_string<_Elem>& str2) const
stringless	include/stringXF.h	/^typedef stringcmp<std::less<std::string>, char> stringless; $/;"	t
stringless	syntax/symbol.h	/^struct stringless : public std::binary_function<const tchar*, const tchar*, bool>$/;"	s	inherits:std::binary_function
stringless::operator ()	syntax/symbol.h	/^	bool operator()(const tchar* str1, const tchar* str2) const$/;"	f	struct:stringless	access:public	signature:(const tchar* str1, const tchar* str2) const
substr	include/stringX.h	/^	_Myt substr(size_type _Off = 0, size_type _Count = _Mybase::npos) const$/;"	f	class:xstring_basic	access:public	signature:(size_type _Off = 0, size_type _Count = _Mybase::npos) const
swap	include/arrayX.h	/^		void swap(block& _Other) throw()$/;"	f	struct:smart_vector::block	access:public	signature:(block& _Other)
swap	include/arrayX.h	/^	void swap(_Myt& _Other)$/;"	f	class:smart_vector	access:public	signature:(_Myt& _Other)
swap	include/functionalX.h	/^	void swap(_Myt& _Right)$/;"	f	struct:triple	access:public	signature:(_Myt& _Right)
swap	include/markuputils.h	/^	void swap(file& other)$/;"	f	class:file	access:public	signature:(file& other)
swap	include/markuputils.h	/^	void swap(ifile& other)$/;"	f	class:ifile	access:public	signature:(ifile& other)
swap	include/share_ptr.h	/^	void swap(share_ptr<_Tx>& other)$/;"	f	class:share_ptr	access:public	signature:(share_ptr<_Tx>& other)
swap	syntax/automachine.h	/^	void swap(automachine& other)$/;"	f	class:automachine	access:public	signature:(automachine& other)
swap	syntax/grammar.cpp	/^void grammar::swap(grammar& other) throw ()$/;"	f	class:grammar	signature:(grammar& other)
swap	syntax/grammar.cpp	/^void tinygrammar::swap(tinygrammar& other) throw()$/;"	f	class:tinygrammar	signature:(tinygrammar& other)
swap	syntax/grammar.h	/^	void swap(grammar& other) throw ();$/;"	p	class:grammar	access:public	signature:(grammar& other)
swap	syntax/grammar.h	/^	void swap(tinygrammar& other) throw();$/;"	p	class:tinygrammar	access:public	signature:(tinygrammar& other)
swap	syntax/loader.h	/^	void swap(loader& other);$/;"	p	class:loader	access:public	signature:(loader& other)
swap	syntax/production.cpp	/^void production::swap(production& other)$/;"	f	class:production	signature:(production& other)
swap	syntax/production.h	/^	void swap(production& other);$/;"	p	class:production	access:public	signature:(production& other)
swap	syntax/statemachine.h	/^	void swap(state_machine& other)$/;"	f	class:state_machine	access:public	signature:(state_machine& other)
swap	syntax/symbol.h	/^	void swap(symholder& other)$/;"	f	class:symholder	access:public	signature:(symholder& other)
swap	syntax/word.h	/^	void swap(word& aword)$/;"	f	struct:word	access:public	signature:(word& aword)
swcvt	include/stringXF.h	/^	struct swcvt$/;"	s	namespace:Format
switch_brace_or	galgorithm/regex2nfa.cpp	/^	int switch_brace_or(std::vector<int>& R, const char* p, int L, char rc)$/;"	f	struct:parsecontent	access:public	signature:(std::vector<int>& R, const char* p, int L, char rc)
switch_brace_or	tmp/back/regex2nfa.cpp	/^	int switch_brace_or(std::vector<int>& R, const char* p, int L, char rc)$/;"	f	struct:parsecontent	access:public	signature:(std::vector<int>& R, const char* p, int L, char rc)
sym	galgorithm/regex2nfa.cpp	/^	struct sym$/;"	s	struct:parsecontent	file:	access:public
sym	tmp/back/regex2nfa.cpp	/^	struct sym$/;"	s	struct:parsecontent	file:	access:public
symbol	syntax/symbol.h	/^struct symbol$/;"	s
symbol	test/output/gen.cpp	/^	symbol()$/;"	f	struct:symbol	access:public	signature:()
symbol	test/output/gen.cpp	/^struct symbol : public type$/;"	s	file:	inherits:type
symbol	test/output/tinyg.cpp	/^	symbol()$/;"	f	struct:symbol	access:public	signature:()
symbol	test/output/tinyg.cpp	/^struct symbol : public type$/;"	s	file:	inherits:type
symbol::Lfuncs	syntax/symbol.h	/^	int8 Lfuncs;$/;"	m	struct:symbol	access:public
symbol::Lname	syntax/symbol.h	/^	int16 Lname;$/;"	m	struct:symbol	access:public
symbol::funcs	syntax/symbol.h	/^	symfunc* funcs;$/;"	m	struct:symbol	access:public
symbol::ist	syntax/symbol.h	/^	int8 ist;$/;"	m	struct:symbol	access:public
symbol::name	syntax/symbol.h	/^	const tchar* name;$/;"	m	struct:symbol	access:public
symbol::sid	syntax/symbol.h	/^	int32 sid; \/\/ symbol id: used to index symbol$/;"	m	struct:symbol	access:public
symbol::sid	test/output/gen.cpp	/^	enum{ sid = 1029 };$/;"	e	enum:symbol::__anon33	file:
symbol::sid	test/output/tinyg.cpp	/^	enum{ sid = 6 };$/;"	e	enum:symbol::__anon41	file:
symbol::symbol	test/output/gen.cpp	/^	symbol()$/;"	f	struct:symbol	access:public	signature:()
symbol::symbol	test/output/tinyg.cpp	/^	symbol()$/;"	f	struct:symbol	access:public	signature:()
symbolname_Cmp	syntax/symbol.h	/^struct symbolname_Cmp : public std::binary_function<symbol, symbol, bool>$/;"	s	inherits:std::binary_function
symbolname_Cmp::_Cmp	syntax/symbol.h	/^	_CmpFunc _Cmp;$/;"	m	struct:symbolname_Cmp	access:public
symbolname_Cmp::operator ()	syntax/symbol.h	/^	bool operator()(const symbol& s1, const symbol& s2) const$/;"	f	struct:symbolname_Cmp	access:public	signature:(const symbol& s1, const symbol& s2) const
symbolname_Less	syntax/symbol.h	/^typedef symbolname_Cmp<stringless> symbolname_Less;$/;"	t
symbols	test/vhelp.h	/^	static const compile::symholder*& symbols()$/;"	f	class:V	access:public	signature:()
symbols	test/vhelp.h	/^	static const compile::symholder*& symbols()$/;"	f	struct:symindex	access:public	signature:()
symbols_	syntax/grammar.h	/^	symholder symbols_; \/\/ all symbols$/;"	m	class:tinygrammar	access:protected
symcontentstring_	syntax/symbol.h	/^	kog::smart_vector<tchar> symcontentstring_;$/;"	m	class:symholder	access:private
symfunc	syntax/symbol.h	/^struct symfunc$/;"	s
symfunc::func	syntax/symbol.h	/^	function func;$/;"	m	struct:symfunc	access:public
symfunc::function	syntax/symbol.h	/^	typedef void* (*function)(void*);$/;"	t	struct:symfunc	access:public
symfunc::name	syntax/symbol.h	/^	tstring name;$/;"	m	struct:symfunc	access:public
symholder	syntax/symbol.h	/^	symholder()$/;"	f	class:symholder	access:public	signature:()
symholder	syntax/symbol.h	/^	symholder(_Iter_Sym _First, _Iter_Sym _End) $/;"	f	class:symholder	access:public	signature:(_Iter_Sym _First, _Iter_Sym _End)
symholder	syntax/symbol.h	/^	symholder(_StrIter _First_Str, _StrIter _End_Str, _SymIter _First_Sym, _SymIter _End_Sym)$/;"	f	class:symholder	access:public	signature:(_StrIter _First_Str, _StrIter _End_Str, _SymIter _First_Sym, _SymIter _End_Sym)
symholder	syntax/symbol.h	/^class symholder : public kog::smart_vector<symbol>$/;"	c	inherits:kog::smart_vector
symholder::getstringptr	syntax/symbol.h	/^	const tchar* getstringptr() const$/;"	f	class:symholder	access:public	signature:() const
symholder::index	syntax/symbol.cpp	/^int32 symholder::index(const tstring& name) const$/;"	f	class:symholder	signature:(const tstring& name) const
symholder::index	syntax/symbol.h	/^	int index(const tstring& name) const;$/;"	p	class:symholder	access:public	signature:(const tstring& name) const
symholder::make_index	syntax/symbol.cpp	/^void symholder::make_index()$/;"	f	class:symholder	signature:()
symholder::make_index	syntax/symbol.h	/^	void make_index();$/;"	p	class:symholder	access:public	signature:()
symholder::nameIndexer_	syntax/symbol.h	/^	std::map<const tchar*, const symbol*, stringless> nameIndexer_;$/;"	m	class:symholder	access:private
symholder::swap	syntax/symbol.h	/^	void swap(symholder& other)$/;"	f	class:symholder	access:public	signature:(symholder& other)
symholder::symcontentstring_	syntax/symbol.h	/^	kog::smart_vector<tchar> symcontentstring_;$/;"	m	class:symholder	access:private
symholder::symholder	syntax/symbol.h	/^	symholder()$/;"	f	class:symholder	access:public	signature:()
symholder::symholder	syntax/symbol.h	/^	symholder(_Iter_Sym _First, _Iter_Sym _End) $/;"	f	class:symholder	access:public	signature:(_Iter_Sym _First, _Iter_Sym _End)
symholder::symholder	syntax/symbol.h	/^	symholder(_StrIter _First_Str, _StrIter _End_Str, _SymIter _First_Sym, _SymIter _End_Sym)$/;"	f	class:symholder	access:public	signature:(_StrIter _First_Str, _StrIter _End_Str, _SymIter _First_Sym, _SymIter _End_Sym)
symholder::updata_sys_symbols	syntax/symbol.h	/^	void updata_sys_symbols();$/;"	p	class:symholder	access:private	signature:()
symindex	test/vhelp.h	/^	symindex(const compile::tchar* name)$/;"	f	struct:symindex	access:public	signature:(const compile::tchar* name)
symindex	test/vhelp.h	/^	symindex(const tstring& name)$/;"	f	struct:symindex	access:public	signature:(const tstring& name)
symindex	test/vhelp.h	/^	symindex(int32 u)$/;"	f	struct:symindex	access:public	signature:(int32 u)
symindex	test/vhelp.h	/^struct symindex$/;"	s
symindex::idx	test/vhelp.h	/^	int32 idx;$/;"	m	struct:symindex	access:public
symindex::int32	test/vhelp.h	/^	typedef compile::int32 int32;$/;"	t	struct:symindex	access:public
symindex::operator int32	test/vhelp.h	/^	operator int32() const$/;"	f	struct:symindex	access:public	signature:() const
symindex::symbols	test/vhelp.h	/^	static const compile::symholder*& symbols()$/;"	f	struct:symindex	access:public	signature:()
symindex::symindex	test/vhelp.h	/^	symindex(const compile::tchar* name)$/;"	f	struct:symindex	access:public	signature:(const compile::tchar* name)
symindex::symindex	test/vhelp.h	/^	symindex(const tstring& name)$/;"	f	struct:symindex	access:public	signature:(const tstring& name)
symindex::symindex	test/vhelp.h	/^	symindex(int32 u)$/;"	f	struct:symindex	access:public	signature:(int32 u)
symindex::tstring	test/vhelp.h	/^	typedef compile::tstring tstring;$/;"	t	struct:symindex	access:public
syms	galgorithm/regex2nfa.cpp	/^	std::deque<sym> syms;$/;"	m	struct:parsecontent	file:	access:public
syms	tmp/back/regex2nfa.cpp	/^	std::deque<sym> syms;$/;"	m	struct:parsecontent	file:	access:public
symtype	syntax/grammar.h	/^	enum symtype$/;"	g	class:grammar	access:public
syntax_	makecompiler/gensyntax.h	/^	const grammar* syntax_;$/;"	m	class:syntaxgenerator	access:public
syntaxgenerator	makecompiler/gensyntax.cpp	/^syntaxgenerator::syntaxgenerator()$/;"	f	class:syntaxgenerator	signature:()
syntaxgenerator	makecompiler/gensyntax.h	/^	syntaxgenerator();$/;"	p	class:syntaxgenerator	access:public	signature:()
syntaxgenerator	makecompiler/gensyntax.h	/^class syntaxgenerator$/;"	c
syntaxgenerator::cppfile_	makecompiler/gensyntax.h	/^	tstring cppfile_;$/;"	m	class:syntaxgenerator	access:public
syntaxgenerator::cppstream_	makecompiler/gensyntax.h	/^	std::ostream* cppstream_;$/;"	m	class:syntaxgenerator	access:public
syntaxgenerator::operator ()	makecompiler/gensyntax.cpp	/^void syntaxgenerator::operator()(const grammar* aGrammar, const tstring& outfile)$/;"	f	class:syntaxgenerator	signature:(const grammar* aGrammar, const tstring& outfile)
syntaxgenerator::operator ()	makecompiler/gensyntax.h	/^	void operator()(const grammar* aGrammar, const tstring& outfile);$/;"	p	class:syntaxgenerator	access:public	signature:(const grammar* aGrammar, const tstring& outfile)
syntaxgenerator::print_statemachines	makecompiler/gensyntax.cpp	/^void syntaxgenerator::print_statemachines()$/;"	f	class:syntaxgenerator	signature:()
syntaxgenerator::print_statemachines	makecompiler/gensyntax.h	/^	void print_statemachines();$/;"	p	class:syntaxgenerator	access:private	signature:()
syntaxgenerator::print_symbols	makecompiler/gensyntax.cpp	/^void syntaxgenerator::print_symbols()$/;"	f	class:syntaxgenerator	signature:()
syntaxgenerator::print_symbols	makecompiler/gensyntax.h	/^	void print_symbols();$/;"	p	class:syntaxgenerator	access:private	signature:()
syntaxgenerator::regex_str_to_machine	makecompiler/gensyntax.cpp	/^void syntaxgenerator::regex_str_to_machine(const std::string& regexstr, automachine& m)$/;"	f	class:syntaxgenerator	signature:(const std::string& regexstr, automachine& m)
syntaxgenerator::regex_str_to_machine	makecompiler/gensyntax.h	/^	void regex_str_to_machine(const std::string& regexstr, automachine& m);$/;"	p	class:syntaxgenerator	access:private	signature:(const std::string& regexstr, automachine& m)
syntaxgenerator::syntax_	makecompiler/gensyntax.h	/^	const grammar* syntax_;$/;"	m	class:syntaxgenerator	access:public
syntaxgenerator::syntaxgenerator	makecompiler/gensyntax.cpp	/^syntaxgenerator::syntaxgenerator()$/;"	f	class:syntaxgenerator	signature:()
syntaxgenerator::syntaxgenerator	makecompiler/gensyntax.h	/^	syntaxgenerator();$/;"	p	class:syntaxgenerator	access:public	signature:()
syntaxgenerator::~syntaxgenerator	makecompiler/gensyntax.cpp	/^syntaxgenerator::~syntaxgenerator()$/;"	f	class:syntaxgenerator	signature:()
syntaxgenerator::~syntaxgenerator	makecompiler/gensyntax.h	/^	virtual ~syntaxgenerator();$/;"	p	class:syntaxgenerator	access:public	signature:()
tabident	makecompiler/gensyntax.cpp	/^	tabident(int i = 0)$/;"	f	struct:tabident	access:public	signature:(int i = 0)
tabident	makecompiler/gensyntax.cpp	/^struct tabident$/;"	s	file:
tabident::dectab	makecompiler/gensyntax.cpp	/^	static tabident dectab;$/;"	m	struct:tabident	file:	access:public
tabident::inc	makecompiler/gensyntax.cpp	/^	int inc;$/;"	m	struct:tabident	file:	access:private
tabident::inctab	makecompiler/gensyntax.cpp	/^	static tabident inctab;$/;"	m	struct:tabident	file:	access:public
tabident::newline	makecompiler/gensyntax.cpp	/^	static std::ostream& newline(std::ostream& os)$/;"	f	struct:tabident	access:public	signature:(std::ostream& os)
tabident::operator <<	makecompiler/gensyntax.cpp	/^	friend std::ostream& operator<<(std::ostream& os, const tabident& a)$/;"	f	struct:tabident	access:friend	signature:(std::ostream& os, const tabident& a)
tabident::tabident	makecompiler/gensyntax.cpp	/^	tabident(int i = 0)$/;"	f	struct:tabident	access:public	signature:(int i = 0)
tabident::tabs	makecompiler/gensyntax.cpp	/^	static int tabs;$/;"	m	struct:tabident	file:	access:private
tabident::tabs	makecompiler/gensyntax.cpp	/^int tabident::tabs = 0;$/;"	m	class:tabident	file:
tabs	makecompiler/gensyntax.cpp	/^	static int tabs;$/;"	m	struct:tabident	file:	access:private
tabs	makecompiler/gensyntax.cpp	/^int tabident::tabs = 0;$/;"	m	class:tabident	file:
tabs	tmp/coutfun.cpp	/^	static int tabs;$/;"	m	struct:Ident	file:	access:public
tabs	tmp/coutfun.cpp	/^int Ident::tabs = 0;$/;"	m	class:Ident	file:
tchar	include/basic_types.h	/^typedef char tchar;$/;"	t
tchar	test/vhelp.h	/^	typedef compile::tchar tchar;$/;"	t	class:Asymbol	access:private
test_grammar	test/basicalgorithmtest.cpp	/^	void test_grammar(grammar& gin)$/;"	f	class:basicalg_test	file:	access:private	signature:(grammar& gin)
third	include/functionalX.h	/^	_Ty3 third; \/\/ the third stored value$/;"	m	struct:triple	access:public
third_argument_type	include/functionalX.h	/^	typedef _Arg3 third_argument_type;$/;"	t	struct:triple_function	access:public
third_type	include/functionalX.h	/^	typedef _Ty3 third_type;$/;"	t	struct:triple	access:public
tid	compiler/type.h	/^	int32 tid; \/\/ type id$/;"	m	struct:type	access:public
tig_	galgorithm/eclosures.h	/^	const tinygrammar* tig_;$/;"	m	class:eclosure	access:private
tinygrammar	syntax/grammar.cpp	/^tinygrammar::tinygrammar()$/;"	f	class:tinygrammar	signature:()
tinygrammar	syntax/grammar.cpp	/^tinygrammar::tinygrammar(const tinygrammar& other)$/;"	f	class:tinygrammar	signature:(const tinygrammar& other)
tinygrammar	syntax/grammar.h	/^	tinygrammar();$/;"	p	class:tinygrammar	access:public	signature:()
tinygrammar	syntax/grammar.h	/^	tinygrammar(_Iter_Sym _First_Sym, _Iter_Sym _Last_Sym, _Iter_Prod _First_Prod, _Iter_Prod _Last_Prod, int32 _Start, int32 _Eplison = -1, int32 _Ending = -1)$/;"	f	class:tinygrammar	access:public	signature:(_Iter_Sym _First_Sym, _Iter_Sym _Last_Sym, _Iter_Prod _First_Prod, _Iter_Prod _Last_Prod, int32 _Start, int32 _Eplison = -1, int32 _Ending = -1)
tinygrammar	syntax/grammar.h	/^	tinygrammar(const tinygrammar& other);$/;"	p	class:tinygrammar	access:public	signature:(const tinygrammar& other)
tinygrammar	syntax/grammar.h	/^class tinygrammar$/;"	c
tinygrammar::MEMBER_VARIABLE_GET_SET	syntax/grammar.h	/^	MEMBER_VARIABLE_GET_SET(int32, endings, ending_symbol_);$/;"	p	class:tinygrammar	access:public	signature:(int32, endings, ending_symbol_)
tinygrammar::MEMBER_VARIABLE_GET_SET	syntax/grammar.h	/^	MEMBER_VARIABLE_GET_SET(int32, eplisons, eplison_symbol_);$/;"	p	class:tinygrammar	access:public	signature:(int32, eplisons, eplison_symbol_)
tinygrammar::MEMBER_VARIABLE_GET_SET	syntax/grammar.h	/^	MEMBER_VARIABLE_GET_SET(int32, starts, start_symbol_);$/;"	p	class:tinygrammar	access:public	signature:(int32, starts, start_symbol_)
tinygrammar::MEMBER_VARIABLE_GET_SET	syntax/grammar.h	/^	MEMBER_VARIABLE_GET_SET(symholder, symbols, symbols_);$/;"	p	class:tinygrammar	access:public	signature:(symholder, symbols, symbols_)
tinygrammar::MEMBER_VARIABLE_GET_SET	syntax/grammar.h	/^	MEMBER_VARIABLE_GET_SET(vecprods, productions, productions_);$/;"	p	class:tinygrammar	access:public	signature:(vecprods, productions, productions_)
tinygrammar::ending_symbol_	syntax/grammar.h	/^	int32 ending_symbol_; \/\/ ending symbol sid: -1 no$/;"	m	class:tinygrammar	access:protected
tinygrammar::eplison_symbol_	syntax/grammar.h	/^	int32 eplison_symbol_; \/\/ eplison symbol sid: -1 not in grammar$/;"	m	class:tinygrammar	access:protected
tinygrammar::productions_	syntax/grammar.h	/^	vecprods productions_; \/\/ productions$/;"	m	class:tinygrammar	access:protected
tinygrammar::start_symbol_	syntax/grammar.h	/^	int32 start_symbol_; \/\/ start symbol sid$/;"	m	class:tinygrammar	access:protected
tinygrammar::swap	syntax/grammar.cpp	/^void tinygrammar::swap(tinygrammar& other) throw()$/;"	f	class:tinygrammar	signature:(tinygrammar& other)
tinygrammar::swap	syntax/grammar.h	/^	void swap(tinygrammar& other) throw();$/;"	p	class:tinygrammar	access:public	signature:(tinygrammar& other)
tinygrammar::symbols_	syntax/grammar.h	/^	symholder symbols_; \/\/ all symbols$/;"	m	class:tinygrammar	access:protected
tinygrammar::tinygrammar	syntax/grammar.cpp	/^tinygrammar::tinygrammar()$/;"	f	class:tinygrammar	signature:()
tinygrammar::tinygrammar	syntax/grammar.cpp	/^tinygrammar::tinygrammar(const tinygrammar& other)$/;"	f	class:tinygrammar	signature:(const tinygrammar& other)
tinygrammar::tinygrammar	syntax/grammar.h	/^	tinygrammar();$/;"	p	class:tinygrammar	access:public	signature:()
tinygrammar::tinygrammar	syntax/grammar.h	/^	tinygrammar(_Iter_Sym _First_Sym, _Iter_Sym _Last_Sym, _Iter_Prod _First_Prod, _Iter_Prod _Last_Prod, int32 _Start, int32 _Eplison = -1, int32 _Ending = -1)$/;"	f	class:tinygrammar	access:public	signature:(_Iter_Sym _First_Sym, _Iter_Sym _Last_Sym, _Iter_Prod _First_Prod, _Iter_Prod _Last_Prod, int32 _Start, int32 _Eplison = -1, int32 _Ending = -1)
tinygrammar::tinygrammar	syntax/grammar.h	/^	tinygrammar(const tinygrammar& other);$/;"	p	class:tinygrammar	access:public	signature:(const tinygrammar& other)
tinygrammar::vecprods	syntax/grammar.h	/^	typedef kog::smart_vector<production> vecprods;$/;"	t	class:tinygrammar	access:public
tinygrammar::~tinygrammar	syntax/grammar.cpp	/^tinygrammar::~tinygrammar()$/;"	f	class:tinygrammar	signature:()
tinygrammar::~tinygrammar	syntax/grammar.h	/^	virtual ~tinygrammar();$/;"	p	class:tinygrammar	access:public	signature:()
to_lower	include/stringX.h	/^	_Myt& to_lower()$/;"	f	class:xstring_basic	access:public	signature:()
to_upper	include/stringX.h	/^	_Myt& to_upper()$/;"	f	class:xstring_basic	access:public	signature:()
tocfg	galgorithm/regex2nfa.cpp	/^void regex2nfa::tocfg(const tstring& input, grammar& otput)$/;"	f	class:regex2nfa	signature:(const tstring& input, grammar& otput)
tocfg	galgorithm/regex2nfa.h	/^	void tocfg(const tstring& input, grammar& otput);$/;"	p	class:regex2nfa	access:private	signature:(const tstring& input, grammar& otput)
tocfg	tmp/back/regex2nfa.cpp	/^void regex2nfa::tocfg(const tstring& input, grammar& otput)$/;"	f	class:regex2nfa	signature:(const tstring& input, grammar& otput)
todfa	galgorithm/nfa2dfa.cpp	/^void nfa2dfa::todfa(const tinygrammar& tig, tinygrammar& tog)$/;"	f	class:nfa2dfa	signature:(const tinygrammar& tig, tinygrammar& tog)
todfa	galgorithm/nfa2dfa.h	/^	void todfa(const tinygrammar& tig, tinygrammar& tog);$/;"	p	class:nfa2dfa	access:private	signature:(const tinygrammar& tig, tinygrammar& tog)
todfa	test/nfa2dfatest.cpp	/^	void todfa(const grammar& gin)$/;"	f	class:nfa2dfa_test	file:	access:private	signature:(const grammar& gin)
toe	galgorithm/basicalgorithms.h	/^	vecint toe; \/\/ symbol A->..->e?$/;"	m	class:eliminate_eplison	access:private
tolower	include/stringXF.h	/^_Elem tolower(_Elem _ch)$/;"	f	signature:(_Elem _ch)
tolower	include/stringXF.h	/^std::basic_string<_Elem> tolower(const std::basic_string<_Elem>& _Str)$/;"	f	signature:(const std::basic_string<_Elem>& _Str)
tonfa	galgorithm/regex2nfa.cpp	/^void regex2nfa::tonfa(const grammar& input, grammar& otput)$/;"	f	class:regex2nfa	signature:(const grammar& input, grammar& otput)
tonfa	galgorithm/regex2nfa.h	/^	void tonfa(const grammar& input, grammar& otput);$/;"	p	class:regex2nfa	access:private	signature:(const grammar& input, grammar& otput)
tonfa	tmp/back/regex2nfa.cpp	/^void regex2nfa::tonfa(const grammar& input, grammar& otput)$/;"	f	class:regex2nfa	signature:(const grammar& input, grammar& otput)
tostring	include/stringX.h	/^	static _Myt tostring(const _Tz& _value)$/;"	f	class:xstring_basic	access:public	signature:(const _Tz& _value)
toupper	include/stringXF.h	/^_Elem toupper(_Elem _ch)$/;"	f	signature:(_Elem _ch)
toupper	include/stringXF.h	/^std::basic_string<_Elem> toupper(const std::basic_string<_Elem>& _Str)$/;"	f	signature:(const std::basic_string<_Elem>& _Str)
trim	include/stringX.h	/^	_Myt& trim(int _TrimType = trim_both)$/;"	f	class:xstring_basic	access:public	signature:(int _TrimType = trim_both)
trim	include/stringX.h	/^	static _Myt trim(const _Myt& _Str, int _TrimType = 3)$/;"	f	class:xstring_basic	access:public	signature:(const _Myt& _Str, int _TrimType = 3)
trim	include/stringXF.h	/^inline std::string trim(const std::string& path, int trimType = 3)$/;"	f	signature:(const std::string& path, int trimType = 3)
trim_begin	include/stringX.h	/^	enum {trim_begin, trim_end, trim_both};$/;"	e	enum:xstring_basic::__anon4
trim_both	include/stringX.h	/^	enum {trim_begin, trim_end, trim_both};$/;"	e	enum:xstring_basic::__anon4
trim_end	include/stringX.h	/^	enum {trim_begin, trim_end, trim_both};$/;"	e	enum:xstring_basic::__anon4
triple	include/functionalX.h	/^		triple(const triple<_Other1, _Other2, _Other3>& _Right)$/;"	f	struct:triple	access:public	signature:(const triple<_Other1, _Other2, _Other3>& _Right)
triple	include/functionalX.h	/^	triple()$/;"	f	struct:triple	access:public	signature:()
triple	include/functionalX.h	/^	triple(const _Ty1& _Val1, const _Ty2& _Val2, const _Ty3& _Val3)$/;"	f	struct:triple	access:public	signature:(const _Ty1& _Val1, const _Ty2& _Val2, const _Ty3& _Val3)
triple	include/functionalX.h	/^struct triple$/;"	s
triple::_Myt	include/functionalX.h	/^	typedef triple<_Ty1, _Ty2, _Ty3> _Myt;$/;"	t	struct:triple	access:public
triple::first	include/functionalX.h	/^	_Ty1 first;	\/\/ the first stored value$/;"	m	struct:triple	access:public
triple::first_type	include/functionalX.h	/^	typedef _Ty1 first_type;$/;"	t	struct:triple	access:public
triple::second	include/functionalX.h	/^	_Ty2 second;	\/\/ the second stored value$/;"	m	struct:triple	access:public
triple::second_type	include/functionalX.h	/^	typedef _Ty2 second_type;$/;"	t	struct:triple	access:public
triple::swap	include/functionalX.h	/^	void swap(_Myt& _Right)$/;"	f	struct:triple	access:public	signature:(_Myt& _Right)
triple::third	include/functionalX.h	/^	_Ty3 third; \/\/ the third stored value$/;"	m	struct:triple	access:public
triple::third_type	include/functionalX.h	/^	typedef _Ty3 third_type;$/;"	t	struct:triple	access:public
triple::triple	include/functionalX.h	/^		triple(const triple<_Other1, _Other2, _Other3>& _Right)$/;"	f	struct:triple	access:public	signature:(const triple<_Other1, _Other2, _Other3>& _Right)
triple::triple	include/functionalX.h	/^	triple()$/;"	f	struct:triple	access:public	signature:()
triple::triple	include/functionalX.h	/^	triple(const _Ty1& _Val1, const _Ty2& _Val2, const _Ty3& _Val3)$/;"	f	struct:triple	access:public	signature:(const _Ty1& _Val1, const _Ty2& _Val2, const _Ty3& _Val3)
triple_function	include/functionalX.h	/^struct triple_function$/;"	s
triple_function::first_argument_type	include/functionalX.h	/^	typedef _Arg1 first_argument_type;$/;"	t	struct:triple_function	access:public
triple_function::result_type	include/functionalX.h	/^	typedef _Result result_type;$/;"	t	struct:triple_function	access:public
triple_function::second_argument_type	include/functionalX.h	/^	typedef _Arg2 second_argument_type;$/;"	t	struct:triple_function	access:public
triple_function::third_argument_type	include/functionalX.h	/^	typedef _Arg3 third_argument_type;$/;"	t	struct:triple_function	access:public
triple_function_adptor	include/functionalX.h	/^inline triple_function_adptor_t<_Arg1, _Arg2, _Arg3, _Result> triple_function_adptor(_Result (*_Func)(_Arg1, _Arg2, _Arg3))$/;"	f	signature:(_Result (_Func)_Arg1, _Arg2, _Arg3))
triple_function_adptor_t	include/functionalX.h	/^	triple_function_adptor_t(_FunType pfun)$/;"	f	struct:triple_function_adptor_t	access:public	signature:(_FunType pfun)
triple_function_adptor_t	include/functionalX.h	/^struct triple_function_adptor_t : public triple_function<_Arg1, _Arg2, _Arg3, _Result>$/;"	s	inherits:triple_function
triple_function_adptor_t::_FunType	include/functionalX.h	/^	typedef _Result (*_FunType)(_Arg1, _Arg2, _Arg3);$/;"	t	struct:triple_function_adptor_t	access:public
triple_function_adptor_t::_pFun	include/functionalX.h	/^	_FunType _pFun;$/;"	m	struct:triple_function_adptor_t	access:private
triple_function_adptor_t::operator ()	include/functionalX.h	/^	_Result operator()(_Arg1 arg1, _Arg2 arg2, _Arg3 arg3) const$/;"	f	struct:triple_function_adptor_t	access:public	signature:(_Arg1 arg1, _Arg2 arg2, _Arg3 arg3) const
triple_function_adptor_t::triple_function_adptor_t	include/functionalX.h	/^	triple_function_adptor_t(_FunType pfun)$/;"	f	struct:triple_function_adptor_t	access:public	signature:(_FunType pfun)
true_node	galgorithm/regex2nfa.cpp	/^	void true_node(const char* vs, const char* ve, int L)$/;"	f	struct:parsecontent	access:public	signature:(const char* vs, const char* ve, int L)
true_node	tmp/back/regex2nfa.cpp	/^	void true_node(const char* vs, const char* ve, int L)$/;"	f	struct:parsecontent	access:public	signature:(const char* vs, const char* ve, int L)
try_to_read_symbol	compiler/extract.cpp	/^	int try_to_read_symbol(word& aword, int_type _Meta)$/;"	f	class:iwordstream	file:	access:private	signature:(word& aword, int_type _Meta)
tryconvert	include/stringXF.h	/^		static bool tryconvert(const std::string& _Src, std::wstring& _Dst, std::exception& ex)$/;"	f	struct:Format::swcvt	access:private	signature:(const std::string& _Src, std::wstring& _Dst, std::exception& ex)
tryconvert	include/stringXF.h	/^		static bool tryconvert(const std::wstring& _Src, std::string& _Dst, std::exception& ex)$/;"	f	struct:Format::swcvt	access:private	signature:(const std::wstring& _Src, std::string& _Dst, std::exception& ex)
tryparse	include/stringX.h	/^	static bool tryparse(const _Myt& str, _Tz& _tz)$/;"	f	class:xstring_basic	access:public	signature:(const _Myt& str, _Tz& _tz)
tryparse	include/stringX.h	/^	static bool tryparse(const _Myt& str, _Tz& _tz, std::string& exceptionMsg)$/;"	f	class:xstring_basic	access:private	signature:(const _Myt& str, _Tz& _tz, std::string& exceptionMsg)
tstring	include/basic_types.h	/^typedef std::string tstring;$/;"	t
tstring	syntax/automachine.h	/^	typedef sc::tstring tstring;$/;"	t	class:automachine	access:public
tstring	test/vhelp.h	/^	typedef compile::tstring tstring;$/;"	t	class:Aproduction	access:private
tstring	test/vhelp.h	/^	typedef compile::tstring tstring;$/;"	t	class:Asymbol	access:private
tstring	test/vhelp.h	/^	typedef compile::tstring tstring;$/;"	t	class:V	access:private
tstring	test/vhelp.h	/^	typedef compile::tstring tstring;$/;"	t	struct:symindex	access:public
tstring	third_party/regex/xregex.h	/^	typedef std::basic_string<char_type> tstring;$/;"	t	class:stringX::xregex	access:public
txt	syntax/word.h	/^	_Str txt;$/;"	m	struct:word	access:public
type	compiler/type.h	/^struct type$/;"	s
type	include/mplX.h	/^	typedef _FalseType type;$/;"	t	struct:choos_t	access:public
type	include/mplX.h	/^	typedef _TrueType type;$/;"	t	struct:choos_t	access:public
type	include/mplX.h	/^	typedef _Tx type;$/;"	t	struct:remove_const	access:public
type	include/mplX.h	/^	typedef const _T type;$/;"	t	struct:add_const	access:public
type	include/mplX.h	/^	typedef const _Tx& type;$/;"	t	struct:const_reference	access:public
type	syntax/automachine.h	/^		int32 type() const { return eattype_; }$/;"	f	class:automachine::sheetrow	access:public	signature:() const
type	syntax/automachine.h	/^		void type(int32 t) { eattype_ = t; }$/;"	f	class:automachine::sheetrow	access:public	signature:(int32 t)
type::tid	compiler/type.h	/^	int32 tid; \/\/ type id$/;"	m	struct:type	access:public
uchar	include/basic_types.h	/^typedef unsigned char uchar;$/;"	t
uint16	include/basic_types.h	/^typedef unsigned short uint16;$/;"	t
uint32	include/basic_types.h	/^typedef unsigned int uint32;$/;"	t
uint64	include/basic_types.h	/^typedef unsigned long int uint64;$/;"	t
uint8	include/basic_types.h	/^typedef unsigned char uint8;$/;"	t
unary_function_adptor	include/functionalX.h	/^inline unary_function_adptor_t<_Arg, _Result> unary_function_adptor(_Result (*_Func)(_Arg))$/;"	f	signature:(_Result (_Func)_Arg))
unary_function_adptor_t	include/functionalX.h	/^	unary_function_adptor_t(_FunType pfun)$/;"	f	struct:unary_function_adptor_t	access:public	signature:(_FunType pfun)
unary_function_adptor_t	include/functionalX.h	/^struct unary_function_adptor_t : public std::unary_function<_Arg, _Result>$/;"	s	inherits:std::unary_function
unary_function_adptor_t::_FunType	include/functionalX.h	/^	typedef _Result (*_FunType)(_Arg);$/;"	t	struct:unary_function_adptor_t	access:public
unary_function_adptor_t::_pFun	include/functionalX.h	/^	_FunType _pFun;$/;"	m	struct:unary_function_adptor_t	access:private
unary_function_adptor_t::operator ()	include/functionalX.h	/^	_Result operator()(_Arg arg) const$/;"	f	struct:unary_function_adptor_t	access:public	signature:(_Arg arg) const
unary_function_adptor_t::unary_function_adptor_t	include/functionalX.h	/^	unary_function_adptor_t(_FunType pfun)$/;"	f	struct:unary_function_adptor_t	access:public	signature:(_FunType pfun)
unittest	test/unittest.cpp	/^unittest::unittest(int min_argc, const std::string& usage)$/;"	f	class:unittest	signature:(int min_argc, const std::string& usage)
unittest	test/unittest.cpp	/^unittest::unittest(void)$/;"	f	class:unittest	signature:(void)
unittest	test/unittest.h	/^	unittest(int min_argc, const std::string& usage);$/;"	p	class:unittest	access:public	signature:(int min_argc, const std::string& usage)
unittest	test/unittest.h	/^	unittest(void);$/;"	p	class:unittest	access:public	signature:(void)
unittest	test/unittest.h	/^class unittest$/;"	c
unittest::MEMBER_VARIABLE_GET_SET	test/unittest.h	/^	MEMBER_VARIABLE_GET_SET(std::string, out_folder, outfolder_);$/;"	p	class:unittest	access:public	signature:(std::string, out_folder, outfolder_)
unittest::init	test/unittest.h	/^	virtual void init(int argc, const char* argv[]) = 0;$/;"	p	class:unittest	access:public	signature:(int argc, const char* argv[])
unittest::minargc_	test/unittest.h	/^	int minargc_;$/;"	m	class:unittest	access:private
unittest::outfolder_	test/unittest.h	/^	std::string outfolder_;$/;"	m	class:unittest	access:private
unittest::run	test/unittest.cpp	/^void unittest::run()$/;"	f	class:unittest	signature:()
unittest::run	test/unittest.cpp	/^void unittest::run(const std::string& outfolder)$/;"	f	class:unittest	signature:(const std::string& outfolder)
unittest::run	test/unittest.h	/^	void run();$/;"	p	class:unittest	access:public	signature:()
unittest::run	test/unittest.h	/^	void run(const std::string& outfolder);$/;"	p	class:unittest	access:public	signature:(const std::string& outfolder)
unittest::run_test	test/unittest.h	/^	virtual void run_test() = 0;$/;"	p	class:unittest	access:private	signature:()
unittest::unittest	test/unittest.cpp	/^unittest::unittest(int min_argc, const std::string& usage)$/;"	f	class:unittest	signature:(int min_argc, const std::string& usage)
unittest::unittest	test/unittest.cpp	/^unittest::unittest(void)$/;"	f	class:unittest	signature:(void)
unittest::unittest	test/unittest.h	/^	unittest(int min_argc, const std::string& usage);$/;"	p	class:unittest	access:public	signature:(int min_argc, const std::string& usage)
unittest::unittest	test/unittest.h	/^	unittest(void);$/;"	p	class:unittest	access:public	signature:(void)
unittest::usage_	test/unittest.h	/^	std::string usage_;$/;"	m	class:unittest	access:private
unittest::~unittest	test/unittest.cpp	/^unittest::~unittest(void)$/;"	f	class:unittest	signature:(void)
unittest::~unittest	test/unittest.h	/^	virtual ~unittest(void);$/;"	p	class:unittest	access:public	signature:(void)
unittest_list	test/unittest.cpp	/^class unittest_list : public std::list<unittest*>, public kog::singleton<unittest_list>$/;"	c	file:	inherits:std::list,kog::singleton
unittest_list::run_all_unittest	test/unittest.cpp	/^	int run_all_unittest(int argc, const char* argv[])$/;"	f	class:unittest_list	access:public	signature:(int argc, const char* argv[])
updata_sys_symbols	syntax/symbol.h	/^	void updata_sys_symbols();$/;"	p	class:symholder	access:private	signature:()
update_closure	galgorithm/lranalyse.cpp	/^	void update_closure(lrstate& lrs) const;$/;"	p	struct:AlgorithmArg	file:	access:public	signature:(lrstate& lrs) const
update_closure	galgorithm/lranalyse.cpp	/^void Algorithm::update_closure(lrstateitem& li)$/;"	f	class:Algorithm	signature:(lrstateitem& li)
update_firsts	galgorithm/lranalyse.cpp	/^	void update_firsts(lrstateitem& snew, const lrstateitem& sorg) const;$/;"	p	struct:AlgorithmArg	file:	access:public	signature:(lrstateitem& snew, const lrstateitem& sorg) const
usage_	test/unittest.h	/^	std::string usage_;$/;"	m	class:unittest	access:private
usedp	galgorithm/basicalgorithms.h	/^	vecint usedp;$/;"	m	class:removenotused	access:private
useds	galgorithm/basicalgorithms.h	/^	vecint useds;$/;"	m	class:removenotused	access:private
utilsfunc	include/markuputils.h	/^class utilsfunc$/;"	c
v	include/memoryX.h	/^	_Tx* v;$/;"	m	struct:memblock	access:private
v	syntax/automachine.h	/^		typedef kog::smart_vector<gotoitem> v;$/;"	t	class:automachine::sheetrow	access:private
v	test/vhelp.h	/^	typedef kog::smart_vector<int32> v;$/;"	t	class:V	access:private
value	compiler/value.h	/^struct value$/;"	s
value	include/buckethash.h	/^	typedef typename _V value;$/;"	t	class:buckethash	access:public
value	include/functionalX.h	/^	const static unsigned int value = 0;$/;"	m	struct:binary	access:public
value	include/functionalX.h	/^	const static unsigned int value = binary<_BinaryValue \/ 10>::value * 2 + _BinaryValue % 10;$/;"	m	struct:binary	access:public
value	include/mplX.h	/^	const static bool value = false;$/;"	m	struct:is_const_t	access:public
value	include/mplX.h	/^	const static bool value = true;$/;"	m	struct:is_const_t	access:public
value	include/mplX.h	/^	const static int value = sizeof(_T);$/;"	m	struct:fire_error	access:public
value::address	compiler/value.h	/^	uint32 address;$/;"	m	struct:value	access:public
value::defvalue	compiler/value.h	/^	byte* defvalue;$/;"	m	struct:value	access:public
value::size	compiler/value.h	/^	uint32 size;$/;"	m	struct:value	access:public
value::vsym	compiler/value.h	/^	const symbol* vsym;$/;"	m	struct:value	access:public
value::vtype	compiler/value.h	/^	const type* vtype;$/;"	m	struct:value	access:public
value_reference	include/buckethash.h	/^	typedef typename value& value_reference;$/;"	t	class:buckethash	access:public
value_type	include/arrayX.h	/^	typedef _Tx value_type;$/;"	t	class:smart_vector	access:public
value_type	include/arrayX.h	/^	typedef typename mpl::remove_const<_Ty>::type value_type;$/;"	t	struct:SmartArray	access:public
value_type	include/arrayX.h	/^	typedef typename mpl::remove_const<_Ty>::type value_type;$/;"	t	struct:SmartMatrix	access:public
value_type	include/functionalX.h	/^	typedef _Ty value_type;$/;"	t	struct:mem_value_t	access:public
value_type	include/iteratorX.h	/^	typedef typename _Base::value_type value_type;$/;"	t	struct:array_iterator	access:public
value_type	include/memoryX.h	/^	typedef _Tx value_type;$/;"	t	struct:memblock	access:public
value_type	include/mplX.h	/^	typedef _Tx value_type;$/;"	t	struct:parse_class_value_type	access:public
value_type	include/mplX.h	/^	typedef _Ty value_type;$/;"	t	struct:parse_class_value_type	access:public
value_type	include/singleton.h	/^	typedef _T value_type;$/;"	t	class:singleton	access:public
value_type	include/stringX.h	/^	typedef typename _Mybase::value_type value_type;$/;"	t	class:xstring_basic	access:public
values	include/arrayX.h	/^		pointer values;$/;"	m	struct:smart_vector::block	access:public
valuetype	test/output/gen.cpp	/^	valuetype()$/;"	f	struct:valuetype	access:public	signature:()
valuetype	test/output/gen.cpp	/^struct valuetype : public type$/;"	s	file:	inherits:type
valuetype	test/output/tinyg.cpp	/^	valuetype()$/;"	f	struct:valuetype	access:public	signature:()
valuetype	test/output/tinyg.cpp	/^struct valuetype : public type$/;"	s	file:	inherits:type
valuetype::sid	test/output/gen.cpp	/^	enum{ sid = 1030 };$/;"	e	enum:valuetype::__anon34	file:
valuetype::sid	test/output/tinyg.cpp	/^	enum{ sid = 5 };$/;"	e	enum:valuetype::__anon40	file:
valuetype::valuetype	test/output/gen.cpp	/^	valuetype()$/;"	f	struct:valuetype	access:public	signature:()
valuetype::valuetype	test/output/tinyg.cpp	/^	valuetype()$/;"	f	struct:valuetype	access:public	signature:()
vecint	galgorithm/basicalgorithms.h	/^	typedef kog::smart_vector<int32> vecint;$/;"	t	class:eliminate_eplison	access:private
vecint	galgorithm/basicalgorithms.h	/^	typedef kog::smart_vector<int32> vecint;$/;"	t	class:removenotused	access:private
vecint	galgorithm/firstfollow.h	/^	typedef kog::smart_vector<int32> vecint;$/;"	t	class:firstset	access:public
vecint	galgorithm/firstfollow.h	/^	typedef kog::smart_vector<int32> vecint;$/;"	t	class:followset	access:public
vecintset	galgorithm/firstfollow.h	/^	typedef kog::smart_vector<vecint> vecintset;$/;"	t	class:firstset	access:public
vecintset	galgorithm/firstfollow.h	/^	typedef kog::smart_vector<vecint> vecintset;$/;"	t	class:followset	access:public
veckeywords	syntax/grammar.h	/^	typedef kog::smart_vector<std::pair<tstring, int32> > veckeywords;$/;"	t	class:grammar	access:public
vecprods	syntax/grammar.h	/^	typedef kog::smart_vector<production> vecprods;$/;"	t	class:tinygrammar	access:public
vecsmacs	syntax/grammar.h	/^	typedef kog::smart_vector<std::pair<tstring, int32> > vecsmacs; \/\/ first: symbol.sid, second: regex string$/;"	t	class:grammar	access:public
vsym	compiler/value.h	/^	const symbol* vsym;$/;"	m	struct:value	access:public
vtype	compiler/value.h	/^	const type* vtype;$/;"	m	struct:value	access:public
whitespaces_	syntax/grammar.h	/^	tstring whitespaces_;	\/\/ whitespace: space tab or some other charactors$/;"	m	class:grammar	access:protected
word	syntax/word.h	/^	word(const _Str& str, short state = Unknown)$/;"	f	struct:word	access:public	signature:(const _Str& str, short state = Unknown)
word	syntax/word.h	/^	word(void) {}$/;"	f	struct:word	access:public	signature:(void)
word	syntax/word.h	/^struct word$/;"	s
word::Error	syntax/word.h	/^	enum{Known = 1, Unknown = 0, Error = -1};$/;"	e	enum:word::__anon7
word::Known	syntax/word.h	/^	enum{Known = 1, Unknown = 0, Error = -1};$/;"	e	enum:word::__anon7
word::Unknown	syntax/word.h	/^	enum{Known = 1, Unknown = 0, Error = -1};$/;"	e	enum:word::__anon7
word::_Str	syntax/word.h	/^	typedef sc::tstring _Str;$/;"	t	struct:word	access:public
word::swap	syntax/word.h	/^	void swap(word& aword)$/;"	f	struct:word	access:public	signature:(word& aword)
word::txt	syntax/word.h	/^	_Str txt;$/;"	m	struct:word	access:public
word::word	syntax/word.h	/^	word(const _Str& str, short state = Unknown)$/;"	f	struct:word	access:public	signature:(const _Str& str, short state = Unknown)
word::word	syntax/word.h	/^	word(void) {}$/;"	f	struct:word	access:public	signature:(void)
word::wordClass	syntax/word.h	/^	short wordClass;$/;"	m	struct:word	access:public
word::wordstate	syntax/word.h	/^	short wordstate;$/;"	m	struct:word	access:public
wordClass	syntax/word.h	/^	short wordClass;$/;"	m	struct:word	access:public
words_	compiler/extract.h	/^	deqwords words_;$/;"	m	class:streamsplit	access:private
wordstate	syntax/word.h	/^	short wordstate;$/;"	m	struct:word	access:public
x	tmp/sizetest.cpp	/^	int x;$/;"	m	struct:A	file:	access:public
x_ATTRIBQUOTE	third_party/xml/Markup.cpp	45;"	d	file:
x_AddElem	third_party/xml/Markup.cpp	/^bool CMarkup::x_AddElem( MCD_PCSZ pName, MCD_PCSZ pValue, int nFlags )$/;"	f	class:CMarkup	signature:( MCD_PCSZ pName, MCD_PCSZ pValue, int nFlags )
x_AddElem	third_party/xml/Markup.cpp	/^bool CMarkup::x_AddElem( MCD_PCSZ pName, int nValue, int nFlags )$/;"	f	class:CMarkup	signature:( MCD_PCSZ pName, int nValue, int nFlags )
x_AddElem	third_party/xml/Markup.h	/^	bool x_AddElem( MCD_PCSZ pName, MCD_PCSZ pValue, int nFlags );$/;"	p	class:CMarkup	access:protected	signature:( MCD_PCSZ pName, MCD_PCSZ pValue, int nFlags )
x_AddElem	third_party/xml/Markup.h	/^	bool x_AddElem( MCD_PCSZ pName, int nValue, int nFlags );$/;"	p	class:CMarkup	access:protected	signature:( MCD_PCSZ pName, int nValue, int nFlags )
x_AddNode	third_party/xml/Markup.cpp	/^bool CMarkup::x_AddNode( int nNodeType, MCD_PCSZ pText, int nNodeFlags )$/;"	f	class:CMarkup	signature:( int nNodeType, MCD_PCSZ pText, int nNodeFlags )
x_AddNode	third_party/xml/Markup.h	/^	bool x_AddNode( int nNodeType, MCD_PCSZ pText, int nNodeFlags );$/;"	p	class:CMarkup	access:protected	signature:( int nNodeType, MCD_PCSZ pText, int nNodeFlags )
x_AddResult	third_party/xml/Markup.cpp	/^void x_AddResult( MCD_STR& strResult, MCD_CSTR pszID, MCD_CSTR pszVal = NULL, int nResultCode = 0, int n = -1, int n2 = -1 )$/;"	f	signature:( MCD_STR& strResult, MCD_CSTR pszID, MCD_CSTR pszVal = NULL, int nResultCode = 0, int n = -1, int n2 = -1 )
x_AddSubDoc	third_party/xml/Markup.cpp	/^bool CMarkup::x_AddSubDoc( MCD_PCSZ pSubDoc, int nFlags )$/;"	f	class:CMarkup	signature:( MCD_PCSZ pSubDoc, int nFlags )
x_AddSubDoc	third_party/xml/Markup.h	/^	bool x_AddSubDoc( MCD_PCSZ pSubDoc, int nFlags );$/;"	p	class:CMarkup	access:protected	signature:( MCD_PCSZ pSubDoc, int nFlags )
x_Adjust	third_party/xml/Markup.cpp	/^void CMarkup::x_Adjust( int iPos, int nShift, bool bAfterPos \/*=false*\/ )$/;"	f	class:CMarkup	signature:( int iPos, int nShift, bool bAfterPos )
x_Adjust	third_party/xml/Markup.h	/^	void x_Adjust( int iPos, int nShift, bool bAfterPos = false );$/;"	p	class:CMarkup	access:protected	signature:( int iPos, int nShift, bool bAfterPos = false )
x_AdjustForNode	third_party/xml/Markup.cpp	/^void CMarkup::x_AdjustForNode( int iPosParent, int iPos, int nShift )$/;"	f	class:CMarkup	signature:( int iPosParent, int iPos, int nShift )
x_AdjustForNode	third_party/xml/Markup.h	/^	void x_AdjustForNode( int iPosParent, int iPos, int nShift );$/;"	p	class:CMarkup	access:protected	signature:( int iPosParent, int iPos, int nShift )
x_AllocElemPos	third_party/xml/Markup.cpp	/^bool CMarkup::x_AllocElemPos( int nNewSize \/*=0*\/ )$/;"	f	class:CMarkup	signature:( int nNewSize )
x_AllocElemPos	third_party/xml/Markup.h	/^	bool x_AllocElemPos( int nNewSize = 0 );$/;"	p	class:CMarkup	access:protected	signature:( int nNewSize = 0 )
x_CheckSavedPos	third_party/xml/Markup.cpp	/^void CMarkup::x_CheckSavedPos()$/;"	f	class:CMarkup	signature:()
x_CheckSavedPos	third_party/xml/Markup.h	/^	void x_CheckSavedPos();$/;"	p	class:CMarkup	access:protected	signature:()
x_CreateNode	third_party/xml/Markup.cpp	/^bool CMarkup::x_CreateNode( MCD_STR& strNode, int nNodeType, MCD_PCSZ pText )$/;"	f	class:CMarkup	signature:( MCD_STR& strNode, int nNodeType, MCD_PCSZ pText )
x_CreateNode	third_party/xml/Markup.h	/^	static bool x_CreateNode( MCD_STR& strNode, int nNodeType, MCD_PCSZ pText );$/;"	p	class:CMarkup	access:protected	signature:( MCD_STR& strNode, int nNodeType, MCD_PCSZ pText )
x_DocChange	third_party/xml/Markup.cpp	/^void CMarkup::x_DocChange( int nLeft, int nReplace, const MCD_STR& strInsert )$/;"	f	class:CMarkup	signature:( int nLeft, int nReplace, const MCD_STR& strInsert )
x_DocChange	third_party/xml/Markup.h	/^	void x_DocChange( int nLeft, int nReplace, const MCD_STR& strInsert );$/;"	p	class:CMarkup	access:protected	signature:( int nLeft, int nReplace, const MCD_STR& strInsert )
x_EOL	third_party/xml/Markup.cpp	43;"	d	file:
x_EOLLEN	third_party/xml/Markup.cpp	44;"	d	file:
x_EncodeCDATASection	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::x_EncodeCDATASection( MCD_PCSZ szData )$/;"	f	class:CMarkup	signature:( MCD_PCSZ szData )
x_EncodeCDATASection	third_party/xml/Markup.h	/^	static MCD_STR x_EncodeCDATASection( MCD_PCSZ szData );$/;"	p	class:CMarkup	access:protected	signature:( MCD_PCSZ szData )
x_EndianSwapRequired	third_party/xml/Markup.cpp	/^bool x_EndianSwapRequired( int nDocFlags )$/;"	f	signature:( int nDocFlags )
x_EndianSwapUTF16	third_party/xml/Markup.cpp	/^void x_EndianSwapUTF16( unsigned short* pBuffer, int nCharLen )$/;"	f	signature:( unsigned short* pBuffer, int nCharLen )
x_FindElem	third_party/xml/Markup.cpp	/^int CMarkup::x_FindElem( int iPosParent, int iPos, PathPos& path ) const$/;"	f	class:CMarkup	signature:( int iPosParent, int iPos, PathPos& path ) const
x_FindElem	third_party/xml/Markup.h	/^	int x_FindElem( int iPosParent, int iPos, PathPos& path ) const;$/;"	p	class:CMarkup	access:protected	signature:( int iPosParent, int iPos, PathPos& path ) const
x_GetAttrib	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::x_GetAttrib( int iPos, MCD_PCSZ pAttrib ) const$/;"	f	class:CMarkup	signature:( int iPos, MCD_PCSZ pAttrib ) const
x_GetAttrib	third_party/xml/Markup.h	/^	MCD_STR x_GetAttrib( int iPos, MCD_PCSZ pAttrib ) const;$/;"	p	class:CMarkup	access:protected	signature:( int iPos, MCD_PCSZ pAttrib ) const
x_GetData	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::x_GetData( int iPos )$/;"	f	class:CMarkup	signature:( int iPos )
x_GetData	third_party/xml/Markup.h	/^	MCD_STR x_GetData( int iPos );$/;"	p	class:CMarkup	access:protected	signature:( int iPos )
x_GetElemContent	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::x_GetElemContent( int iPos ) const$/;"	f	class:CMarkup	signature:( int iPos ) const
x_GetElemContent	third_party/xml/Markup.h	/^	MCD_STR x_GetElemContent( int iPos ) const;$/;"	p	class:CMarkup	access:protected	signature:( int iPos ) const
x_GetEncodingCodePage	third_party/xml/Markup.cpp	/^int x_GetEncodingCodePage( MCD_CSTR pszEncoding )$/;"	f	signature:( MCD_CSTR pszEncoding )
x_GetFreePos	third_party/xml/Markup.cpp	/^int CMarkup::x_GetFreePos()$/;"	f	class:CMarkup	signature:()
x_GetFreePos	third_party/xml/Markup.h	/^	int x_GetFreePos();$/;"	p	class:CMarkup	access:protected	signature:()
x_GetParent	third_party/xml/Markup.cpp	/^int CMarkup::x_GetParent( int i )$/;"	f	class:CMarkup	signature:( int i )
x_GetParent	third_party/xml/Markup.h	/^	int x_GetParent( int i );$/;"	p	class:CMarkup	access:protected	signature:( int i )
x_GetPath	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::x_GetPath( int iPos ) const$/;"	f	class:CMarkup	signature:( int iPos ) const
x_GetPath	third_party/xml/Markup.h	/^	MCD_STR x_GetPath( int iPos ) const;$/;"	p	class:CMarkup	access:protected	signature:( int iPos ) const
x_GetSubDoc	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::x_GetSubDoc( int iPos )$/;"	f	class:CMarkup	signature:( int iPos )
x_GetSubDoc	third_party/xml/Markup.h	/^	MCD_STR x_GetSubDoc( int iPos );$/;"	p	class:CMarkup	access:protected	signature:( int iPos )
x_GetTagName	third_party/xml/Markup.cpp	/^MCD_STR CMarkup::x_GetTagName( int iPos ) const$/;"	f	class:CMarkup	signature:( int iPos ) const
x_GetTagName	third_party/xml/Markup.h	/^	MCD_STR x_GetTagName( int iPos ) const;$/;"	p	class:CMarkup	access:protected	signature:( int iPos ) const
x_Hash	third_party/xml/Markup.cpp	/^int x_Hash( MCD_PCSZ p, int nSize )$/;"	f	signature:( MCD_PCSZ p, int nSize )
x_InitMarkup	third_party/xml/Markup.cpp	/^void CMarkup::x_InitMarkup()$/;"	f	class:CMarkup	signature:()
x_InitMarkup	third_party/xml/Markup.h	/^	void x_InitMarkup();$/;"	p	class:CMarkup	access:protected	signature:()
x_InsertNew	third_party/xml/Markup.cpp	/^int CMarkup::x_InsertNew( int iPosParent, int& iPosRel, NodePos& node )$/;"	f	class:CMarkup	signature:( int iPosParent, int& iPosRel, NodePos& node )
x_InsertNew	third_party/xml/Markup.h	/^	int x_InsertNew( int iPosParent, int& iPosRel, NodePos& node );$/;"	p	class:CMarkup	access:protected	signature:( int iPosParent, int& iPosRel, NodePos& node )
x_IntToStr	third_party/xml/Markup.cpp	/^MCD_STR x_IntToStr( int n )$/;"	f	signature:( int n )
x_LinkElem	third_party/xml/Markup.cpp	/^void CMarkup::x_LinkElem( int iPosParent, int iPosBefore, int iPos )$/;"	f	class:CMarkup	signature:( int iPosParent, int iPosBefore, int iPos )
x_LinkElem	third_party/xml/Markup.h	/^	void x_LinkElem( int iPosParent, int iPosBefore, int iPos );$/;"	p	class:CMarkup	access:protected	signature:( int iPosParent, int iPosBefore, int iPos )
x_NoDefaultChar	third_party/xml/Markup.cpp	/^bool x_NoDefaultChar( int nCP )$/;"	f	signature:( int nCP )
x_ParseDoc	third_party/xml/Markup.cpp	/^bool CMarkup::x_ParseDoc()$/;"	f	class:CMarkup	signature:()
x_ParseDoc	third_party/xml/Markup.h	/^	bool x_ParseDoc();$/;"	p	class:CMarkup	access:protected	signature:()
x_ParseElem	third_party/xml/Markup.cpp	/^int CMarkup::x_ParseElem( int iPosParent, TokenPos& token )$/;"	f	class:CMarkup	signature:( int iPosParent, TokenPos& token )
x_ParseElem	third_party/xml/Markup.h	/^	int x_ParseElem( int iPos, TokenPos& token );$/;"	p	class:CMarkup	access:protected	signature:( int iPos, TokenPos& token )
x_ReleasePos	third_party/xml/Markup.cpp	/^int CMarkup::x_ReleasePos( int iPos )$/;"	f	class:CMarkup	signature:( int iPos )
x_ReleasePos	third_party/xml/Markup.h	/^	int x_ReleasePos( int iPos );$/;"	p	class:CMarkup	access:protected	signature:( int iPos )
x_ReleaseSubDoc	third_party/xml/Markup.cpp	/^int CMarkup::x_ReleaseSubDoc( int iPos )$/;"	f	class:CMarkup	signature:( int iPos )
x_ReleaseSubDoc	third_party/xml/Markup.h	/^	int x_ReleaseSubDoc( int iPos );$/;"	p	class:CMarkup	access:protected	signature:( int iPos )
x_RemoveElem	third_party/xml/Markup.cpp	/^int CMarkup::x_RemoveElem( int iPos )$/;"	f	class:CMarkup	signature:( int iPos )
x_RemoveElem	third_party/xml/Markup.h	/^	int x_RemoveElem( int iPos );$/;"	p	class:CMarkup	access:protected	signature:( int iPos )
x_RemoveNode	third_party/xml/Markup.cpp	/^void CMarkup::x_RemoveNode( int iPosParent, int& iPos, int& nNodeType, int& nNodeOffset, int& nNodeLength )$/;"	f	class:CMarkup	signature:( int iPosParent, int& iPos, int& nNodeType, int& nNodeOffset, int& nNodeLength )
x_RemoveNode	third_party/xml/Markup.h	/^	void x_RemoveNode( int iPosParent, int& iPos, int& nNodeType, int& nNodeOffset, int& nNodeLength );$/;"	p	class:CMarkup	access:protected	signature:( int iPosParent, int& iPos, int& nNodeType, int& nNodeOffset, int& nNodeLength )
x_SetAttrib	third_party/xml/Markup.cpp	/^bool CMarkup::x_SetAttrib( int iPos, MCD_PCSZ pAttrib, MCD_PCSZ pValue, int nFlags \/*=0*\/ )$/;"	f	class:CMarkup	signature:( int iPos, MCD_PCSZ pAttrib, MCD_PCSZ pValue, int nFlags )
x_SetAttrib	third_party/xml/Markup.cpp	/^bool CMarkup::x_SetAttrib( int iPos, MCD_PCSZ pAttrib, int nValue, int nFlags \/*=0*\/ )$/;"	f	class:CMarkup	signature:( int iPos, MCD_PCSZ pAttrib, int nValue, int nFlags )
x_SetAttrib	third_party/xml/Markup.h	/^	bool x_SetAttrib( int iPos, MCD_PCSZ pAttrib, MCD_PCSZ pValue, int nFlags=0 );$/;"	p	class:CMarkup	access:protected	signature:( int iPos, MCD_PCSZ pAttrib, MCD_PCSZ pValue, int nFlags=0 )
x_SetAttrib	third_party/xml/Markup.h	/^	bool x_SetAttrib( int iPos, MCD_PCSZ pAttrib, int nValue, int nFlags=0 );$/;"	p	class:CMarkup	access:protected	signature:( int iPos, MCD_PCSZ pAttrib, int nValue, int nFlags=0 )
x_SetData	third_party/xml/Markup.cpp	/^bool CMarkup::x_SetData( int iPos, MCD_PCSZ szData, int nFlags )$/;"	f	class:CMarkup	signature:( int iPos, MCD_PCSZ szData, int nFlags )
x_SetData	third_party/xml/Markup.cpp	/^bool CMarkup::x_SetData( int iPos, int nValue )$/;"	f	class:CMarkup	signature:( int iPos, int nValue )
x_SetData	third_party/xml/Markup.h	/^	bool x_SetData( int iPos, MCD_PCSZ szData, int nFlags );$/;"	p	class:CMarkup	access:protected	signature:( int iPos, MCD_PCSZ szData, int nFlags )
x_SetData	third_party/xml/Markup.h	/^	bool x_SetData( int iPos, int nValue );$/;"	p	class:CMarkup	access:protected	signature:( int iPos, int nValue )
x_SetDebugState	third_party/xml/Markup.cpp	/^void CMarkup::x_SetDebugState()$/;"	f	class:CMarkup	signature:()
x_SetDebugState	third_party/xml/Markup.h	/^	void x_SetDebugState();$/;"	p	class:CMarkup	access:protected	signature:()
x_SetElemContent	third_party/xml/Markup.cpp	/^bool CMarkup::x_SetElemContent( MCD_PCSZ szContent )$/;"	f	class:CMarkup	signature:( MCD_PCSZ szContent )
x_SetElemContent	third_party/xml/Markup.h	/^	bool x_SetElemContent( MCD_PCSZ szContent );$/;"	p	class:CMarkup	access:protected	signature:( MCD_PCSZ szContent )
x_SetPos	third_party/xml/Markup.cpp	/^void CMarkup::x_SetPos( int iPosParent, int iPos, int iPosChild )$/;"	f	class:CMarkup	signature:( int iPosParent, int iPos, int iPosChild )
x_SetPos	third_party/xml/Markup.h	/^	void x_SetPos( int iPosParent, int iPos, int iPosChild );$/;"	p	class:CMarkup	access:protected	signature:( int iPosParent, int iPos, int iPosChild )
x_StrInsertReplace	third_party/xml/Markup.cpp	/^void x_StrInsertReplace( MCD_STR& str, int nLeft, int nReplace, const MCD_STR& strInsert )$/;"	f	signature:( MCD_STR& str, int nLeft, int nReplace, const MCD_STR& strInsert )
x_UnlinkElem	third_party/xml/Markup.cpp	/^int CMarkup::x_UnlinkElem( int iPos )$/;"	f	class:CMarkup	signature:( int iPos )
x_UnlinkElem	third_party/xml/Markup.h	/^	int x_UnlinkElem( int iPos );$/;"	p	class:CMarkup	access:protected	signature:( int iPos )
x_UnlinkPrevElem	third_party/xml/Markup.cpp	/^int CMarkup::x_UnlinkPrevElem( int iPosParent, int iPosBefore, int iPos )$/;"	f	class:CMarkup	signature:( int iPosParent, int iPosBefore, int iPos )
x_UnlinkPrevElem	third_party/xml/Markup.h	/^	int x_UnlinkPrevElem( int iPosParent, int iPosBefore, int iPos );$/;"	p	class:CMarkup	access:protected	signature:( int iPosParent, int iPosBefore, int iPos )
xregex	third_party/regex/xregex.cpp	/^xregex::xregex(void)$/;"	f	class:stringX::xregex	signature:(void)
xregex	third_party/regex/xregex.h	/^	xregex(void);$/;"	p	class:stringX::xregex	access:public	signature:(void)
xregex	third_party/regex/xregex.h	/^class xregex$/;"	c	namespace:stringX
xstring	include/stringX.h	/^typedef xstring_basic<char> xstring;$/;"	t
xstring_basic	include/stringX.h	/^	xstring_basic()$/;"	f	class:xstring_basic	access:public	signature:()
xstring_basic	include/stringX.h	/^	xstring_basic(_It _First, _It _Last)$/;"	f	class:xstring_basic	access:public	signature:(_It _First, _It _Last)
xstring_basic	include/stringX.h	/^	xstring_basic(const _Elem* _Ptr)$/;"	f	class:xstring_basic	access:public	signature:(const _Elem* _Ptr)
xstring_basic	include/stringX.h	/^	xstring_basic(const _Elem* _Ptr, size_t _Count)$/;"	f	class:xstring_basic	access:public	signature:(const _Elem* _Ptr, size_t _Count)
xstring_basic	include/stringX.h	/^	xstring_basic(const _Mybase& _Right, size_t _Roff, size_t n = _Mybase::npos)$/;"	f	class:xstring_basic	access:public	signature:(const _Mybase& _Right, size_t _Roff, size_t n = _Mybase::npos)
xstring_basic	include/stringX.h	/^	xstring_basic(const _Mybase& str)$/;"	f	class:xstring_basic	access:public	signature:(const _Mybase& str)
xstring_basic	include/stringX.h	/^	xstring_basic(size_t _Count, _Elem _Ch)$/;"	f	class:xstring_basic	access:public	signature:(size_t _Count, _Elem _Ch)
xstring_basic	include/stringX.h	/^class xstring_basic$/;"	c	inherits:std::basic_string
xstring_basic::OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(append, const _Elem*, _Ptr);$/;"	p	class:xstring_basic	access:public	signature:(append, const _Elem*, _Ptr)
xstring_basic::OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(append, const _Mybase&, _Right);$/;"	p	class:xstring_basic	access:public	signature:(append, const _Mybase&, _Right)
xstring_basic::OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(assign, const _Elem*, _Ptr);$/;"	p	class:xstring_basic	access:public	signature:(assign, const _Elem*, _Ptr)
xstring_basic::OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(assign, const _Mybase&, _Right);$/;"	p	class:xstring_basic	access:public	signature:(assign, const _Mybase&, _Right)
xstring_basic::OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(operator+=, _Elem, _Ch);$/;"	p	class:xstring_basic	access:public	signature:(operator+=, _Elem, _Ch)
xstring_basic::OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(operator+=, const _Elem*&, _Ptr);$/;"	p	class:xstring_basic	access:public	signature:(operator+=, const _Elem*&, _Ptr)
xstring_basic::OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(operator+=, const _Mybase&, _Right);$/;"	p	class:xstring_basic	access:public	signature:(operator+=, const _Mybase&, _Right)
xstring_basic::OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(operator=, _Elem, _Ch);$/;"	p	class:xstring_basic	access:public	signature:(operator=, _Elem, _Ch)
xstring_basic::OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(operator=, const _Elem*&, _Ptr);$/;"	p	class:xstring_basic	access:public	signature:(operator=, const _Elem*&, _Ptr)
xstring_basic::OVERWRITE_FUNCTION_1	include/stringX.h	/^	OVERWRITE_FUNCTION_1(operator=, const _Mybase&, _Right);$/;"	p	class:xstring_basic	access:public	signature:(operator=, const _Mybase&, _Right)
xstring_basic::OVERWRITE_FUNCTION_2	include/stringX.h	/^	OVERWRITE_FUNCTION_2(append, _It, _First, _It, _Last);$/;"	p	class:xstring_basic	access:public	signature:(append, _It, _First, _It, _Last)
xstring_basic::OVERWRITE_FUNCTION_2	include/stringX.h	/^	OVERWRITE_FUNCTION_2(append, const _Elem*, _Ptr, size_type, _Count);$/;"	p	class:xstring_basic	access:public	signature:(append, const _Elem*, _Ptr, size_type, _Count)
xstring_basic::OVERWRITE_FUNCTION_2	include/stringX.h	/^	OVERWRITE_FUNCTION_2(append, size_type, _Count, _Elem, _Ch);$/;"	p	class:xstring_basic	access:public	signature:(append, size_type, _Count, _Elem, _Ch)
xstring_basic::OVERWRITE_FUNCTION_2	include/stringX.h	/^	OVERWRITE_FUNCTION_2(assign, _It, _First, _It, _Last);$/;"	p	class:xstring_basic	access:public	signature:(assign, _It, _First, _It, _Last)
xstring_basic::OVERWRITE_FUNCTION_2	include/stringX.h	/^	OVERWRITE_FUNCTION_2(assign, const _Elem*, _Ptr, size_type, _Count);$/;"	p	class:xstring_basic	access:public	signature:(assign, const _Elem*, _Ptr, size_type, _Count)
xstring_basic::OVERWRITE_FUNCTION_2	include/stringX.h	/^	OVERWRITE_FUNCTION_2(assign, size_type, _Count, _Elem, _Ch);$/;"	p	class:xstring_basic	access:public	signature:(assign, size_type, _Count, _Elem, _Ch)
xstring_basic::OVERWRITE_FUNCTION_2	include/stringX.h	/^	OVERWRITE_FUNCTION_2(insert, size_type, _Off, const _Elem*, _Ptr);$/;"	p	class:xstring_basic	access:public	signature:(insert, size_type, _Off, const _Elem*, _Ptr)
xstring_basic::OVERWRITE_FUNCTION_2	include/stringX.h	/^	OVERWRITE_FUNCTION_2(insert, size_type, _Off, const _Mybase&, _Right);$/;"	p	class:xstring_basic	access:public	signature:(insert, size_type, _Off, const _Mybase&, _Right)
xstring_basic::OVERWRITE_FUNCTION_3	include/stringX.h	/^	OVERWRITE_FUNCTION_3(append, const _Mybase&, _Right, size_type, _Roff, size_type, _Count);$/;"	p	class:xstring_basic	access:public	signature:(append, const _Mybase&, _Right, size_type, _Roff, size_type, _Count)
xstring_basic::OVERWRITE_FUNCTION_3	include/stringX.h	/^	OVERWRITE_FUNCTION_3(assign, const _Mybase&, _Right, size_type, _Roff, size_type, _Count);$/;"	p	class:xstring_basic	access:public	signature:(assign, const _Mybase&, _Right, size_type, _Roff, size_type, _Count)
xstring_basic::OVERWRITE_FUNCTION_3	include/stringX.h	/^	OVERWRITE_FUNCTION_3(insert, size_type, _Off, const _Elem*, _Ptr, size_type, _Count);$/;"	p	class:xstring_basic	access:public	signature:(insert, size_type, _Off, const _Elem*, _Ptr, size_type, _Count)
xstring_basic::OVERWRITE_FUNCTION_3	include/stringX.h	/^	OVERWRITE_FUNCTION_3(insert, size_type, _Off, size_type, _Count, _Elem, _Ch);$/;"	p	class:xstring_basic	access:public	signature:(insert, size_type, _Off, size_type, _Count, _Elem, _Ch)
xstring_basic::OVERWRITE_FUNCTION_3	include/stringX.h	/^	OVERWRITE_FUNCTION_3(replace, size_type, _Off, size_type, _N0, const _Elem*, _Ptr);$/;"	p	class:xstring_basic	access:public	signature:(replace, size_type, _Off, size_type, _N0, const _Elem*, _Ptr)
xstring_basic::OVERWRITE_FUNCTION_3	include/stringX.h	/^	OVERWRITE_FUNCTION_3(replace, size_type, _Off, size_type, _N0, const _Myt&, _Right);$/;"	p	class:xstring_basic	access:public	signature:(replace, size_type, _Off, size_type, _N0, const _Myt&, _Right)
xstring_basic::OVERWRITE_FUNCTION_3	include/stringX.h	/^	OVERWRITE_FUNCTION_3(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, const _Elem*, _Ptr);$/;"	p	class:xstring_basic	access:public	signature:(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, const _Elem*, _Ptr)
xstring_basic::OVERWRITE_FUNCTION_3	include/stringX.h	/^	OVERWRITE_FUNCTION_3(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, const _Myt&, _Right);$/;"	p	class:xstring_basic	access:public	signature:(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, const _Myt&, _Right)
xstring_basic::OVERWRITE_FUNCTION_4	include/stringX.h	/^	OVERWRITE_FUNCTION_4(insert, size_type, _Off, const _Mybase&, _Right, size_type, _Roff, size_type, _Count);$/;"	p	class:xstring_basic	access:public	signature:(insert, size_type, _Off, const _Mybase&, _Right, size_type, _Roff, size_type, _Count)
xstring_basic::OVERWRITE_FUNCTION_4	include/stringX.h	/^	OVERWRITE_FUNCTION_4(replace, size_type, _Off, size_type, _N0, const _Elem*, _Ptr, size_type, _Count);$/;"	p	class:xstring_basic	access:public	signature:(replace, size_type, _Off, size_type, _N0, const _Elem*, _Ptr, size_type, _Count)
xstring_basic::OVERWRITE_FUNCTION_4	include/stringX.h	/^	OVERWRITE_FUNCTION_4(replace, size_type, _Off, size_type, _N0, size_type, _Count, _Elem, _Ch);$/;"	p	class:xstring_basic	access:public	signature:(replace, size_type, _Off, size_type, _N0, size_type, _Count, _Elem, _Ch)
xstring_basic::OVERWRITE_FUNCTION_4	include/stringX.h	/^	OVERWRITE_FUNCTION_4(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, _It, _First2, _It, _Last2);$/;"	p	class:xstring_basic	access:public	signature:(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, _It, _First2, _It, _Last2)
xstring_basic::OVERWRITE_FUNCTION_4	include/stringX.h	/^	OVERWRITE_FUNCTION_4(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, const _Elem*, _Ptr, size_type, _Count);$/;"	p	class:xstring_basic	access:public	signature:(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, const _Elem*, _Ptr, size_type, _Count)
xstring_basic::OVERWRITE_FUNCTION_4	include/stringX.h	/^	OVERWRITE_FUNCTION_4(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, size_type, _Count, _Elem, _Ch);$/;"	p	class:xstring_basic	access:public	signature:(replace, typename _Mybase::iterator, _First, typename _Mybase::iterator, _Last, size_type, _Count, _Elem, _Ch)
xstring_basic::_Ctptr	include/stringX.h	/^	typedef typename _Mybase::const_pointer _Ctptr;$/;"	t	class:xstring_basic	access:public
xstring_basic::_Dift	include/stringX.h	/^	typedef typename _Mybase::difference_type _Dift;$/;"	t	class:xstring_basic	access:public
xstring_basic::_IStream	include/stringX.h	/^	typedef std::basic_istringstream<_Elem, _Traits, _Ax> _IStream;$/;"	t	class:xstring_basic	access:public
xstring_basic::_Mybase	include/stringX.h	/^	typedef std::basic_string<_Elem, _Traits, _Ax> _Mybase;$/;"	t	class:xstring_basic	access:public
xstring_basic::_Myt	include/stringX.h	/^	typedef xstring_basic<_Elem, _Traits, _Ax> _Myt;$/;"	t	class:xstring_basic	access:public
xstring_basic::_OStream	include/stringX.h	/^	typedef std::basic_ostringstream<_Elem, _Traits, _Ax> _OStream;$/;"	t	class:xstring_basic	access:public
xstring_basic::_Reft	include/stringX.h	/^	typedef typename _Mybase::reference _Reft;$/;"	t	class:xstring_basic	access:public
xstring_basic::_Stream	include/stringX.h	/^	typedef std::basic_stringstream<_Elem, _Traits, _Ax> _Stream;$/;"	t	class:xstring_basic	access:public
xstring_basic::_Tptr	include/stringX.h	/^	typedef typename _Mybase::pointer _Tptr;$/;"	t	class:xstring_basic	access:public
xstring_basic::base	include/stringX.h	/^	_Mybase& base()$/;"	f	class:xstring_basic	access:public	signature:()
xstring_basic::base	include/stringX.h	/^	const _Mybase& base() const$/;"	f	class:xstring_basic	access:public	signature:() const
xstring_basic::const_pointer	include/stringX.h	/^	typedef _Ctptr const_pointer;$/;"	t	class:xstring_basic	access:public
xstring_basic::const_reference	include/stringX.h	/^	typedef typename _Mybase::const_reference const_reference;$/;"	t	class:xstring_basic	access:public
xstring_basic::difference_type	include/stringX.h	/^	typedef _Dift difference_type;$/;"	t	class:xstring_basic	access:public
xstring_basic::erase	include/stringX.h	/^	_Myt& erase(size_type _Off = 0, size_type _Count = _Mybase::npos)$/;"	f	class:xstring_basic	access:public	signature:(size_type _Off = 0, size_type _Count = _Mybase::npos)
xstring_basic::format	include/stringX.h	/^	static _Myt format(const _Elem* fmt, ...)$/;"	f	class:xstring_basic	access:public	signature:(const _Elem* fmt, ...)
xstring_basic::getstream	include/stringX.h	/^	bool getstream(_IStream& _istream)$/;"	f	class:xstring_basic	access:public	signature:(_IStream& _istream)
xstring_basic::getstream	include/stringX.h	/^	bool getstream(_OStream& _ostream)$/;"	f	class:xstring_basic	access:public	signature:(_OStream& _ostream)
xstring_basic::getstream	include/stringX.h	/^	bool getstream(_Stream& _stream)$/;"	f	class:xstring_basic	access:public	signature:(_Stream& _stream)
xstring_basic::isdigit	include/stringX.h	/^	static bool isdigit(_Elem _Ch)$/;"	f	class:xstring_basic	access:public	signature:(_Elem _Ch)
xstring_basic::isinteger	include/stringX.h	/^	static bool isinteger(const _Myt& _Str)$/;"	f	class:xstring_basic	access:public	signature:(const _Myt& _Str)
xstring_basic::islatter	include/stringX.h	/^	static bool islatter(_Elem _Ch)$/;"	f	class:xstring_basic	access:public	signature:(_Elem _Ch)
xstring_basic::isspace	include/stringX.h	/^	static bool isspace(_Elem _Ch)$/;"	f	class:xstring_basic	access:public	signature:(_Elem _Ch)
xstring_basic::operator +	include/stringX.h	/^	_Myt operator +(const _Elem _Right) const$/;"	f	class:xstring_basic	access:public	signature:(const _Elem _Right) const
xstring_basic::operator +	include/stringX.h	/^	_Myt operator +(const _Elem* _Right) const$/;"	f	class:xstring_basic	access:public	signature:(const _Elem* _Right) const
xstring_basic::operator +	include/stringX.h	/^	_Myt operator +(const _Mybase& _Right) const$/;"	f	class:xstring_basic	access:public	signature:(const _Mybase& _Right) const
xstring_basic::operator +	include/stringX.h	/^	_Myt operator +(const _Tz& _tz) const$/;"	f	class:xstring_basic	access:public	signature:(const _Tz& _tz) const
xstring_basic::operator +=	include/stringX.h	/^	_Myt& operator +=(const _Myt& _Right)$/;"	f	class:xstring_basic	access:public	signature:(const _Myt& _Right)
xstring_basic::operator +=	include/stringX.h	/^	_Myt& operator +=(const _Tz& _tz)$/;"	f	class:xstring_basic	access:public	signature:(const _Tz& _tz)
xstring_basic::operator _Mybase&	include/stringX.h	/^	operator _Mybase&()$/;"	f	class:xstring_basic	access:public	signature:()
xstring_basic::operator const _Mybase&	include/stringX.h	/^	operator const _Mybase&() const$/;"	f	class:xstring_basic	access:public	signature:() const
xstring_basic::parse	include/stringX.h	/^	static _Tz parse(const _Myt& str)$/;"	f	class:xstring_basic	access:public	signature:(const _Myt& str)
xstring_basic::pointer	include/stringX.h	/^	typedef _Tptr pointer;$/;"	t	class:xstring_basic	access:public
xstring_basic::reference	include/stringX.h	/^	typedef _Reft reference;$/;"	t	class:xstring_basic	access:public
xstring_basic::replace	include/stringX.h	/^	_Myt& replace(size_type _Off,$/;"	f	class:xstring_basic	access:public	signature:(size_type _Off, size_type _N0, const _Mybase& _Right, size_type _Roff, size_type _Count)
xstring_basic::size_type	include/stringX.h	/^	typedef typename _Mybase::size_type size_type;$/;"	t	class:xstring_basic	access:public
xstring_basic::substr	include/stringX.h	/^	_Myt substr(size_type _Off = 0, size_type _Count = _Mybase::npos) const$/;"	f	class:xstring_basic	access:public	signature:(size_type _Off = 0, size_type _Count = _Mybase::npos) const
xstring_basic::to_lower	include/stringX.h	/^	_Myt& to_lower()$/;"	f	class:xstring_basic	access:public	signature:()
xstring_basic::to_upper	include/stringX.h	/^	_Myt& to_upper()$/;"	f	class:xstring_basic	access:public	signature:()
xstring_basic::tostring	include/stringX.h	/^	static _Myt tostring(const _Tz& _value)$/;"	f	class:xstring_basic	access:public	signature:(const _Tz& _value)
xstring_basic::trim	include/stringX.h	/^	_Myt& trim(int _TrimType = trim_both)$/;"	f	class:xstring_basic	access:public	signature:(int _TrimType = trim_both)
xstring_basic::trim	include/stringX.h	/^	static _Myt trim(const _Myt& _Str, int _TrimType = 3)$/;"	f	class:xstring_basic	access:public	signature:(const _Myt& _Str, int _TrimType = 3)
xstring_basic::trim_begin	include/stringX.h	/^	enum {trim_begin, trim_end, trim_both};$/;"	e	enum:xstring_basic::__anon4
xstring_basic::trim_both	include/stringX.h	/^	enum {trim_begin, trim_end, trim_both};$/;"	e	enum:xstring_basic::__anon4
xstring_basic::trim_end	include/stringX.h	/^	enum {trim_begin, trim_end, trim_both};$/;"	e	enum:xstring_basic::__anon4
xstring_basic::tryparse	include/stringX.h	/^	static bool tryparse(const _Myt& str, _Tz& _tz)$/;"	f	class:xstring_basic	access:public	signature:(const _Myt& str, _Tz& _tz)
xstring_basic::tryparse	include/stringX.h	/^	static bool tryparse(const _Myt& str, _Tz& _tz, std::string& exceptionMsg)$/;"	f	class:xstring_basic	access:private	signature:(const _Myt& str, _Tz& _tz, std::string& exceptionMsg)
xstring_basic::value_type	include/stringX.h	/^	typedef typename _Mybase::value_type value_type;$/;"	t	class:xstring_basic	access:public
xstring_basic::xstring_basic	include/stringX.h	/^	xstring_basic()$/;"	f	class:xstring_basic	access:public	signature:()
xstring_basic::xstring_basic	include/stringX.h	/^	xstring_basic(_It _First, _It _Last)$/;"	f	class:xstring_basic	access:public	signature:(_It _First, _It _Last)
xstring_basic::xstring_basic	include/stringX.h	/^	xstring_basic(const _Elem* _Ptr)$/;"	f	class:xstring_basic	access:public	signature:(const _Elem* _Ptr)
xstring_basic::xstring_basic	include/stringX.h	/^	xstring_basic(const _Elem* _Ptr, size_t _Count)$/;"	f	class:xstring_basic	access:public	signature:(const _Elem* _Ptr, size_t _Count)
xstring_basic::xstring_basic	include/stringX.h	/^	xstring_basic(const _Mybase& _Right, size_t _Roff, size_t n = _Mybase::npos)$/;"	f	class:xstring_basic	access:public	signature:(const _Mybase& _Right, size_t _Roff, size_t n = _Mybase::npos)
xstring_basic::xstring_basic	include/stringX.h	/^	xstring_basic(const _Mybase& str)$/;"	f	class:xstring_basic	access:public	signature:(const _Mybase& str)
xstring_basic::xstring_basic	include/stringX.h	/^	xstring_basic(size_t _Count, _Elem _Ch)$/;"	f	class:xstring_basic	access:public	signature:(size_t _Count, _Elem _Ch)
xstringcat	include/stringX.h	/^xstring_basic<_Elem> xstringcat(const _Elem* str1, const _Elem* str2)$/;"	f	signature:(const _Elem* str1, const _Elem* str2)
xwstring	include/stringX.h	/^typedef xstring_basic<wchar_t> xwstring;$/;"	t
y	tmp/sizetest.cpp	/^	short y;$/;"	m	struct:A	file:	access:public
z	tmp/sizetest.cpp	/^	char z;$/;"	m	struct:A	file:	access:public
~CMarkup	third_party/xml/Markup.cpp	/^CMarkup::~CMarkup()$/;"	f	class:CMarkup	signature:()
~CMarkup	third_party/xml/Markup.h	/^	~CMarkup();$/;"	p	class:CMarkup	access:public	signature:()
~ElemPosTree	third_party/xml/Markup.cpp	/^	~ElemPosTree() { Release(); };$/;"	f	struct:ElemPosTree	access:public	signature:()
~ElemStack	third_party/xml/Markup.cpp	/^	~ElemStack() { if (pL) delete [] pL; };$/;"	f	struct:ElemStack	access:public	signature:()
~SavedPosMap	third_party/xml/Markup.cpp	/^	~SavedPosMap() { if (pTable) { for (int n=0;n<nMapSize;++n) if (pTable[n]) delete[] pTable[n]; delete[] pTable; } };$/;"	f	struct:SavedPosMap	access:public	signature:()
~SavedPosMapArray	third_party/xml/Markup.cpp	/^	~SavedPosMapArray() { ReleaseMaps(); };$/;"	f	struct:SavedPosMapArray	access:public	signature:()
~automachine	syntax/automachine.cpp	/^automachine::~automachine()$/;"	f	class:automachine	signature:()
~automachine	syntax/automachine.h	/^	virtual ~automachine();$/;"	p	class:automachine	access:public	signature:()
~block	include/arrayX.h	/^		~block()$/;"	f	struct:smart_vector::block	access:public	signature:()
~file	include/markuputils.h	/^	virtual ~file()$/;"	f	class:file	access:public	signature:()
~grammar	syntax/grammar.cpp	/^grammar::~grammar()$/;"	f	class:grammar	signature:()
~grammar	syntax/grammar.h	/^	virtual ~grammar();$/;"	p	class:grammar	access:public	signature:()
~lalr1machine	compiler/lalr1machine.h	/^	virtual ~lalr1machine();$/;"	p	class:lalr1machine	access:public	signature:()
~loader	syntax/loader.h	/^	virtual ~loader();$/;"	p	class:loader	access:public	signature:()
~share_ptr	include/share_ptr.h	/^	~share_ptr()$/;"	f	class:share_ptr	access:public	signature:()
~singleton	include/singleton.h	/^	~singleton(){}$/;"	f	class:singleton	access:protected	signature:()
~state_machine	syntax/statemachine.cpp	/^state_machine::~state_machine()$/;"	f	class:state_machine	signature:()
~state_machine	syntax/statemachine.h	/^	virtual ~state_machine();$/;"	p	class:state_machine	access:public	signature:()
~streamsplit	compiler/extract.cpp	/^compile::doc::streamsplit::~streamsplit()$/;"	f	class:compile::doc::streamsplit	signature:()
~streamsplit	compiler/extract.h	/^	virtual ~streamsplit();$/;"	p	class:streamsplit	access:public	signature:()
~syntaxgenerator	makecompiler/gensyntax.cpp	/^syntaxgenerator::~syntaxgenerator()$/;"	f	class:syntaxgenerator	signature:()
~syntaxgenerator	makecompiler/gensyntax.h	/^	virtual ~syntaxgenerator();$/;"	p	class:syntaxgenerator	access:public	signature:()
~tinygrammar	syntax/grammar.cpp	/^tinygrammar::~tinygrammar()$/;"	f	class:tinygrammar	signature:()
~tinygrammar	syntax/grammar.h	/^	virtual ~tinygrammar();$/;"	p	class:tinygrammar	access:public	signature:()
~unittest	test/unittest.cpp	/^unittest::~unittest(void)$/;"	f	class:unittest	signature:(void)
~unittest	test/unittest.h	/^	virtual ~unittest(void);$/;"	p	class:unittest	access:public	signature:(void)
~xregex	third_party/regex/xregex.cpp	/^xregex::~xregex(void)$/;"	f	class:stringX::xregex	signature:(void)
~xregex	third_party/regex/xregex.h	/^	~xregex(void);$/;"	p	class:stringX::xregex	access:public	signature:(void)
